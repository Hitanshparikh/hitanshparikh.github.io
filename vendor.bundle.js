/*! For license information please see vendor.bundle.js.LICENSE.txt */
(self.webpackChunkwebpack_boilerplate = self.webpackChunkwebpack_boilerplate || []).push([
    [736], {
        614: (e, t, i) => {
            "use strict";
            var n = i(1192);
            e.exports = function(e, t) {
                return void 0 === t && (t = !1),
                    function(i, r, s) {
                        if (i) e(i);
                        else if (r.statusCode >= 400 && r.statusCode <= 599) {
                            var a = s;
                            if (t)
                                if (n.TextDecoder) {
                                    var o = function(e) {
                                        void 0 === e && (e = "");
                                        return e.toLowerCase().split(";").reduce((function(e, t) {
                                            var i = t.split("="),
                                                n = i[0],
                                                r = i[1];
                                            return "charset" === n.trim() ? r.trim() : e
                                        }), "utf-8")
                                    }(r.headers && r.headers["content-type"]);
                                    try {
                                        a = new TextDecoder(o).decode(s)
                                    } catch (e) {}
                                } else a = String.fromCharCode.apply(null, new Uint8Array(s));
                            e({
                                cause: a
                            })
                        } else e(null, s)
                    }
            }
        },
        3065: (e, t, i) => {
            "use strict";
            var n = i(1192),
                r = i(9894),
                s = i(6534);
            l.httpHandler = i(614);
            var a = function(e) {
                var t = {};
                return e ? (e.trim().split("\n").forEach((function(e) {
                    var i = e.indexOf(":"),
                        n = e.slice(0, i).trim().toLowerCase(),
                        r = e.slice(i + 1).trim();
                    void 0 === t[n] ? t[n] = r : Array.isArray(t[n]) ? t[n].push(r) : t[n] = [t[n], r]
                })), t) : t
            };

            function o(e, t, i) {
                var n = e;
                return s(t) ? (i = t, "string" == typeof e && (n = {
                    uri: e
                })) : n = r({}, t, {
                    uri: e
                }), n.callback = i, n
            }

            function l(e, t, i) {
                return h(t = o(e, t, i))
            }

            function h(e) {
                if (void 0 === e.callback) throw new Error("callback argument missing");
                var t = !1,
                    i = function(i, n, r) {
                        t || (t = !0, e.callback(i, n, r))
                    };

                function n() {
                    var e = void 0;
                    if (e = c.response ? c.response : c.responseText || function(e) {
                            try {
                                if ("document" === e.responseType) return e.responseXML;
                                var t = e.responseXML && "parsererror" === e.responseXML.documentElement.nodeName;
                                if ("" === e.responseType && !t) return e.responseXML
                            } catch (e) {}
                            return null
                        }(c), y) try {
                        e = JSON.parse(e)
                    } catch (e) {}
                    return e
                }

                function r(e) {
                    return clearTimeout(u), e instanceof Error || (e = new Error("" + (e || "Unknown XMLHttpRequest Error"))), e.statusCode = 0, i(e, _)
                }

                function s() {
                    if (!h) {
                        var t;
                        clearTimeout(u), t = e.useXDR && void 0 === c.status ? 200 : 1223 === c.status ? 204 : c.status;
                        var r = _,
                            s = null;
                        return 0 !== t ? (r = {
                            body: n(),
                            statusCode: t,
                            method: p,
                            headers: {},
                            url: d,
                            rawRequest: c
                        }, c.getAllResponseHeaders && (r.headers = a(c.getAllResponseHeaders()))) : s = new Error("Internal XMLHttpRequest Error"), i(s, r, r.body)
                    }
                }
                var o, h, c = e.xhr || null;
                c || (c = e.cors || e.useXDR ? new l.XDomainRequest : new l.XMLHttpRequest);
                var u, d = c.url = e.uri || e.url,
                    p = c.method = e.method || "GET",
                    f = e.body || e.data,
                    m = c.headers = e.headers || {},
                    g = !!e.sync,
                    y = !1,
                    _ = {
                        body: void 0,
                        headers: {},
                        statusCode: 0,
                        method: p,
                        url: d,
                        rawRequest: c
                    };
                if ("json" in e && !1 !== e.json && (y = !0, m.accept || m.Accept || (m.Accept = "application/json"), "GET" !== p && "HEAD" !== p && (m["content-type"] || m["Content-Type"] || (m["Content-Type"] = "application/json"), f = JSON.stringify(!0 === e.json ? f : e.json))), c.onreadystatechange = function() {
                        4 === c.readyState && setTimeout(s, 0)
                    }, c.onload = s, c.onerror = r, c.onprogress = function() {}, c.onabort = function() {
                        h = !0
                    }, c.ontimeout = r, c.open(p, d, !g, e.username, e.password), g || (c.withCredentials = !!e.withCredentials), !g && e.timeout > 0 && (u = setTimeout((function() {
                        if (!h) {
                            h = !0, c.abort("timeout");
                            var e = new Error("XMLHttpRequest timeout");
                            e.code = "ETIMEDOUT", r(e)
                        }
                    }), e.timeout)), c.setRequestHeader)
                    for (o in m) m.hasOwnProperty(o) && c.setRequestHeader(o, m[o]);
                else if (e.headers && ! function(e) {
                        for (var t in e)
                            if (e.hasOwnProperty(t)) return !1;
                        return !0
                    }(e.headers)) throw new Error("Headers cannot be set on an XDomainRequest object");
                return "responseType" in e && (c.responseType = e.responseType), "beforeSend" in e && "function" == typeof e.beforeSend && e.beforeSend(c), c.send(f || null), c
            }
            e.exports = l, e.exports.default = l, l.XMLHttpRequest = n.XMLHttpRequest || function() {}, l.XDomainRequest = "withCredentials" in new l.XMLHttpRequest ? l.XMLHttpRequest : n.XDomainRequest,
                function(e, t) {
                    for (var i = 0; i < e.length; i++) t(e[i])
                }(["get", "put", "post", "patch", "head", "delete"], (function(e) {
                    l["delete" === e ? "del" : e] = function(t, i, n) {
                        return (i = o(t, i, n)).method = e.toUpperCase(), h(i)
                    }
                }))
        },
        7453: (e, t) => {
            "use strict";

            function i(e, t) {
                return void 0 === t && (t = Object), t && "function" == typeof t.freeze ? t.freeze(e) : e
            }
            var n = i({
                    HTML: "text/html",
                    isHTML: function(e) {
                        return e === n.HTML
                    },
                    XML_APPLICATION: "application/xml",
                    XML_TEXT: "text/xml",
                    XML_XHTML_APPLICATION: "application/xhtml+xml",
                    XML_SVG_IMAGE: "image/svg+xml"
                }),
                r = i({
                    HTML: "http://www.w3.org/1999/xhtml",
                    isHTML: function(e) {
                        return e === r.HTML
                    },
                    SVG: "http://www.w3.org/2000/svg",
                    XML: "http://www.w3.org/XML/1998/namespace",
                    XMLNS: "http://www.w3.org/2000/xmlns/"
                });
            t.assign = function(e, t) {
                if (null === e || "object" != typeof e) throw new TypeError("target is not an object");
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                return e
            }, t.find = function(e, t, i) {
                if (void 0 === i && (i = Array.prototype), e && "function" == typeof i.find) return i.find.call(e, t);
                for (var n = 0; n < e.length; n++)
                    if (Object.prototype.hasOwnProperty.call(e, n)) {
                        var r = e[n];
                        if (t.call(void 0, r, n, e)) return r
                    }
            }, t.freeze = i, t.MIME_TYPE = n, t.NAMESPACE = r
        },
        3161: (e, t, i) => {
            var n = i(7453),
                r = i(7080),
                s = i(8057),
                a = i(8868),
                o = r.DOMImplementation,
                l = n.NAMESPACE,
                h = a.ParseError,
                c = a.XMLReader;

            function u(e) {
                return e.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n")
            }

            function d(e) {
                this.options = e || {
                    locator: {}
                }
            }

            function p() {
                this.cdata = !1
            }

            function f(e, t) {
                t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber
            }

            function m(e) {
                if (e) return "\n@" + (e.systemId || "") + "#[line:" + e.lineNumber + ",col:" + e.columnNumber + "]"
            }

            function g(e, t, i) {
                return "string" == typeof e ? e.substr(t, i) : e.length >= t + i || t ? new java.lang.String(e, t, i) + "" : e
            }

            function y(e, t) {
                e.currentElement ? e.currentElement.appendChild(t) : e.doc.appendChild(t)
            }
            d.prototype.parseFromString = function(e, t) {
                var i = this.options,
                    n = new c,
                    r = i.domBuilder || new p,
                    a = i.errorHandler,
                    o = i.locator,
                    h = i.xmlns || {},
                    d = /\/x?html?$/.test(t),
                    f = d ? s.HTML_ENTITIES : s.XML_ENTITIES;
                o && r.setDocumentLocator(o), n.errorHandler = function(e, t, i) {
                    if (!e) {
                        if (t instanceof p) return t;
                        e = t
                    }
                    var n = {},
                        r = e instanceof Function;

                    function s(t) {
                        var s = e[t];
                        !s && r && (s = 2 == e.length ? function(i) {
                            e(t, i)
                        } : e), n[t] = s && function(e) {
                            s("[xmldom " + t + "]\t" + e + m(i))
                        } || function() {}
                    }
                    return i = i || {}, s("warning"), s("error"), s("fatalError"), n
                }(a, r, o), n.domBuilder = i.domBuilder || r, d && (h[""] = l.HTML), h.xml = h.xml || l.XML;
                var g = i.normalizeLineEndings || u;
                return e && "string" == typeof e ? n.parse(g(e), h, f) : n.errorHandler.error("invalid doc source"), r.doc
            }, p.prototype = {
                startDocument: function() {
                    this.doc = (new o).createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId)
                },
                startElement: function(e, t, i, n) {
                    var r = this.doc,
                        s = r.createElementNS(e, i || t),
                        a = n.length;
                    y(this, s), this.currentElement = s, this.locator && f(this.locator, s);
                    for (var o = 0; o < a; o++) {
                        e = n.getURI(o);
                        var l = n.getValue(o),
                            h = (i = n.getQName(o), r.createAttributeNS(e, i));
                        this.locator && f(n.getLocator(o), h), h.value = h.nodeValue = l, s.setAttributeNode(h)
                    }
                },
                endElement: function(e, t, i) {
                    var n = this.currentElement;
                    n.tagName;
                    this.currentElement = n.parentNode
                },
                startPrefixMapping: function(e, t) {},
                endPrefixMapping: function(e) {},
                processingInstruction: function(e, t) {
                    var i = this.doc.createProcessingInstruction(e, t);
                    this.locator && f(this.locator, i), y(this, i)
                },
                ignorableWhitespace: function(e, t, i) {},
                characters: function(e, t, i) {
                    if (e = g.apply(this, arguments)) {
                        if (this.cdata) var n = this.doc.createCDATASection(e);
                        else n = this.doc.createTextNode(e);
                        this.currentElement ? this.currentElement.appendChild(n) : /^\s*$/.test(e) && this.doc.appendChild(n), this.locator && f(this.locator, n)
                    }
                },
                skippedEntity: function(e) {},
                endDocument: function() {
                    this.doc.normalize()
                },
                setDocumentLocator: function(e) {
                    (this.locator = e) && (e.lineNumber = 0)
                },
                comment: function(e, t, i) {
                    e = g.apply(this, arguments);
                    var n = this.doc.createComment(e);
                    this.locator && f(this.locator, n), y(this, n)
                },
                startCDATA: function() {
                    this.cdata = !0
                },
                endCDATA: function() {
                    this.cdata = !1
                },
                startDTD: function(e, t, i) {
                    var n = this.doc.implementation;
                    if (n && n.createDocumentType) {
                        var r = n.createDocumentType(e, t, i);
                        this.locator && f(this.locator, r), y(this, r), this.doc.doctype = r
                    }
                },
                warning: function(e) {
                    console.warn("[xmldom warning]\t" + e, m(this.locator))
                },
                error: function(e) {
                    console.error("[xmldom error]\t" + e, m(this.locator))
                },
                fatalError: function(e) {
                    throw new h(e, this.locator)
                }
            }, "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, (function(e) {
                p.prototype[e] = function() {
                    return null
                }
            })), t.DOMParser = d
        },
        7080: (e, t, i) => {
            var n = i(7453),
                r = n.find,
                s = n.NAMESPACE;

            function a(e) {
                return "" !== e
            }

            function o(e, t) {
                return e.hasOwnProperty(t) || (e[t] = !0), e
            }

            function l(e) {
                if (!e) return [];
                var t = function(e) {
                    return e ? e.split(/[\t\n\f\r ]+/).filter(a) : []
                }(e);
                return Object.keys(t.reduce(o, {}))
            }

            function h(e, t) {
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }

            function c(e, t) {
                var i = e.prototype;
                if (!(i instanceof t)) {
                    function n() {}
                    n.prototype = t.prototype, h(i, n = new n), e.prototype = i = n
                }
                i.constructor != e && ("function" != typeof e && console.error("unknown Class:" + e), i.constructor = e)
            }
            var u = {},
                d = u.ELEMENT_NODE = 1,
                p = u.ATTRIBUTE_NODE = 2,
                f = u.TEXT_NODE = 3,
                m = u.CDATA_SECTION_NODE = 4,
                g = u.ENTITY_REFERENCE_NODE = 5,
                y = u.ENTITY_NODE = 6,
                _ = u.PROCESSING_INSTRUCTION_NODE = 7,
                v = u.COMMENT_NODE = 8,
                b = u.DOCUMENT_NODE = 9,
                T = u.DOCUMENT_TYPE_NODE = 10,
                x = u.DOCUMENT_FRAGMENT_NODE = 11,
                w = u.NOTATION_NODE = 12,
                S = {},
                E = {},
                M = (S.INDEX_SIZE_ERR = (E[1] = "Index size error", 1), S.DOMSTRING_SIZE_ERR = (E[2] = "DOMString size error", 2), S.HIERARCHY_REQUEST_ERR = (E[3] = "Hierarchy request error", 3)),
                C = (S.WRONG_DOCUMENT_ERR = (E[4] = "Wrong document", 4), S.INVALID_CHARACTER_ERR = (E[5] = "Invalid character", 5), S.NO_DATA_ALLOWED_ERR = (E[6] = "No data allowed", 6), S.NO_MODIFICATION_ALLOWED_ERR = (E[7] = "No modification allowed", 7), S.NOT_FOUND_ERR = (E[8] = "Not found", 8)),
                A = (S.NOT_SUPPORTED_ERR = (E[9] = "Not supported", 9), S.INUSE_ATTRIBUTE_ERR = (E[10] = "Attribute in use", 10));
            S.INVALID_STATE_ERR = (E[11] = "Invalid state", 11), S.SYNTAX_ERR = (E[12] = "Syntax error", 12), S.INVALID_MODIFICATION_ERR = (E[13] = "Invalid modification", 13), S.NAMESPACE_ERR = (E[14] = "Invalid namespace", 14), S.INVALID_ACCESS_ERR = (E[15] = "Invalid access", 15);

            function L(e, t) {
                if (t instanceof Error) var i = t;
                else i = this, Error.call(this, E[e]), this.message = E[e], Error.captureStackTrace && Error.captureStackTrace(this, L);
                return i.code = e, t && (this.message = this.message + ": " + t), i
            }

            function I() {}

            function P(e, t) {
                this._node = e, this._refresh = t, R(this)
            }

            function R(e) {
                var t = e._node._inc || e._node.ownerDocument._inc;
                if (e._inc != t) {
                    var i = e._refresh(e._node);
                    ve(e, "length", i.length), h(i, e), e._inc = t
                }
            }

            function k() {}

            function D(e, t) {
                for (var i = e.length; i--;)
                    if (e[i] === t) return i
            }

            function O(e, t, i, n) {
                if (n ? t[D(t, n)] = i : t[t.length++] = i, e) {
                    i.ownerElement = e;
                    var r = e.ownerDocument;
                    r && (n && V(r, e, n), function(e, t, i) {
                        e && e._inc++;
                        var n = i.namespaceURI;
                        n === s.XMLNS && (t._nsMap[i.prefix ? i.localName : ""] = i.value)
                    }(r, e, i))
                }
            }

            function N(e, t, i) {
                var n = D(t, i);
                if (!(n >= 0)) throw new L(C, new Error(e.tagName + "@" + i));
                for (var r = t.length - 1; n < r;) t[n] = t[++n];
                if (t.length = r, e) {
                    var s = e.ownerDocument;
                    s && (V(s, e, i), i.ownerElement = null)
                }
            }

            function U() {}

            function B() {}

            function F(e) {
                return ("<" == e ? "&lt;" : ">" == e && "&gt;") || "&" == e && "&amp;" || '"' == e && "&quot;" || "&#" + e.charCodeAt() + ";"
            }

            function H(e, t) {
                if (t(e)) return !0;
                if (e = e.firstChild)
                    do {
                        if (H(e, t)) return !0
                    } while (e = e.nextSibling)
            }

            function z() {
                this.ownerDocument = this
            }

            function V(e, t, i, n) {
                e && e._inc++, i.namespaceURI === s.XMLNS && delete t._nsMap[i.prefix ? i.localName : ""]
            }

            function G(e, t, i) {
                if (e && e._inc) {
                    e._inc++;
                    var n = t.childNodes;
                    if (i) n[n.length++] = i;
                    else {
                        for (var r = t.firstChild, s = 0; r;) n[s++] = r, r = r.nextSibling;
                        n.length = s, delete n[n.length]
                    }
                }
            }

            function W(e, t) {
                var i = t.previousSibling,
                    n = t.nextSibling;
                return i ? i.nextSibling = n : e.firstChild = n, n ? n.previousSibling = i : e.lastChild = i, t.parentNode = null, t.previousSibling = null, t.nextSibling = null, G(e.ownerDocument, e), t
            }

            function j(e) {
                return e && e.nodeType === B.DOCUMENT_TYPE_NODE
            }

            function q(e) {
                return e && e.nodeType === B.ELEMENT_NODE
            }

            function $(e) {
                return e && e.nodeType === B.TEXT_NODE
            }

            function X(e, t) {
                var i = e.childNodes || [];
                if (r(i, q) || j(t)) return !1;
                var n = r(i, j);
                return !(t && n && i.indexOf(n) > i.indexOf(t))
            }

            function Y(e, t) {
                var i = e.childNodes || [];
                if (r(i, (function(e) {
                        return q(e) && e !== t
                    }))) return !1;
                var n = r(i, j);
                return !(t && n && i.indexOf(n) > i.indexOf(t))
            }

            function K(e, t, i) {
                if (! function(e) {
                        return e && (e.nodeType === B.DOCUMENT_NODE || e.nodeType === B.DOCUMENT_FRAGMENT_NODE || e.nodeType === B.ELEMENT_NODE)
                    }(e)) throw new L(M, "Unexpected parent node type " + e.nodeType);
                if (i && i.parentNode !== e) throw new L(C, "child not in parent");
                if (! function(e) {
                        return e && (q(e) || $(e) || j(e) || e.nodeType === B.DOCUMENT_FRAGMENT_NODE || e.nodeType === B.COMMENT_NODE || e.nodeType === B.PROCESSING_INSTRUCTION_NODE)
                    }(t) || j(t) && e.nodeType !== B.DOCUMENT_NODE) throw new L(M, "Unexpected node type " + t.nodeType + " for parent node type " + e.nodeType)
            }

            function J(e, t, i) {
                var n = e.childNodes || [],
                    s = t.childNodes || [];
                if (t.nodeType === B.DOCUMENT_FRAGMENT_NODE) {
                    var a = s.filter(q);
                    if (a.length > 1 || r(s, $)) throw new L(M, "More than one element or text in fragment");
                    if (1 === a.length && !X(e, i)) throw new L(M, "Element in fragment can not be inserted before doctype")
                }
                if (q(t) && !X(e, i)) throw new L(M, "Only one element can be added and only after doctype");
                if (j(t)) {
                    if (r(n, j)) throw new L(M, "Only one doctype is allowed");
                    var o = r(n, q);
                    if (i && n.indexOf(o) < n.indexOf(i)) throw new L(M, "Doctype can only be inserted before an element");
                    if (!i && o) throw new L(M, "Doctype can not be appended since element is present")
                }
            }

            function Z(e, t, i) {
                var n = e.childNodes || [],
                    s = t.childNodes || [];
                if (t.nodeType === B.DOCUMENT_FRAGMENT_NODE) {
                    var a = s.filter(q);
                    if (a.length > 1 || r(s, $)) throw new L(M, "More than one element or text in fragment");
                    if (1 === a.length && !Y(e, i)) throw new L(M, "Element in fragment can not be inserted before doctype")
                }
                if (q(t) && !Y(e, i)) throw new L(M, "Only one element can be added and only after doctype");
                if (j(t)) {
                    if (r(n, (function(e) {
                            return j(e) && e !== i
                        }))) throw new L(M, "Only one doctype is allowed");
                    var o = r(n, q);
                    if (i && n.indexOf(o) < n.indexOf(i)) throw new L(M, "Doctype can only be inserted before an element")
                }
            }

            function Q(e, t, i, n) {
                K(e, t, i), e.nodeType === B.DOCUMENT_NODE && (n || J)(e, t, i);
                var r = t.parentNode;
                if (r && r.removeChild(t), t.nodeType === x) {
                    var s = t.firstChild;
                    if (null == s) return t;
                    var a = t.lastChild
                } else s = a = t;
                var o = i ? i.previousSibling : e.lastChild;
                s.previousSibling = o, a.nextSibling = i, o ? o.nextSibling = s : e.firstChild = s, null == i ? e.lastChild = a : i.previousSibling = a;
                do {
                    s.parentNode = e
                } while (s !== a && (s = s.nextSibling));
                return G(e.ownerDocument || e, e), t.nodeType == x && (t.firstChild = t.lastChild = null), t
            }

            function ee() {
                this._nsMap = {}
            }

            function te() {}

            function ie() {}

            function ne() {}

            function re() {}

            function se() {}

            function ae() {}

            function oe() {}

            function le() {}

            function he() {}

            function ce() {}

            function ue() {}

            function de() {}

            function pe(e, t) {
                var i = [],
                    n = 9 == this.nodeType && this.documentElement || this,
                    r = n.prefix,
                    s = n.namespaceURI;
                if (s && null == r && null == (r = n.lookupPrefix(s))) var a = [{
                    namespace: s,
                    prefix: null
                }];
                return ge(this, i, e, t, a), i.join("")
            }

            function fe(e, t, i) {
                var n = e.prefix || "",
                    r = e.namespaceURI;
                if (!r) return !1;
                if ("xml" === n && r === s.XML || r === s.XMLNS) return !1;
                for (var a = i.length; a--;) {
                    var o = i[a];
                    if (o.prefix === n) return o.namespace !== r
                }
                return !0
            }

            function me(e, t, i) {
                e.push(" ", t, '="', i.replace(/[<>&"\t\n\r]/g, F), '"')
            }

            function ge(e, t, i, n, r) {
                if (r || (r = []), n) {
                    if (!(e = n(e))) return;
                    if ("string" == typeof e) return void t.push(e)
                }
                switch (e.nodeType) {
                    case d:
                        var a = e.attributes,
                            o = a.length,
                            l = e.firstChild,
                            h = e.tagName,
                            c = h;
                        if (!(i = s.isHTML(e.namespaceURI) || i) && !e.prefix && e.namespaceURI) {
                            for (var u, y = 0; y < a.length; y++)
                                if ("xmlns" === a.item(y).name) {
                                    u = a.item(y).value;
                                    break
                                }
                            if (!u)
                                for (var w = r.length - 1; w >= 0; w--) {
                                    if ("" === (S = r[w]).prefix && S.namespace === e.namespaceURI) {
                                        u = S.namespace;
                                        break
                                    }
                                }
                            if (u !== e.namespaceURI)
                                for (w = r.length - 1; w >= 0; w--) {
                                    var S;
                                    if ((S = r[w]).namespace === e.namespaceURI) {
                                        S.prefix && (c = S.prefix + ":" + h);
                                        break
                                    }
                                }
                        }
                        t.push("<", c);
                        for (var E = 0; E < o; E++) {
                            "xmlns" == (M = a.item(E)).prefix ? r.push({
                                prefix: M.localName,
                                namespace: M.value
                            }) : "xmlns" == M.nodeName && r.push({
                                prefix: "",
                                namespace: M.value
                            })
                        }
                        for (E = 0; E < o; E++) {
                            var M, C, A;
                            if (fe(M = a.item(E), 0, r)) me(t, (C = M.prefix || "") ? "xmlns:" + C : "xmlns", A = M.namespaceURI), r.push({
                                prefix: C,
                                namespace: A
                            });
                            ge(M, t, i, n, r)
                        }
                        if (h === c && fe(e, 0, r)) me(t, (C = e.prefix || "") ? "xmlns:" + C : "xmlns", A = e.namespaceURI), r.push({
                            prefix: C,
                            namespace: A
                        });
                        if (l || i && !/^(?:meta|link|img|br|hr|input)$/i.test(h)) {
                            if (t.push(">"), i && /^script$/i.test(h))
                                for (; l;) l.data ? t.push(l.data) : ge(l, t, i, n, r.slice()), l = l.nextSibling;
                            else
                                for (; l;) ge(l, t, i, n, r.slice()), l = l.nextSibling;
                            t.push("</", c, ">")
                        } else t.push("/>");
                        return;
                    case b:
                    case x:
                        for (l = e.firstChild; l;) ge(l, t, i, n, r.slice()), l = l.nextSibling;
                        return;
                    case p:
                        return me(t, e.name, e.value);
                    case f:
                        return t.push(e.data.replace(/[<&>]/g, F));
                    case m:
                        return t.push("<![CDATA[", e.data, "]]>");
                    case v:
                        return t.push("\x3c!--", e.data, "--\x3e");
                    case T:
                        var L = e.publicId,
                            I = e.systemId;
                        if (t.push("<!DOCTYPE ", e.name), L) t.push(" PUBLIC ", L), I && "." != I && t.push(" ", I), t.push(">");
                        else if (I && "." != I) t.push(" SYSTEM ", I, ">");
                        else {
                            var P = e.internalSubset;
                            P && t.push(" [", P, "]"), t.push(">")
                        }
                        return;
                    case _:
                        return t.push("<?", e.target, " ", e.data, "?>");
                    case g:
                        return t.push("&", e.nodeName, ";");
                    default:
                        t.push("??", e.nodeName)
                }
            }

            function ye(e, t, i) {
                var n;
                switch (t.nodeType) {
                    case d:
                        (n = t.cloneNode(!1)).ownerDocument = e;
                    case x:
                        break;
                    case p:
                        i = !0
                }
                if (n || (n = t.cloneNode(!1)), n.ownerDocument = e, n.parentNode = null, i)
                    for (var r = t.firstChild; r;) n.appendChild(ye(e, r, i)), r = r.nextSibling;
                return n
            }

            function _e(e, t, i) {
                var n = new t.constructor;
                for (var r in t)
                    if (Object.prototype.hasOwnProperty.call(t, r)) {
                        var s = t[r];
                        "object" != typeof s && s != n[r] && (n[r] = s)
                    }
                switch (t.childNodes && (n.childNodes = new I), n.ownerDocument = e, n.nodeType) {
                    case d:
                        var a = t.attributes,
                            o = n.attributes = new k,
                            l = a.length;
                        o._ownerElement = n;
                        for (var h = 0; h < l; h++) n.setAttributeNode(_e(e, a.item(h), !0));
                        break;
                    case p:
                        i = !0
                }
                if (i)
                    for (var c = t.firstChild; c;) n.appendChild(_e(e, c, i)), c = c.nextSibling;
                return n
            }

            function ve(e, t, i) {
                e[t] = i
            }
            L.prototype = Error.prototype, h(S, L), I.prototype = {
                length: 0,
                item: function(e) {
                    return this[e] || null
                },
                toString: function(e, t) {
                    for (var i = [], n = 0; n < this.length; n++) ge(this[n], i, e, t);
                    return i.join("")
                },
                filter: function(e) {
                    return Array.prototype.filter.call(this, e)
                },
                indexOf: function(e) {
                    return Array.prototype.indexOf.call(this, e)
                }
            }, P.prototype.item = function(e) {
                return R(this), this[e]
            }, c(P, I), k.prototype = {
                length: 0,
                item: I.prototype.item,
                getNamedItem: function(e) {
                    for (var t = this.length; t--;) {
                        var i = this[t];
                        if (i.nodeName == e) return i
                    }
                },
                setNamedItem: function(e) {
                    var t = e.ownerElement;
                    if (t && t != this._ownerElement) throw new L(A);
                    var i = this.getNamedItem(e.nodeName);
                    return O(this._ownerElement, this, e, i), i
                },
                setNamedItemNS: function(e) {
                    var t, i = e.ownerElement;
                    if (i && i != this._ownerElement) throw new L(A);
                    return t = this.getNamedItemNS(e.namespaceURI, e.localName), O(this._ownerElement, this, e, t), t
                },
                removeNamedItem: function(e) {
                    var t = this.getNamedItem(e);
                    return N(this._ownerElement, this, t), t
                },
                removeNamedItemNS: function(e, t) {
                    var i = this.getNamedItemNS(e, t);
                    return N(this._ownerElement, this, i), i
                },
                getNamedItemNS: function(e, t) {
                    for (var i = this.length; i--;) {
                        var n = this[i];
                        if (n.localName == t && n.namespaceURI == e) return n
                    }
                    return null
                }
            }, U.prototype = {
                hasFeature: function(e, t) {
                    return !0
                },
                createDocument: function(e, t, i) {
                    var n = new z;
                    if (n.implementation = this, n.childNodes = new I, n.doctype = i || null, i && n.appendChild(i), t) {
                        var r = n.createElementNS(e, t);
                        n.appendChild(r)
                    }
                    return n
                },
                createDocumentType: function(e, t, i) {
                    var n = new ae;
                    return n.name = e, n.nodeName = e, n.publicId = t || "", n.systemId = i || "", n
                }
            }, B.prototype = {
                firstChild: null,
                lastChild: null,
                previousSibling: null,
                nextSibling: null,
                attributes: null,
                parentNode: null,
                childNodes: null,
                ownerDocument: null,
                nodeValue: null,
                namespaceURI: null,
                prefix: null,
                localName: null,
                insertBefore: function(e, t) {
                    return Q(this, e, t)
                },
                replaceChild: function(e, t) {
                    Q(this, e, t, Z), t && this.removeChild(t)
                },
                removeChild: function(e) {
                    return W(this, e)
                },
                appendChild: function(e) {
                    return this.insertBefore(e, null)
                },
                hasChildNodes: function() {
                    return null != this.firstChild
                },
                cloneNode: function(e) {
                    return _e(this.ownerDocument || this, this, e)
                },
                normalize: function() {
                    for (var e = this.firstChild; e;) {
                        var t = e.nextSibling;
                        t && t.nodeType == f && e.nodeType == f ? (this.removeChild(t), e.appendData(t.data)) : (e.normalize(), e = t)
                    }
                },
                isSupported: function(e, t) {
                    return this.ownerDocument.implementation.hasFeature(e, t)
                },
                hasAttributes: function() {
                    return this.attributes.length > 0
                },
                lookupPrefix: function(e) {
                    for (var t = this; t;) {
                        var i = t._nsMap;
                        if (i)
                            for (var n in i)
                                if (Object.prototype.hasOwnProperty.call(i, n) && i[n] === e) return n;
                        t = t.nodeType == p ? t.ownerDocument : t.parentNode
                    }
                    return null
                },
                lookupNamespaceURI: function(e) {
                    for (var t = this; t;) {
                        var i = t._nsMap;
                        if (i && Object.prototype.hasOwnProperty.call(i, e)) return i[e];
                        t = t.nodeType == p ? t.ownerDocument : t.parentNode
                    }
                    return null
                },
                isDefaultNamespace: function(e) {
                    return null == this.lookupPrefix(e)
                }
            }, h(u, B), h(u, B.prototype), z.prototype = {
                nodeName: "#document",
                nodeType: b,
                doctype: null,
                documentElement: null,
                _inc: 1,
                insertBefore: function(e, t) {
                    if (e.nodeType == x) {
                        for (var i = e.firstChild; i;) {
                            var n = i.nextSibling;
                            this.insertBefore(i, t), i = n
                        }
                        return e
                    }
                    return Q(this, e, t), e.ownerDocument = this, null === this.documentElement && e.nodeType === d && (this.documentElement = e), e
                },
                removeChild: function(e) {
                    return this.documentElement == e && (this.documentElement = null), W(this, e)
                },
                replaceChild: function(e, t) {
                    Q(this, e, t, Z), e.ownerDocument = this, t && this.removeChild(t), q(e) && (this.documentElement = e)
                },
                importNode: function(e, t) {
                    return ye(this, e, t)
                },
                getElementById: function(e) {
                    var t = null;
                    return H(this.documentElement, (function(i) {
                        if (i.nodeType == d && i.getAttribute("id") == e) return t = i, !0
                    })), t
                },
                getElementsByClassName: function(e) {
                    var t = l(e);
                    return new P(this, (function(i) {
                        var n = [];
                        return t.length > 0 && H(i.documentElement, (function(r) {
                            if (r !== i && r.nodeType === d) {
                                var s = r.getAttribute("class");
                                if (s) {
                                    var a = e === s;
                                    if (!a) {
                                        var o = l(s);
                                        a = t.every((h = o, function(e) {
                                            return h && -1 !== h.indexOf(e)
                                        }))
                                    }
                                    a && n.push(r)
                                }
                            }
                            var h
                        })), n
                    }))
                },
                createElement: function(e) {
                    var t = new ee;
                    return t.ownerDocument = this, t.nodeName = e, t.tagName = e, t.localName = e, t.childNodes = new I, (t.attributes = new k)._ownerElement = t, t
                },
                createDocumentFragment: function() {
                    var e = new ce;
                    return e.ownerDocument = this, e.childNodes = new I, e
                },
                createTextNode: function(e) {
                    var t = new ne;
                    return t.ownerDocument = this, t.appendData(e), t
                },
                createComment: function(e) {
                    var t = new re;
                    return t.ownerDocument = this, t.appendData(e), t
                },
                createCDATASection: function(e) {
                    var t = new se;
                    return t.ownerDocument = this, t.appendData(e), t
                },
                createProcessingInstruction: function(e, t) {
                    var i = new ue;
                    return i.ownerDocument = this, i.tagName = i.target = e, i.nodeValue = i.data = t, i
                },
                createAttribute: function(e) {
                    var t = new te;
                    return t.ownerDocument = this, t.name = e, t.nodeName = e, t.localName = e, t.specified = !0, t
                },
                createEntityReference: function(e) {
                    var t = new he;
                    return t.ownerDocument = this, t.nodeName = e, t
                },
                createElementNS: function(e, t) {
                    var i = new ee,
                        n = t.split(":"),
                        r = i.attributes = new k;
                    return i.childNodes = new I, i.ownerDocument = this, i.nodeName = t, i.tagName = t, i.namespaceURI = e, 2 == n.length ? (i.prefix = n[0], i.localName = n[1]) : i.localName = t, r._ownerElement = i, i
                },
                createAttributeNS: function(e, t) {
                    var i = new te,
                        n = t.split(":");
                    return i.ownerDocument = this, i.nodeName = t, i.name = t, i.namespaceURI = e, i.specified = !0, 2 == n.length ? (i.prefix = n[0], i.localName = n[1]) : i.localName = t, i
                }
            }, c(z, B), ee.prototype = {
                nodeType: d,
                hasAttribute: function(e) {
                    return null != this.getAttributeNode(e)
                },
                getAttribute: function(e) {
                    var t = this.getAttributeNode(e);
                    return t && t.value || ""
                },
                getAttributeNode: function(e) {
                    return this.attributes.getNamedItem(e)
                },
                setAttribute: function(e, t) {
                    var i = this.ownerDocument.createAttribute(e);
                    i.value = i.nodeValue = "" + t, this.setAttributeNode(i)
                },
                removeAttribute: function(e) {
                    var t = this.getAttributeNode(e);
                    t && this.removeAttributeNode(t)
                },
                appendChild: function(e) {
                    return e.nodeType === x ? this.insertBefore(e, null) : function(e, t) {
                        return t.parentNode && t.parentNode.removeChild(t), t.parentNode = e, t.previousSibling = e.lastChild, t.nextSibling = null, t.previousSibling ? t.previousSibling.nextSibling = t : e.firstChild = t, e.lastChild = t, G(e.ownerDocument, e, t), t
                    }(this, e)
                },
                setAttributeNode: function(e) {
                    return this.attributes.setNamedItem(e)
                },
                setAttributeNodeNS: function(e) {
                    return this.attributes.setNamedItemNS(e)
                },
                removeAttributeNode: function(e) {
                    return this.attributes.removeNamedItem(e.nodeName)
                },
                removeAttributeNS: function(e, t) {
                    var i = this.getAttributeNodeNS(e, t);
                    i && this.removeAttributeNode(i)
                },
                hasAttributeNS: function(e, t) {
                    return null != this.getAttributeNodeNS(e, t)
                },
                getAttributeNS: function(e, t) {
                    var i = this.getAttributeNodeNS(e, t);
                    return i && i.value || ""
                },
                setAttributeNS: function(e, t, i) {
                    var n = this.ownerDocument.createAttributeNS(e, t);
                    n.value = n.nodeValue = "" + i, this.setAttributeNode(n)
                },
                getAttributeNodeNS: function(e, t) {
                    return this.attributes.getNamedItemNS(e, t)
                },
                getElementsByTagName: function(e) {
                    return new P(this, (function(t) {
                        var i = [];
                        return H(t, (function(n) {
                            n === t || n.nodeType != d || "*" !== e && n.tagName != e || i.push(n)
                        })), i
                    }))
                },
                getElementsByTagNameNS: function(e, t) {
                    return new P(this, (function(i) {
                        var n = [];
                        return H(i, (function(r) {
                            r === i || r.nodeType !== d || "*" !== e && r.namespaceURI !== e || "*" !== t && r.localName != t || n.push(r)
                        })), n
                    }))
                }
            }, z.prototype.getElementsByTagName = ee.prototype.getElementsByTagName, z.prototype.getElementsByTagNameNS = ee.prototype.getElementsByTagNameNS, c(ee, B), te.prototype.nodeType = p, c(te, B), ie.prototype = {
                data: "",
                substringData: function(e, t) {
                    return this.data.substring(e, e + t)
                },
                appendData: function(e) {
                    e = this.data + e, this.nodeValue = this.data = e, this.length = e.length
                },
                insertData: function(e, t) {
                    this.replaceData(e, 0, t)
                },
                appendChild: function(e) {
                    throw new Error(E[M])
                },
                deleteData: function(e, t) {
                    this.replaceData(e, t, "")
                },
                replaceData: function(e, t, i) {
                    i = this.data.substring(0, e) + i + this.data.substring(e + t), this.nodeValue = this.data = i, this.length = i.length
                }
            }, c(ie, B), ne.prototype = {
                nodeName: "#text",
                nodeType: f,
                splitText: function(e) {
                    var t = this.data,
                        i = t.substring(e);
                    t = t.substring(0, e), this.data = this.nodeValue = t, this.length = t.length;
                    var n = this.ownerDocument.createTextNode(i);
                    return this.parentNode && this.parentNode.insertBefore(n, this.nextSibling), n
                }
            }, c(ne, ie), re.prototype = {
                nodeName: "#comment",
                nodeType: v
            }, c(re, ie), se.prototype = {
                nodeName: "#cdata-section",
                nodeType: m
            }, c(se, ie), ae.prototype.nodeType = T, c(ae, B), oe.prototype.nodeType = w, c(oe, B), le.prototype.nodeType = y, c(le, B), he.prototype.nodeType = g, c(he, B), ce.prototype.nodeName = "#document-fragment", ce.prototype.nodeType = x, c(ce, B), ue.prototype.nodeType = _, c(ue, B), de.prototype.serializeToString = function(e, t, i) {
                return pe.call(e, t, i)
            }, B.prototype.toString = pe;
            try {
                if (Object.defineProperty) {
                    function be(e) {
                        switch (e.nodeType) {
                            case d:
                            case x:
                                var t = [];
                                for (e = e.firstChild; e;) 7 !== e.nodeType && 8 !== e.nodeType && t.push(be(e)), e = e.nextSibling;
                                return t.join("");
                            default:
                                return e.nodeValue
                        }
                    }
                    Object.defineProperty(P.prototype, "length", {
                        get: function() {
                            return R(this), this.$$length
                        }
                    }), Object.defineProperty(B.prototype, "textContent", {
                        get: function() {
                            return be(this)
                        },
                        set: function(e) {
                            switch (this.nodeType) {
                                case d:
                                case x:
                                    for (; this.firstChild;) this.removeChild(this.firstChild);
                                    (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e));
                                    break;
                                default:
                                    this.data = e, this.value = e, this.nodeValue = e
                            }
                        }
                    }), ve = function(e, t, i) {
                        e["$$" + t] = i
                    }
                }
            } catch (Te) {}
            t.DocumentType = ae, t.DOMException = L, t.DOMImplementation = U, t.Element = ee, t.Node = B, t.NodeList = I, t.XMLSerializer = de
        },
        8057: (e, t, i) => {
            var n = i(7453).freeze;
            t.XML_ENTITIES = n({
                amp: "&",
                apos: "'",
                gt: ">",
                lt: "<",
                quot: '"'
            }), t.HTML_ENTITIES = n({
                lt: "<",
                gt: ">",
                amp: "&",
                quot: '"',
                apos: "'",
                Agrave: "À",
                Aacute: "Á",
                Acirc: "Â",
                Atilde: "Ã",
                Auml: "Ä",
                Aring: "Å",
                AElig: "Æ",
                Ccedil: "Ç",
                Egrave: "È",
                Eacute: "É",
                Ecirc: "Ê",
                Euml: "Ë",
                Igrave: "Ì",
                Iacute: "Í",
                Icirc: "Î",
                Iuml: "Ï",
                ETH: "Ð",
                Ntilde: "Ñ",
                Ograve: "Ò",
                Oacute: "Ó",
                Ocirc: "Ô",
                Otilde: "Õ",
                Ouml: "Ö",
                Oslash: "Ø",
                Ugrave: "Ù",
                Uacute: "Ú",
                Ucirc: "Û",
                Uuml: "Ü",
                Yacute: "Ý",
                THORN: "Þ",
                szlig: "ß",
                agrave: "à",
                aacute: "á",
                acirc: "â",
                atilde: "ã",
                auml: "ä",
                aring: "å",
                aelig: "æ",
                ccedil: "ç",
                egrave: "è",
                eacute: "é",
                ecirc: "ê",
                euml: "ë",
                igrave: "ì",
                iacute: "í",
                icirc: "î",
                iuml: "ï",
                eth: "ð",
                ntilde: "ñ",
                ograve: "ò",
                oacute: "ó",
                ocirc: "ô",
                otilde: "õ",
                ouml: "ö",
                oslash: "ø",
                ugrave: "ù",
                uacute: "ú",
                ucirc: "û",
                uuml: "ü",
                yacute: "ý",
                thorn: "þ",
                yuml: "ÿ",
                nbsp: " ",
                iexcl: "¡",
                cent: "¢",
                pound: "£",
                curren: "¤",
                yen: "¥",
                brvbar: "¦",
                sect: "§",
                uml: "¨",
                copy: "©",
                ordf: "ª",
                laquo: "«",
                not: "¬",
                shy: "­­",
                reg: "®",
                macr: "¯",
                deg: "°",
                plusmn: "±",
                sup2: "²",
                sup3: "³",
                acute: "´",
                micro: "µ",
                para: "¶",
                middot: "·",
                cedil: "¸",
                sup1: "¹",
                ordm: "º",
                raquo: "»",
                frac14: "¼",
                frac12: "½",
                frac34: "¾",
                iquest: "¿",
                times: "×",
                divide: "÷",
                forall: "∀",
                part: "∂",
                exist: "∃",
                empty: "∅",
                nabla: "∇",
                isin: "∈",
                notin: "∉",
                ni: "∋",
                prod: "∏",
                sum: "∑",
                minus: "−",
                lowast: "∗",
                radic: "√",
                prop: "∝",
                infin: "∞",
                ang: "∠",
                and: "∧",
                or: "∨",
                cap: "∩",
                cup: "∪",
                int: "∫",
                there4: "∴",
                sim: "∼",
                cong: "≅",
                asymp: "≈",
                ne: "≠",
                equiv: "≡",
                le: "≤",
                ge: "≥",
                sub: "⊂",
                sup: "⊃",
                nsub: "⊄",
                sube: "⊆",
                supe: "⊇",
                oplus: "⊕",
                otimes: "⊗",
                perp: "⊥",
                sdot: "⋅",
                Alpha: "Α",
                Beta: "Β",
                Gamma: "Γ",
                Delta: "Δ",
                Epsilon: "Ε",
                Zeta: "Ζ",
                Eta: "Η",
                Theta: "Θ",
                Iota: "Ι",
                Kappa: "Κ",
                Lambda: "Λ",
                Mu: "Μ",
                Nu: "Ν",
                Xi: "Ξ",
                Omicron: "Ο",
                Pi: "Π",
                Rho: "Ρ",
                Sigma: "Σ",
                Tau: "Τ",
                Upsilon: "Υ",
                Phi: "Φ",
                Chi: "Χ",
                Psi: "Ψ",
                Omega: "Ω",
                alpha: "α",
                beta: "β",
                gamma: "γ",
                delta: "δ",
                epsilon: "ε",
                zeta: "ζ",
                eta: "η",
                theta: "θ",
                iota: "ι",
                kappa: "κ",
                lambda: "λ",
                mu: "μ",
                nu: "ν",
                xi: "ξ",
                omicron: "ο",
                pi: "π",
                rho: "ρ",
                sigmaf: "ς",
                sigma: "σ",
                tau: "τ",
                upsilon: "υ",
                phi: "φ",
                chi: "χ",
                psi: "ψ",
                omega: "ω",
                thetasym: "ϑ",
                upsih: "ϒ",
                piv: "ϖ",
                OElig: "Œ",
                oelig: "œ",
                Scaron: "Š",
                scaron: "š",
                Yuml: "Ÿ",
                fnof: "ƒ",
                circ: "ˆ",
                tilde: "˜",
                ensp: " ",
                emsp: " ",
                thinsp: " ",
                zwnj: "‌",
                zwj: "‍",
                lrm: "‎",
                rlm: "‏",
                ndash: "–",
                mdash: "—",
                lsquo: "‘",
                rsquo: "’",
                sbquo: "‚",
                ldquo: "“",
                rdquo: "”",
                bdquo: "„",
                dagger: "†",
                Dagger: "‡",
                bull: "•",
                hellip: "…",
                permil: "‰",
                prime: "′",
                Prime: "″",
                lsaquo: "‹",
                rsaquo: "›",
                oline: "‾",
                euro: "€",
                trade: "™",
                larr: "←",
                uarr: "↑",
                rarr: "→",
                darr: "↓",
                harr: "↔",
                crarr: "↵",
                lceil: "⌈",
                rceil: "⌉",
                lfloor: "⌊",
                rfloor: "⌋",
                loz: "◊",
                spades: "♠",
                clubs: "♣",
                hearts: "♥",
                diams: "♦"
            }), t.entityMap = t.HTML_ENTITIES
        },
        8903: (e, t, i) => {
            var n = i(7080);
            n.DOMImplementation, n.XMLSerializer, t.DOMParser = i(3161).DOMParser
        },
        8868: (e, t, i) => {
            var n = i(7453).NAMESPACE,
                r = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
                s = new RegExp("[\\-\\.0-9" + r.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),
                a = new RegExp("^" + r.source + s.source + "*(?::" + r.source + s.source + "*)?$"),
                o = 0,
                l = 1,
                h = 2,
                c = 3,
                u = 4,
                d = 5,
                p = 6,
                f = 7;

            function m(e, t) {
                this.message = e, this.locator = t, Error.captureStackTrace && Error.captureStackTrace(this, m)
            }

            function g() {}

            function y(e, t) {
                return t.lineNumber = e.lineNumber, t.columnNumber = e.columnNumber, t
            }

            function _(e, t, i, r, s, a) {
                function m(e, t, n) {
                    i.attributeNames.hasOwnProperty(e) && a.fatalError("Attribute " + e + " redefined"), i.addValue(e, t.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, s), n)
                }
                for (var g, y = ++t, _ = o;;) {
                    var v = e.charAt(y);
                    switch (v) {
                        case "=":
                            if (_ === l) g = e.slice(t, y), _ = c;
                            else {
                                if (_ !== h) throw new Error("attribute equal must after attrName");
                                _ = c
                            }
                            break;
                        case "'":
                        case '"':
                            if (_ === c || _ === l) {
                                if (_ === l && (a.warning('attribute value must after "="'), g = e.slice(t, y)), t = y + 1, !((y = e.indexOf(v, t)) > 0)) throw new Error("attribute value no end '" + v + "' match");
                                m(g, b = e.slice(t, y), t - 1), _ = d
                            } else {
                                if (_ != u) throw new Error('attribute value must after "="');
                                m(g, b = e.slice(t, y), t), a.warning('attribute "' + g + '" missed start quot(' + v + ")!!"), t = y + 1, _ = d
                            }
                            break;
                        case "/":
                            switch (_) {
                                case o:
                                    i.setTagName(e.slice(t, y));
                                case d:
                                case p:
                                case f:
                                    _ = f, i.closed = !0;
                                case u:
                                case l:
                                case h:
                                    break;
                                default:
                                    throw new Error("attribute invalid close char('/')")
                            }
                            break;
                        case "":
                            return a.error("unexpected end of input"), _ == o && i.setTagName(e.slice(t, y)), y;
                        case ">":
                            switch (_) {
                                case o:
                                    i.setTagName(e.slice(t, y));
                                case d:
                                case p:
                                case f:
                                    break;
                                case u:
                                case l:
                                    "/" === (b = e.slice(t, y)).slice(-1) && (i.closed = !0, b = b.slice(0, -1));
                                case h:
                                    _ === h && (b = g), _ == u ? (a.warning('attribute "' + b + '" missed quot(")!'), m(g, b, t)) : (n.isHTML(r[""]) && b.match(/^(?:disabled|checked|selected)$/i) || a.warning('attribute "' + b + '" missed value!! "' + b + '" instead!!'), m(b, b, t));
                                    break;
                                case c:
                                    throw new Error("attribute value missed!!")
                            }
                            return y;
                        case "":
                            v = " ";
                        default:
                            if (v <= " ") switch (_) {
                                case o:
                                    i.setTagName(e.slice(t, y)), _ = p;
                                    break;
                                case l:
                                    g = e.slice(t, y), _ = h;
                                    break;
                                case u:
                                    var b = e.slice(t, y);
                                    a.warning('attribute "' + b + '" missed quot(")!!'), m(g, b, t);
                                case d:
                                    _ = p
                            } else switch (_) {
                                case h:
                                    i.tagName;
                                    n.isHTML(r[""]) && g.match(/^(?:disabled|checked|selected)$/i) || a.warning('attribute "' + g + '" missed value!! "' + g + '" instead2!!'), m(g, g, t), t = y, _ = l;
                                    break;
                                case d:
                                    a.warning('attribute space is required"' + g + '"!!');
                                case p:
                                    _ = l, t = y;
                                    break;
                                case c:
                                    _ = u, t = y;
                                    break;
                                case f:
                                    throw new Error("elements closed character '/' and '>' must be connected to")
                            }
                    }
                    y++
                }
            }

            function v(e, t, i) {
                for (var r = e.tagName, s = null, a = e.length; a--;) {
                    var o = e[a],
                        l = o.qName,
                        h = o.value;
                    if ((p = l.indexOf(":")) > 0) var c = o.prefix = l.slice(0, p),
                        u = l.slice(p + 1),
                        d = "xmlns" === c && u;
                    else u = l, c = null, d = "xmlns" === l && "";
                    o.localName = u, !1 !== d && (null == s && (s = {}, x(i, i = {})), i[d] = s[d] = h, o.uri = n.XMLNS, t.startPrefixMapping(d, h))
                }
                for (a = e.length; a--;) {
                    (c = (o = e[a]).prefix) && ("xml" === c && (o.uri = n.XML), "xmlns" !== c && (o.uri = i[c || ""]))
                }
                var p;
                (p = r.indexOf(":")) > 0 ? (c = e.prefix = r.slice(0, p), u = e.localName = r.slice(p + 1)) : (c = null, u = e.localName = r);
                var f = e.uri = i[c || ""];
                if (t.startElement(f, u, r, e), !e.closed) return e.currentNSMap = i, e.localNSMap = s, !0;
                if (t.endElement(f, u, r), s)
                    for (c in s) Object.prototype.hasOwnProperty.call(s, c) && t.endPrefixMapping(c)
            }

            function b(e, t, i, n, r) {
                if (/^(?:script|textarea)$/i.test(i)) {
                    var s = e.indexOf("</" + i + ">", t),
                        a = e.substring(t + 1, s);
                    if (/[&<]/.test(a)) return /^script$/i.test(i) ? (r.characters(a, 0, a.length), s) : (a = a.replace(/&#?\w+;/g, n), r.characters(a, 0, a.length), s)
                }
                return t + 1
            }

            function T(e, t, i, n) {
                var r = n[i];
                return null == r && ((r = e.lastIndexOf("</" + i + ">")) < t && (r = e.lastIndexOf("</" + i)), n[i] = r), r < t
            }

            function x(e, t) {
                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }

            function w(e, t, i, n) {
                if ("-" === e.charAt(t + 2)) return "-" === e.charAt(t + 3) ? (r = e.indexOf("--\x3e", t + 4)) > t ? (i.comment(e, t + 4, r - t - 4), r + 3) : (n.error("Unclosed comment"), -1) : -1;
                if ("CDATA[" == e.substr(t + 3, 6)) {
                    var r = e.indexOf("]]>", t + 9);
                    return i.startCDATA(), i.characters(e, t + 9, r - t - 9), i.endCDATA(), r + 3
                }
                var s = function(e, t) {
                        var i, n = [],
                            r = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
                        r.lastIndex = t, r.exec(e);
                        for (; i = r.exec(e);)
                            if (n.push(i), i[1]) return n
                    }(e, t),
                    a = s.length;
                if (a > 1 && /!doctype/i.test(s[0][0])) {
                    var o = s[1][0],
                        l = !1,
                        h = !1;
                    a > 3 && (/^public$/i.test(s[2][0]) ? (l = s[3][0], h = a > 4 && s[4][0]) : /^system$/i.test(s[2][0]) && (h = s[3][0]));
                    var c = s[a - 1];
                    return i.startDTD(o, l, h), i.endDTD(), c.index + c[0].length
                }
                return -1
            }

            function S(e, t, i) {
                var n = e.indexOf("?>", t);
                if (n) {
                    var r = e.substring(t, n).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
                    if (r) {
                        r[0].length;
                        return i.processingInstruction(r[1], r[2]), n + 2
                    }
                    return -1
                }
                return -1
            }

            function E() {
                this.attributeNames = {}
            }
            m.prototype = new Error, m.prototype.name = m.name, g.prototype = {
                parse: function(e, t, i) {
                    var r = this.domBuilder;
                    r.startDocument(), x(t, t = {}),
                        function(e, t, i, r, s) {
                            function a(e) {
                                if (e > 65535) {
                                    var t = 55296 + ((e -= 65536) >> 10),
                                        i = 56320 + (1023 & e);
                                    return String.fromCharCode(t, i)
                                }
                                return String.fromCharCode(e)
                            }

                            function o(e) {
                                var t = e.slice(1, -1);
                                return Object.hasOwnProperty.call(i, t) ? i[t] : "#" === t.charAt(0) ? a(parseInt(t.substr(1).replace("x", "0x"))) : (s.error("entity not found:" + e), e)
                            }

                            function l(t) {
                                if (t > x) {
                                    var i = e.substring(x, t).replace(/&#?\w+;/g, o);
                                    p && h(x), r.characters(i, 0, t - x), x = t
                                }
                            }

                            function h(t, i) {
                                for (; t >= u && (i = d.exec(e));) c = i.index, u = c + i[0].length, p.lineNumber++;
                                p.columnNumber = t - c + 1
                            }
                            var c = 0,
                                u = 0,
                                d = /.*(?:\r\n?|\n)|.*$/g,
                                p = r.locator,
                                f = [{
                                    currentNSMap: t
                                }],
                                g = {},
                                x = 0;
                            for (;;) {
                                try {
                                    var M = e.indexOf("<", x);
                                    if (M < 0) {
                                        if (!e.substr(x).match(/^\s*$/)) {
                                            var C = r.doc,
                                                A = C.createTextNode(e.substr(x));
                                            C.appendChild(A), r.currentElement = A
                                        }
                                        return
                                    }
                                    switch (M > x && l(M), e.charAt(M + 1)) {
                                        case "/":
                                            var L = e.indexOf(">", M + 3),
                                                I = e.substring(M + 2, L).replace(/[ \t\n\r]+$/g, ""),
                                                P = f.pop();
                                            L < 0 ? (I = e.substring(M + 2).replace(/[\s<].*/, ""), s.error("end tag name: " + I + " is not complete:" + P.tagName), L = M + 1 + I.length) : I.match(/\s</) && (I = I.replace(/[\s<].*/, ""), s.error("end tag name: " + I + " maybe not complete"), L = M + 1 + I.length);
                                            var R = P.localNSMap,
                                                k = P.tagName == I;
                                            if (k || P.tagName && P.tagName.toLowerCase() == I.toLowerCase()) {
                                                if (r.endElement(P.uri, P.localName, I), R)
                                                    for (var D in R) Object.prototype.hasOwnProperty.call(R, D) && r.endPrefixMapping(D);
                                                k || s.fatalError("end tag name: " + I + " is not match the current start tagName:" + P.tagName)
                                            } else f.push(P);
                                            L++;
                                            break;
                                        case "?":
                                            p && h(M), L = S(e, M, r);
                                            break;
                                        case "!":
                                            p && h(M), L = w(e, M, r, s);
                                            break;
                                        default:
                                            p && h(M);
                                            var O = new E,
                                                N = f[f.length - 1].currentNSMap,
                                                U = (L = _(e, M, O, N, o, s), O.length);
                                            if (!O.closed && T(e, L, O.tagName, g) && (O.closed = !0, i.nbsp || s.warning("unclosed xml attribute")), p && U) {
                                                for (var B = y(p, {}), F = 0; F < U; F++) {
                                                    var H = O[F];
                                                    h(H.offset), H.locator = y(p, {})
                                                }
                                                r.locator = B, v(O, r, N) && f.push(O), r.locator = p
                                            } else v(O, r, N) && f.push(O);
                                            n.isHTML(O.uri) && !O.closed ? L = b(e, L, O.tagName, o, r) : L++
                                    }
                                } catch (e) {
                                    if (e instanceof m) throw e;
                                    s.error("element parse error: " + e), L = -1
                                }
                                L > x ? x = L : l(Math.max(M, x) + 1)
                            }
                        }(e, t, i, r, this.errorHandler), r.endDocument()
                }
            }, E.prototype = {
                setTagName: function(e) {
                    if (!a.test(e)) throw new Error("invalid tagName:" + e);
                    this.tagName = e
                },
                addValue: function(e, t, i) {
                    if (!a.test(e)) throw new Error("invalid attribute:" + e);
                    this.attributeNames[e] = this.length, this[this.length++] = {
                        qName: e,
                        value: t,
                        offset: i
                    }
                },
                length: 0,
                getLocalName: function(e) {
                    return this[e].localName
                },
                getLocator: function(e) {
                    return this[e].locator
                },
                getQName: function(e) {
                    return this[e].qName
                },
                getURI: function(e) {
                    return this[e].uri
                },
                getValue: function(e) {
                    return this[e].value
                }
            }, t.XMLReader = g, t.ParseError = m
        },
        6717: (e, t) => {
            "use strict";
            t.byteLength = function(e) {
                var t = l(e),
                    i = t[0],
                    n = t[1];
                return 3 * (i + n) / 4 - n
            }, t.toByteArray = function(e) {
                var t, i, s = l(e),
                    a = s[0],
                    o = s[1],
                    h = new r(function(e, t, i) {
                        return 3 * (t + i) / 4 - i
                    }(0, a, o)),
                    c = 0,
                    u = o > 0 ? a - 4 : a;
                for (i = 0; i < u; i += 4) t = n[e.charCodeAt(i)] << 18 | n[e.charCodeAt(i + 1)] << 12 | n[e.charCodeAt(i + 2)] << 6 | n[e.charCodeAt(i + 3)], h[c++] = t >> 16 & 255, h[c++] = t >> 8 & 255, h[c++] = 255 & t;
                2 === o && (t = n[e.charCodeAt(i)] << 2 | n[e.charCodeAt(i + 1)] >> 4, h[c++] = 255 & t);
                1 === o && (t = n[e.charCodeAt(i)] << 10 | n[e.charCodeAt(i + 1)] << 4 | n[e.charCodeAt(i + 2)] >> 2, h[c++] = t >> 8 & 255, h[c++] = 255 & t);
                return h
            }, t.fromByteArray = function(e) {
                for (var t, n = e.length, r = n % 3, s = [], a = 16383, o = 0, l = n - r; o < l; o += a) s.push(h(e, o, o + a > l ? l : o + a));
                1 === r ? (t = e[n - 1], s.push(i[t >> 2] + i[t << 4 & 63] + "==")) : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], s.push(i[t >> 10] + i[t >> 4 & 63] + i[t << 2 & 63] + "="));
                return s.join("")
            };
            for (var i = [], n = [], r = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, o = s.length; a < o; ++a) i[a] = s[a], n[s.charCodeAt(a)] = a;

            function l(e) {
                var t = e.length;
                if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                var i = e.indexOf("=");
                return -1 === i && (i = t), [i, i === t ? 0 : 4 - i % 4]
            }

            function h(e, t, n) {
                for (var r, s, a = [], o = t; o < n; o += 3) r = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (255 & e[o + 2]), a.push(i[(s = r) >> 18 & 63] + i[s >> 12 & 63] + i[s >> 6 & 63] + i[63 & s]);
                return a.join("")
            }
            n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63
        },
        5851: (e, t, i) => {
            "use strict";
            var n = i(6717),
                r = i(9350),
                s = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
            t.lW = l, t.h2 = 50;
            var a = 2147483647;

            function o(e) {
                if (e > a) throw new RangeError('The value "' + e + '" is invalid for option "size"');
                var t = new Uint8Array(e);
                return Object.setPrototypeOf(t, l.prototype), t
            }

            function l(e, t, i) {
                if ("number" == typeof e) {
                    if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
                    return u(e)
                }
                return h(e, t, i)
            }

            function h(e, t, i) {
                if ("string" == typeof e) return function(e, t) {
                    "string" == typeof t && "" !== t || (t = "utf8");
                    if (!l.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
                    var i = 0 | m(e, t),
                        n = o(i),
                        r = n.write(e, t);
                    r !== i && (n = n.slice(0, r));
                    return n
                }(e, t);
                if (ArrayBuffer.isView(e)) return function(e) {
                    if (z(e, Uint8Array)) {
                        var t = new Uint8Array(e);
                        return p(t.buffer, t.byteOffset, t.byteLength)
                    }
                    return d(e)
                }(e);
                if (null == e) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
                if (z(e, ArrayBuffer) || e && z(e.buffer, ArrayBuffer)) return p(e, t, i);
                if ("undefined" != typeof SharedArrayBuffer && (z(e, SharedArrayBuffer) || e && z(e.buffer, SharedArrayBuffer))) return p(e, t, i);
                if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
                var n = e.valueOf && e.valueOf();
                if (null != n && n !== e) return l.from(n, t, i);
                var r = function(e) {
                    if (l.isBuffer(e)) {
                        var t = 0 | f(e.length),
                            i = o(t);
                        return 0 === i.length || e.copy(i, 0, 0, t), i
                    }
                    if (void 0 !== e.length) return "number" != typeof e.length || V(e.length) ? o(0) : d(e);
                    if ("Buffer" === e.type && Array.isArray(e.data)) return d(e.data)
                }(e);
                if (r) return r;
                if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return l.from(e[Symbol.toPrimitive]("string"), t, i);
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
            }

            function c(e) {
                if ("number" != typeof e) throw new TypeError('"size" argument must be of type number');
                if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"')
            }

            function u(e) {
                return c(e), o(e < 0 ? 0 : 0 | f(e))
            }

            function d(e) {
                for (var t = e.length < 0 ? 0 : 0 | f(e.length), i = o(t), n = 0; n < t; n += 1) i[n] = 255 & e[n];
                return i
            }

            function p(e, t, i) {
                if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
                if (e.byteLength < t + (i || 0)) throw new RangeError('"length" is outside of buffer bounds');
                var n;
                return n = void 0 === t && void 0 === i ? new Uint8Array(e) : void 0 === i ? new Uint8Array(e, t) : new Uint8Array(e, t, i), Object.setPrototypeOf(n, l.prototype), n
            }

            function f(e) {
                if (e >= a) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
                return 0 | e
            }

            function m(e, t) {
                if (l.isBuffer(e)) return e.length;
                if (ArrayBuffer.isView(e) || z(e, ArrayBuffer)) return e.byteLength;
                if ("string" != typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
                var i = e.length,
                    n = arguments.length > 2 && !0 === arguments[2];
                if (!n && 0 === i) return 0;
                for (var r = !1;;) switch (t) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return i;
                    case "utf8":
                    case "utf-8":
                        return B(e).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * i;
                    case "hex":
                        return i >>> 1;
                    case "base64":
                        return F(e).length;
                    default:
                        if (r) return n ? -1 : B(e).length;
                        t = ("" + t).toLowerCase(), r = !0
                }
            }

            function g(e, t, i) {
                var n = !1;
                if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
                if ((void 0 === i || i > this.length) && (i = this.length), i <= 0) return "";
                if ((i >>>= 0) <= (t >>>= 0)) return "";
                for (e || (e = "utf8");;) switch (e) {
                    case "hex":
                        return I(this, t, i);
                    case "utf8":
                    case "utf-8":
                        return M(this, t, i);
                    case "ascii":
                        return A(this, t, i);
                    case "latin1":
                    case "binary":
                        return L(this, t, i);
                    case "base64":
                        return E(this, t, i);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return P(this, t, i);
                    default:
                        if (n) throw new TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(), n = !0
                }
            }

            function y(e, t, i) {
                var n = e[t];
                e[t] = e[i], e[i] = n
            }

            function _(e, t, i, n, r) {
                if (0 === e.length) return -1;
                if ("string" == typeof i ? (n = i, i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648), V(i = +i) && (i = r ? 0 : e.length - 1), i < 0 && (i = e.length + i), i >= e.length) {
                    if (r) return -1;
                    i = e.length - 1
                } else if (i < 0) {
                    if (!r) return -1;
                    i = 0
                }
                if ("string" == typeof t && (t = l.from(t, n)), l.isBuffer(t)) return 0 === t.length ? -1 : v(e, t, i, n, r);
                if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? r ? Uint8Array.prototype.indexOf.call(e, t, i) : Uint8Array.prototype.lastIndexOf.call(e, t, i) : v(e, [t], i, n, r);
                throw new TypeError("val must be string, number or Buffer")
            }

            function v(e, t, i, n, r) {
                var s, a = 1,
                    o = e.length,
                    l = t.length;
                if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                    if (e.length < 2 || t.length < 2) return -1;
                    a = 2, o /= 2, l /= 2, i /= 2
                }

                function h(e, t) {
                    return 1 === a ? e[t] : e.readUInt16BE(t * a)
                }
                if (r) {
                    var c = -1;
                    for (s = i; s < o; s++)
                        if (h(e, s) === h(t, -1 === c ? 0 : s - c)) {
                            if (-1 === c && (c = s), s - c + 1 === l) return c * a
                        } else -1 !== c && (s -= s - c), c = -1
                } else
                    for (i + l > o && (i = o - l), s = i; s >= 0; s--) {
                        for (var u = !0, d = 0; d < l; d++)
                            if (h(e, s + d) !== h(t, d)) {
                                u = !1;
                                break
                            }
                        if (u) return s
                    }
                return -1
            }

            function b(e, t, i, n) {
                i = Number(i) || 0;
                var r = e.length - i;
                n ? (n = Number(n)) > r && (n = r) : n = r;
                var s = t.length;
                n > s / 2 && (n = s / 2);
                for (var a = 0; a < n; ++a) {
                    var o = parseInt(t.substr(2 * a, 2), 16);
                    if (V(o)) return a;
                    e[i + a] = o
                }
                return a
            }

            function T(e, t, i, n) {
                return H(B(t, e.length - i), e, i, n)
            }

            function x(e, t, i, n) {
                return H(function(e) {
                    for (var t = [], i = 0; i < e.length; ++i) t.push(255 & e.charCodeAt(i));
                    return t
                }(t), e, i, n)
            }

            function w(e, t, i, n) {
                return H(F(t), e, i, n)
            }

            function S(e, t, i, n) {
                return H(function(e, t) {
                    for (var i, n, r, s = [], a = 0; a < e.length && !((t -= 2) < 0); ++a) n = (i = e.charCodeAt(a)) >> 8, r = i % 256, s.push(r), s.push(n);
                    return s
                }(t, e.length - i), e, i, n)
            }

            function E(e, t, i) {
                return 0 === t && i === e.length ? n.fromByteArray(e) : n.fromByteArray(e.slice(t, i))
            }

            function M(e, t, i) {
                i = Math.min(e.length, i);
                for (var n = [], r = t; r < i;) {
                    var s, a, o, l, h = e[r],
                        c = null,
                        u = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
                    if (r + u <= i) switch (u) {
                        case 1:
                            h < 128 && (c = h);
                            break;
                        case 2:
                            128 == (192 & (s = e[r + 1])) && (l = (31 & h) << 6 | 63 & s) > 127 && (c = l);
                            break;
                        case 3:
                            s = e[r + 1], a = e[r + 2], 128 == (192 & s) && 128 == (192 & a) && (l = (15 & h) << 12 | (63 & s) << 6 | 63 & a) > 2047 && (l < 55296 || l > 57343) && (c = l);
                            break;
                        case 4:
                            s = e[r + 1], a = e[r + 2], o = e[r + 3], 128 == (192 & s) && 128 == (192 & a) && 128 == (192 & o) && (l = (15 & h) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) > 65535 && l < 1114112 && (c = l)
                    }
                    null === c ? (c = 65533, u = 1) : c > 65535 && (c -= 65536, n.push(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), n.push(c), r += u
                }
                return function(e) {
                    var t = e.length;
                    if (t <= C) return String.fromCharCode.apply(String, e);
                    var i = "",
                        n = 0;
                    for (; n < t;) i += String.fromCharCode.apply(String, e.slice(n, n += C));
                    return i
                }(n)
            }
            l.TYPED_ARRAY_SUPPORT = function() {
                try {
                    var e = new Uint8Array(1),
                        t = {
                            foo: function() {
                                return 42
                            }
                        };
                    return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), 42 === e.foo()
                } catch (e) {
                    return !1
                }
            }(), l.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(l.prototype, "parent", {
                enumerable: !0,
                get: function() {
                    if (l.isBuffer(this)) return this.buffer
                }
            }), Object.defineProperty(l.prototype, "offset", {
                enumerable: !0,
                get: function() {
                    if (l.isBuffer(this)) return this.byteOffset
                }
            }), l.poolSize = 8192, l.from = function(e, t, i) {
                return h(e, t, i)
            }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array), l.alloc = function(e, t, i) {
                return function(e, t, i) {
                    return c(e), e <= 0 ? o(e) : void 0 !== t ? "string" == typeof i ? o(e).fill(t, i) : o(e).fill(t) : o(e)
                }(e, t, i)
            }, l.allocUnsafe = function(e) {
                return u(e)
            }, l.allocUnsafeSlow = function(e) {
                return u(e)
            }, l.isBuffer = function(e) {
                return null != e && !0 === e._isBuffer && e !== l.prototype
            }, l.compare = function(e, t) {
                if (z(e, Uint8Array) && (e = l.from(e, e.offset, e.byteLength)), z(t, Uint8Array) && (t = l.from(t, t.offset, t.byteLength)), !l.isBuffer(e) || !l.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (e === t) return 0;
                for (var i = e.length, n = t.length, r = 0, s = Math.min(i, n); r < s; ++r)
                    if (e[r] !== t[r]) {
                        i = e[r], n = t[r];
                        break
                    }
                return i < n ? -1 : n < i ? 1 : 0
            }, l.isEncoding = function(e) {
                switch (String(e).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, l.concat = function(e, t) {
                if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === e.length) return l.alloc(0);
                var i;
                if (void 0 === t)
                    for (t = 0, i = 0; i < e.length; ++i) t += e[i].length;
                var n = l.allocUnsafe(t),
                    r = 0;
                for (i = 0; i < e.length; ++i) {
                    var s = e[i];
                    if (z(s, Uint8Array)) r + s.length > n.length ? l.from(s).copy(n, r) : Uint8Array.prototype.set.call(n, s, r);
                    else {
                        if (!l.isBuffer(s)) throw new TypeError('"list" argument must be an Array of Buffers');
                        s.copy(n, r)
                    }
                    r += s.length
                }
                return n
            }, l.byteLength = m, l.prototype._isBuffer = !0, l.prototype.swap16 = function() {
                var e = this.length;
                if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (var t = 0; t < e; t += 2) y(this, t, t + 1);
                return this
            }, l.prototype.swap32 = function() {
                var e = this.length;
                if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (var t = 0; t < e; t += 4) y(this, t, t + 3), y(this, t + 1, t + 2);
                return this
            }, l.prototype.swap64 = function() {
                var e = this.length;
                if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (var t = 0; t < e; t += 8) y(this, t, t + 7), y(this, t + 1, t + 6), y(this, t + 2, t + 5), y(this, t + 3, t + 4);
                return this
            }, l.prototype.toString = function() {
                var e = this.length;
                return 0 === e ? "" : 0 === arguments.length ? M(this, 0, e) : g.apply(this, arguments)
            }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(e) {
                if (!l.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                return this === e || 0 === l.compare(this, e)
            }, l.prototype.inspect = function() {
                var e = "",
                    i = t.h2;
                return e = this.toString("hex", 0, i).replace(/(.{2})/g, "$1 ").trim(), this.length > i && (e += " ... "), "<Buffer " + e + ">"
            }, s && (l.prototype[s] = l.prototype.inspect), l.prototype.compare = function(e, t, i, n, r) {
                if (z(e, Uint8Array) && (e = l.from(e, e.offset, e.byteLength)), !l.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
                if (void 0 === t && (t = 0), void 0 === i && (i = e ? e.length : 0), void 0 === n && (n = 0), void 0 === r && (r = this.length), t < 0 || i > e.length || n < 0 || r > this.length) throw new RangeError("out of range index");
                if (n >= r && t >= i) return 0;
                if (n >= r) return -1;
                if (t >= i) return 1;
                if (this === e) return 0;
                for (var s = (r >>>= 0) - (n >>>= 0), a = (i >>>= 0) - (t >>>= 0), o = Math.min(s, a), h = this.slice(n, r), c = e.slice(t, i), u = 0; u < o; ++u)
                    if (h[u] !== c[u]) {
                        s = h[u], a = c[u];
                        break
                    }
                return s < a ? -1 : a < s ? 1 : 0
            }, l.prototype.includes = function(e, t, i) {
                return -1 !== this.indexOf(e, t, i)
            }, l.prototype.indexOf = function(e, t, i) {
                return _(this, e, t, i, !0)
            }, l.prototype.lastIndexOf = function(e, t, i) {
                return _(this, e, t, i, !1)
            }, l.prototype.write = function(e, t, i, n) {
                if (void 0 === t) n = "utf8", i = this.length, t = 0;
                else if (void 0 === i && "string" == typeof t) n = t, i = this.length, t = 0;
                else {
                    if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    t >>>= 0, isFinite(i) ? (i >>>= 0, void 0 === n && (n = "utf8")) : (n = i, i = void 0)
                }
                var r = this.length - t;
                if ((void 0 === i || i > r) && (i = r), e.length > 0 && (i < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                n || (n = "utf8");
                for (var s = !1;;) switch (n) {
                    case "hex":
                        return b(this, e, t, i);
                    case "utf8":
                    case "utf-8":
                        return T(this, e, t, i);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return x(this, e, t, i);
                    case "base64":
                        return w(this, e, t, i);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return S(this, e, t, i);
                    default:
                        if (s) throw new TypeError("Unknown encoding: " + n);
                        n = ("" + n).toLowerCase(), s = !0
                }
            }, l.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            };
            var C = 4096;

            function A(e, t, i) {
                var n = "";
                i = Math.min(e.length, i);
                for (var r = t; r < i; ++r) n += String.fromCharCode(127 & e[r]);
                return n
            }

            function L(e, t, i) {
                var n = "";
                i = Math.min(e.length, i);
                for (var r = t; r < i; ++r) n += String.fromCharCode(e[r]);
                return n
            }

            function I(e, t, i) {
                var n = e.length;
                (!t || t < 0) && (t = 0), (!i || i < 0 || i > n) && (i = n);
                for (var r = "", s = t; s < i; ++s) r += G[e[s]];
                return r
            }

            function P(e, t, i) {
                for (var n = e.slice(t, i), r = "", s = 0; s < n.length - 1; s += 2) r += String.fromCharCode(n[s] + 256 * n[s + 1]);
                return r
            }

            function R(e, t, i) {
                if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + t > i) throw new RangeError("Trying to access beyond buffer length")
            }

            function k(e, t, i, n, r, s) {
                if (!l.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (t > r || t < s) throw new RangeError('"value" argument is out of bounds');
                if (i + n > e.length) throw new RangeError("Index out of range")
            }

            function D(e, t, i, n, r, s) {
                if (i + n > e.length) throw new RangeError("Index out of range");
                if (i < 0) throw new RangeError("Index out of range")
            }

            function O(e, t, i, n, s) {
                return t = +t, i >>>= 0, s || D(e, 0, i, 4), r.write(e, t, i, n, 23, 4), i + 4
            }

            function N(e, t, i, n, s) {
                return t = +t, i >>>= 0, s || D(e, 0, i, 8), r.write(e, t, i, n, 52, 8), i + 8
            }
            l.prototype.slice = function(e, t) {
                var i = this.length;
                (e = ~~e) < 0 ? (e += i) < 0 && (e = 0) : e > i && (e = i), (t = void 0 === t ? i : ~~t) < 0 ? (t += i) < 0 && (t = 0) : t > i && (t = i), t < e && (t = e);
                var n = this.subarray(e, t);
                return Object.setPrototypeOf(n, l.prototype), n
            }, l.prototype.readUintLE = l.prototype.readUIntLE = function(e, t, i) {
                e >>>= 0, t >>>= 0, i || R(e, t, this.length);
                for (var n = this[e], r = 1, s = 0; ++s < t && (r *= 256);) n += this[e + s] * r;
                return n
            }, l.prototype.readUintBE = l.prototype.readUIntBE = function(e, t, i) {
                e >>>= 0, t >>>= 0, i || R(e, t, this.length);
                for (var n = this[e + --t], r = 1; t > 0 && (r *= 256);) n += this[e + --t] * r;
                return n
            }, l.prototype.readUint8 = l.prototype.readUInt8 = function(e, t) {
                return e >>>= 0, t || R(e, 1, this.length), this[e]
            }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(e, t) {
                return e >>>= 0, t || R(e, 2, this.length), this[e] | this[e + 1] << 8
            }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(e, t) {
                return e >>>= 0, t || R(e, 2, this.length), this[e] << 8 | this[e + 1]
            }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(e, t) {
                return e >>>= 0, t || R(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
            }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(e, t) {
                return e >>>= 0, t || R(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
            }, l.prototype.readIntLE = function(e, t, i) {
                e >>>= 0, t >>>= 0, i || R(e, t, this.length);
                for (var n = this[e], r = 1, s = 0; ++s < t && (r *= 256);) n += this[e + s] * r;
                return n >= (r *= 128) && (n -= Math.pow(2, 8 * t)), n
            }, l.prototype.readIntBE = function(e, t, i) {
                e >>>= 0, t >>>= 0, i || R(e, t, this.length);
                for (var n = t, r = 1, s = this[e + --n]; n > 0 && (r *= 256);) s += this[e + --n] * r;
                return s >= (r *= 128) && (s -= Math.pow(2, 8 * t)), s
            }, l.prototype.readInt8 = function(e, t) {
                return e >>>= 0, t || R(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
            }, l.prototype.readInt16LE = function(e, t) {
                e >>>= 0, t || R(e, 2, this.length);
                var i = this[e] | this[e + 1] << 8;
                return 32768 & i ? 4294901760 | i : i
            }, l.prototype.readInt16BE = function(e, t) {
                e >>>= 0, t || R(e, 2, this.length);
                var i = this[e + 1] | this[e] << 8;
                return 32768 & i ? 4294901760 | i : i
            }, l.prototype.readInt32LE = function(e, t) {
                return e >>>= 0, t || R(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
            }, l.prototype.readInt32BE = function(e, t) {
                return e >>>= 0, t || R(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
            }, l.prototype.readFloatLE = function(e, t) {
                return e >>>= 0, t || R(e, 4, this.length), r.read(this, e, !0, 23, 4)
            }, l.prototype.readFloatBE = function(e, t) {
                return e >>>= 0, t || R(e, 4, this.length), r.read(this, e, !1, 23, 4)
            }, l.prototype.readDoubleLE = function(e, t) {
                return e >>>= 0, t || R(e, 8, this.length), r.read(this, e, !0, 52, 8)
            }, l.prototype.readDoubleBE = function(e, t) {
                return e >>>= 0, t || R(e, 8, this.length), r.read(this, e, !1, 52, 8)
            }, l.prototype.writeUintLE = l.prototype.writeUIntLE = function(e, t, i, n) {
                (e = +e, t >>>= 0, i >>>= 0, n) || k(this, e, t, i, Math.pow(2, 8 * i) - 1, 0);
                var r = 1,
                    s = 0;
                for (this[t] = 255 & e; ++s < i && (r *= 256);) this[t + s] = e / r & 255;
                return t + i
            }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(e, t, i, n) {
                (e = +e, t >>>= 0, i >>>= 0, n) || k(this, e, t, i, Math.pow(2, 8 * i) - 1, 0);
                var r = i - 1,
                    s = 1;
                for (this[t + r] = 255 & e; --r >= 0 && (s *= 256);) this[t + r] = e / s & 255;
                return t + i
            }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1
            }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
            }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
            }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4
            }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
            }, l.prototype.writeIntLE = function(e, t, i, n) {
                if (e = +e, t >>>= 0, !n) {
                    var r = Math.pow(2, 8 * i - 1);
                    k(this, e, t, i, r - 1, -r)
                }
                var s = 0,
                    a = 1,
                    o = 0;
                for (this[t] = 255 & e; ++s < i && (a *= 256);) e < 0 && 0 === o && 0 !== this[t + s - 1] && (o = 1), this[t + s] = (e / a >> 0) - o & 255;
                return t + i
            }, l.prototype.writeIntBE = function(e, t, i, n) {
                if (e = +e, t >>>= 0, !n) {
                    var r = Math.pow(2, 8 * i - 1);
                    k(this, e, t, i, r - 1, -r)
                }
                var s = i - 1,
                    a = 1,
                    o = 0;
                for (this[t + s] = 255 & e; --s >= 0 && (a *= 256);) e < 0 && 0 === o && 0 !== this[t + s + 1] && (o = 1), this[t + s] = (e / a >> 0) - o & 255;
                return t + i
            }, l.prototype.writeInt8 = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
            }, l.prototype.writeInt16LE = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
            }, l.prototype.writeInt16BE = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
            }, l.prototype.writeInt32LE = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
            }, l.prototype.writeInt32BE = function(e, t, i) {
                return e = +e, t >>>= 0, i || k(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
            }, l.prototype.writeFloatLE = function(e, t, i) {
                return O(this, e, t, !0, i)
            }, l.prototype.writeFloatBE = function(e, t, i) {
                return O(this, e, t, !1, i)
            }, l.prototype.writeDoubleLE = function(e, t, i) {
                return N(this, e, t, !0, i)
            }, l.prototype.writeDoubleBE = function(e, t, i) {
                return N(this, e, t, !1, i)
            }, l.prototype.copy = function(e, t, i, n) {
                if (!l.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (i || (i = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < i && (n = i), n === i) return 0;
                if (0 === e.length || 0 === this.length) return 0;
                if (t < 0) throw new RangeError("targetStart out of bounds");
                if (i < 0 || i >= this.length) throw new RangeError("Index out of range");
                if (n < 0) throw new RangeError("sourceEnd out of bounds");
                n > this.length && (n = this.length), e.length - t < n - i && (n = e.length - t + i);
                var r = n - i;
                return this === e && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, i, n) : Uint8Array.prototype.set.call(e, this.subarray(i, n), t), r
            }, l.prototype.fill = function(e, t, i, n) {
                if ("string" == typeof e) {
                    if ("string" == typeof t ? (n = t, t = 0, i = this.length) : "string" == typeof i && (n = i, i = this.length), void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
                    if ("string" == typeof n && !l.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
                    if (1 === e.length) {
                        var r = e.charCodeAt(0);
                        ("utf8" === n && r < 128 || "latin1" === n) && (e = r)
                    }
                } else "number" == typeof e ? e &= 255 : "boolean" == typeof e && (e = Number(e));
                if (t < 0 || this.length < t || this.length < i) throw new RangeError("Out of range index");
                if (i <= t) return this;
                var s;
                if (t >>>= 0, i = void 0 === i ? this.length : i >>> 0, e || (e = 0), "number" == typeof e)
                    for (s = t; s < i; ++s) this[s] = e;
                else {
                    var a = l.isBuffer(e) ? e : l.from(e, n),
                        o = a.length;
                    if (0 === o) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    for (s = 0; s < i - t; ++s) this[s + t] = a[s % o]
                }
                return this
            };
            var U = /[^+/0-9A-Za-z-_]/g;

            function B(e, t) {
                var i;
                t = t || 1 / 0;
                for (var n = e.length, r = null, s = [], a = 0; a < n; ++a) {
                    if ((i = e.charCodeAt(a)) > 55295 && i < 57344) {
                        if (!r) {
                            if (i > 56319) {
                                (t -= 3) > -1 && s.push(239, 191, 189);
                                continue
                            }
                            if (a + 1 === n) {
                                (t -= 3) > -1 && s.push(239, 191, 189);
                                continue
                            }
                            r = i;
                            continue
                        }
                        if (i < 56320) {
                            (t -= 3) > -1 && s.push(239, 191, 189), r = i;
                            continue
                        }
                        i = 65536 + (r - 55296 << 10 | i - 56320)
                    } else r && (t -= 3) > -1 && s.push(239, 191, 189);
                    if (r = null, i < 128) {
                        if ((t -= 1) < 0) break;
                        s.push(i)
                    } else if (i < 2048) {
                        if ((t -= 2) < 0) break;
                        s.push(i >> 6 | 192, 63 & i | 128)
                    } else if (i < 65536) {
                        if ((t -= 3) < 0) break;
                        s.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128)
                    } else {
                        if (!(i < 1114112)) throw new Error("Invalid code point");
                        if ((t -= 4) < 0) break;
                        s.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128)
                    }
                }
                return s
            }

            function F(e) {
                return n.toByteArray(function(e) {
                    if ((e = (e = e.split("=")[0]).trim().replace(U, "")).length < 2) return "";
                    for (; e.length % 4 != 0;) e += "=";
                    return e
                }(e))
            }

            function H(e, t, i, n) {
                for (var r = 0; r < n && !(r + i >= t.length || r >= e.length); ++r) t[r + i] = e[r];
                return r
            }

            function z(e, t) {
                return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
            }

            function V(e) {
                return e != e
            }
            var G = function() {
                for (var e = "0123456789abcdef", t = new Array(256), i = 0; i < 16; ++i)
                    for (var n = 16 * i, r = 0; r < 16; ++r) t[n + r] = e[i] + e[r];
                return t
            }()
        },
        930: (e, t, i) => {
            var n, r = void 0 !== i.g ? i.g : "undefined" != typeof window ? window : {},
                s = i(5893);
            "undefined" != typeof document ? n = document : (n = r["__GLOBAL_DOCUMENT_CACHE@4"]) || (n = r["__GLOBAL_DOCUMENT_CACHE@4"] = s), e.exports = n
        },
        1192: (e, t, i) => {
            var n;
            n = "undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self ? self : {}, e.exports = n
        },
        6608: (e, t, i) => {
            "use strict";
            i.d(t, {
                L: () => b
            });
            var n, r, s, a, o, l, h, c, u = function() {
                    return "undefined" != typeof window
                },
                d = function() {
                    return n || u() && (n = window.gsap) && n.registerPlugin && n
                },
                p = function(e) {
                    return "string" == typeof e
                },
                f = function(e) {
                    return "function" == typeof e
                },
                m = function(e, t) {
                    var i = "x" === t ? "Width" : "Height",
                        n = "scroll" + i,
                        r = "client" + i;
                    return e === s || e === a || e === o ? Math.max(a[n], o[n]) - (s["inner" + i] || a[r] || o[r]) : e[n] - e["offset" + i]
                },
                g = function(e, t) {
                    var i = "scroll" + ("x" === t ? "Left" : "Top");
                    return e === s && (null != e.pageXOffset ? i = "page" + t.toUpperCase() + "Offset" : e = null != a[i] ? a : o),
                        function() {
                            return e[i]
                        }
                },
                y = function(e, t) {
                    if (!(e = l(e)[0]) || !e.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
                        x: 0,
                        y: 0
                    };
                    var i = e.getBoundingClientRect(),
                        n = !t || t === s || t === o,
                        r = n ? {
                            top: a.clientTop - (s.pageYOffset || a.scrollTop || o.scrollTop || 0),
                            left: a.clientLeft - (s.pageXOffset || a.scrollLeft || o.scrollLeft || 0)
                        } : t.getBoundingClientRect(),
                        h = {
                            x: i.left - r.left,
                            y: i.top - r.top
                        };
                    return !n && t && (h.x += g(t, "x")(), h.y += g(t, "y")()), h
                },
                _ = function(e, t, i, n, r) {
                    return isNaN(e) || "object" == typeof e ? p(e) && "=" === e.charAt(1) ? parseFloat(e.substr(2)) * ("-" === e.charAt(0) ? -1 : 1) + n - r : "max" === e ? m(t, i) - r : Math.min(m(t, i), y(e, t)[i] - r) : parseFloat(e) - r
                },
                v = function() {
                    n = d(), u() && n && "undefined" != typeof document && document.body && (s = window, o = document.body, a = document.documentElement, l = n.utils.toArray, n.config({
                        autoKillThreshold: 7
                    }), h = n.config(), r = 1)
                },
                b = {
                    version: "3.11.4",
                    name: "scrollTo",
                    rawVars: 1,
                    register: function(e) {
                        n = e, v()
                    },
                    init: function(e, t, i, a, o) {
                        r || v();
                        var l = this,
                            h = n.getProperty(e, "scrollSnapType");
                        l.isWin = e === s, l.target = e, l.tween = i, t = function(e, t, i, n) {
                            if (f(e) && (e = e(t, i, n)), "object" != typeof e) return p(e) && "max" !== e && "=" !== e.charAt(1) ? {
                                x: e,
                                y: e
                            } : {
                                y: e
                            };
                            if (e.nodeType) return {
                                y: e,
                                x: e
                            };
                            var r, s = {};
                            for (r in e) s[r] = "onAutoKill" !== r && f(e[r]) ? e[r](t, i, n) : e[r];
                            return s
                        }(t, a, e, o), l.vars = t, l.autoKill = !!t.autoKill, l.getX = g(e, "x"), l.getY = g(e, "y"), l.x = l.xPrev = l.getX(), l.y = l.yPrev = l.getY(), c || (c = n.core.globals().ScrollTrigger), "smooth" === n.getProperty(e, "scrollBehavior") && n.set(e, {
                            scrollBehavior: "auto"
                        }), h && "none" !== h && (l.snap = 1, l.snapInline = e.style.scrollSnapType, e.style.scrollSnapType = "none"), null != t.x ? (l.add(l, "x", l.x, _(t.x, e, "x", l.x, t.offsetX || 0), a, o), l._props.push("scrollTo_x")) : l.skipX = 1, null != t.y ? (l.add(l, "y", l.y, _(t.y, e, "y", l.y, t.offsetY || 0), a, o), l._props.push("scrollTo_y")) : l.skipY = 1
                    },
                    render: function(e, t) {
                        for (var i, n, r, a, o, l = t._pt, u = t.target, d = t.tween, p = t.autoKill, f = t.xPrev, g = t.yPrev, y = t.isWin, _ = t.snap, v = t.snapInline; l;) l.r(e, l.d), l = l._next;
                        i = y || !t.skipX ? t.getX() : f, r = (n = y || !t.skipY ? t.getY() : g) - g, a = i - f, o = h.autoKillThreshold, t.x < 0 && (t.x = 0), t.y < 0 && (t.y = 0), p && (!t.skipX && (a > o || a < -o) && i < m(u, "x") && (t.skipX = 1), !t.skipY && (r > o || r < -o) && n < m(u, "y") && (t.skipY = 1), t.skipX && t.skipY && (d.kill(), t.vars.onAutoKill && t.vars.onAutoKill.apply(d, t.vars.onAutoKillParams || []))), y ? s.scrollTo(t.skipX ? i : t.x, t.skipY ? n : t.y) : (t.skipY || (u.scrollTop = t.y), t.skipX || (u.scrollLeft = t.x)), !_ || 1 !== e && 0 !== e || (n = u.scrollTop, i = u.scrollLeft, v ? u.style.scrollSnapType = v : u.style.removeProperty("scroll-snap-type"), u.scrollTop = n + 1, u.scrollLeft = i + 1, u.scrollTop = n, u.scrollLeft = i), t.xPrev = t.x, t.yPrev = t.y, c && c.update()
                    },
                    kill: function(e) {
                        var t = "scrollTo" === e;
                        (t || "scrollTo_x" === e) && (this.skipX = 1), (t || "scrollTo_y" === e) && (this.skipY = 1)
                    }
                };
            b.max = m, b.getOffset = y, b.buildGetter = g, d() && n.registerPlugin(b)
        },
        1605: (e, t, i) => {
            "use strict";

            function n(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var n = t[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                }
            }
            i.d(t, {
                i: () => Kt
            });
            var r, s, a, o, l, h, c, u, d, p, f, m, g, y = function() {
                    return r || "undefined" != typeof window && (r = window.gsap) && r.registerPlugin && r
                },
                _ = 1,
                v = [],
                b = [],
                T = [],
                x = Date.now,
                w = function(e, t) {
                    return t
                },
                S = function(e, t) {
                    return ~T.indexOf(e) && T[T.indexOf(e) + 1][t]
                },
                E = function(e) {
                    return !!~p.indexOf(e)
                },
                M = function(e, t, i, n, r) {
                    return e.addEventListener(t, i, {
                        passive: !n,
                        capture: !!r
                    })
                },
                C = function(e, t, i, n) {
                    return e.removeEventListener(t, i, !!n)
                },
                A = "scrollLeft",
                L = "scrollTop",
                I = function() {
                    return f && f.isPressed || b.cache++
                },
                P = function(e, t) {
                    var i = function i(n) {
                        if (n || 0 === n) {
                            _ && (a.history.scrollRestoration = "manual");
                            var r = f && f.isPressed;
                            n = i.v = Math.round(n) || (f && f.iOS ? 1 : 0), e(n), i.cacheID = b.cache, r && w("ss", n)
                        } else(t || b.cache !== i.cacheID || w("ref")) && (i.cacheID = b.cache, i.v = e());
                        return i.v + i.offset
                    };
                    return i.offset = 0, e && i
                },
                R = {
                    s: A,
                    p: "left",
                    p2: "Left",
                    os: "right",
                    os2: "Right",
                    d: "width",
                    d2: "Width",
                    a: "x",
                    sc: P((function(e) {
                        return arguments.length ? a.scrollTo(e, k.sc()) : a.pageXOffset || o[A] || l[A] || h[A] || 0
                    }))
                },
                k = {
                    s: L,
                    p: "top",
                    p2: "Top",
                    os: "bottom",
                    os2: "Bottom",
                    d: "height",
                    d2: "Height",
                    a: "y",
                    op: R,
                    sc: P((function(e) {
                        return arguments.length ? a.scrollTo(R.sc(), e) : a.pageYOffset || o[L] || l[L] || h[L] || 0
                    }))
                },
                D = function(e) {
                    return r.utils.toArray(e)[0] || ("string" == typeof e && !1 !== r.config().nullTargetWarn ? console.warn("Element not found:", e) : null)
                },
                O = function(e, t) {
                    var i = t.s,
                        n = t.sc;
                    E(e) && (e = o.scrollingElement || l);
                    var s = b.indexOf(e),
                        a = n === k.sc ? 1 : 2;
                    !~s && (s = b.push(e) - 1), b[s + a] || e.addEventListener("scroll", I);
                    var h = b[s + a],
                        c = h || (b[s + a] = P(S(e, i), !0) || (E(e) ? n : P((function(t) {
                            return arguments.length ? e[i] = t : e[i]
                        }))));
                    return c.target = e, h || (c.smooth = "smooth" === r.getProperty(e, "scrollBehavior")), c
                },
                N = function(e, t, i) {
                    var n = e,
                        r = e,
                        s = x(),
                        a = s,
                        o = t || 50,
                        l = Math.max(500, 3 * o),
                        h = function(e, t) {
                            var l = x();
                            t || l - s > o ? (r = n, n = e, a = s, s = l) : i ? n += e : n = r + (e - r) / (l - a) * (s - a)
                        };
                    return {
                        update: h,
                        reset: function() {
                            r = n = i ? 0 : n, a = s = 0
                        },
                        getVelocity: function(e) {
                            var t = a,
                                o = r,
                                c = x();
                            return (e || 0 === e) && e !== n && h(e), s === a || c - a > l ? 0 : (n + (i ? o : -o)) / ((i ? c : s) - t) * 1e3
                        }
                    }
                },
                U = function(e, t) {
                    return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
                },
                B = function(e) {
                    var t = Math.max.apply(Math, e),
                        i = Math.min.apply(Math, e);
                    return Math.abs(t) >= Math.abs(i) ? t : i
                },
                F = function() {
                    var e, t, i, n;
                    (d = r.core.globals().ScrollTrigger) && d.core && (e = d.core, t = e.bridge || {}, i = e._scrollers, n = e._proxies, i.push.apply(i, b), n.push.apply(n, T), b = i, T = n, w = function(e, i) {
                        return t[e](i)
                    })
                },
                H = function(e) {
                    return (r = e || y()) && "undefined" != typeof document && document.body && (a = window, o = document, l = o.documentElement, h = o.body, p = [a, o, l, h], r.utils.clamp, g = r.core.context || function() {}, u = "onpointerenter" in h ? "pointer" : "mouse", c = z.isTouch = a.matchMedia && a.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in a || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, m = z.eventTypes = ("ontouchstart" in l ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in l ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout((function() {
                        return _ = 0
                    }), 500), F(), s = 1), s
                };
            R.op = k, b.cache = 0;
            var z = function() {
                function e(e) {
                    this.init(e)
                }
                var t, i, p;
                return e.prototype.init = function(e) {
                    s || H(r) || console.warn("Please gsap.registerPlugin(Observer)"), d || F();
                    var t = e.tolerance,
                        i = e.dragMinimum,
                        n = e.type,
                        p = e.target,
                        y = e.lineHeight,
                        _ = e.debounce,
                        b = e.preventDefault,
                        T = e.onStop,
                        w = e.onStopDelay,
                        S = e.ignore,
                        A = e.wheelSpeed,
                        L = e.event,
                        P = e.onDragStart,
                        z = e.onDragEnd,
                        V = e.onDrag,
                        G = e.onPress,
                        W = e.onRelease,
                        j = e.onRight,
                        q = e.onLeft,
                        $ = e.onUp,
                        X = e.onDown,
                        Y = e.onChangeX,
                        K = e.onChangeY,
                        J = e.onChange,
                        Z = e.onToggleX,
                        Q = e.onToggleY,
                        ee = e.onHover,
                        te = e.onHoverEnd,
                        ie = e.onMove,
                        ne = e.ignoreCheck,
                        re = e.isNormalizer,
                        se = e.onGestureStart,
                        ae = e.onGestureEnd,
                        oe = e.onWheel,
                        le = e.onEnable,
                        he = e.onDisable,
                        ce = e.onClick,
                        ue = e.scrollSpeed,
                        de = e.capture,
                        pe = e.allowClicks,
                        fe = e.lockAxis,
                        me = e.onLockAxis;
                    this.target = p = D(p) || l, this.vars = e, S && (S = r.utils.toArray(S)), t = t || 1e-9, i = i || 0, A = A || 1, ue = ue || 1, n = n || "wheel,touch,pointer", _ = !1 !== _, y || (y = parseFloat(a.getComputedStyle(h).lineHeight) || 22);
                    var ge, ye, _e, ve, be, Te, xe, we = this,
                        Se = 0,
                        Ee = 0,
                        Me = O(p, R),
                        Ce = O(p, k),
                        Ae = Me(),
                        Le = Ce(),
                        Ie = ~n.indexOf("touch") && !~n.indexOf("pointer") && "pointerdown" === m[0],
                        Pe = E(p),
                        Re = p.ownerDocument || o,
                        ke = [0, 0, 0],
                        De = [0, 0, 0],
                        Oe = 0,
                        Ne = function() {
                            return Oe = x()
                        },
                        Ue = function(e, t) {
                            return (we.event = e) && S && ~S.indexOf(e.target) || t && Ie && "touch" !== e.pointerType || ne && ne(e, t)
                        },
                        Be = function() {
                            var e = we.deltaX = B(ke),
                                i = we.deltaY = B(De),
                                n = Math.abs(e) >= t,
                                r = Math.abs(i) >= t;
                            J && (n || r) && J(we, e, i, ke, De), n && (j && we.deltaX > 0 && j(we), q && we.deltaX < 0 && q(we), Y && Y(we), Z && we.deltaX < 0 != Se < 0 && Z(we), Se = we.deltaX, ke[0] = ke[1] = ke[2] = 0), r && (X && we.deltaY > 0 && X(we), $ && we.deltaY < 0 && $(we), K && K(we), Q && we.deltaY < 0 != Ee < 0 && Q(we), Ee = we.deltaY, De[0] = De[1] = De[2] = 0), (ve || _e) && (ie && ie(we), _e && (V(we), _e = !1), ve = !1), Te && !(Te = !1) && me && me(we), be && (oe(we), be = !1), ge = 0
                        },
                        Fe = function(e, t, i) {
                            ke[i] += e, De[i] += t, we._vx.update(e), we._vy.update(t), _ ? ge || (ge = requestAnimationFrame(Be)) : Be()
                        },
                        He = function(e, t) {
                            fe && !xe && (we.axis = xe = Math.abs(e) > Math.abs(t) ? "x" : "y", Te = !0), "y" !== xe && (ke[2] += e, we._vx.update(e, !0)), "x" !== xe && (De[2] += t, we._vy.update(t, !0)), _ ? ge || (ge = requestAnimationFrame(Be)) : Be()
                        },
                        ze = function(e) {
                            if (!Ue(e, 1)) {
                                var t = (e = U(e, b)).clientX,
                                    n = e.clientY,
                                    r = t - we.x,
                                    s = n - we.y,
                                    a = we.isDragging;
                                we.x = t, we.y = n, (a || Math.abs(we.startX - t) >= i || Math.abs(we.startY - n) >= i) && (V && (_e = !0), a || (we.isDragging = !0), He(r, s), a || P && P(we))
                            }
                        },
                        Ve = we.onPress = function(e) {
                            Ue(e, 1) || (we.axis = xe = null, ye.pause(), we.isPressed = !0, e = U(e), Se = Ee = 0, we.startX = we.x = e.clientX, we.startY = we.y = e.clientY, we._vx.reset(), we._vy.reset(), M(re ? p : Re, m[1], ze, b, !0), we.deltaX = we.deltaY = 0, G && G(we))
                        },
                        Ge = function(e) {
                            if (!Ue(e, 1)) {
                                C(re ? p : Re, m[1], ze, !0);
                                var t = !isNaN(we.y - we.startY),
                                    i = we.isDragging && (Math.abs(we.x - we.startX) > 3 || Math.abs(we.y - we.startY) > 3),
                                    n = U(e);
                                !i && t && (we._vx.reset(), we._vy.reset(), b && pe && r.delayedCall(.08, (function() {
                                    if (x() - Oe > 300 && !e.defaultPrevented)
                                        if (e.target.click) e.target.click();
                                        else if (Re.createEvent) {
                                        var t = Re.createEvent("MouseEvents");
                                        t.initMouseEvent("click", !0, !0, a, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(t)
                                    }
                                }))), we.isDragging = we.isGesturing = we.isPressed = !1, T && !re && ye.restart(!0), z && i && z(we), W && W(we, i)
                            }
                        },
                        We = function(e) {
                            return e.touches && e.touches.length > 1 && (we.isGesturing = !0) && se(e, we.isDragging)
                        },
                        je = function() {
                            return (we.isGesturing = !1) || ae(we)
                        },
                        qe = function(e) {
                            if (!Ue(e)) {
                                var t = Me(),
                                    i = Ce();
                                Fe((t - Ae) * ue, (i - Le) * ue, 1), Ae = t, Le = i, T && ye.restart(!0)
                            }
                        },
                        $e = function(e) {
                            if (!Ue(e)) {
                                e = U(e, b), oe && (be = !0);
                                var t = (1 === e.deltaMode ? y : 2 === e.deltaMode ? a.innerHeight : 1) * A;
                                Fe(e.deltaX * t, e.deltaY * t, 0), T && !re && ye.restart(!0)
                            }
                        },
                        Xe = function(e) {
                            if (!Ue(e)) {
                                var t = e.clientX,
                                    i = e.clientY,
                                    n = t - we.x,
                                    r = i - we.y;
                                we.x = t, we.y = i, ve = !0, (n || r) && He(n, r)
                            }
                        },
                        Ye = function(e) {
                            we.event = e, ee(we)
                        },
                        Ke = function(e) {
                            we.event = e, te(we)
                        },
                        Je = function(e) {
                            return Ue(e) || U(e, b) && ce(we)
                        };
                    ye = we._dc = r.delayedCall(w || .25, (function() {
                        we._vx.reset(), we._vy.reset(), ye.pause(), T && T(we)
                    })).pause(), we.deltaX = we.deltaY = 0, we._vx = N(0, 50, !0), we._vy = N(0, 50, !0), we.scrollX = Me, we.scrollY = Ce, we.isDragging = we.isGesturing = we.isPressed = !1, g(this), we.enable = function(e) {
                        return we.isEnabled || (M(Pe ? Re : p, "scroll", I), n.indexOf("scroll") >= 0 && M(Pe ? Re : p, "scroll", qe, b, de), n.indexOf("wheel") >= 0 && M(p, "wheel", $e, b, de), (n.indexOf("touch") >= 0 && c || n.indexOf("pointer") >= 0) && (M(p, m[0], Ve, b, de), M(Re, m[2], Ge), M(Re, m[3], Ge), pe && M(p, "click", Ne, !1, !0), ce && M(p, "click", Je), se && M(Re, "gesturestart", We), ae && M(Re, "gestureend", je), ee && M(p, u + "enter", Ye), te && M(p, u + "leave", Ke), ie && M(p, u + "move", Xe)), we.isEnabled = !0, e && e.type && Ve(e), le && le(we)), we
                    }, we.disable = function() {
                        we.isEnabled && (v.filter((function(e) {
                            return e !== we && E(e.target)
                        })).length || C(Pe ? Re : p, "scroll", I), we.isPressed && (we._vx.reset(), we._vy.reset(), C(re ? p : Re, m[1], ze, !0)), C(Pe ? Re : p, "scroll", qe, de), C(p, "wheel", $e, de), C(p, m[0], Ve, de), C(Re, m[2], Ge), C(Re, m[3], Ge), C(p, "click", Ne, !0), C(p, "click", Je), C(Re, "gesturestart", We), C(Re, "gestureend", je), C(p, u + "enter", Ye), C(p, u + "leave", Ke), C(p, u + "move", Xe), we.isEnabled = we.isPressed = we.isDragging = !1, he && he(we))
                    }, we.kill = we.revert = function() {
                        we.disable();
                        var e = v.indexOf(we);
                        e >= 0 && v.splice(e, 1), f === we && (f = 0)
                    }, v.push(we), re && E(p) && (f = we), we.enable(L)
                }, t = e, (i = [{
                    key: "velocityX",
                    get: function() {
                        return this._vx.getVelocity()
                    }
                }, {
                    key: "velocityY",
                    get: function() {
                        return this._vy.getVelocity()
                    }
                }]) && n(t.prototype, i), p && n(t, p), e
            }();
            z.version = "3.11.4", z.create = function(e) {
                return new z(e)
            }, z.register = H, z.getAll = function() {
                return v.slice()
            }, z.getById = function(e) {
                return v.filter((function(t) {
                    return t.vars.id === e
                }))[0]
            }, y() && r.registerPlugin(z);
            var V, G, W, j, q, $, X, Y, K, J, Z, Q, ee, te, ie, ne, re, se, ae, oe, le, he, ce, ue, de, pe, fe, me, ge, ye, _e, ve, be, Te, xe = 1,
                we = Date.now,
                Se = we(),
                Ee = 0,
                Me = 0,
                Ce = function() {
                    return te = 1
                },
                Ae = function() {
                    return te = 0
                },
                Le = function(e) {
                    return e
                },
                Ie = function(e) {
                    return Math.round(1e5 * e) / 1e5 || 0
                },
                Pe = function() {
                    return "undefined" != typeof window
                },
                Re = function() {
                    return V || Pe() && (V = window.gsap) && V.registerPlugin && V
                },
                ke = function(e) {
                    return !!~X.indexOf(e)
                },
                De = function(e) {
                    return S(e, "getBoundingClientRect") || (ke(e) ? function() {
                        return jt.width = W.innerWidth, jt.height = W.innerHeight, jt
                    } : function() {
                        return at(e)
                    })
                },
                Oe = function(e, t) {
                    var i = t.s,
                        n = t.d2,
                        r = t.d,
                        s = t.a;
                    return (i = "scroll" + n) && (s = S(e, i)) ? s() - De(e)()[r] : ke(e) ? (q[i] || $[i]) - (W["inner" + n] || q["client" + n] || $["client" + n]) : e[i] - e["offset" + n]
                },
                Ne = function(e, t) {
                    for (var i = 0; i < ae.length; i += 3)(!t || ~t.indexOf(ae[i + 1])) && e(ae[i], ae[i + 1], ae[i + 2])
                },
                Ue = function(e) {
                    return "string" == typeof e
                },
                Be = function(e) {
                    return "function" == typeof e
                },
                Fe = function(e) {
                    return "number" == typeof e
                },
                He = function(e) {
                    return "object" == typeof e
                },
                ze = function(e, t, i) {
                    return e && e.progress(t ? 0 : 1) && i && e.pause()
                },
                Ve = function(e, t) {
                    if (e.enabled) {
                        var i = t(e);
                        i && i.totalTime && (e.callbackAnimation = i)
                    }
                },
                Ge = Math.abs,
                We = "left",
                je = "right",
                qe = "bottom",
                $e = "width",
                Xe = "height",
                Ye = "Right",
                Ke = "Left",
                Je = "Top",
                Ze = "Bottom",
                Qe = "padding",
                et = "margin",
                tt = "Width",
                it = "Height",
                nt = "px",
                rt = function(e) {
                    return W.getComputedStyle(e)
                },
                st = function(e, t) {
                    for (var i in t) i in e || (e[i] = t[i]);
                    return e
                },
                at = function(e, t) {
                    var i = t && "matrix(1, 0, 0, 1, 0, 0)" !== rt(e)[ie] && V.to(e, {
                            x: 0,
                            y: 0,
                            xPercent: 0,
                            yPercent: 0,
                            rotation: 0,
                            rotationX: 0,
                            rotationY: 0,
                            scale: 1,
                            skewX: 0,
                            skewY: 0
                        }).progress(1),
                        n = e.getBoundingClientRect();
                    return i && i.progress(0).kill(), n
                },
                ot = function(e, t) {
                    var i = t.d2;
                    return e["offset" + i] || e["client" + i] || 0
                },
                lt = function(e) {
                    var t, i = [],
                        n = e.labels,
                        r = e.duration();
                    for (t in n) i.push(n[t] / r);
                    return i
                },
                ht = function(e) {
                    var t = V.utils.snap(e),
                        i = Array.isArray(e) && e.slice(0).sort((function(e, t) {
                            return e - t
                        }));
                    return i ? function(e, n, r) {
                        var s;
                        if (void 0 === r && (r = .001), !n) return t(e);
                        if (n > 0) {
                            for (e -= r, s = 0; s < i.length; s++)
                                if (i[s] >= e) return i[s];
                            return i[s - 1]
                        }
                        for (s = i.length, e += r; s--;)
                            if (i[s] <= e) return i[s];
                        return i[0]
                    } : function(i, n, r) {
                        void 0 === r && (r = .001);
                        var s = t(i);
                        return !n || Math.abs(s - i) < r || s - i < 0 == n < 0 ? s : t(n < 0 ? i - e : i + e)
                    }
                },
                ct = function(e, t, i, n) {
                    return i.split(",").forEach((function(i) {
                        return e(t, i, n)
                    }))
                },
                ut = function(e, t, i, n, r) {
                    return e.addEventListener(t, i, {
                        passive: !n,
                        capture: !!r
                    })
                },
                dt = function(e, t, i, n) {
                    return e.removeEventListener(t, i, !!n)
                },
                pt = function(e, t, i) {
                    return i && i.wheelHandler && e(t, "wheel", i)
                },
                ft = {
                    startColor: "green",
                    endColor: "red",
                    indent: 0,
                    fontSize: "16px",
                    fontWeight: "normal"
                },
                mt = {
                    toggleActions: "play",
                    anticipatePin: 0
                },
                gt = {
                    top: 0,
                    left: 0,
                    center: .5,
                    bottom: 1,
                    right: 1
                },
                yt = function(e, t) {
                    if (Ue(e)) {
                        var i = e.indexOf("="),
                            n = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
                        ~i && (e.indexOf("%") > i && (n *= t / 100), e = e.substr(0, i - 1)), e = n + (e in gt ? gt[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
                    }
                    return e
                },
                _t = function(e, t, i, n, r, s, a, o) {
                    var l = r.startColor,
                        h = r.endColor,
                        c = r.fontSize,
                        u = r.indent,
                        d = r.fontWeight,
                        p = j.createElement("div"),
                        f = ke(i) || "fixed" === S(i, "pinType"),
                        m = -1 !== e.indexOf("scroller"),
                        g = f ? $ : i,
                        y = -1 !== e.indexOf("start"),
                        _ = y ? l : h,
                        v = "border-color:" + _ + ";font-size:" + c + ";color:" + _ + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                    return v += "position:" + ((m || o) && f ? "fixed;" : "absolute;"), (m || o || !f) && (v += (n === k ? je : qe) + ":" + (s + parseFloat(u)) + "px;"), a && (v += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), p._isStart = y, p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), p.style.cssText = v, p.innerText = t || 0 === t ? e + "-" + t : e, g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p), p._offset = p["offset" + n.op.d2], vt(p, 0, n, y), p
                },
                vt = function(e, t, i, n) {
                    var r = {
                            display: "block"
                        },
                        s = i[n ? "os2" : "p2"],
                        a = i[n ? "p2" : "os2"];
                    e._isFlipped = n, r[i.a + "Percent"] = n ? -100 : 0, r[i.a] = n ? "1px" : 0, r["border" + s + tt] = 1, r["border" + a + tt] = 0, r[i.p] = t + "px", V.set(e, r)
                },
                bt = [],
                Tt = {},
                xt = function() {
                    return we() - Ee > 34 && (_e || (_e = requestAnimationFrame(Bt)))
                },
                wt = function() {
                    (!ce || !ce.isPressed || ce.startX > $.clientWidth) && (b.cache++, ce ? _e || (_e = requestAnimationFrame(Bt)) : Bt(), Ee || Lt("scrollStart"), Ee = we())
                },
                St = function() {
                    pe = W.innerWidth, de = W.innerHeight
                },
                Et = function() {
                    b.cache++, !ee && !he && !j.fullscreenElement && !j.webkitFullscreenElement && (!ue || pe !== W.innerWidth || Math.abs(W.innerHeight - de) > .25 * W.innerHeight) && Y.restart(!0)
                },
                Mt = {},
                Ct = [],
                At = function e() {
                    return dt(Kt, "scrollEnd", e) || Ot(!0)
                },
                Lt = function(e) {
                    return Mt[e] && Mt[e].map((function(e) {
                        return e()
                    })) || Ct
                },
                It = [],
                Pt = function(e) {
                    for (var t = 0; t < It.length; t += 5)(!e || It[t + 4] && It[t + 4].query === e) && (It[t].style.cssText = It[t + 1], It[t].getBBox && It[t].setAttribute("transform", It[t + 2] || ""), It[t + 3].uncache = 1)
                },
                Rt = function(e, t) {
                    var i;
                    for (ne = 0; ne < bt.length; ne++) !(i = bt[ne]) || t && i._ctx !== t || (e ? i.kill(1) : i.revert(!0, !0));
                    t && Pt(t), t || Lt("revert")
                },
                kt = function(e, t) {
                    b.cache++, (t || !ve) && b.forEach((function(e) {
                        return Be(e) && e.cacheID++ && (e.rec = 0)
                    })), Ue(e) && (W.history.scrollRestoration = ge = e)
                },
                Dt = 0,
                Ot = function(e, t) {
                    if (!Ee || e) {
                        ve = Kt.isRefreshing = !0, b.forEach((function(e) {
                            return Be(e) && e.cacheID++ && (e.rec = e())
                        }));
                        var i = Lt("refreshInit");
                        oe && Kt.sort(), t || Rt(), b.forEach((function(e) {
                            Be(e) && (e.smooth && (e.target.style.scrollBehavior = "auto"), e(0))
                        })), bt.slice(0).forEach((function(e) {
                            return e.refresh()
                        })), bt.forEach((function(e, t) {
                            if (e._subPinOffset && e.pin) {
                                var i = e.vars.horizontal ? "offsetWidth" : "offsetHeight",
                                    n = e.pin[i];
                                e.revert(!0, 1), e.adjustPinSpacing(e.pin[i] - n), e.revert(!1, 1)
                            }
                        })), bt.forEach((function(e) {
                            return "max" === e.vars.end && e.setPositions(e.start, Math.max(e.start + 1, Oe(e.scroller, e._dir)))
                        })), i.forEach((function(e) {
                            return e && e.render && e.render(-1)
                        })), b.forEach((function(e) {
                            Be(e) && (e.smooth && requestAnimationFrame((function() {
                                return e.target.style.scrollBehavior = "smooth"
                            })), e.rec && e(e.rec))
                        })), kt(ge, 1), Y.pause(), Dt++, Bt(2), bt.forEach((function(e) {
                            return Be(e.vars.onRefresh) && e.vars.onRefresh(e)
                        })), ve = Kt.isRefreshing = !1, Lt("refresh")
                    } else ut(Kt, "scrollEnd", At)
                },
                Nt = 0,
                Ut = 1,
                Bt = function(e) {
                    if (!ve || 2 === e) {
                        Kt.isUpdating = !0, Te && Te.update(0);
                        var t = bt.length,
                            i = we(),
                            n = i - Se >= 50,
                            r = t && bt[0].scroll();
                        if (Ut = Nt > r ? -1 : 1, Nt = r, n && (Ee && !te && i - Ee > 200 && (Ee = 0, Lt("scrollEnd")), Z = Se, Se = i), Ut < 0) {
                            for (ne = t; ne-- > 0;) bt[ne] && bt[ne].update(0, n);
                            Ut = 1
                        } else
                            for (ne = 0; ne < t; ne++) bt[ne] && bt[ne].update(0, n);
                        Kt.isUpdating = !1
                    }
                    _e = 0
                },
                Ft = [We, "top", qe, je, et + Ze, et + Ye, et + Je, et + Ke, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
                Ht = Ft.concat([$e, Xe, "boxSizing", "max" + tt, "max" + it, "position", et, Qe, Qe + Je, Qe + Ye, Qe + Ze, Qe + Ke]),
                zt = function(e, t, i, n) {
                    if (!e._gsap.swappedIn) {
                        for (var r, s = Ft.length, a = t.style, o = e.style; s--;) a[r = Ft[s]] = i[r];
                        a.position = "absolute" === i.position ? "absolute" : "relative", "inline" === i.display && (a.display = "inline-block"), o[qe] = o[je] = "auto", a.flexBasis = i.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[$e] = ot(e, R) + nt, a[Xe] = ot(e, k) + nt, a[Qe] = o[et] = o.top = o[We] = "0", Gt(n), o[$e] = o["max" + tt] = i[$e], o[Xe] = o["max" + it] = i[Xe], o[Qe] = i[Qe], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0
                    }
                },
                Vt = /([A-Z])/g,
                Gt = function(e) {
                    if (e) {
                        var t, i, n = e.t.style,
                            r = e.length,
                            s = 0;
                        for ((e.t._gsap || V.core.getCache(e.t)).uncache = 1; s < r; s += 2) i = e[s + 1], t = e[s], i ? n[t] = i : n[t] && n.removeProperty(t.replace(Vt, "-$1").toLowerCase())
                    }
                },
                Wt = function(e) {
                    for (var t = Ht.length, i = e.style, n = [], r = 0; r < t; r++) n.push(Ht[r], i[Ht[r]]);
                    return n.t = e, n
                },
                jt = {
                    left: 0,
                    top: 0
                },
                qt = function(e, t, i, n, r, s, a, o, l, h, c, u, d) {
                    Be(e) && (e = e(o)), Ue(e) && "max" === e.substr(0, 3) && (e = u + ("=" === e.charAt(4) ? yt("0" + e.substr(3), i) : 0));
                    var p, f, m, g = d ? d.time() : 0;
                    if (d && d.seek(0), Fe(e)) a && vt(a, i, n, !0);
                    else {
                        Be(t) && (t = t(o));
                        var y, _, v, b, T = (e || "0").split(" ");
                        m = D(t) || $, (y = at(m) || {}) && (y.left || y.top) || "none" !== rt(m).display || (b = m.style.display, m.style.display = "block", y = at(m), b ? m.style.display = b : m.style.removeProperty("display")), _ = yt(T[0], y[n.d]), v = yt(T[1] || "0", i), e = y[n.p] - l[n.p] - h + _ + r - v, a && vt(a, v, n, i - v < 20 || a._isStart && v > 20), i -= i - v
                    }
                    if (s) {
                        var x = e + i,
                            w = s._isStart;
                        p = "scroll" + n.d2, vt(s, x, n, w && x > 20 || !w && (c ? Math.max($[p], q[p]) : s.parentNode[p]) <= x + 1), c && (l = at(a), c && (s.style[n.op.p] = l[n.op.p] - n.op.m - s._offset + nt))
                    }
                    return d && m && (p = at(m), d.seek(u), f = at(m), d._caScrollDist = p[n.p] - f[n.p], e = e / d._caScrollDist * u), d && d.seek(g), d ? e : Math.round(e)
                },
                $t = /(webkit|moz|length|cssText|inset)/i,
                Xt = function(e, t, i, n) {
                    if (e.parentNode !== t) {
                        var r, s, a = e.style;
                        if (t === $) {
                            for (r in e._stOrig = a.cssText, s = rt(e)) + r || $t.test(r) || !s[r] || "string" != typeof a[r] || "0" === r || (a[r] = s[r]);
                            a.top = i, a.left = n
                        } else a.cssText = e._stOrig;
                        V.core.getCache(e).uncache = 1, t.appendChild(e)
                    }
                },
                Yt = function(e, t) {
                    var i, n, r = O(e, t),
                        s = "_scroll" + t.p2,
                        a = function t(a, o, l, h, c) {
                            var u = t.tween,
                                d = o.onComplete,
                                p = {};
                            return l = l || r(), c = h && c || 0, h = h || a - l, u && u.kill(), i = Math.round(l), o[s] = a, o.modifiers = p, p[s] = function(e) {
                                return (e = Math.round(r())) !== i && e !== n && Math.abs(e - i) > 3 && Math.abs(e - n) > 3 ? (u.kill(), t.tween = 0) : e = l + h * u.ratio + c * u.ratio * u.ratio, n = i, i = Math.round(e)
                            }, o.onUpdate = function() {
                                b.cache++, Bt()
                            }, o.onComplete = function() {
                                t.tween = 0, d && d.call(u)
                            }, u = t.tween = V.to(e, o)
                        };
                    return e[s] = r, r.wheelHandler = function() {
                        return a.tween && a.tween.kill() && (a.tween = 0)
                    }, ut(e, "wheel", r.wheelHandler), a
                },
                Kt = function() {
                    function e(t, i) {
                        G || e.register(V) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(t, i)
                    }
                    return e.prototype.init = function(t, i) {
                        if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), Me) {
                            var n, r, s, a, o, l, h, c, u, d, p, f, m, g, y, _, v, x, w, E, M, C, A, L, I, P, N, U, B, F, H, z, G, X, Y, Q, ie, re, se, ae, he, ce, ue = t = st(Ue(t) || Fe(t) || t.nodeType ? {
                                    trigger: t
                                } : t, mt),
                                de = ue.onUpdate,
                                pe = ue.toggleClass,
                                fe = ue.id,
                                ge = ue.onToggle,
                                _e = ue.onRefresh,
                                Se = ue.scrub,
                                Ce = ue.trigger,
                                Ae = ue.pin,
                                Pe = ue.pinSpacing,
                                Re = ue.invalidateOnRefresh,
                                Ne = ue.anticipatePin,
                                We = ue.onScrubComplete,
                                je = ue.onSnapComplete,
                                qe = ue.once,
                                ct = ue.snap,
                                pt = ue.pinReparent,
                                gt = ue.pinSpacer,
                                vt = ue.containerAnimation,
                                xt = ue.fastScrollEnd,
                                St = ue.preventOverlaps,
                                Mt = t.horizontal || t.containerAnimation && !1 !== t.horizontal ? R : k,
                                Ct = !Se && 0 !== Se,
                                Lt = D(t.scroller || W),
                                It = V.core.getCache(Lt),
                                Pt = ke(Lt),
                                Rt = "fixed" === ("pinType" in t ? t.pinType : S(Lt, "pinType") || Pt && "fixed"),
                                kt = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack],
                                Nt = Ct && t.toggleActions.split(" "),
                                Bt = "markers" in t ? t.markers : mt.markers,
                                Ft = Pt ? 0 : parseFloat(rt(Lt)["border" + Mt.p2 + tt]) || 0,
                                Ht = this,
                                Vt = t.onRefreshInit && function() {
                                    return t.onRefreshInit(Ht)
                                },
                                $t = function(e, t, i) {
                                    var n = i.d,
                                        r = i.d2,
                                        s = i.a;
                                    return (s = S(e, "getBoundingClientRect")) ? function() {
                                        return s()[n]
                                    } : function() {
                                        return (t ? W["inner" + r] : e["client" + r]) || 0
                                    }
                                }(Lt, Pt, Mt),
                                Kt = function(e, t) {
                                    return !t || ~T.indexOf(e) ? De(e) : function() {
                                        return jt
                                    }
                                }(Lt, Pt),
                                Jt = 0,
                                Zt = 0,
                                Qt = O(Lt, Mt);
                            if (me(Ht), Ht._dir = Mt, Ne *= 45, Ht.scroller = Lt, Ht.scroll = vt ? vt.time.bind(vt) : Qt, a = Qt(), Ht.vars = t, i = i || t.animation, "refreshPriority" in t && (oe = 1, -9999 === t.refreshPriority && (Te = Ht)), It.tweenScroll = It.tweenScroll || {
                                    top: Yt(Lt, k),
                                    left: Yt(Lt, R)
                                }, Ht.tweenTo = n = It.tweenScroll[Mt.p], Ht.scrubDuration = function(e) {
                                    (z = Fe(e) && e) ? H ? H.duration(e) : H = V.to(i, {
                                        ease: "expo",
                                        totalProgress: "+=0.001",
                                        duration: z,
                                        paused: !0,
                                        onComplete: function() {
                                            return We && We(Ht)
                                        }
                                    }): (H && H.progress(1).kill(), H = 0)
                                }, i && (i.vars.lazy = !1, i._initted || !1 !== i.vars.immediateRender && !1 !== t.immediateRender && i.duration() && i.render(0, !0, !0), Ht.animation = i.pause(), i.scrollTrigger = Ht, Ht.scrubDuration(Se), B = 0, fe || (fe = i.vars.id)), bt.push(Ht), ct && (He(ct) && !ct.push || (ct = {
                                    snapTo: ct
                                }), "scrollBehavior" in $.style && V.set(Pt ? [$, q] : Lt, {
                                    scrollBehavior: "auto"
                                }), b.forEach((function(e) {
                                    return Be(e) && e.target === (Pt ? j.scrollingElement || q : Lt) && (e.smooth = !1)
                                })), s = Be(ct.snapTo) ? ct.snapTo : "labels" === ct.snapTo ? function(e) {
                                    return function(t) {
                                        return V.utils.snap(lt(e), t)
                                    }
                                }(i) : "labelsDirectional" === ct.snapTo ? (ae = i, function(e, t) {
                                    return ht(lt(ae))(e, t.direction)
                                }) : !1 !== ct.directional ? function(e, t) {
                                    return ht(ct.snapTo)(e, we() - Zt < 500 ? 0 : t.direction)
                                } : V.utils.snap(ct.snapTo), G = ct.duration || {
                                    min: .1,
                                    max: 2
                                }, G = He(G) ? J(G.min, G.max) : J(G, G), X = V.delayedCall(ct.delay || z / 2 || .1, (function() {
                                    var e = Qt(),
                                        t = we() - Zt < 500,
                                        r = n.tween;
                                    if (!(t || Math.abs(Ht.getVelocity()) < 10) || r || te || Jt === e) Ht.isActive && Jt !== e && X.restart(!0);
                                    else {
                                        var a = (e - l) / m,
                                            o = i && !Ct ? i.totalProgress() : a,
                                            c = t ? 0 : (o - F) / (we() - Z) * 1e3 || 0,
                                            u = V.utils.clamp(-a, 1 - a, Ge(c / 2) * c / .185),
                                            d = a + (!1 === ct.inertia ? 0 : u),
                                            p = J(0, 1, s(d, Ht)),
                                            f = Math.round(l + p * m),
                                            g = ct,
                                            y = g.onStart,
                                            _ = g.onInterrupt,
                                            v = g.onComplete;
                                        if (e <= h && e >= l && f !== e) {
                                            if (r && !r._initted && r.data <= Ge(f - e)) return;
                                            !1 === ct.inertia && (u = p - a), n(f, {
                                                duration: G(Ge(.185 * Math.max(Ge(d - o), Ge(p - o)) / c / .05 || 0)),
                                                ease: ct.ease || "power3",
                                                data: Ge(f - e),
                                                onInterrupt: function() {
                                                    return X.restart(!0) && _ && _(Ht)
                                                },
                                                onComplete: function() {
                                                    Ht.update(), Jt = Qt(), B = F = i && !Ct ? i.totalProgress() : Ht.progress, je && je(Ht), v && v(Ht)
                                                }
                                            }, e, u * m, f - e - u * m), y && y(Ht, n.tween)
                                        }
                                    }
                                })).pause()), fe && (Tt[fe] = Ht), (se = (Ce = Ht.trigger = D(Ce || Ae)) && Ce._gsap && Ce._gsap.stRevert) && (se = se(Ht)), Ae = !0 === Ae ? Ce : D(Ae), Ue(pe) && (pe = {
                                    targets: Ce,
                                    className: pe
                                }), Ae && (!1 === Pe || Pe === et || (Pe = !(!Pe && Ae.parentNode && Ae.parentNode.style && "flex" === rt(Ae.parentNode).display) && Qe), Ht.pin = Ae, (r = V.core.getCache(Ae)).spacer ? g = r.pinState : (gt && ((gt = D(gt)) && !gt.nodeType && (gt = gt.current || gt.nativeElement), r.spacerIsNative = !!gt, gt && (r.spacerState = Wt(gt))), r.spacer = v = gt || j.createElement("div"), v.classList.add("pin-spacer"), fe && v.classList.add("pin-spacer-" + fe), r.pinState = g = Wt(Ae)), !1 !== t.force3D && V.set(Ae, {
                                    force3D: !0
                                }), Ht.spacer = v = r.spacer, U = rt(Ae), A = U[Pe + Mt.os2], w = V.getProperty(Ae), E = V.quickSetter(Ae, Mt.a, nt), zt(Ae, v, U), _ = Wt(Ae)), Bt) {
                                f = He(Bt) ? st(Bt, ft) : ft, d = _t("scroller-start", fe, Lt, Mt, f, 0), p = _t("scroller-end", fe, Lt, Mt, f, 0, d), x = d["offset" + Mt.op.d2];
                                var ei = D(S(Lt, "content") || Lt);
                                c = this.markerStart = _t("start", fe, ei, Mt, f, x, 0, vt), u = this.markerEnd = _t("end", fe, ei, Mt, f, x, 0, vt), vt && (re = V.quickSetter([c, u], Mt.a, nt)), Rt || T.length && !0 === S(Lt, "fixedMarkers") || (ce = rt(he = Pt ? $ : Lt).position, he.style.position = "absolute" === ce || "fixed" === ce ? ce : "relative", V.set([d, p], {
                                    force3D: !0
                                }), I = V.quickSetter(d, Mt.a, nt), N = V.quickSetter(p, Mt.a, nt))
                            }
                            if (vt) {
                                var ti = vt.vars.onUpdate,
                                    ii = vt.vars.onUpdateParams;
                                vt.eventCallback("onUpdate", (function() {
                                    Ht.update(0, 0, 1), ti && ti.apply(ii || [])
                                }))
                            }
                            Ht.previous = function() {
                                return bt[bt.indexOf(Ht) - 1]
                            }, Ht.next = function() {
                                return bt[bt.indexOf(Ht) + 1]
                            }, Ht.revert = function(e, t) {
                                if (!t) return Ht.kill(!0);
                                var n = !1 !== e || !Ht.enabled,
                                    r = ee;
                                n !== Ht.isReverted && (n && (Q = Math.max(Qt(), Ht.scroll.rec || 0), Y = Ht.progress, ie = i && i.progress()), c && [c, u, d, p].forEach((function(e) {
                                    return e.style.display = n ? "none" : "block"
                                })), n && (ee = 1, Ht.update(n)), !Ae || pt && Ht.isActive || (n ? function(e, t, i) {
                                    Gt(i);
                                    var n = e._gsap;
                                    if (n.spacerIsNative) Gt(n.spacerState);
                                    else if (e._gsap.swappedIn) {
                                        var r = t.parentNode;
                                        r && (r.insertBefore(e, t), r.removeChild(t))
                                    }
                                    e._gsap.swappedIn = !1
                                }(Ae, v, g) : zt(Ae, v, rt(Ae), L)), n || Ht.update(n), ee = r, Ht.isReverted = n)
                            }, Ht.refresh = function(r, s) {
                                if (!ee && Ht.enabled || s)
                                    if (Ae && r && Ee) ut(e, "scrollEnd", At);
                                    else {
                                        !ve && Vt && Vt(Ht), ee = 1, Zt = we(), n.tween && (n.tween.kill(), n.tween = 0), H && H.pause(), Re && i && i.revert({
                                            kill: !1
                                        }).invalidate(), Ht.isReverted || Ht.revert(!0, !0), Ht._subPinOffset = !1;
                                        for (var f, b, T, x, S, E, A, I, N, U, B, F = $t(), z = Kt(), G = vt ? vt.duration() : Oe(Lt, Mt), W = 0, K = 0, J = t.end, Z = t.endTrigger || Ce, te = t.start || (0 !== t.start && Ce ? Ae ? "0 0" : "0 100%" : 0), ne = Ht.pinnedContainer = t.pinnedContainer && D(t.pinnedContainer), re = Ce && Math.max(0, bt.indexOf(Ht)) || 0, se = re; se--;)(E = bt[se]).end || E.refresh(0, 1) || (ee = 1), !(A = E.pin) || A !== Ce && A !== Ae || E.isReverted || (U || (U = []), U.unshift(E), E.revert(!0, !0)), E !== bt[se] && (re--, se--);
                                        for (Be(te) && (te = te(Ht)), l = qt(te, Ce, F, Mt, Qt(), c, d, Ht, z, Ft, Rt, G, vt) || (Ae ? -.001 : 0), Be(J) && (J = J(Ht)), Ue(J) && !J.indexOf("+=") && (~J.indexOf(" ") ? J = (Ue(te) ? te.split(" ")[0] : "") + J : (W = yt(J.substr(2), F), J = Ue(te) ? te : l + W, Z = Ce)), h = Math.max(l, qt(J || (Z ? "100% 0" : G), Z, F, Mt, Qt() + W, u, p, Ht, z, Ft, Rt, G, vt)) || -.001, m = h - l || (l -= .01) && .001, W = 0, se = re; se--;)(A = (E = bt[se]).pin) && E.start - E._pinPush <= l && !vt && E.end > 0 && (f = E.end - E.start, (A === Ce && E.start - E._pinPush < l || A === ne) && !Fe(te) && (W += f * (1 - E.progress)), A === Ae && (K += f));
                                        if (l += W, h += W, Ht._pinPush = K, c && W && ((f = {})[Mt.a] = "+=" + W, ne && (f[Mt.p] = "-=" + Qt()), V.set([c, u], f)), Ae) f = rt(Ae), x = Mt === k, T = Qt(), M = parseFloat(w(Mt.a)) + K, !G && h > 1 && ((B = {
                                            style: B = (Pt ? j.scrollingElement || q : Lt).style,
                                            value: B["overflow" + Mt.a.toUpperCase()]
                                        })["overflow" + Mt.a.toUpperCase()] = "scroll"), zt(Ae, v, f), _ = Wt(Ae), b = at(Ae, !0), I = Rt && O(Lt, x ? R : k)(), Pe && ((L = [Pe + Mt.os2, m + K + nt]).t = v, (se = Pe === Qe ? ot(Ae, Mt) + m + K : 0) && L.push(Mt.d, se + nt), Gt(L), ne && bt.forEach((function(e) {
                                            e.pin === ne && !1 !== e.vars.pinSpacing && (e._subPinOffset = !0)
                                        })), Rt && Qt(Q)), Rt && ((S = {
                                            top: b.top + (x ? T - l : I) + nt,
                                            left: b.left + (x ? I : T - l) + nt,
                                            boxSizing: "border-box",
                                            position: "fixed"
                                        })[$e] = S["max" + tt] = Math.ceil(b.width) + nt, S[Xe] = S["max" + it] = Math.ceil(b.height) + nt, S[et] = S[et + Je] = S[et + Ye] = S[et + Ze] = S[et + Ke] = "0", S[Qe] = f[Qe], S[Qe + Je] = f[Qe + Je], S[Qe + Ye] = f[Qe + Ye], S[Qe + Ze] = f[Qe + Ze], S[Qe + Ke] = f[Qe + Ke], y = function(e, t, i) {
                                            for (var n, r = [], s = e.length, a = i ? 8 : 0; a < s; a += 2) n = e[a], r.push(n, n in t ? t[n] : e[a + 1]);
                                            return r.t = e.t, r
                                        }(g, S, pt), ve && Qt(0)), i ? (N = i._initted, le(1), i.render(i.duration(), !0, !0), C = w(Mt.a) - M + m + K, P = Math.abs(m - C) > 1, Rt && P && y.splice(y.length - 2, 2), i.render(0, !0, !0), N || i.invalidate(!0), i.parent || i.totalTime(i.totalTime()), le(0)) : C = m, B && (B.value ? B.style["overflow" + Mt.a.toUpperCase()] = B.value : B.style.removeProperty("overflow-" + Mt.a));
                                        else if (Ce && Qt() && !vt)
                                            for (b = Ce.parentNode; b && b !== $;) b._pinOffset && (l -= b._pinOffset, h -= b._pinOffset), b = b.parentNode;
                                        U && U.forEach((function(e) {
                                            return e.revert(!1, !0)
                                        })), Ht.start = l, Ht.end = h, a = o = ve ? Q : Qt(), vt || ve || (a < Q && Qt(Q), Ht.scroll.rec = 0), Ht.revert(!1, !0), X && (Jt = -1, Ht.isActive && Qt(l + m * Y), X.restart(!0)), ee = 0, i && Ct && (i._initted || ie) && i.progress() !== ie && i.progress(ie, !0).render(i.time(), !0, !0), (Y !== Ht.progress || vt) && (i && !Ct && i.totalProgress(Y, !0), Ht.progress = (a - l) / m === Y ? 0 : Y), Ae && Pe && (v._pinOffset = Math.round(Ht.progress * C)), _e && !ve && _e(Ht)
                                    }
                            }, Ht.getVelocity = function() {
                                return (Qt() - o) / (we() - Z) * 1e3 || 0
                            }, Ht.endAnimation = function() {
                                ze(Ht.callbackAnimation), i && (H ? H.progress(1) : i.paused() ? Ct || ze(i, Ht.direction < 0, 1) : ze(i, i.reversed()))
                            }, Ht.labelToScroll = function(e) {
                                return i && i.labels && (l || Ht.refresh() || l) + i.labels[e] / i.duration() * m || 0
                            }, Ht.getTrailing = function(e) {
                                var t = bt.indexOf(Ht),
                                    i = Ht.direction > 0 ? bt.slice(0, t).reverse() : bt.slice(t + 1);
                                return (Ue(e) ? i.filter((function(t) {
                                    return t.vars.preventOverlaps === e
                                })) : i).filter((function(e) {
                                    return Ht.direction > 0 ? e.end <= l : e.start >= h
                                }))
                            }, Ht.update = function(e, t, r) {
                                if (!vt || r || e) {
                                    var s, c, u, p, f, g, b, T = ve ? Q : Ht.scroll(),
                                        x = e ? 0 : (T - l) / m,
                                        w = x < 0 ? 0 : x > 1 ? 1 : x || 0,
                                        S = Ht.progress;
                                    if (t && (o = a, a = vt ? Qt() : T, ct && (F = B, B = i && !Ct ? i.totalProgress() : w)), Ne && !w && Ae && !ee && !xe && Ee && l < T + (T - o) / (we() - Z) * Ne && (w = 1e-4), w !== S && Ht.enabled) {
                                        if (p = (f = (s = Ht.isActive = !!w && w < 1) !== (!!S && S < 1)) || !!w != !!S, Ht.direction = w > S ? 1 : -1, Ht.progress = w, p && !ee && (c = w && !S ? 0 : 1 === w ? 1 : 1 === S ? 2 : 3, Ct && (u = !f && "none" !== Nt[c + 1] && Nt[c + 1] || Nt[c], b = i && ("complete" === u || "reset" === u || u in i))), St && (f || b) && (b || Se || !i) && (Be(St) ? St(Ht) : Ht.getTrailing(St).forEach((function(e) {
                                                return e.endAnimation()
                                            }))), Ct || (!H || ee || xe ? i && i.totalProgress(w, !!ee) : (H._dp._time - H._start !== H._time && H.render(H._dp._time - H._start), H.resetTo ? H.resetTo("totalProgress", w, i._tTime / i._tDur) : (H.vars.totalProgress = w, H.invalidate().restart()))), Ae)
                                            if (e && Pe && (v.style[Pe + Mt.os2] = A), Rt) {
                                                if (p) {
                                                    if (g = !e && w > S && h + 1 > T && T + 1 >= Oe(Lt, Mt), pt)
                                                        if (e || !s && !g) Xt(Ae, v);
                                                        else {
                                                            var L = at(Ae, !0),
                                                                R = T - l;
                                                            Xt(Ae, $, L.top + (Mt === k ? R : 0) + nt, L.left + (Mt === k ? 0 : R) + nt)
                                                        }
                                                    Gt(s || g ? y : _), P && w < 1 && s || E(M + (1 !== w || g ? 0 : C))
                                                }
                                            } else E(Ie(M + C * w));
                                        ct && !n.tween && !ee && !xe && X.restart(!0), pe && (f || qe && w && (w < 1 || !ye)) && K(pe.targets).forEach((function(e) {
                                            return e.classList[s || qe ? "add" : "remove"](pe.className)
                                        })), de && !Ct && !e && de(Ht), p && !ee ? (Ct && (b && ("complete" === u ? i.pause().totalProgress(1) : "reset" === u ? i.restart(!0).pause() : "restart" === u ? i.restart(!0) : i[u]()), de && de(Ht)), !f && ye || (ge && f && Ve(Ht, ge), kt[c] && Ve(Ht, kt[c]), qe && (1 === w ? Ht.kill(!1, 1) : kt[c] = 0), f || kt[c = 1 === w ? 1 : 3] && Ve(Ht, kt[c])), xt && !s && Math.abs(Ht.getVelocity()) > (Fe(xt) ? xt : 2500) && (ze(Ht.callbackAnimation), H ? H.progress(1) : ze(i, "reverse" === u ? 1 : !w, 1))) : Ct && de && !ee && de(Ht)
                                    }
                                    if (N) {
                                        var D = vt ? T / vt.duration() * (vt._caScrollDist || 0) : T;
                                        I(D + (d._isFlipped ? 1 : 0)), N(D)
                                    }
                                    re && re(-T / vt.duration() * (vt._caScrollDist || 0))
                                }
                            }, Ht.enable = function(t, i) {
                                Ht.enabled || (Ht.enabled = !0, ut(Lt, "resize", Et), ut(Pt ? j : Lt, "scroll", wt), Vt && ut(e, "refreshInit", Vt), !1 !== t && (Ht.progress = Y = 0, a = o = Jt = Qt()), !1 !== i && Ht.refresh())
                            }, Ht.getTween = function(e) {
                                return e && n ? n.tween : H
                            }, Ht.setPositions = function(e, t) {
                                Ae && (M += e - l, C += t - e - m, Pe === Qe && Ht.adjustPinSpacing(t - e - m)), Ht.start = l = e, Ht.end = h = t, m = t - e, Ht.update()
                            }, Ht.adjustPinSpacing = function(e) {
                                if (L) {
                                    var t = L.indexOf(Mt.d) + 1;
                                    L[t] = parseFloat(L[t]) + e + nt, L[1] = parseFloat(L[1]) + e + nt, Gt(L)
                                }
                            }, Ht.disable = function(t, i) {
                                if (Ht.enabled && (!1 !== t && Ht.revert(!0, !0), Ht.enabled = Ht.isActive = !1, i || H && H.pause(), Q = 0, r && (r.uncache = 1), Vt && dt(e, "refreshInit", Vt), X && (X.pause(), n.tween && n.tween.kill() && (n.tween = 0)), !Pt)) {
                                    for (var s = bt.length; s--;)
                                        if (bt[s].scroller === Lt && bt[s] !== Ht) return;
                                    dt(Lt, "resize", Et), dt(Lt, "scroll", wt)
                                }
                            }, Ht.kill = function(e, n) {
                                Ht.disable(e, n), H && !n && H.kill(), fe && delete Tt[fe];
                                var s = bt.indexOf(Ht);
                                s >= 0 && bt.splice(s, 1), s === ne && Ut > 0 && ne--, s = 0, bt.forEach((function(e) {
                                    return e.scroller === Ht.scroller && (s = 1)
                                })), s || ve || (Ht.scroll.rec = 0), i && (i.scrollTrigger = null, e && i.revert({
                                    kill: !1
                                }), n || i.kill()), c && [c, u, d, p].forEach((function(e) {
                                    return e.parentNode && e.parentNode.removeChild(e)
                                })), Te === Ht && (Te = 0), Ae && (r && (r.uncache = 1), s = 0, bt.forEach((function(e) {
                                    return e.pin === Ae && s++
                                })), s || (r.spacer = 0)), t.onKill && t.onKill(Ht)
                            }, Ht.enable(!1, !1), se && se(Ht), i && i.add && !m ? V.delayedCall(.01, (function() {
                                return l || h || Ht.refresh()
                            })) && (m = .01) && (l = h = 0) : Ht.refresh(), Ae && function() {
                                if (be !== Dt) {
                                    var e = be = Dt;
                                    requestAnimationFrame((function() {
                                        return e === Dt && Ot(!0)
                                    }))
                                }
                            }()
                        } else this.update = this.refresh = this.kill = Le
                    }, e.register = function(t) {
                        return G || (V = t || Re(), Pe() && window.document && e.enable(), G = Me), G
                    }, e.defaults = function(e) {
                        if (e)
                            for (var t in e) mt[t] = e[t];
                        return mt
                    }, e.disable = function(e, t) {
                        Me = 0, bt.forEach((function(i) {
                            return i[t ? "kill" : "disable"](e)
                        })), dt(W, "wheel", wt), dt(j, "scroll", wt), clearInterval(Q), dt(j, "touchcancel", Le), dt($, "touchstart", Le), ct(dt, j, "pointerdown,touchstart,mousedown", Ce), ct(dt, j, "pointerup,touchend,mouseup", Ae), Y.kill(), Ne(dt);
                        for (var i = 0; i < b.length; i += 3) pt(dt, b[i], b[i + 1]), pt(dt, b[i], b[i + 2])
                    }, e.enable = function() {
                        if (W = window, j = document, q = j.documentElement, $ = j.body, V && (K = V.utils.toArray, J = V.utils.clamp, me = V.core.context || Le, le = V.core.suppressOverwrites || Le, ge = W.history.scrollRestoration || "auto", V.core.globals("ScrollTrigger", e), $)) {
                            Me = 1, z.register(V), e.isTouch = z.isTouch, fe = z.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), ut(W, "wheel", wt), X = [W, j, q, $], V.matchMedia ? (e.matchMedia = function(e) {
                                var t, i = V.matchMedia();
                                for (t in e) i.add(t, e[t]);
                                return i
                            }, V.addEventListener("matchMediaInit", (function() {
                                return Rt()
                            })), V.addEventListener("matchMediaRevert", (function() {
                                return Pt()
                            })), V.addEventListener("matchMedia", (function() {
                                Ot(0, 1), Lt("matchMedia")
                            })), V.matchMedia("(orientation: portrait)", (function() {
                                return St(), St
                            }))) : console.warn("Requires GSAP 3.11.0 or later"), St(), ut(j, "scroll", wt);
                            var t, i, n = $.style,
                                r = n.borderTopStyle,
                                s = V.core.Animation.prototype;
                            for (s.revert || Object.defineProperty(s, "revert", {
                                    value: function() {
                                        return this.time(-.01, !0)
                                    }
                                }), n.borderTopStyle = "solid", t = at($), k.m = Math.round(t.top + k.sc()) || 0, R.m = Math.round(t.left + R.sc()) || 0, r ? n.borderTopStyle = r : n.removeProperty("border-top-style"), Q = setInterval(xt, 250), V.delayedCall(.5, (function() {
                                    return xe = 0
                                })), ut(j, "touchcancel", Le), ut($, "touchstart", Le), ct(ut, j, "pointerdown,touchstart,mousedown", Ce), ct(ut, j, "pointerup,touchend,mouseup", Ae), ie = V.utils.checkPrefix("transform"), Ht.push(ie), G = we(), Y = V.delayedCall(.2, Ot).pause(), ae = [j, "visibilitychange", function() {
                                    var e = W.innerWidth,
                                        t = W.innerHeight;
                                    j.hidden ? (re = e, se = t) : re === e && se === t || Et()
                                }, j, "DOMContentLoaded", Ot, W, "load", Ot, W, "resize", Et], Ne(ut), bt.forEach((function(e) {
                                    return e.enable(0, 1)
                                })), i = 0; i < b.length; i += 3) pt(dt, b[i], b[i + 1]), pt(dt, b[i], b[i + 2])
                        }
                    }, e.config = function(t) {
                        "limitCallbacks" in t && (ye = !!t.limitCallbacks);
                        var i = t.syncInterval;
                        i && clearInterval(Q) || (Q = i) && setInterval(xt, i), "ignoreMobileResize" in t && (ue = 1 === e.isTouch && t.ignoreMobileResize), "autoRefreshEvents" in t && (Ne(dt) || Ne(ut, t.autoRefreshEvents || "none"), he = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
                    }, e.scrollerProxy = function(e, t) {
                        var i = D(e),
                            n = b.indexOf(i),
                            r = ke(i);
                        ~n && b.splice(n, r ? 6 : 2), t && (r ? T.unshift(W, t, $, t, q, t) : T.unshift(i, t))
                    }, e.clearMatchMedia = function(e) {
                        bt.forEach((function(t) {
                            return t._ctx && t._ctx.query === e && t._ctx.kill(!0, !0)
                        }))
                    }, e.isInViewport = function(e, t, i) {
                        var n = (Ue(e) ? D(e) : e).getBoundingClientRect(),
                            r = n[i ? $e : Xe] * t || 0;
                        return i ? n.right - r > 0 && n.left + r < W.innerWidth : n.bottom - r > 0 && n.top + r < W.innerHeight
                    }, e.positionInViewport = function(e, t, i) {
                        Ue(e) && (e = D(e));
                        var n = e.getBoundingClientRect(),
                            r = n[i ? $e : Xe],
                            s = null == t ? r / 2 : t in gt ? gt[t] * r : ~t.indexOf("%") ? parseFloat(t) * r / 100 : parseFloat(t) || 0;
                        return i ? (n.left + s) / W.innerWidth : (n.top + s) / W.innerHeight
                    }, e.killAll = function(e) {
                        if (bt.slice(0).forEach((function(e) {
                                return "ScrollSmoother" !== e.vars.id && e.kill()
                            })), !0 !== e) {
                            var t = Mt.killAll || [];
                            Mt = {}, t.forEach((function(e) {
                                return e()
                            }))
                        }
                    }, e
                }();
            Kt.version = "3.11.4", Kt.saveStyles = function(e) {
                return e ? K(e).forEach((function(e) {
                    if (e && e.style) {
                        var t = It.indexOf(e);
                        t >= 0 && It.splice(t, 5), It.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), V.core.getCache(e), me())
                    }
                })) : It
            }, Kt.revert = function(e, t) {
                return Rt(!e, t)
            }, Kt.create = function(e, t) {
                return new Kt(e, t)
            }, Kt.refresh = function(e) {
                return e ? Et() : (G || Kt.register()) && Ot(!0)
            }, Kt.update = function(e) {
                return ++b.cache && Bt(!0 === e ? 2 : 0)
            }, Kt.clearScrollMemory = kt, Kt.maxScroll = function(e, t) {
                return Oe(e, t ? R : k)
            }, Kt.getScrollFunc = function(e, t) {
                return O(D(e), t ? R : k)
            }, Kt.getById = function(e) {
                return Tt[e]
            }, Kt.getAll = function() {
                return bt.filter((function(e) {
                    return "ScrollSmoother" !== e.vars.id
                }))
            }, Kt.isScrolling = function() {
                return !!Ee
            }, Kt.snapDirectional = ht, Kt.addEventListener = function(e, t) {
                var i = Mt[e] || (Mt[e] = []);
                ~i.indexOf(t) || i.push(t)
            }, Kt.removeEventListener = function(e, t) {
                var i = Mt[e],
                    n = i && i.indexOf(t);
                n >= 0 && i.splice(n, 1)
            }, Kt.batch = function(e, t) {
                var i, n = [],
                    r = {},
                    s = t.interval || .016,
                    a = t.batchMax || 1e9,
                    o = function(e, t) {
                        var i = [],
                            n = [],
                            r = V.delayedCall(s, (function() {
                                t(i, n), i = [], n = []
                            })).pause();
                        return function(e) {
                            i.length || r.restart(!0), i.push(e.trigger), n.push(e), a <= i.length && r.progress(1)
                        }
                    };
                for (i in t) r[i] = "on" === i.substr(0, 2) && Be(t[i]) && "onRefreshInit" !== i ? o(0, t[i]) : t[i];
                return Be(a) && (a = a(), ut(Kt, "refresh", (function() {
                    return a = t.batchMax()
                }))), K(e).forEach((function(e) {
                    var t = {};
                    for (i in r) t[i] = r[i];
                    t.trigger = e, n.push(Kt.create(t))
                })), n
            };
            var Jt, Zt = function(e, t, i, n) {
                    return t > n ? e(n) : t < 0 && e(0), i > n ? (n - t) / (i - t) : i < 0 ? t / (t - i) : 1
                },
                Qt = function e(t, i) {
                    !0 === i ? t.style.removeProperty("touch-action") : t.style.touchAction = !0 === i ? "auto" : i ? "pan-" + i + (z.isTouch ? " pinch-zoom" : "") : "none", t === q && e($, i)
                },
                ei = {
                    auto: 1,
                    scroll: 1
                },
                ti = function(e) {
                    var t, i = e.event,
                        n = e.target,
                        r = e.axis,
                        s = (i.changedTouches ? i.changedTouches[0] : i).target,
                        a = s._gsap || V.core.getCache(s),
                        o = we();
                    if (!a._isScrollT || o - a._isScrollT > 2e3) {
                        for (; s && s !== $ && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !ei[(t = rt(s)).overflowY] && !ei[t.overflowX]);) s = s.parentNode;
                        a._isScroll = s && s !== n && !ke(s) && (ei[(t = rt(s)).overflowY] || ei[t.overflowX]), a._isScrollT = o
                    }(a._isScroll || "x" === r) && (i.stopPropagation(), i._gsapAllow = !0)
                },
                ii = function(e, t, i, n) {
                    return z.create({
                        target: e,
                        capture: !0,
                        debounce: !1,
                        lockAxis: !0,
                        type: t,
                        onWheel: n = n && ti,
                        onPress: n,
                        onDrag: n,
                        onScroll: n,
                        onEnable: function() {
                            return i && ut(j, z.eventTypes[0], ri, !1, !0)
                        },
                        onDisable: function() {
                            return dt(j, z.eventTypes[0], ri, !0)
                        }
                    })
                },
                ni = /(input|label|select|textarea)/i,
                ri = function(e) {
                    var t = ni.test(e.target.tagName);
                    (t || Jt) && (e._gsapAllow = !0, Jt = t)
                },
                si = function(e) {
                    He(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
                    var t, i, n, r, s, a, o, l, h = e,
                        c = h.normalizeScrollX,
                        u = h.momentum,
                        d = h.allowNestedScroll,
                        p = D(e.target) || q,
                        f = V.core.globals().ScrollSmoother,
                        m = f && f.get(),
                        g = fe && (e.content && D(e.content) || m && !1 !== e.content && !m.smooth() && m.content()),
                        y = O(p, k),
                        _ = O(p, R),
                        v = 1,
                        T = (z.isTouch && W.visualViewport ? W.visualViewport.scale * W.visualViewport.width : W.outerWidth) / W.innerWidth,
                        x = 0,
                        w = Be(u) ? function() {
                            return u(t)
                        } : function() {
                            return u || 2.8
                        },
                        S = ii(p, e.type, !0, d),
                        E = function() {
                            return r = !1
                        },
                        M = Le,
                        C = Le,
                        A = function() {
                            i = Oe(p, k), C = J(fe ? 1 : 0, i), c && (M = J(0, Oe(p, R))), n = Dt
                        },
                        L = function() {
                            g._gsap.y = Ie(parseFloat(g._gsap.y) + y.offset) + "px", g.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(g._gsap.y) + ", 0, 1)", y.offset = y.cacheID = 0
                        },
                        I = function() {
                            A(), s.isActive() && s.vars.scrollY > i && (y() > i ? s.progress(1) && y(i) : s.resetTo("scrollY", i))
                        };
                    return g && V.set(g, {
                        y: "+=0"
                    }), e.ignoreCheck = function(e) {
                        return fe && "touchmove" === e.type && function() {
                            if (r) {
                                requestAnimationFrame(E);
                                var e = Ie(t.deltaY / 2),
                                    i = C(y.v - e);
                                if (g && i !== y.v + y.offset) {
                                    y.offset = i - y.v;
                                    var n = Ie((parseFloat(g && g._gsap.y) || 0) - y.offset);
                                    g.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + n + ", 0, 1)", g._gsap.y = n + "px", y.cacheID = b.cache, Bt()
                                }
                                return !0
                            }
                            y.offset && L(), r = !0
                        }() || v > 1.05 && "touchstart" !== e.type || t.isGesturing || e.touches && e.touches.length > 1
                    }, e.onPress = function() {
                        var e = v;
                        v = Ie((W.visualViewport && W.visualViewport.scale || 1) / T), s.pause(), e !== v && Qt(p, v > 1.01 || !c && "x"), a = _(), o = y(), A(), n = Dt
                    }, e.onRelease = e.onGestureStart = function(e, t) {
                        if (y.offset && L(), t) {
                            b.cache++;
                            var n, r, a = w();
                            c && (r = (n = _()) + .05 * a * -e.velocityX / .227, a *= Zt(_, n, r, Oe(p, R)), s.vars.scrollX = M(r)), r = (n = y()) + .05 * a * -e.velocityY / .227, a *= Zt(y, n, r, Oe(p, k)), s.vars.scrollY = C(r), s.invalidate().duration(a).play(.01), (fe && s.vars.scrollY >= i || n >= i - 1) && V.to({}, {
                                onUpdate: I,
                                duration: a
                            })
                        } else l.restart(!0)
                    }, e.onWheel = function() {
                        s._ts && s.pause(), we() - x > 1e3 && (n = 0, x = we())
                    }, e.onChange = function(e, t, i, r, s) {
                        if (Dt !== n && A(), t && c && _(M(r[2] === t ? a + (e.startX - e.x) : _() + t - r[1])), i) {
                            y.offset && L();
                            var l = s[2] === i,
                                h = l ? o + e.startY - e.y : y() + i - s[1],
                                u = C(h);
                            l && h !== u && (o += u - h), y(u)
                        }(i || t) && Bt()
                    }, e.onEnable = function() {
                        Qt(p, !c && "x"), Kt.addEventListener("refresh", I), ut(W, "resize", I), y.smooth && (y.target.style.scrollBehavior = "auto", y.smooth = _.smooth = !1), S.enable()
                    }, e.onDisable = function() {
                        Qt(p, !0), dt(W, "resize", I), Kt.removeEventListener("refresh", I), S.kill()
                    }, e.lockAxis = !1 !== e.lockAxis, (t = new z(e)).iOS = fe, fe && !y() && y(1), fe && V.ticker.add(Le), l = t._dc, s = V.to(t, {
                        ease: "power4",
                        paused: !0,
                        scrollX: c ? "+=0.1" : "+=0",
                        scrollY: "+=0.1",
                        onComplete: l.vars.onComplete
                    }), t
                };
            Kt.sort = function(e) {
                return bt.sort(e || function(e, t) {
                    return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0))
                })
            }, Kt.observe = function(e) {
                return new z(e)
            }, Kt.normalizeScroll = function(e) {
                if (void 0 === e) return ce;
                if (!0 === e && ce) return ce.enable();
                if (!1 === e) return ce && ce.kill();
                var t = e instanceof z ? e : si(e);
                return ce && ce.target === t.target && ce.kill(), ke(t.target) && (ce = t), t
            }, Kt.core = {
                _getVelocityProp: N,
                _inputObserver: ii,
                _scrollers: b,
                _proxies: T,
                bridge: {
                    ss: function() {
                        Ee || Lt("scrollStart"), Ee = we()
                    },
                    ref: function() {
                        return ee
                    }
                }
            }, Re() && V.registerPlugin(Kt)
        },
        7043: (e, t, i) => {
            "use strict";

            function n(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function r(e, t) {
                e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
            }
            i.d(t, {
                p8: () => $n
            });
            var s, a, o, l, h, c, u, d, p, f, m, g, y, _, v, b = {
                    autoSleep: 120,
                    force3D: "auto",
                    nullTargetWarn: 1,
                    units: {
                        lineHeight: ""
                    }
                },
                T = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                x = 1e8,
                w = 1 / x,
                S = 2 * Math.PI,
                E = S / 4,
                M = 0,
                C = Math.sqrt,
                A = Math.cos,
                L = Math.sin,
                I = function(e) {
                    return "string" == typeof e
                },
                P = function(e) {
                    return "function" == typeof e
                },
                R = function(e) {
                    return "number" == typeof e
                },
                k = function(e) {
                    return void 0 === e
                },
                D = function(e) {
                    return "object" == typeof e
                },
                O = function(e) {
                    return !1 !== e
                },
                N = function() {
                    return "undefined" != typeof window
                },
                U = function(e) {
                    return P(e) || I(e)
                },
                B = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
                F = Array.isArray,
                H = /(?:-?\.?\d|\.)+/gi,
                z = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
                V = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                G = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
                W = /[+-]=-?[.\d]+/,
                j = /[^,'"\[\]\s]+/gi,
                q = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
                $ = {},
                X = {},
                Y = function(e) {
                    return (X = Se(e, $)) && Si
                },
                K = function(e, t) {
                    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
                },
                J = function(e, t) {
                    return !t && console.warn(e)
                },
                Z = function(e, t) {
                    return e && ($[e] = t) && X && (X[e] = t) || $
                },
                Q = function() {
                    return 0
                },
                ee = {
                    suppressEvents: !0,
                    isStart: !0,
                    kill: !1
                },
                te = {
                    suppressEvents: !0,
                    kill: !1
                },
                ie = {
                    suppressEvents: !0
                },
                ne = {},
                re = [],
                se = {},
                ae = {},
                oe = {},
                le = 30,
                he = [],
                ce = "",
                ue = function(e) {
                    var t, i, n = e[0];
                    if (D(n) || P(n) || (e = [e]), !(t = (n._gsap || {}).harness)) {
                        for (i = he.length; i-- && !he[i].targetTest(n););
                        t = he[i]
                    }
                    for (i = e.length; i--;) e[i] && (e[i]._gsap || (e[i]._gsap = new Ft(e[i], t))) || e.splice(i, 1);
                    return e
                },
                de = function(e) {
                    return e._gsap || ue(nt(e))[0]._gsap
                },
                pe = function(e, t, i) {
                    return (i = e[t]) && P(i) ? e[t]() : k(i) && e.getAttribute && e.getAttribute(t) || i
                },
                fe = function(e, t) {
                    return (e = e.split(",")).forEach(t) || e
                },
                me = function(e) {
                    return Math.round(1e5 * e) / 1e5 || 0
                },
                ge = function(e) {
                    return Math.round(1e7 * e) / 1e7 || 0
                },
                ye = function(e, t) {
                    var i = t.charAt(0),
                        n = parseFloat(t.substr(2));
                    return e = parseFloat(e), "+" === i ? e + n : "-" === i ? e - n : "*" === i ? e * n : e / n
                },
                _e = function(e, t) {
                    for (var i = t.length, n = 0; e.indexOf(t[n]) < 0 && ++n < i;);
                    return n < i
                },
                ve = function() {
                    var e, t, i = re.length,
                        n = re.slice(0);
                    for (se = {}, re.length = 0, e = 0; e < i; e++)(t = n[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
                },
                be = function(e, t, i, n) {
                    re.length && !a && ve(), e.render(t, i, n || a && t < 0 && (e._initted || e._startAt)), re.length && !a && ve()
                },
                Te = function(e) {
                    var t = parseFloat(e);
                    return (t || 0 === t) && (e + "").match(j).length < 2 ? t : I(e) ? e.trim() : e
                },
                xe = function(e) {
                    return e
                },
                we = function(e, t) {
                    for (var i in t) i in e || (e[i] = t[i]);
                    return e
                },
                Se = function(e, t) {
                    for (var i in t) e[i] = t[i];
                    return e
                },
                Ee = function e(t, i) {
                    for (var n in i) "__proto__" !== n && "constructor" !== n && "prototype" !== n && (t[n] = D(i[n]) ? e(t[n] || (t[n] = {}), i[n]) : i[n]);
                    return t
                },
                Me = function(e, t) {
                    var i, n = {};
                    for (i in e) i in t || (n[i] = e[i]);
                    return n
                },
                Ce = function(e) {
                    var t, i = e.parent || l,
                        n = e.keyframes ? (t = F(e.keyframes), function(e, i) {
                            for (var n in i) n in e || "duration" === n && t || "ease" === n || (e[n] = i[n])
                        }) : we;
                    if (O(e.inherit))
                        for (; i;) n(e, i.vars.defaults), i = i.parent || i._dp;
                    return e
                },
                Ae = function(e, t, i, n, r) {
                    void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                    var s, a = e[n];
                    if (r)
                        for (s = t[r]; a && a[r] > s;) a = a._prev;
                    return a ? (t._next = a._next, a._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[n] = t, t._prev = a, t.parent = t._dp = e, t
                },
                Le = function(e, t, i, n) {
                    void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                    var r = t._prev,
                        s = t._next;
                    r ? r._next = s : e[i] === t && (e[i] = s), s ? s._prev = r : e[n] === t && (e[n] = r), t._next = t._prev = t.parent = null
                },
                Ie = function(e, t) {
                    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e), e._act = 0
                },
                Pe = function(e, t) {
                    if (e && (!t || t._end > e._dur || t._start < 0))
                        for (var i = e; i;) i._dirty = 1, i = i.parent;
                    return e
                },
                Re = function(e) {
                    for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
                    return e
                },
                ke = function(e, t, i, n) {
                    return e._startAt && (a ? e._startAt.revert(te) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, n))
                },
                De = function e(t) {
                    return !t || t._ts && e(t.parent)
                },
                Oe = function(e) {
                    return e._repeat ? Ne(e._tTime, e = e.duration() + e._rDelay) * e : 0
                },
                Ne = function(e, t) {
                    var i = Math.floor(e /= t);
                    return e && i === e ? i - 1 : i
                },
                Ue = function(e, t) {
                    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
                },
                Be = function(e) {
                    return e._end = ge(e._start + (e._tDur / Math.abs(e._ts || e._rts || w) || 0))
                },
                Fe = function(e, t) {
                    var i = e._dp;
                    return i && i.smoothChildTiming && e._ts && (e._start = ge(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Be(e), i._dirty || Pe(i, e)), e
                },
                He = function(e, t) {
                    var i;
                    if ((t._time || t._initted && !t._dur) && (i = Ue(e.rawTime(), t), (!t._dur || Ze(0, t.totalDuration(), i) - t._tTime > w) && t.render(i, !0)), Pe(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                        if (e._dur < e.duration())
                            for (i = e; i._dp;) i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
                        e._zTime = -w
                    }
                },
                ze = function(e, t, i, n) {
                    return t.parent && Ie(t), t._start = ge((R(i) ? i : i || e !== l ? Ye(e, i, t) : e._time) + t._delay), t._end = ge(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), Ae(e, t, "_first", "_last", e._sort ? "_start" : 0), je(t) || (e._recent = t), n || He(e, t), e._ts < 0 && Fe(e, e._tTime), e
                },
                Ve = function(e, t) {
                    return ($.ScrollTrigger || K("scrollTrigger", t)) && $.ScrollTrigger.create(t, e)
                },
                Ge = function(e, t, i, n, r) {
                    return $t(e, t, r), e._initted ? !i && e._pt && !a && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && p !== Mt.frame ? (re.push(e), e._lazy = [r, n], 1) : void 0 : 1
                },
                We = function e(t) {
                    var i = t.parent;
                    return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || e(i))
                },
                je = function(e) {
                    var t = e.data;
                    return "isFromStart" === t || "isStart" === t
                },
                qe = function(e, t, i, n) {
                    var r = e._repeat,
                        s = ge(t) || 0,
                        a = e._tTime / e._tDur;
                    return a && !n && (e._time *= s / e._dur), e._dur = s, e._tDur = r ? r < 0 ? 1e10 : ge(s * (r + 1) + e._rDelay * r) : s, a > 0 && !n && Fe(e, e._tTime = e._tDur * a), e.parent && Be(e), i || Pe(e.parent, e), e
                },
                $e = function(e) {
                    return e instanceof zt ? Pe(e) : qe(e, e._dur)
                },
                Xe = {
                    _start: 0,
                    endTime: Q,
                    totalDuration: Q
                },
                Ye = function e(t, i, n) {
                    var r, s, a, o = t.labels,
                        l = t._recent || Xe,
                        h = t.duration() >= x ? l.endTime(!1) : t._dur;
                    return I(i) && (isNaN(i) || i in o) ? (s = i.charAt(0), a = "%" === i.substr(-1), r = i.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (i = i.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(i.substr(1)) || 0) * (a ? (r < 0 ? l : n).totalDuration() / 100 : 1)) : r < 0 ? (i in o || (o[i] = h), o[i]) : (s = parseFloat(i.charAt(r - 1) + i.substr(r + 1)), a && n && (s = s / 100 * (F(n) ? n[0] : n).totalDuration()), r > 1 ? e(t, i.substr(0, r - 1), n) + s : h + s)) : null == i ? h : +i
                },
                Ke = function(e, t, i) {
                    var n, r, s = R(t[1]),
                        a = (s ? 2 : 1) + (e < 2 ? 0 : 1),
                        o = t[a];
                    if (s && (o.duration = t[1]), o.parent = i, e) {
                        for (n = o, r = i; r && !("immediateRender" in n);) n = r.vars.defaults || {}, r = O(r.vars.inherit) && r.parent;
                        o.immediateRender = O(n.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[a - 1]
                    }
                    return new Zt(t[0], o, t[a + 1])
                },
                Je = function(e, t) {
                    return e || 0 === e ? t(e) : t
                },
                Ze = function(e, t, i) {
                    return i < e ? e : i > t ? t : i
                },
                Qe = function(e, t) {
                    return I(e) && (t = q.exec(e)) ? t[1] : ""
                },
                et = [].slice,
                tt = function(e, t) {
                    return e && D(e) && "length" in e && (!t && !e.length || e.length - 1 in e && D(e[0])) && !e.nodeType && e !== h
                },
                it = function(e, t, i) {
                    return void 0 === i && (i = []), e.forEach((function(e) {
                        var n;
                        return I(e) && !t || tt(e, 1) ? (n = i).push.apply(n, nt(e)) : i.push(e)
                    })) || i
                },
                nt = function(e, t, i) {
                    return o && !t && o.selector ? o.selector(e) : !I(e) || i || !c && Ct() ? F(e) ? it(e, i) : tt(e) ? et.call(e, 0) : e ? [e] : [] : et.call((t || u).querySelectorAll(e), 0)
                },
                rt = function(e) {
                    return e = nt(e)[0] || J("Invalid scope") || {},
                        function(t) {
                            var i = e.current || e.nativeElement || e;
                            return nt(t, i.querySelectorAll ? i : i === e ? J("Invalid scope") || u.createElement("div") : e)
                        }
                },
                st = function(e) {
                    return e.sort((function() {
                        return .5 - Math.random()
                    }))
                },
                at = function(e) {
                    if (P(e)) return e;
                    var t = D(e) ? e : {
                            each: e
                        },
                        i = Dt(t.ease),
                        n = t.from || 0,
                        r = parseFloat(t.base) || 0,
                        s = {},
                        a = n > 0 && n < 1,
                        o = isNaN(n) || a,
                        l = t.axis,
                        h = n,
                        c = n;
                    return I(n) ? h = c = {
                            center: .5,
                            edges: .5,
                            end: 1
                        }[n] || 0 : !a && o && (h = n[0], c = n[1]),
                        function(e, a, u) {
                            var d, p, f, m, g, y, _, v, b, T = (u || t).length,
                                w = s[T];
                            if (!w) {
                                if (!(b = "auto" === t.grid ? 0 : (t.grid || [1, x])[1])) {
                                    for (_ = -x; _ < (_ = u[b++].getBoundingClientRect().left) && b < T;);
                                    b--
                                }
                                for (w = s[T] = [], d = o ? Math.min(b, T) * h - .5 : n % b, p = b === x ? 0 : o ? T * c / b - .5 : n / b | 0, _ = 0, v = x, y = 0; y < T; y++) f = y % b - d, m = p - (y / b | 0), w[y] = g = l ? Math.abs("y" === l ? m : f) : C(f * f + m * m), g > _ && (_ = g), g < v && (v = g);
                                "random" === n && st(w), w.max = _ - v, w.min = v, w.v = T = (parseFloat(t.amount) || parseFloat(t.each) * (b > T ? T - 1 : l ? "y" === l ? T / b : b : Math.max(b, T / b)) || 0) * ("edges" === n ? -1 : 1), w.b = T < 0 ? r - T : r, w.u = Qe(t.amount || t.each) || 0, i = i && T < 0 ? Rt(i) : i
                            }
                            return T = (w[e] - w.min) / w.max || 0, ge(w.b + (i ? i(T) : T) * w.v) + w.u
                        }
                },
                ot = function(e) {
                    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
                    return function(i) {
                        var n = ge(Math.round(parseFloat(i) / e) * e * t);
                        return (n - n % 1) / t + (R(i) ? 0 : Qe(i))
                    }
                },
                lt = function(e, t) {
                    var i, n, r = F(e);
                    return !r && D(e) && (i = r = e.radius || x, e.values ? (e = nt(e.values), (n = !R(e[0])) && (i *= i)) : e = ot(e.increment)), Je(t, r ? P(e) ? function(t) {
                        return n = e(t), Math.abs(n - t) <= i ? n : t
                    } : function(t) {
                        for (var r, s, a = parseFloat(n ? t.x : t), o = parseFloat(n ? t.y : 0), l = x, h = 0, c = e.length; c--;)(r = n ? (r = e[c].x - a) * r + (s = e[c].y - o) * s : Math.abs(e[c] - a)) < l && (l = r, h = c);
                        return h = !i || l <= i ? e[h] : t, n || h === t || R(t) ? h : h + Qe(t)
                    } : ot(e))
                },
                ht = function(e, t, i, n) {
                    return Je(F(e) ? !t : !0 === i ? !!(i = 0) : !n, (function() {
                        return F(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + .99 * i)) / i) * i * n) / n
                    }))
                },
                ct = function(e, t, i) {
                    return Je(i, (function(i) {
                        return e[~~t(i)]
                    }))
                },
                ut = function(e) {
                    for (var t, i, n, r, s = 0, a = ""; ~(t = e.indexOf("random(", s));) n = e.indexOf(")", t), r = "[" === e.charAt(t + 7), i = e.substr(t + 7, n - t - 7).match(r ? j : H), a += e.substr(s, t - s) + ht(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5), s = n + 1;
                    return a + e.substr(s, e.length - s)
                },
                dt = function(e, t, i, n, r) {
                    var s = t - e,
                        a = n - i;
                    return Je(r, (function(t) {
                        return i + ((t - e) / s * a || 0)
                    }))
                },
                pt = function(e, t, i) {
                    var n, r, s, a = e.labels,
                        o = x;
                    for (n in a)(r = a[n] - t) < 0 == !!i && r && o > (r = Math.abs(r)) && (s = n, o = r);
                    return s
                },
                ft = function(e, t, i) {
                    var n, r, s, a = e.vars,
                        l = a[t],
                        h = o,
                        c = e._ctx;
                    if (l) return n = a[t + "Params"], r = a.callbackScope || e, i && re.length && ve(), c && (o = c), s = n ? l.apply(r, n) : l.call(r), o = h, s
                },
                mt = function(e) {
                    return Ie(e), e.scrollTrigger && e.scrollTrigger.kill(!!a), e.progress() < 1 && ft(e, "onInterrupt"), e
                },
                gt = function(e) {
                    var t = (e = !e.name && e.default || e).name,
                        i = P(e),
                        n = t && !i && e.init ? function() {
                            this._props = []
                        } : e,
                        r = {
                            init: Q,
                            render: oi,
                            add: jt,
                            kill: hi,
                            modifier: li,
                            rawVars: 0
                        },
                        s = {
                            targetTest: 0,
                            get: 0,
                            getSetter: ni,
                            aliases: {},
                            register: 0
                        };
                    if (Ct(), e !== n) {
                        if (ae[t]) return;
                        we(n, we(Me(e, r), s)), Se(n.prototype, Se(r, Me(e, s))), ae[n.prop = t] = n, e.targetTest && (he.push(n), ne[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                    }
                    Z(t, n), e.register && e.register(Si, n, di)
                },
                yt = 255,
                _t = {
                    aqua: [0, yt, yt],
                    lime: [0, yt, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, yt],
                    navy: [0, 0, 128],
                    white: [yt, yt, yt],
                    olive: [128, 128, 0],
                    yellow: [yt, yt, 0],
                    orange: [yt, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [yt, 0, 0],
                    pink: [yt, 192, 203],
                    cyan: [0, yt, yt],
                    transparent: [yt, yt, yt, 0]
                },
                vt = function(e, t, i) {
                    return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (i - t) * e * 6 : e < .5 ? i : 3 * e < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * yt + .5 | 0
                },
                bt = function(e, t, i) {
                    var n, r, s, a, o, l, h, c, u, d, p = e ? R(e) ? [e >> 16, e >> 8 & yt, e & yt] : 0 : _t.black;
                    if (!p) {
                        if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), _t[e]) p = _t[e];
                        else if ("#" === e.charAt(0)) {
                            if (e.length < 6 && (n = e.charAt(1), r = e.charAt(2), s = e.charAt(3), e = "#" + n + n + r + r + s + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & yt, p & yt, parseInt(e.substr(7), 16) / 255];
                            p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & yt, e & yt]
                        } else if ("hsl" === e.substr(0, 3))
                            if (p = d = e.match(H), t) {
                                if (~e.indexOf("=")) return p = e.match(z), i && p.length < 4 && (p[3] = 1), p
                            } else a = +p[0] % 360 / 360, o = +p[1] / 100, n = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), p.length > 3 && (p[3] *= 1), p[0] = vt(a + 1 / 3, n, r), p[1] = vt(a, n, r), p[2] = vt(a - 1 / 3, n, r);
                        else p = e.match(H) || _t.transparent;
                        p = p.map(Number)
                    }
                    return t && !d && (n = p[0] / yt, r = p[1] / yt, s = p[2] / yt, l = ((h = Math.max(n, r, s)) + (c = Math.min(n, r, s))) / 2, h === c ? a = o = 0 : (u = h - c, o = l > .5 ? u / (2 - h - c) : u / (h + c), a = h === n ? (r - s) / u + (r < s ? 6 : 0) : h === r ? (s - n) / u + 2 : (n - r) / u + 4, a *= 60), p[0] = ~~(a + .5), p[1] = ~~(100 * o + .5), p[2] = ~~(100 * l + .5)), i && p.length < 4 && (p[3] = 1), p
                },
                Tt = function(e) {
                    var t = [],
                        i = [],
                        n = -1;
                    return e.split(wt).forEach((function(e) {
                        var r = e.match(V) || [];
                        t.push.apply(t, r), i.push(n += r.length + 1)
                    })), t.c = i, t
                },
                xt = function(e, t, i) {
                    var n, r, s, a, o = "",
                        l = (e + o).match(wt),
                        h = t ? "hsla(" : "rgba(",
                        c = 0;
                    if (!l) return e;
                    if (l = l.map((function(e) {
                            return (e = bt(e, t, 1)) && h + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
                        })), i && (s = Tt(e), (n = i.c).join(o) !== s.c.join(o)))
                        for (a = (r = e.replace(wt, "1").split(V)).length - 1; c < a; c++) o += r[c] + (~n.indexOf(c) ? l.shift() || h + "0,0,0,0)" : (s.length ? s : l.length ? l : i).shift());
                    if (!r)
                        for (a = (r = e.split(wt)).length - 1; c < a; c++) o += r[c] + l[c];
                    return o + r[a]
                },
                wt = function() {
                    var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                    for (e in _t) t += "|" + e + "\\b";
                    return new RegExp(t + ")", "gi")
                }(),
                St = /hsl[a]?\(/,
                Et = function(e) {
                    var t, i = e.join(" ");
                    if (wt.lastIndex = 0, wt.test(i)) return t = St.test(i), e[1] = xt(e[1], t), e[0] = xt(e[0], t, Tt(e[1])), !0
                },
                Mt = function() {
                    var e, t, i, n, r, s, a = Date.now,
                        o = 500,
                        l = 33,
                        p = a(),
                        f = p,
                        g = 1e3 / 240,
                        y = g,
                        _ = [],
                        v = function i(h) {
                            var c, u, d, m, v = a() - f,
                                b = !0 === h;
                            if (v > o && (p += v - l), ((c = (d = (f += v) - p) - y) > 0 || b) && (m = ++n.frame, r = d - 1e3 * n.time, n.time = d /= 1e3, y += c + (c >= g ? 4 : g - c), u = 1), b || (e = t(i)), u)
                                for (s = 0; s < _.length; s++) _[s](d, r, m, h)
                        };
                    return n = {
                        time: 0,
                        frame: 0,
                        tick: function() {
                            v(!0)
                        },
                        deltaRatio: function(e) {
                            return r / (1e3 / (e || 60))
                        },
                        wake: function() {
                            d && (!c && N() && (h = c = window, u = h.document || {}, $.gsap = Si, (h.gsapVersions || (h.gsapVersions = [])).push(Si.version), Y(X || h.GreenSockGlobals || !h.gsap && h || {}), i = h.requestAnimationFrame), e && n.sleep(), t = i || function(e) {
                                return setTimeout(e, y - 1e3 * n.time + 1 | 0)
                            }, m = 1, v(2))
                        },
                        sleep: function() {
                            (i ? h.cancelAnimationFrame : clearTimeout)(e), m = 0, t = Q
                        },
                        lagSmoothing: function(e, t) {
                            o = e || 1 / 0, l = Math.min(t || 33, o)
                        },
                        fps: function(e) {
                            g = 1e3 / (e || 240), y = 1e3 * n.time + g
                        },
                        add: function(e, t, i) {
                            var r = t ? function(t, i, s, a) {
                                e(t, i, s, a), n.remove(r)
                            } : e;
                            return n.remove(e), _[i ? "unshift" : "push"](r), Ct(), r
                        },
                        remove: function(e, t) {
                            ~(t = _.indexOf(e)) && _.splice(t, 1) && s >= t && s--
                        },
                        _listeners: _
                    }
                }(),
                Ct = function() {
                    return !m && Mt.wake()
                },
                At = {},
                Lt = /^[\d.\-M][\d.\-,\s]/,
                It = /["']/g,
                Pt = function(e) {
                    for (var t, i, n, r = {}, s = e.substr(1, e.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++) i = s[o], t = o !== l - 1 ? i.lastIndexOf(",") : i.length, n = i.substr(0, t), r[a] = isNaN(n) ? n.replace(It, "").trim() : +n, a = i.substr(t + 1).trim();
                    return r
                },
                Rt = function(e) {
                    return function(t) {
                        return 1 - e(1 - t)
                    }
                },
                kt = function e(t, i) {
                    for (var n, r = t._first; r;) r instanceof zt ? e(r, i) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === i || (r.timeline ? e(r.timeline, i) : (n = r._ease, r._ease = r._yEase, r._yEase = n, r._yoyo = i)), r = r._next
                },
                Dt = function(e, t) {
                    return e && (P(e) ? e : At[e] || function(e) {
                        var t, i, n, r, s = (e + "").split("("),
                            a = At[s[0]];
                        return a && s.length > 1 && a.config ? a.config.apply(null, ~e.indexOf("{") ? [Pt(s[1])] : (t = e, i = t.indexOf("(") + 1, n = t.indexOf(")"), r = t.indexOf("(", i), t.substring(i, ~r && r < n ? t.indexOf(")", n + 1) : n)).split(",").map(Te)) : At._CE && Lt.test(e) ? At._CE("", e) : a
                    }(e)) || t
                },
                Ot = function(e, t, i, n) {
                    void 0 === i && (i = function(e) {
                        return 1 - t(1 - e)
                    }), void 0 === n && (n = function(e) {
                        return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
                    });
                    var r, s = {
                        easeIn: t,
                        easeOut: i,
                        easeInOut: n
                    };
                    return fe(e, (function(e) {
                        for (var t in At[e] = $[e] = s, At[r = e.toLowerCase()] = i, s) At[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = At[e + "." + t] = s[t]
                    })), s
                },
                Nt = function(e) {
                    return function(t) {
                        return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
                    }
                },
                Ut = function e(t, i, n) {
                    var r = i >= 1 ? i : 1,
                        s = (n || (t ? .3 : .45)) / (i < 1 ? i : 1),
                        a = s / S * (Math.asin(1 / r) || 0),
                        o = function(e) {
                            return 1 === e ? 1 : r * Math.pow(2, -10 * e) * L((e - a) * s) + 1
                        },
                        l = "out" === t ? o : "in" === t ? function(e) {
                            return 1 - o(1 - e)
                        } : Nt(o);
                    return s = S / s, l.config = function(i, n) {
                        return e(t, i, n)
                    }, l
                },
                Bt = function e(t, i) {
                    void 0 === i && (i = 1.70158);
                    var n = function(e) {
                            return e ? --e * e * ((i + 1) * e + i) + 1 : 0
                        },
                        r = "out" === t ? n : "in" === t ? function(e) {
                            return 1 - n(1 - e)
                        } : Nt(n);
                    return r.config = function(i) {
                        return e(t, i)
                    }, r
                };
            fe("Linear,Quad,Cubic,Quart,Quint,Strong", (function(e, t) {
                var i = t < 5 ? t + 1 : t;
                Ot(e + ",Power" + (i - 1), t ? function(e) {
                    return Math.pow(e, i)
                } : function(e) {
                    return e
                }, (function(e) {
                    return 1 - Math.pow(1 - e, i)
                }), (function(e) {
                    return e < .5 ? Math.pow(2 * e, i) / 2 : 1 - Math.pow(2 * (1 - e), i) / 2
                }))
            })), At.Linear.easeNone = At.none = At.Linear.easeIn, Ot("Elastic", Ut("in"), Ut("out"), Ut()), g = 7.5625, _ = 1 / (y = 2.75), Ot("Bounce", (function(e) {
                return 1 - v(1 - e)
            }), v = function(e) {
                return e < _ ? g * e * e : e < .7272727272727273 ? g * Math.pow(e - 1.5 / y, 2) + .75 : e < .9090909090909092 ? g * (e -= 2.25 / y) * e + .9375 : g * Math.pow(e - 2.625 / y, 2) + .984375
            }), Ot("Expo", (function(e) {
                return e ? Math.pow(2, 10 * (e - 1)) : 0
            })), Ot("Circ", (function(e) {
                return -(C(1 - e * e) - 1)
            })), Ot("Sine", (function(e) {
                return 1 === e ? 1 : 1 - A(e * E)
            })), Ot("Back", Bt("in"), Bt("out"), Bt()), At.SteppedEase = At.steps = $.SteppedEase = {
                config: function(e, t) {
                    void 0 === e && (e = 1);
                    var i = 1 / e,
                        n = e + (t ? 0 : 1),
                        r = t ? 1 : 0,
                        s = 1 - w;
                    return function(e) {
                        return ((n * Ze(0, s, e) | 0) + r) * i
                    }
                }
            }, T.ease = At["quad.out"], fe("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(e) {
                return ce += e + "," + e + "Params,"
            }));
            var Ft = function(e, t) {
                    this.id = M++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : pe, this.set = t ? t.getSetter : ni
                },
                Ht = function() {
                    function e(e) {
                        this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, qe(this, +e.duration, 1, 1), this.data = e.data, o && (this._ctx = o, o.data.push(this)), m || Mt.wake()
                    }
                    var t = e.prototype;
                    return t.delay = function(e) {
                        return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay
                    }, t.duration = function(e) {
                        return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
                    }, t.totalDuration = function(e) {
                        return arguments.length ? (this._dirty = 0, qe(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                    }, t.totalTime = function(e, t) {
                        if (Ct(), !arguments.length) return this._tTime;
                        var i = this._dp;
                        if (i && i.smoothChildTiming && this._ts) {
                            for (Fe(this, e), !i._dp || i.parent || He(i, this); i && i.parent;) i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent;
                            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && ze(this._dp, this, this._start - this._delay)
                        }
                        return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === w || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), be(this, e, t)), this
                    }, t.time = function(e, t) {
                        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + Oe(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
                    }, t.totalProgress = function(e, t) {
                        return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                    }, t.progress = function(e, t) {
                        return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + Oe(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                    }, t.iteration = function(e, t) {
                        var i = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (e - 1) * i, t) : this._repeat ? Ne(this._tTime, i) + 1 : 1
                    }, t.timeScale = function(e) {
                        if (!arguments.length) return this._rts === -w ? 0 : this._rts;
                        if (this._rts === e) return this;
                        var t = this.parent && this._ts ? Ue(this.parent._time, this) : this._tTime;
                        return this._rts = +e || 0, this._ts = this._ps || e === -w ? 0 : this._rts, this.totalTime(Ze(-this._delay, this._tDur, t), !0), Be(this), Re(this)
                    }, t.paused = function(e) {
                        return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ct(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== w && (this._tTime -= w)))), this) : this._ps
                    }, t.startTime = function(e) {
                        if (arguments.length) {
                            this._start = e;
                            var t = this.parent || this._dp;
                            return t && (t._sort || !this.parent) && ze(t, this, e - this._delay), this
                        }
                        return this._start
                    }, t.endTime = function(e) {
                        return this._start + (O(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                    }, t.rawTime = function(e) {
                        var t = this.parent || this._dp;
                        return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ue(t.rawTime(e), this) : this._tTime : this._tTime
                    }, t.revert = function(e) {
                        void 0 === e && (e = ie);
                        var t = a;
                        return a = e, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e), this.totalTime(-.01, e.suppressEvents)), "nested" !== this.data && !1 !== e.kill && this.kill(), a = t, this
                    }, t.globalTime = function(e) {
                        for (var t = this, i = arguments.length ? e : t.rawTime(); t;) i = t._start + i / (t._ts || 1), t = t._dp;
                        return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(e) : i
                    }, t.repeat = function(e) {
                        return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, $e(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                    }, t.repeatDelay = function(e) {
                        if (arguments.length) {
                            var t = this._time;
                            return this._rDelay = e, $e(this), t ? this.time(t) : this
                        }
                        return this._rDelay
                    }, t.yoyo = function(e) {
                        return arguments.length ? (this._yoyo = e, this) : this._yoyo
                    }, t.seek = function(e, t) {
                        return this.totalTime(Ye(this, e), O(t))
                    }, t.restart = function(e, t) {
                        return this.play().totalTime(e ? -this._delay : 0, O(t))
                    }, t.play = function(e, t) {
                        return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
                    }, t.reverse = function(e, t) {
                        return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
                    }, t.pause = function(e, t) {
                        return null != e && this.seek(e, t), this.paused(!0)
                    }, t.resume = function() {
                        return this.paused(!1)
                    }, t.reversed = function(e) {
                        return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -w : 0)), this) : this._rts < 0
                    }, t.invalidate = function() {
                        return this._initted = this._act = 0, this._zTime = -w, this
                    }, t.isActive = function() {
                        var e, t = this.parent || this._dp,
                            i = this._start;
                        return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= i && e < this.endTime(!0) - w))
                    }, t.eventCallback = function(e, t, i) {
                        var n = this.vars;
                        return arguments.length > 1 ? (t ? (n[e] = t, i && (n[e + "Params"] = i), "onUpdate" === e && (this._onUpdate = t)) : delete n[e], this) : n[e]
                    }, t.then = function(e) {
                        var t = this;
                        return new Promise((function(i) {
                            var n = P(e) ? e : xe,
                                r = function() {
                                    var e = t.then;
                                    t.then = null, P(n) && (n = n(t)) && (n.then || n === t) && (t.then = e), i(n), t.then = e
                                };
                            t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r
                        }))
                    }, t.kill = function() {
                        mt(this)
                    }, e
                }();
            we(Ht.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -w,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var zt = function(e) {
                function t(t, i) {
                    var r;
                    return void 0 === t && (t = {}), (r = e.call(this, t) || this).labels = {}, r.smoothChildTiming = !!t.smoothChildTiming, r.autoRemoveChildren = !!t.autoRemoveChildren, r._sort = O(t.sortChildren), l && ze(t.parent || l, n(r), i), t.reversed && r.reverse(), t.paused && r.paused(!0), t.scrollTrigger && Ve(n(r), t.scrollTrigger), r
                }
                r(t, e);
                var i = t.prototype;
                return i.to = function(e, t, i) {
                    return Ke(0, arguments, this), this
                }, i.from = function(e, t, i) {
                    return Ke(1, arguments, this), this
                }, i.fromTo = function(e, t, i, n) {
                    return Ke(2, arguments, this), this
                }, i.set = function(e, t, i) {
                    return t.duration = 0, t.parent = this, Ce(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new Zt(e, t, Ye(this, i), 1), this
                }, i.call = function(e, t, i) {
                    return ze(this, Zt.delayedCall(0, e, t), i)
                }, i.staggerTo = function(e, t, i, n, r, s, a) {
                    return i.duration = t, i.stagger = i.stagger || n, i.onComplete = s, i.onCompleteParams = a, i.parent = this, new Zt(e, i, Ye(this, r)), this
                }, i.staggerFrom = function(e, t, i, n, r, s, a) {
                    return i.runBackwards = 1, Ce(i).immediateRender = O(i.immediateRender), this.staggerTo(e, t, i, n, r, s, a)
                }, i.staggerFromTo = function(e, t, i, n, r, s, a, o) {
                    return n.startAt = i, Ce(n).immediateRender = O(n.immediateRender), this.staggerTo(e, t, n, r, s, a, o)
                }, i.render = function(e, t, i) {
                    var n, r, s, o, h, c, u, d, p, f, m, g, y = this._time,
                        _ = this._dirty ? this.totalDuration() : this._tDur,
                        v = this._dur,
                        b = e <= 0 ? 0 : ge(e),
                        T = this._zTime < 0 != e < 0 && (this._initted || !v);
                    if (this !== l && b > _ && e >= 0 && (b = _), b !== this._tTime || i || T) {
                        if (y !== this._time && v && (b += this._time - y, e += this._time - y), n = b, p = this._start, c = !(d = this._ts), T && (v || (y = this._zTime), (e || !t) && (this._zTime = e)), this._repeat) {
                            if (m = this._yoyo, h = v + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * h + e, t, i);
                            if (n = ge(b % h), b === _ ? (o = this._repeat, n = v) : ((o = ~~(b / h)) && o === b / h && (n = v, o--), n > v && (n = v)), f = Ne(this._tTime, h), !y && this._tTime && f !== o && (f = o), m && 1 & o && (n = v - n, g = 1), o !== f && !this._lock) {
                                var x = m && 1 & f,
                                    S = x === (m && 1 & o);
                                if (o < f && (x = !x), y = x ? 0 : v, this._lock = 1, this.render(y || (g ? 0 : ge(o * h)), t, !v)._lock = 0, this._tTime = b, !t && this.parent && ft(this, "onRepeat"), this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1), y && y !== this._time || c !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                                if (v = this._dur, _ = this._tDur, S && (this._lock = 2, y = x ? v : -1e-4, this.render(y, !0), this.vars.repeatRefresh && !g && this.invalidate()), this._lock = 0, !this._ts && !c) return this;
                                kt(this, g)
                            }
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (u = function(e, t, i) {
                                var n;
                                if (i > t)
                                    for (n = e._first; n && n._start <= i;) {
                                        if ("isPause" === n.data && n._start > t) return n;
                                        n = n._next
                                    } else
                                        for (n = e._last; n && n._start >= i;) {
                                            if ("isPause" === n.data && n._start < t) return n;
                                            n = n._prev
                                        }
                            }(this, ge(y), ge(n)), u && (b -= n - (n = u._start))), this._tTime = b, this._time = n, this._act = !d, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, y = 0), !y && n && !t && (ft(this, "onStart"), this._tTime !== b)) return this;
                        if (n >= y && e >= 0)
                            for (r = this._first; r;) {
                                if (s = r._next, (r._act || n >= r._start) && r._ts && u !== r) {
                                    if (r.parent !== this) return this.render(e, t, i);
                                    if (r.render(r._ts > 0 ? (n - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (n - r._start) * r._ts, t, i), n !== this._time || !this._ts && !c) {
                                        u = 0, s && (b += this._zTime = -w);
                                        break
                                    }
                                }
                                r = s
                            } else {
                                r = this._last;
                                for (var E = e < 0 ? e : n; r;) {
                                    if (s = r._prev, (r._act || E <= r._end) && r._ts && u !== r) {
                                        if (r.parent !== this) return this.render(e, t, i);
                                        if (r.render(r._ts > 0 ? (E - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (E - r._start) * r._ts, t, i || a && (r._initted || r._startAt)), n !== this._time || !this._ts && !c) {
                                            u = 0, s && (b += this._zTime = E ? -w : w);
                                            break
                                        }
                                    }
                                    r = s
                                }
                            }
                        if (u && !t && (this.pause(), u.render(n >= y ? 0 : -w)._zTime = n >= y ? 1 : -1, this._ts)) return this._start = p, Be(this), this.render(e, t, i);
                        this._onUpdate && !t && ft(this, "onUpdate", !0), (b === _ && this._tTime >= this.totalDuration() || !b && y) && (p !== this._start && Math.abs(d) === Math.abs(this._ts) || this._lock || ((e || !v) && (b === _ && this._ts > 0 || !b && this._ts < 0) && Ie(this, 1), t || e < 0 && !y || !b && !y && _ || (ft(this, b === _ && e >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(b < _ && this.timeScale() > 0) && this._prom())))
                    }
                    return this
                }, i.add = function(e, t) {
                    var i = this;
                    if (R(t) || (t = Ye(this, t, e)), !(e instanceof Ht)) {
                        if (F(e)) return e.forEach((function(e) {
                            return i.add(e, t)
                        })), this;
                        if (I(e)) return this.addLabel(e, t);
                        if (!P(e)) return this;
                        e = Zt.delayedCall(0, e)
                    }
                    return this !== e ? ze(this, e, t) : this
                }, i.getChildren = function(e, t, i, n) {
                    void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === i && (i = !0), void 0 === n && (n = -x);
                    for (var r = [], s = this._first; s;) s._start >= n && (s instanceof Zt ? t && r.push(s) : (i && r.push(s), e && r.push.apply(r, s.getChildren(!0, t, i)))), s = s._next;
                    return r
                }, i.getById = function(e) {
                    for (var t = this.getChildren(1, 1, 1), i = t.length; i--;)
                        if (t[i].vars.id === e) return t[i]
                }, i.remove = function(e) {
                    return I(e) ? this.removeLabel(e) : P(e) ? this.killTweensOf(e) : (Le(this, e), e === this._recent && (this._recent = this._last), Pe(this))
                }, i.totalTime = function(t, i) {
                    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = ge(Mt.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, i), this._forcing = 0, this) : this._tTime
                }, i.addLabel = function(e, t) {
                    return this.labels[e] = Ye(this, t), this
                }, i.removeLabel = function(e) {
                    return delete this.labels[e], this
                }, i.addPause = function(e, t, i) {
                    var n = Zt.delayedCall(0, t || Q, i);
                    return n.data = "isPause", this._hasPause = 1, ze(this, n, Ye(this, e))
                }, i.removePause = function(e) {
                    var t = this._first;
                    for (e = Ye(this, e); t;) t._start === e && "isPause" === t.data && Ie(t), t = t._next
                }, i.killTweensOf = function(e, t, i) {
                    for (var n = this.getTweensOf(e, i), r = n.length; r--;) Vt !== n[r] && n[r].kill(e, t);
                    return this
                }, i.getTweensOf = function(e, t) {
                    for (var i, n = [], r = nt(e), s = this._first, a = R(t); s;) s instanceof Zt ? _e(s._targets, r) && (a ? (!Vt || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && n.push(s) : (i = s.getTweensOf(r, t)).length && n.push.apply(n, i), s = s._next;
                    return n
                }, i.tweenTo = function(e, t) {
                    t = t || {};
                    var i, n = this,
                        r = Ye(n, e),
                        s = t,
                        a = s.startAt,
                        o = s.onStart,
                        l = s.onStartParams,
                        h = s.immediateRender,
                        c = Zt.to(n, we({
                            ease: t.ease || "none",
                            lazy: !1,
                            immediateRender: !1,
                            time: r,
                            overwrite: "auto",
                            duration: t.duration || Math.abs((r - (a && "time" in a ? a.time : n._time)) / n.timeScale()) || w,
                            onStart: function() {
                                if (n.pause(), !i) {
                                    var e = t.duration || Math.abs((r - (a && "time" in a ? a.time : n._time)) / n.timeScale());
                                    c._dur !== e && qe(c, e, 0, 1).render(c._time, !0, !0), i = 1
                                }
                                o && o.apply(c, l || [])
                            }
                        }, t));
                    return h ? c.render(0) : c
                }, i.tweenFromTo = function(e, t, i) {
                    return this.tweenTo(t, we({
                        startAt: {
                            time: Ye(this, e)
                        }
                    }, i))
                }, i.recent = function() {
                    return this._recent
                }, i.nextLabel = function(e) {
                    return void 0 === e && (e = this._time), pt(this, Ye(this, e))
                }, i.previousLabel = function(e) {
                    return void 0 === e && (e = this._time), pt(this, Ye(this, e), 1)
                }, i.currentLabel = function(e) {
                    return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + w)
                }, i.shiftChildren = function(e, t, i) {
                    void 0 === i && (i = 0);
                    for (var n, r = this._first, s = this.labels; r;) r._start >= i && (r._start += e, r._end += e), r = r._next;
                    if (t)
                        for (n in s) s[n] >= i && (s[n] += e);
                    return Pe(this)
                }, i.invalidate = function(t) {
                    var i = this._first;
                    for (this._lock = 0; i;) i.invalidate(t), i = i._next;
                    return e.prototype.invalidate.call(this, t)
                }, i.clear = function(e) {
                    void 0 === e && (e = !0);
                    for (var t, i = this._first; i;) t = i._next, this.remove(i), i = t;
                    return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), Pe(this)
                }, i.totalDuration = function(e) {
                    var t, i, n, r = 0,
                        s = this,
                        a = s._last,
                        o = x;
                    if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -e : e));
                    if (s._dirty) {
                        for (n = s.parent; a;) t = a._prev, a._dirty && a.totalDuration(), (i = a._start) > o && s._sort && a._ts && !s._lock ? (s._lock = 1, ze(s, a, i - a._delay, 1)._lock = 0) : o = i, i < 0 && a._ts && (r -= i, (!n && !s._dp || n && n.smoothChildTiming) && (s._start += i / s._ts, s._time -= i, s._tTime -= i), s.shiftChildren(-i, !1, -Infinity), o = 0), a._end > r && a._ts && (r = a._end), a = t;
                        qe(s, s === l && s._time > r ? s._time : r, 1, 1), s._dirty = 0
                    }
                    return s._tDur
                }, t.updateRoot = function(e) {
                    if (l._ts && (be(l, Ue(e, l)), p = Mt.frame), Mt.frame >= le) {
                        le += b.autoSleep || 120;
                        var t = l._first;
                        if ((!t || !t._ts) && b.autoSleep && Mt._listeners.length < 2) {
                            for (; t && !t._ts;) t = t._next;
                            t || Mt.sleep()
                        }
                    }
                }, t
            }(Ht);
            we(zt.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var Vt, Gt, Wt = function(e, t, i, n, r, s, a) {
                    var o, l, h, c, u, d, p, f, m = new di(this._pt, e, t, 0, 1, ai, null, r),
                        g = 0,
                        y = 0;
                    for (m.b = i, m.e = n, i += "", (p = ~(n += "").indexOf("random(")) && (n = ut(n)), s && (s(f = [i, n], e, t), i = f[0], n = f[1]), l = i.match(G) || []; o = G.exec(n);) c = o[0], u = n.substring(g, o.index), h ? h = (h + 1) % 5 : "rgba(" === u.substr(-5) && (h = 1), c !== l[y++] && (d = parseFloat(l[y - 1]) || 0, m._pt = {
                        _next: m._pt,
                        p: u || 1 === y ? u : ",",
                        s: d,
                        c: "=" === c.charAt(1) ? ye(d, c) - d : parseFloat(c) - d,
                        m: h && h < 4 ? Math.round : 0
                    }, g = G.lastIndex);
                    return m.c = g < n.length ? n.substring(g, n.length) : "", m.fp = a, (W.test(n) || p) && (m.e = 0), this._pt = m, m
                },
                jt = function(e, t, i, n, r, s, a, o, l, h) {
                    P(n) && (n = n(r || 0, e, s));
                    var c, u = e[t],
                        d = "get" !== i ? i : P(u) ? l ? e[t.indexOf("set") || !P(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : u,
                        p = P(u) ? l ? ti : ei : Qt;
                    if (I(n) && (~n.indexOf("random(") && (n = ut(n)), "=" === n.charAt(1) && ((c = ye(d, n) + (Qe(d) || 0)) || 0 === c) && (n = c)), !h || d !== n || Gt) return isNaN(d * n) || "" === n ? (!u && !(t in e) && K(t, n), Wt.call(this, e, t, d, n, p, o || b.stringFilter, l)) : (c = new di(this._pt, e, t, +d || 0, n - (d || 0), "boolean" == typeof u ? si : ri, 0, p), l && (c.fp = l), a && c.modifier(a, this, e), this._pt = c)
                },
                qt = function(e, t, i, n, r, s) {
                    var a, o, l, h;
                    if (ae[e] && !1 !== (a = new ae[e]).init(r, a.rawVars ? t[e] : function(e, t, i, n, r) {
                            if (P(e) && (e = Yt(e, r, t, i, n)), !D(e) || e.style && e.nodeType || F(e) || B(e)) return I(e) ? Yt(e, r, t, i, n) : e;
                            var s, a = {};
                            for (s in e) a[s] = Yt(e[s], r, t, i, n);
                            return a
                        }(t[e], n, r, s, i), i, n, s) && (i._pt = o = new di(i._pt, r, e, 0, 1, a.render, a, 0, a.priority), i !== f))
                        for (l = i._ptLookup[i._targets.indexOf(r)], h = a._props.length; h--;) l[a._props[h]] = o;
                    return a
                },
                $t = function e(t, i, n) {
                    var r, o, h, c, u, d, p, f, m, g, y, _, v, b = t.vars,
                        S = b.ease,
                        E = b.startAt,
                        M = b.immediateRender,
                        C = b.lazy,
                        A = b.onUpdate,
                        L = b.onUpdateParams,
                        I = b.callbackScope,
                        P = b.runBackwards,
                        R = b.yoyoEase,
                        k = b.keyframes,
                        D = b.autoRevert,
                        N = t._dur,
                        U = t._startAt,
                        B = t._targets,
                        F = t.parent,
                        H = F && "nested" === F.data ? F.vars.targets : B,
                        z = "auto" === t._overwrite && !s,
                        V = t.timeline;
                    if (V && (!k || !S) && (S = "none"), t._ease = Dt(S, T.ease), t._yEase = R ? Rt(Dt(!0 === R ? S : R, T.ease)) : 0, R && t._yoyo && !t._repeat && (R = t._yEase, t._yEase = t._ease, t._ease = R), t._from = !V && !!b.runBackwards, !V || k && !b.stagger) {
                        if (_ = (f = B[0] ? de(B[0]).harness : 0) && b[f.prop], r = Me(b, ne), U && (U._zTime < 0 && U.progress(1), i < 0 && P && M && !D ? U.render(-1, !0) : U.revert(P && N ? te : ee), U._lazy = 0), E) {
                            if (Ie(t._startAt = Zt.set(B, we({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: F,
                                    immediateRender: !0,
                                    lazy: !U && O(C),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: A,
                                    onUpdateParams: L,
                                    callbackScope: I,
                                    stagger: 0
                                }, E))), t._startAt._dp = 0, t._startAt._sat = t, i < 0 && (a || !M && !D) && t._startAt.revert(te), M && N && i <= 0 && n <= 0) return void(i && (t._zTime = i))
                        } else if (P && N && !U)
                            if (i && (M = !1), h = we({
                                    overwrite: !1,
                                    data: "isFromStart",
                                    lazy: M && !U && O(C),
                                    immediateRender: M,
                                    stagger: 0,
                                    parent: F
                                }, r), _ && (h[f.prop] = _), Ie(t._startAt = Zt.set(B, h)), t._startAt._dp = 0, t._startAt._sat = t, i < 0 && (a ? t._startAt.revert(te) : t._startAt.render(-1, !0)), t._zTime = i, M) {
                                if (!i) return
                            } else e(t._startAt, w, w);
                        for (t._pt = t._ptCache = 0, C = N && O(C) || C && !N, o = 0; o < B.length; o++) {
                            if (p = (u = B[o])._gsap || ue(B)[o]._gsap, t._ptLookup[o] = g = {}, se[p.id] && re.length && ve(), y = H === B ? o : H.indexOf(u), f && !1 !== (m = new f).init(u, _ || r, t, y, H) && (t._pt = c = new di(t._pt, u, m.name, 0, 1, m.render, m, 0, m.priority), m._props.forEach((function(e) {
                                    g[e] = c
                                })), m.priority && (d = 1)), !f || _)
                                for (h in r) ae[h] && (m = qt(h, r, t, y, u, H)) ? m.priority && (d = 1) : g[h] = c = jt.call(t, u, h, "get", r[h], y, H, 0, b.stringFilter);
                            t._op && t._op[o] && t.kill(u, t._op[o]), z && t._pt && (Vt = t, l.killTweensOf(u, g, t.globalTime(i)), v = !t.parent, Vt = 0), t._pt && C && (se[p.id] = 1)
                        }
                        d && ui(t), t._onInit && t._onInit(t)
                    }
                    t._onUpdate = A, t._initted = (!t._op || t._pt) && !v, k && i <= 0 && V.render(x, !0, !0)
                },
                Xt = function(e, t, i, n) {
                    var r, s, a = t.ease || n || "power1.inOut";
                    if (F(t)) s = i[e] || (i[e] = []), t.forEach((function(e, i) {
                        return s.push({
                            t: i / (t.length - 1) * 100,
                            v: e,
                            e: a
                        })
                    }));
                    else
                        for (r in t) s = i[r] || (i[r] = []), "ease" === r || s.push({
                            t: parseFloat(e),
                            v: t[r],
                            e: a
                        })
                },
                Yt = function(e, t, i, n, r) {
                    return P(e) ? e.call(t, i, n, r) : I(e) && ~e.indexOf("random(") ? ut(e) : e
                },
                Kt = ce + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
                Jt = {};
            fe(Kt + ",id,stagger,delay,duration,paused,scrollTrigger", (function(e) {
                return Jt[e] = 1
            }));
            var Zt = function(e) {
                function t(t, i, r, a) {
                    var o;
                    "number" == typeof i && (r.duration = i, i = r, r = null);
                    var h, c, u, d, p, f, m, g, y = (o = e.call(this, a ? i : Ce(i)) || this).vars,
                        _ = y.duration,
                        v = y.delay,
                        T = y.immediateRender,
                        x = y.stagger,
                        S = y.overwrite,
                        E = y.keyframes,
                        M = y.defaults,
                        C = y.scrollTrigger,
                        A = y.yoyoEase,
                        L = i.parent || l,
                        I = (F(t) || B(t) ? R(t[0]) : "length" in i) ? [t] : nt(t);
                    if (o._targets = I.length ? ue(I) : J("GSAP target " + t + " not found. https://greensock.com", !b.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = S, E || x || U(_) || U(v)) {
                        if (i = o.vars, (h = o.timeline = new zt({
                                data: "nested",
                                defaults: M || {},
                                targets: L && "nested" === L.data ? L.vars.targets : I
                            })).kill(), h.parent = h._dp = n(o), h._start = 0, x || U(_) || U(v)) {
                            if (d = I.length, m = x && at(x), D(x))
                                for (p in x) ~Kt.indexOf(p) && (g || (g = {}), g[p] = x[p]);
                            for (c = 0; c < d; c++)(u = Me(i, Jt)).stagger = 0, A && (u.yoyoEase = A), g && Se(u, g), f = I[c], u.duration = +Yt(_, n(o), c, f, I), u.delay = (+Yt(v, n(o), c, f, I) || 0) - o._delay, !x && 1 === d && u.delay && (o._delay = v = u.delay, o._start += v, u.delay = 0), h.to(f, u, m ? m(c, f, I) : 0), h._ease = At.none;
                            h.duration() ? _ = v = 0 : o.timeline = 0
                        } else if (E) {
                            Ce(we(h.vars.defaults, {
                                ease: "none"
                            })), h._ease = Dt(E.ease || i.ease || "none");
                            var P, k, N, H = 0;
                            if (F(E)) E.forEach((function(e) {
                                return h.to(I, e, ">")
                            })), h.duration();
                            else {
                                for (p in u = {}, E) "ease" === p || "easeEach" === p || Xt(p, E[p], u, E.easeEach);
                                for (p in u)
                                    for (P = u[p].sort((function(e, t) {
                                            return e.t - t.t
                                        })), H = 0, c = 0; c < P.length; c++)(N = {
                                        ease: (k = P[c]).e,
                                        duration: (k.t - (c ? P[c - 1].t : 0)) / 100 * _
                                    })[p] = k.v, h.to(I, N, H), H += N.duration;
                                h.duration() < _ && h.to({}, {
                                    duration: _ - h.duration()
                                })
                            }
                        }
                        _ || o.duration(_ = h.duration())
                    } else o.timeline = 0;
                    return !0 !== S || s || (Vt = n(o), l.killTweensOf(I), Vt = 0), ze(L, n(o), r), i.reversed && o.reverse(), i.paused && o.paused(!0), (T || !_ && !E && o._start === ge(L._time) && O(T) && De(n(o)) && "nested" !== L.data) && (o._tTime = -w, o.render(Math.max(0, -v) || 0)), C && Ve(n(o), C), o
                }
                r(t, e);
                var i = t.prototype;
                return i.render = function(e, t, i) {
                    var n, r, s, o, l, h, c, u, d, p = this._time,
                        f = this._tDur,
                        m = this._dur,
                        g = e < 0,
                        y = e > f - w && !g ? f : e < w ? 0 : e;
                    if (m) {
                        if (y !== this._tTime || !e || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g) {
                            if (n = y, u = this.timeline, this._repeat) {
                                if (o = m + this._rDelay, this._repeat < -1 && g) return this.totalTime(100 * o + e, t, i);
                                if (n = ge(y % o), y === f ? (s = this._repeat, n = m) : ((s = ~~(y / o)) && s === y / o && (n = m, s--), n > m && (n = m)), (h = this._yoyo && 1 & s) && (d = this._yEase, n = m - n), l = Ne(this._tTime, o), n === p && !i && this._initted) return this._tTime = y, this;
                                s !== l && (u && this._yEase && kt(u, h), !this.vars.repeatRefresh || h || this._lock || (this._lock = i = 1, this.render(ge(o * s), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (Ge(this, g ? e : n, i, t, y)) return this._tTime = 0, this;
                                if (p !== this._time) return this;
                                if (m !== this._dur) return this.render(e, t, i)
                            }
                            if (this._tTime = y, this._time = n, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (d || this._ease)(n / m), this._from && (this.ratio = c = 1 - c), n && !p && !t && (ft(this, "onStart"), this._tTime !== y)) return this;
                            for (r = this._pt; r;) r.r(c, r.d), r = r._next;
                            u && u.render(e < 0 ? e : !n && h ? -w : u._dur * u._ease(n / this._dur), t, i) || this._startAt && (this._zTime = e), this._onUpdate && !t && (g && ke(this, e, 0, i), ft(this, "onUpdate")), this._repeat && s !== l && this.vars.onRepeat && !t && this.parent && ft(this, "onRepeat"), y !== this._tDur && y || this._tTime !== y || (g && !this._onUpdate && ke(this, e, 0, !0), (e || !m) && (y === this._tDur && this._ts > 0 || !y && this._ts < 0) && Ie(this, 1), t || g && !p || !(y || p || h) || (ft(this, y === f ? "onComplete" : "onReverseComplete", !0), this._prom && !(y < f && this.timeScale() > 0) && this._prom()))
                        }
                    } else ! function(e, t, i, n) {
                        var r, s, o, l = e.ratio,
                            h = t < 0 || !t && (!e._start && We(e) && (e._initted || !je(e)) || (e._ts < 0 || e._dp._ts < 0) && !je(e)) ? 0 : 1,
                            c = e._rDelay,
                            u = 0;
                        if (c && e._repeat && (u = Ze(0, e._tDur, t), s = Ne(u, c), e._yoyo && 1 & s && (h = 1 - h), s !== Ne(e._tTime, c) && (l = 1 - h, e.vars.repeatRefresh && e._initted && e.invalidate())), h !== l || a || n || e._zTime === w || !t && e._zTime) {
                            if (!e._initted && Ge(e, t, n, i, u)) return;
                            for (o = e._zTime, e._zTime = t || (i ? w : 0), i || (i = t && !o), e.ratio = h, e._from && (h = 1 - h), e._time = 0, e._tTime = u, r = e._pt; r;) r.r(h, r.d), r = r._next;
                            t < 0 && ke(e, t, 0, !0), e._onUpdate && !i && ft(e, "onUpdate"), u && e._repeat && !i && e.parent && ft(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === h && (h && Ie(e, 1), i || a || (ft(e, h ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
                        } else e._zTime || (e._zTime = t)
                    }(this, e, t, i);
                    return this
                }, i.targets = function() {
                    return this._targets
                }, i.invalidate = function(t) {
                    return (!t || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(t), e.prototype.invalidate.call(this, t)
                }, i.resetTo = function(e, t, i, n) {
                    m || Mt.wake(), this._ts || this.play();
                    var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                    return this._initted || $t(this, r),
                        function(e, t, i, n, r, s, a) {
                            var o, l, h, c, u = (e._pt && e._ptCache || (e._ptCache = {}))[t];
                            if (!u)
                                for (u = e._ptCache[t] = [], h = e._ptLookup, c = e._targets.length; c--;) {
                                    if ((o = h[c][t]) && o.d && o.d._pt)
                                        for (o = o.d._pt; o && o.p !== t && o.fp !== t;) o = o._next;
                                    if (!o) return Gt = 1, e.vars[t] = "+=0", $t(e, a), Gt = 0, 1;
                                    u.push(o)
                                }
                            for (c = u.length; c--;)(o = (l = u[c])._pt || l).s = !n && 0 !== n || r ? o.s + (n || 0) + s * o.c : n, o.c = i - o.s, l.e && (l.e = me(i) + Qe(l.e)), l.b && (l.b = o.s + Qe(l.b))
                        }(this, e, t, i, n, this._ease(r / this._dur), r) ? this.resetTo(e, t, i, n) : (Fe(this, 0), this.parent || Ae(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
                }, i.kill = function(e, t) {
                    if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? mt(this) : this;
                    if (this.timeline) {
                        var i = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(e, t, Vt && !0 !== Vt.vars.overwrite)._first || mt(this), this.parent && i !== this.timeline.totalDuration() && qe(this, this._dur * this.timeline._tDur / i, 0, 1), this
                    }
                    var n, r, s, a, o, l, h, c = this._targets,
                        u = e ? nt(e) : c,
                        d = this._ptLookup,
                        p = this._pt;
                    if ((!t || "all" === t) && function(e, t) {
                            for (var i = e.length, n = i === t.length; n && i-- && e[i] === t[i];);
                            return i < 0
                        }(c, u)) return "all" === t && (this._pt = 0), mt(this);
                    for (n = this._op = this._op || [], "all" !== t && (I(t) && (o = {}, fe(t, (function(e) {
                            return o[e] = 1
                        })), t = o), t = function(e, t) {
                            var i, n, r, s, a = e[0] ? de(e[0]).harness : 0,
                                o = a && a.aliases;
                            if (!o) return t;
                            for (n in i = Se({}, t), o)
                                if (n in i)
                                    for (r = (s = o[n].split(",")).length; r--;) i[s[r]] = i[n];
                            return i
                        }(c, t)), h = c.length; h--;)
                        if (~u.indexOf(c[h]))
                            for (o in r = d[h], "all" === t ? (n[h] = t, a = r, s = {}) : (s = n[h] = n[h] || {}, a = t), a)(l = r && r[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || Le(this, l, "_pt"), delete r[o]), "all" !== s && (s[o] = 1);
                    return this._initted && !this._pt && p && mt(this), this
                }, t.to = function(e, i) {
                    return new t(e, i, arguments[2])
                }, t.from = function(e, t) {
                    return Ke(1, arguments)
                }, t.delayedCall = function(e, i, n, r) {
                    return new t(i, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: e,
                        onComplete: i,
                        onReverseComplete: i,
                        onCompleteParams: n,
                        onReverseCompleteParams: n,
                        callbackScope: r
                    })
                }, t.fromTo = function(e, t, i) {
                    return Ke(2, arguments)
                }, t.set = function(e, i) {
                    return i.duration = 0, i.repeatDelay || (i.repeat = 0), new t(e, i)
                }, t.killTweensOf = function(e, t, i) {
                    return l.killTweensOf(e, t, i)
                }, t
            }(Ht);
            we(Zt.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), fe("staggerTo,staggerFrom,staggerFromTo", (function(e) {
                Zt[e] = function() {
                    var t = new zt,
                        i = et.call(arguments, 0);
                    return i.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, i)
                }
            }));
            var Qt = function(e, t, i) {
                    return e[t] = i
                },
                ei = function(e, t, i) {
                    return e[t](i)
                },
                ti = function(e, t, i, n) {
                    return e[t](n.fp, i)
                },
                ii = function(e, t, i) {
                    return e.setAttribute(t, i)
                },
                ni = function(e, t) {
                    return P(e[t]) ? ei : k(e[t]) && e.setAttribute ? ii : Qt
                },
                ri = function(e, t) {
                    return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
                },
                si = function(e, t) {
                    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
                },
                ai = function(e, t) {
                    var i = t._pt,
                        n = "";
                    if (!e && t.b) n = t.b;
                    else if (1 === e && t.e) n = t.e;
                    else {
                        for (; i;) n = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round(1e4 * (i.s + i.c * e)) / 1e4) + n, i = i._next;
                        n += t.c
                    }
                    t.set(t.t, t.p, n, t)
                },
                oi = function(e, t) {
                    for (var i = t._pt; i;) i.r(e, i.d), i = i._next
                },
                li = function(e, t, i, n) {
                    for (var r, s = this._pt; s;) r = s._next, s.p === n && s.modifier(e, t, i), s = r
                },
                hi = function(e) {
                    for (var t, i, n = this._pt; n;) i = n._next, n.p === e && !n.op || n.op === e ? Le(this, n, "_pt") : n.dep || (t = 1), n = i;
                    return !t
                },
                ci = function(e, t, i, n) {
                    n.mSet(e, t, n.m.call(n.tween, i, n.mt), n)
                },
                ui = function(e) {
                    for (var t, i, n, r, s = e._pt; s;) {
                        for (t = s._next, i = n; i && i.pr > s.pr;) i = i._next;
                        (s._prev = i ? i._prev : r) ? s._prev._next = s: n = s, (s._next = i) ? i._prev = s : r = s, s = t
                    }
                    e._pt = n
                },
                di = function() {
                    function e(e, t, i, n, r, s, a, o, l) {
                        this.t = t, this.s = n, this.c = r, this.p = i, this.r = s || ri, this.d = a || this, this.set = o || Qt, this.pr = l || 0, this._next = e, e && (e._prev = this)
                    }
                    return e.prototype.modifier = function(e, t, i) {
                        this.mSet = this.mSet || this.set, this.set = ci, this.m = e, this.mt = i, this.tween = t
                    }, e
                }();
            fe(ce + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(e) {
                return ne[e] = 1
            })), $.TweenMax = $.TweenLite = Zt, $.TimelineLite = $.TimelineMax = zt, l = new zt({
                sortChildren: !1,
                defaults: T,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }), b.stringFilter = Et;
            var pi = [],
                fi = {},
                mi = [],
                gi = 0,
                yi = function(e) {
                    return (fi[e] || mi).map((function(e) {
                        return e()
                    }))
                },
                _i = function() {
                    var e = Date.now(),
                        t = [];
                    e - gi > 2 && (yi("matchMediaInit"), pi.forEach((function(e) {
                        var i, n, r, s, a = e.queries,
                            o = e.conditions;
                        for (n in a)(i = h.matchMedia(a[n]).matches) && (r = 1), i !== o[n] && (o[n] = i, s = 1);
                        s && (e.revert(), r && t.push(e))
                    })), yi("matchMediaRevert"), t.forEach((function(e) {
                        return e.onMatch(e)
                    })), gi = e, yi("matchMedia"))
                },
                vi = function() {
                    function e(e, t) {
                        this.selector = t && rt(t), this.data = [], this._r = [], this.isReverted = !1, e && this.add(e)
                    }
                    var t = e.prototype;
                    return t.add = function(e, t, i) {
                        P(e) && (i = t, t = e, e = P);
                        var n = this,
                            r = function() {
                                var e, r = o,
                                    s = n.selector;
                                return r && r !== n && r.data.push(n), i && (n.selector = rt(i)), o = n, e = t.apply(n, arguments), P(e) && n._r.push(e), o = r, n.selector = s, n.isReverted = !1, e
                            };
                        return n.last = r, e === P ? r(n) : e ? n[e] = r : r
                    }, t.ignore = function(e) {
                        var t = o;
                        o = null, e(this), o = t
                    }, t.getTweens = function() {
                        var t = [];
                        return this.data.forEach((function(i) {
                            return i instanceof e ? t.push.apply(t, i.getTweens()) : i instanceof Zt && !(i.parent && "nested" === i.parent.data) && t.push(i)
                        })), t
                    }, t.clear = function() {
                        this._r.length = this.data.length = 0
                    }, t.kill = function(e, t) {
                        var i = this;
                        if (e) {
                            var n = this.getTweens();
                            this.data.forEach((function(e) {
                                "isFlip" === e.data && (e.revert(), e.getChildren(!0, !0, !1).forEach((function(e) {
                                    return n.splice(n.indexOf(e), 1)
                                })))
                            })), n.map((function(e) {
                                return {
                                    g: e.globalTime(0),
                                    t: e
                                }
                            })).sort((function(e, t) {
                                return t.g - e.g || -1
                            })).forEach((function(t) {
                                return t.t.revert(e)
                            })), this.data.forEach((function(t) {
                                return !(t instanceof Ht) && t.revert && t.revert(e)
                            })), this._r.forEach((function(t) {
                                return t(e, i)
                            })), this.isReverted = !0
                        } else this.data.forEach((function(e) {
                            return e.kill && e.kill()
                        }));
                        if (this.clear(), t) {
                            var r = pi.indexOf(this);
                            ~r && pi.splice(r, 1)
                        }
                    }, t.revert = function(e) {
                        this.kill(e || {})
                    }, e
                }(),
                bi = function() {
                    function e(e) {
                        this.contexts = [], this.scope = e
                    }
                    var t = e.prototype;
                    return t.add = function(e, t, i) {
                        D(e) || (e = {
                            matches: e
                        });
                        var n, r, s, a = new vi(0, i || this.scope),
                            o = a.conditions = {};
                        for (r in this.contexts.push(a), t = a.add("onMatch", t), a.queries = e, e) "all" === r ? s = 1 : (n = h.matchMedia(e[r])) && (pi.indexOf(a) < 0 && pi.push(a), (o[r] = n.matches) && (s = 1), n.addListener ? n.addListener(_i) : n.addEventListener("change", _i));
                        return s && t(a), this
                    }, t.revert = function(e) {
                        this.kill(e || {})
                    }, t.kill = function(e) {
                        this.contexts.forEach((function(t) {
                            return t.kill(e, !0)
                        }))
                    }, e
                }(),
                Ti = {
                    registerPlugin: function() {
                        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                        t.forEach((function(e) {
                            return gt(e)
                        }))
                    },
                    timeline: function(e) {
                        return new zt(e)
                    },
                    getTweensOf: function(e, t) {
                        return l.getTweensOf(e, t)
                    },
                    getProperty: function(e, t, i, n) {
                        I(e) && (e = nt(e)[0]);
                        var r = de(e || {}).get,
                            s = i ? xe : Te;
                        return "native" === i && (i = ""), e ? t ? s((ae[t] && ae[t].get || r)(e, t, i, n)) : function(t, i, n) {
                            return s((ae[t] && ae[t].get || r)(e, t, i, n))
                        } : e
                    },
                    quickSetter: function(e, t, i) {
                        if ((e = nt(e)).length > 1) {
                            var n = e.map((function(e) {
                                    return Si.quickSetter(e, t, i)
                                })),
                                r = n.length;
                            return function(e) {
                                for (var t = r; t--;) n[t](e)
                            }
                        }
                        e = e[0] || {};
                        var s = ae[t],
                            a = de(e),
                            o = a.harness && (a.harness.aliases || {})[t] || t,
                            l = s ? function(t) {
                                var n = new s;
                                f._pt = 0, n.init(e, i ? t + i : t, f, 0, [e]), n.render(1, n), f._pt && oi(1, f)
                            } : a.set(e, o);
                        return s ? l : function(t) {
                            return l(e, o, i ? t + i : t, a, 1)
                        }
                    },
                    quickTo: function(e, t, i) {
                        var n, r = Si.to(e, Se(((n = {})[t] = "+=0.1", n.paused = !0, n), i || {})),
                            s = function(e, i, n) {
                                return r.resetTo(t, e, i, n)
                            };
                        return s.tween = r, s
                    },
                    isTweening: function(e) {
                        return l.getTweensOf(e, !0).length > 0
                    },
                    defaults: function(e) {
                        return e && e.ease && (e.ease = Dt(e.ease, T.ease)), Ee(T, e || {})
                    },
                    config: function(e) {
                        return Ee(b, e || {})
                    },
                    registerEffect: function(e) {
                        var t = e.name,
                            i = e.effect,
                            n = e.plugins,
                            r = e.defaults,
                            s = e.extendTimeline;
                        (n || "").split(",").forEach((function(e) {
                            return e && !ae[e] && !$[e] && J(t + " effect requires " + e + " plugin.")
                        })), oe[t] = function(e, t, n) {
                            return i(nt(e), we(t || {}, r), n)
                        }, s && (zt.prototype[t] = function(e, i, n) {
                            return this.add(oe[t](e, D(i) ? i : (n = i) && {}, this), n)
                        })
                    },
                    registerEase: function(e, t) {
                        At[e] = Dt(t)
                    },
                    parseEase: function(e, t) {
                        return arguments.length ? Dt(e, t) : At
                    },
                    getById: function(e) {
                        return l.getById(e)
                    },
                    exportRoot: function(e, t) {
                        void 0 === e && (e = {});
                        var i, n, r = new zt(e);
                        for (r.smoothChildTiming = O(e.smoothChildTiming), l.remove(r), r._dp = 0, r._time = r._tTime = l._time, i = l._first; i;) n = i._next, !t && !i._dur && i instanceof Zt && i.vars.onComplete === i._targets[0] || ze(r, i, i._start - i._delay), i = n;
                        return ze(l, r, 0), r
                    },
                    context: function(e, t) {
                        return e ? new vi(e, t) : o
                    },
                    matchMedia: function(e) {
                        return new bi(e)
                    },
                    matchMediaRefresh: function() {
                        return pi.forEach((function(e) {
                            var t, i, n = e.conditions;
                            for (i in n) n[i] && (n[i] = !1, t = 1);
                            t && e.revert()
                        })) || _i()
                    },
                    addEventListener: function(e, t) {
                        var i = fi[e] || (fi[e] = []);
                        ~i.indexOf(t) || i.push(t)
                    },
                    removeEventListener: function(e, t) {
                        var i = fi[e],
                            n = i && i.indexOf(t);
                        n >= 0 && i.splice(n, 1)
                    },
                    utils: {
                        wrap: function e(t, i, n) {
                            var r = i - t;
                            return F(t) ? ct(t, e(0, t.length), i) : Je(n, (function(e) {
                                return (r + (e - t) % r) % r + t
                            }))
                        },
                        wrapYoyo: function e(t, i, n) {
                            var r = i - t,
                                s = 2 * r;
                            return F(t) ? ct(t, e(0, t.length - 1), i) : Je(n, (function(e) {
                                return t + ((e = (s + (e - t) % s) % s || 0) > r ? s - e : e)
                            }))
                        },
                        distribute: at,
                        random: ht,
                        snap: lt,
                        normalize: function(e, t, i) {
                            return dt(e, t, 0, 1, i)
                        },
                        getUnit: Qe,
                        clamp: function(e, t, i) {
                            return Je(i, (function(i) {
                                return Ze(e, t, i)
                            }))
                        },
                        splitColor: bt,
                        toArray: nt,
                        selector: rt,
                        mapRange: dt,
                        pipe: function() {
                            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                            return function(e) {
                                return t.reduce((function(e, t) {
                                    return t(e)
                                }), e)
                            }
                        },
                        unitize: function(e, t) {
                            return function(i) {
                                return e(parseFloat(i)) + (t || Qe(i))
                            }
                        },
                        interpolate: function e(t, i, n, r) {
                            var s = isNaN(t + i) ? 0 : function(e) {
                                return (1 - e) * t + e * i
                            };
                            if (!s) {
                                var a, o, l, h, c, u = I(t),
                                    d = {};
                                if (!0 === n && (r = 1) && (n = null), u) t = {
                                    p: t
                                }, i = {
                                    p: i
                                };
                                else if (F(t) && !F(i)) {
                                    for (l = [], h = t.length, c = h - 2, o = 1; o < h; o++) l.push(e(t[o - 1], t[o]));
                                    h--, s = function(e) {
                                        e *= h;
                                        var t = Math.min(c, ~~e);
                                        return l[t](e - t)
                                    }, n = i
                                } else r || (t = Se(F(t) ? [] : {}, t));
                                if (!l) {
                                    for (a in i) jt.call(d, t, a, "get", i[a]);
                                    s = function(e) {
                                        return oi(e, d) || (u ? t.p : t)
                                    }
                                }
                            }
                            return Je(n, s)
                        },
                        shuffle: st
                    },
                    install: Y,
                    effects: oe,
                    ticker: Mt,
                    updateRoot: zt.updateRoot,
                    plugins: ae,
                    globalTimeline: l,
                    core: {
                        PropTween: di,
                        globals: Z,
                        Tween: Zt,
                        Timeline: zt,
                        Animation: Ht,
                        getCache: de,
                        _removeLinkedListItem: Le,
                        reverting: function() {
                            return a
                        },
                        context: function(e) {
                            return e && o && (o.data.push(e), e._ctx = o), o
                        },
                        suppressOverwrites: function(e) {
                            return s = e
                        }
                    }
                };
            fe("to,from,fromTo,delayedCall,set,killTweensOf", (function(e) {
                return Ti[e] = Zt[e]
            })), Mt.add(zt.updateRoot), f = Ti.to({}, {
                duration: 0
            });
            var xi = function(e, t) {
                    for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t;) i = i._next;
                    return i
                },
                wi = function(e, t) {
                    return {
                        name: e,
                        rawVars: 1,
                        init: function(e, i, n) {
                            n._onInit = function(e) {
                                var n, r;
                                if (I(i) && (n = {}, fe(i, (function(e) {
                                        return n[e] = 1
                                    })), i = n), t) {
                                    for (r in n = {}, i) n[r] = t(i[r]);
                                    i = n
                                }! function(e, t) {
                                    var i, n, r, s = e._targets;
                                    for (i in t)
                                        for (n = s.length; n--;)(r = e._ptLookup[n][i]) && (r = r.d) && (r._pt && (r = xi(r, i)), r && r.modifier && r.modifier(t[i], e, s[n], i))
                                }(e, i)
                            }
                        }
                    }
                },
                Si = Ti.registerPlugin({
                    name: "attr",
                    init: function(e, t, i, n, r) {
                        var s, a, o;
                        for (s in this.tween = i, t) o = e.getAttribute(s) || "", (a = this.add(e, "setAttribute", (o || 0) + "", t[s], n, r, 0, 0, s)).op = s, a.b = o, this._props.push(s)
                    },
                    render: function(e, t) {
                        for (var i = t._pt; i;) a ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next
                    }
                }, {
                    name: "endArray",
                    init: function(e, t) {
                        for (var i = t.length; i--;) this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1)
                    }
                }, wi("roundProps", ot), wi("modifiers"), wi("snap", lt)) || Ti;
            Zt.version = zt.version = Si.version = "3.11.4", d = 1, N() && Ct();
            At.Power0, At.Power1, At.Power2, At.Power3, At.Power4, At.Linear, At.Quad, At.Cubic, At.Quart, At.Quint, At.Strong, At.Elastic, At.Back, At.SteppedEase, At.Bounce, At.Sine, At.Expo, At.Circ;
            var Ei, Mi, Ci, Ai, Li, Ii, Pi, Ri, ki = {},
                Di = 180 / Math.PI,
                Oi = Math.PI / 180,
                Ni = Math.atan2,
                Ui = /([A-Z])/g,
                Bi = /(left|right|width|margin|padding|x)/i,
                Fi = /[\s,\(]\S/,
                Hi = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                zi = function(e, t) {
                    return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
                },
                Vi = function(e, t) {
                    return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
                },
                Gi = function(e, t) {
                    return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
                },
                Wi = function(e, t) {
                    var i = t.s + t.c * e;
                    t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
                },
                ji = function(e, t) {
                    return t.set(t.t, t.p, e ? t.e : t.b, t)
                },
                qi = function(e, t) {
                    return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
                },
                $i = function(e, t, i) {
                    return e.style[t] = i
                },
                Xi = function(e, t, i) {
                    return e.style.setProperty(t, i)
                },
                Yi = function(e, t, i) {
                    return e._gsap[t] = i
                },
                Ki = function(e, t, i) {
                    return e._gsap.scaleX = e._gsap.scaleY = i
                },
                Ji = function(e, t, i, n, r) {
                    var s = e._gsap;
                    s.scaleX = s.scaleY = i, s.renderTransform(r, s)
                },
                Zi = function(e, t, i, n, r) {
                    var s = e._gsap;
                    s[t] = i, s.renderTransform(r, s)
                },
                Qi = "transform",
                en = Qi + "Origin",
                tn = function(e, t) {
                    var i = this,
                        n = this.target,
                        r = n.style;
                    if (e in ki) {
                        if (this.tfm = this.tfm || {}, "transform" !== e && (~(e = Hi[e] || e).indexOf(",") ? e.split(",").forEach((function(e) {
                                return i.tfm[e] = bn(n, e)
                            })) : this.tfm[e] = n._gsap.x ? n._gsap[e] : bn(n, e)), this.props.indexOf(Qi) >= 0) return;
                        n._gsap.svg && (this.svgo = n.getAttribute("data-svg-origin"), this.props.push(en, t, "")), e = Qi
                    }(r || t) && this.props.push(e, t, r[e])
                },
                nn = function(e) {
                    e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
                },
                rn = function() {
                    var e, t, i = this.props,
                        n = this.target,
                        r = n.style,
                        s = n._gsap;
                    for (e = 0; e < i.length; e += 3) i[e + 1] ? n[i[e]] = i[e + 2] : i[e + 2] ? r[i[e]] = i[e + 2] : r.removeProperty(i[e].replace(Ui, "-$1").toLowerCase());
                    if (this.tfm) {
                        for (t in this.tfm) s[t] = this.tfm[t];
                        s.svg && (s.renderTransform(), n.setAttribute("data-svg-origin", this.svgo || "")), !(e = Pi()) || e.isStart || r[Qi] || (nn(r), s.uncache = 1)
                    }
                },
                sn = function(e, t) {
                    var i = {
                        target: e,
                        props: [],
                        revert: rn,
                        save: tn
                    };
                    return t && t.split(",").forEach((function(e) {
                        return i.save(e)
                    })), i
                },
                an = function(e, t) {
                    var i = Mi.createElementNS ? Mi.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Mi.createElement(e);
                    return i.style ? i : Mi.createElement(e)
                },
                on = function e(t, i, n) {
                    var r = getComputedStyle(t);
                    return r[i] || r.getPropertyValue(i.replace(Ui, "-$1").toLowerCase()) || r.getPropertyValue(i) || !n && e(t, hn(i) || i, 1) || ""
                },
                ln = "O,Moz,ms,Ms,Webkit".split(","),
                hn = function(e, t, i) {
                    var n = (t || Li).style,
                        r = 5;
                    if (e in n && !i) return e;
                    for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(ln[r] + e in n););
                    return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? ln[r] : "") + e
                },
                cn = function() {
                    "undefined" != typeof window && window.document && (Ei = window, Mi = Ei.document, Ci = Mi.documentElement, Li = an("div") || {
                        style: {}
                    }, an("div"), Qi = hn(Qi), en = Qi + "Origin", Li.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Ri = !!hn("perspective"), Pi = Si.core.reverting, Ai = 1)
                },
                un = function e(t) {
                    var i, n = an("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                        r = this.parentNode,
                        s = this.nextSibling,
                        a = this.style.cssText;
                    if (Ci.appendChild(n), n.appendChild(this), this.style.display = "block", t) try {
                        i = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = e
                    } catch (e) {} else this._gsapBBox && (i = this._gsapBBox());
                    return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), Ci.removeChild(n), this.style.cssText = a, i
                },
                dn = function(e, t) {
                    for (var i = t.length; i--;)
                        if (e.hasAttribute(t[i])) return e.getAttribute(t[i])
                },
                pn = function(e) {
                    var t;
                    try {
                        t = e.getBBox()
                    } catch (i) {
                        t = un.call(e, !0)
                    }
                    return t && (t.width || t.height) || e.getBBox === un || (t = un.call(e, !0)), !t || t.width || t.x || t.y ? t : {
                        x: +dn(e, ["x", "cx", "x1"]) || 0,
                        y: +dn(e, ["y", "cy", "y1"]) || 0,
                        width: 0,
                        height: 0
                    }
                },
                fn = function(e) {
                    return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !pn(e))
                },
                mn = function(e, t) {
                    if (t) {
                        var i = e.style;
                        t in ki && t !== en && (t = Qi), i.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), i.removeProperty(t.replace(Ui, "-$1").toLowerCase())) : i.removeAttribute(t)
                    }
                },
                gn = function(e, t, i, n, r, s) {
                    var a = new di(e._pt, t, i, 0, 1, s ? qi : ji);
                    return e._pt = a, a.b = n, a.e = r, e._props.push(i), a
                },
                yn = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                _n = {
                    grid: 1,
                    flex: 1
                },
                vn = function e(t, i, n, r) {
                    var s, a, o, l, h = parseFloat(n) || 0,
                        c = (n + "").trim().substr((h + "").length) || "px",
                        u = Li.style,
                        d = Bi.test(i),
                        p = "svg" === t.tagName.toLowerCase(),
                        f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
                        m = 100,
                        g = "px" === r,
                        y = "%" === r;
                    return r === c || !h || yn[r] || yn[c] ? h : ("px" !== c && !g && (h = e(t, i, n, "px")), l = t.getCTM && fn(t), !y && "%" !== c || !ki[i] && !~i.indexOf("adius") ? (u[d ? "width" : "height"] = m + (g ? c : r), a = ~i.indexOf("adius") || "em" === r && t.appendChild && !p ? t : t.parentNode, l && (a = (t.ownerSVGElement || {}).parentNode), a && a !== Mi && a.appendChild || (a = Mi.body), (o = a._gsap) && y && o.width && d && o.time === Mt.time && !o.uncache ? me(h / o.width * m) : ((y || "%" === c) && !_n[on(a, "display")] && (u.position = on(t, "position")), a === t && (u.position = "static"), a.appendChild(Li), s = Li[f], a.removeChild(Li), u.position = "absolute", d && y && ((o = de(a)).time = Mt.time, o.width = a[f]), me(g ? s * h / m : s && h ? m / s * h : 0))) : (s = l ? t.getBBox()[d ? "width" : "height"] : t[f], me(y ? h / s * m : h / 100 * s)))
                },
                bn = function(e, t, i, n) {
                    var r;
                    return Ai || cn(), t in Hi && "transform" !== t && ~(t = Hi[t]).indexOf(",") && (t = t.split(",")[0]), ki[t] && "transform" !== t ? (r = Pn(e, n), r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : Rn(on(e, en)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || n || ~(r + "").indexOf("calc(")) && (r = Sn[t] && Sn[t](e, t, i) || on(e, t) || pe(e, t) || ("opacity" === t ? 1 : 0)), i && !~(r + "").trim().indexOf(" ") ? vn(e, t, r, i) + i : r
                },
                Tn = function(e, t, i, n) {
                    if (!i || "none" === i) {
                        var r = hn(t, e, 1),
                            s = r && on(e, r, 1);
                        s && s !== i ? (t = r, i = s) : "borderColor" === t && (i = on(e, "borderTopColor"))
                    }
                    var a, o, l, h, c, u, d, p, f, m, g, y = new di(this._pt, e.style, t, 0, 1, ai),
                        _ = 0,
                        v = 0;
                    if (y.b = i, y.e = n, i += "", "auto" === (n += "") && (e.style[t] = n, n = on(e, t) || n, e.style[t] = i), Et(a = [i, n]), n = a[1], l = (i = a[0]).match(V) || [], (n.match(V) || []).length) {
                        for (; o = V.exec(n);) d = o[0], f = n.substring(_, o.index), c ? c = (c + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (c = 1), d !== (u = l[v++] || "") && (h = parseFloat(u) || 0, g = u.substr((h + "").length), "=" === d.charAt(1) && (d = ye(h, d) + g), p = parseFloat(d), m = d.substr((p + "").length), _ = V.lastIndex - m.length, m || (m = m || b.units[t] || g, _ === n.length && (n += m, y.e += m)), g !== m && (h = vn(e, t, u, m) || 0), y._pt = {
                            _next: y._pt,
                            p: f || 1 === v ? f : ",",
                            s: h,
                            c: p - h,
                            m: c && c < 4 || "zIndex" === t ? Math.round : 0
                        });
                        y.c = _ < n.length ? n.substring(_, n.length) : ""
                    } else y.r = "display" === t && "none" === n ? qi : ji;
                    return W.test(n) && (y.e = 0), this._pt = y, y
                },
                xn = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                wn = function(e, t) {
                    if (t.tween && t.tween._time === t.tween._dur) {
                        var i, n, r, s = t.t,
                            a = s.style,
                            o = t.u,
                            l = s._gsap;
                        if ("all" === o || !0 === o) a.cssText = "", n = 1;
                        else
                            for (r = (o = o.split(",")).length; --r > -1;) i = o[r], ki[i] && (n = 1, i = "transformOrigin" === i ? en : Qi), mn(s, i);
                        n && (mn(s, Qi), l && (l.svg && s.removeAttribute("transform"), Pn(s, 1), l.uncache = 1, nn(a)))
                    }
                },
                Sn = {
                    clearProps: function(e, t, i, n, r) {
                        if ("isFromStart" !== r.data) {
                            var s = e._pt = new di(e._pt, t, i, 0, 0, wn);
                            return s.u = n, s.pr = -10, s.tween = r, e._props.push(i), 1
                        }
                    }
                },
                En = [1, 0, 0, 1, 0, 0],
                Mn = {},
                Cn = function(e) {
                    return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
                },
                An = function(e) {
                    var t = on(e, Qi);
                    return Cn(t) ? En : t.substr(7).match(z).map(me)
                },
                Ln = function(e, t) {
                    var i, n, r, s, a = e._gsap || de(e),
                        o = e.style,
                        l = An(e);
                    return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? En : l : (l !== En || e.offsetParent || e === Ci || a.svg || (r = o.display, o.display = "block", (i = e.parentNode) && e.offsetParent || (s = 1, n = e.nextElementSibling, Ci.appendChild(e)), l = An(e), r ? o.display = r : mn(e, "display"), s && (n ? i.insertBefore(e, n) : i ? i.appendChild(e) : Ci.removeChild(e))), t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
                },
                In = function(e, t, i, n, r, s) {
                    var a, o, l, h = e._gsap,
                        c = r || Ln(e, !0),
                        u = h.xOrigin || 0,
                        d = h.yOrigin || 0,
                        p = h.xOffset || 0,
                        f = h.yOffset || 0,
                        m = c[0],
                        g = c[1],
                        y = c[2],
                        _ = c[3],
                        v = c[4],
                        b = c[5],
                        T = t.split(" "),
                        x = parseFloat(T[0]) || 0,
                        w = parseFloat(T[1]) || 0;
                    i ? c !== En && (o = m * _ - g * y) && (l = x * (-g / o) + w * (m / o) - (m * b - g * v) / o, x = x * (_ / o) + w * (-y / o) + (y * b - _ * v) / o, w = l) : (x = (a = pn(e)).x + (~T[0].indexOf("%") ? x / 100 * a.width : x), w = a.y + (~(T[1] || T[0]).indexOf("%") ? w / 100 * a.height : w)), n || !1 !== n && h.smooth ? (v = x - u, b = w - d, h.xOffset = p + (v * m + b * y) - v, h.yOffset = f + (v * g + b * _) - b) : h.xOffset = h.yOffset = 0, h.xOrigin = x, h.yOrigin = w, h.smooth = !!n, h.origin = t, h.originIsAbsolute = !!i, e.style[en] = "0px 0px", s && (gn(s, h, "xOrigin", u, x), gn(s, h, "yOrigin", d, w), gn(s, h, "xOffset", p, h.xOffset), gn(s, h, "yOffset", f, h.yOffset)), e.setAttribute("data-svg-origin", x + " " + w)
                },
                Pn = function(e, t) {
                    var i = e._gsap || new Ft(e);
                    if ("x" in i && !t && !i.uncache) return i;
                    var n, r, s, a, o, l, h, c, u, d, p, f, m, g, y, _, v, T, x, w, S, E, M, C, A, L, I, P, R, k, D, O, N = e.style,
                        U = i.scaleX < 0,
                        B = "px",
                        F = "deg",
                        H = getComputedStyle(e),
                        z = on(e, en) || "0";
                    return n = r = s = l = h = c = u = d = p = 0, a = o = 1, i.svg = !(!e.getCTM || !fn(e)), H.translate && ("none" === H.translate && "none" === H.scale && "none" === H.rotate || (N[Qi] = ("none" !== H.translate ? "translate3d(" + (H.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== H.rotate ? "rotate(" + H.rotate + ") " : "") + ("none" !== H.scale ? "scale(" + H.scale.split(" ").join(",") + ") " : "") + ("none" !== H[Qi] ? H[Qi] : "")), N.scale = N.rotate = N.translate = "none"), g = Ln(e, i.svg), i.svg && (i.uncache ? (A = e.getBBox(), z = i.xOrigin - A.x + "px " + (i.yOrigin - A.y) + "px", C = "") : C = !t && e.getAttribute("data-svg-origin"), In(e, C || z, !!C || i.originIsAbsolute, !1 !== i.smooth, g)), f = i.xOrigin || 0, m = i.yOrigin || 0, g !== En && (T = g[0], x = g[1], w = g[2], S = g[3], n = E = g[4], r = M = g[5], 6 === g.length ? (a = Math.sqrt(T * T + x * x), o = Math.sqrt(S * S + w * w), l = T || x ? Ni(x, T) * Di : 0, (u = w || S ? Ni(w, S) * Di + l : 0) && (o *= Math.abs(Math.cos(u * Oi))), i.svg && (n -= f - (f * T + m * w), r -= m - (f * x + m * S))) : (O = g[6], k = g[7], I = g[8], P = g[9], R = g[10], D = g[11], n = g[12], r = g[13], s = g[14], h = (y = Ni(O, R)) * Di, y && (C = E * (_ = Math.cos(-y)) + I * (v = Math.sin(-y)), A = M * _ + P * v, L = O * _ + R * v, I = E * -v + I * _, P = M * -v + P * _, R = O * -v + R * _, D = k * -v + D * _, E = C, M = A, O = L), c = (y = Ni(-w, R)) * Di, y && (_ = Math.cos(-y), D = S * (v = Math.sin(-y)) + D * _, T = C = T * _ - I * v, x = A = x * _ - P * v, w = L = w * _ - R * v), l = (y = Ni(x, T)) * Di, y && (C = T * (_ = Math.cos(y)) + x * (v = Math.sin(y)), A = E * _ + M * v, x = x * _ - T * v, M = M * _ - E * v, T = C, E = A), h && Math.abs(h) + Math.abs(l) > 359.9 && (h = l = 0, c = 180 - c), a = me(Math.sqrt(T * T + x * x + w * w)), o = me(Math.sqrt(M * M + O * O)), y = Ni(E, M), u = Math.abs(y) > 2e-4 ? y * Di : 0, p = D ? 1 / (D < 0 ? -D : D) : 0), i.svg && (C = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !Cn(on(e, Qi)), C && e.setAttribute("transform", C))), Math.abs(u) > 90 && Math.abs(u) < 270 && (U ? (a *= -1, u += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, u += u <= 0 ? 180 : -180)), t = t || i.uncache, i.x = n - ((i.xPercent = n && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + B, i.y = r - ((i.yPercent = r && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + B, i.z = s + B, i.scaleX = me(a), i.scaleY = me(o), i.rotation = me(l) + F, i.rotationX = me(h) + F, i.rotationY = me(c) + F, i.skewX = u + F, i.skewY = d + F, i.transformPerspective = p + B, (i.zOrigin = parseFloat(z.split(" ")[2]) || 0) && (N[en] = Rn(z)), i.xOffset = i.yOffset = 0, i.force3D = b.force3D, i.renderTransform = i.svg ? Fn : Ri ? Bn : Dn, i.uncache = 0, i
                },
                Rn = function(e) {
                    return (e = e.split(" "))[0] + " " + e[1]
                },
                kn = function(e, t, i) {
                    var n = Qe(t);
                    return me(parseFloat(t) + parseFloat(vn(e, "x", i + "px", n))) + n
                },
                Dn = function(e, t) {
                    t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Bn(e, t)
                },
                On = "0deg",
                Nn = "0px",
                Un = ") ",
                Bn = function(e, t) {
                    var i = t || this,
                        n = i.xPercent,
                        r = i.yPercent,
                        s = i.x,
                        a = i.y,
                        o = i.z,
                        l = i.rotation,
                        h = i.rotationY,
                        c = i.rotationX,
                        u = i.skewX,
                        d = i.skewY,
                        p = i.scaleX,
                        f = i.scaleY,
                        m = i.transformPerspective,
                        g = i.force3D,
                        y = i.target,
                        _ = i.zOrigin,
                        v = "",
                        b = "auto" === g && e && 1 !== e || !0 === g;
                    if (_ && (c !== On || h !== On)) {
                        var T, x = parseFloat(h) * Oi,
                            w = Math.sin(x),
                            S = Math.cos(x);
                        x = parseFloat(c) * Oi, T = Math.cos(x), s = kn(y, s, w * T * -_), a = kn(y, a, -Math.sin(x) * -_), o = kn(y, o, S * T * -_ + _)
                    }
                    m !== Nn && (v += "perspective(" + m + Un), (n || r) && (v += "translate(" + n + "%, " + r + "%) "), (b || s !== Nn || a !== Nn || o !== Nn) && (v += o !== Nn || b ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + Un), l !== On && (v += "rotate(" + l + Un), h !== On && (v += "rotateY(" + h + Un), c !== On && (v += "rotateX(" + c + Un), u === On && d === On || (v += "skew(" + u + ", " + d + Un), 1 === p && 1 === f || (v += "scale(" + p + ", " + f + Un), y.style[Qi] = v || "translate(0, 0)"
                },
                Fn = function(e, t) {
                    var i, n, r, s, a, o = t || this,
                        l = o.xPercent,
                        h = o.yPercent,
                        c = o.x,
                        u = o.y,
                        d = o.rotation,
                        p = o.skewX,
                        f = o.skewY,
                        m = o.scaleX,
                        g = o.scaleY,
                        y = o.target,
                        _ = o.xOrigin,
                        v = o.yOrigin,
                        b = o.xOffset,
                        T = o.yOffset,
                        x = o.forceCSS,
                        w = parseFloat(c),
                        S = parseFloat(u);
                    d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= Oi, p *= Oi, i = Math.cos(d) * m, n = Math.sin(d) * m, r = Math.sin(d - p) * -g, s = Math.cos(d - p) * g, p && (f *= Oi, a = Math.tan(p - f), r *= a = Math.sqrt(1 + a * a), s *= a, f && (a = Math.tan(f), i *= a = Math.sqrt(1 + a * a), n *= a)), i = me(i), n = me(n), r = me(r), s = me(s)) : (i = m, s = g, n = r = 0), (w && !~(c + "").indexOf("px") || S && !~(u + "").indexOf("px")) && (w = vn(y, "x", c, "px"), S = vn(y, "y", u, "px")), (_ || v || b || T) && (w = me(w + _ - (_ * i + v * r) + b), S = me(S + v - (_ * n + v * s) + T)), (l || h) && (a = y.getBBox(), w = me(w + l / 100 * a.width), S = me(S + h / 100 * a.height)), a = "matrix(" + i + "," + n + "," + r + "," + s + "," + w + "," + S + ")", y.setAttribute("transform", a), x && (y.style[Qi] = a)
                },
                Hn = function(e, t, i, n, r) {
                    var s, a, o = 360,
                        l = I(r),
                        h = parseFloat(r) * (l && ~r.indexOf("rad") ? Di : 1) - n,
                        c = n + h + "deg";
                    return l && ("short" === (s = r.split("_")[1]) && (h %= o) !== h % 180 && (h += h < 0 ? o : -360), "cw" === s && h < 0 ? h = (h + 36e9) % o - ~~(h / o) * o : "ccw" === s && h > 0 && (h = (h - 36e9) % o - ~~(h / o) * o)), e._pt = a = new di(e._pt, t, i, n, h, Vi), a.e = c, a.u = "deg", e._props.push(i), a
                },
                zn = function(e, t) {
                    for (var i in t) e[i] = t[i];
                    return e
                },
                Vn = function(e, t, i) {
                    var n, r, s, a, o, l, h, c = zn({}, i._gsap),
                        u = i.style;
                    for (r in c.svg ? (s = i.getAttribute("transform"), i.setAttribute("transform", ""), u[Qi] = t, n = Pn(i, 1), mn(i, Qi), i.setAttribute("transform", s)) : (s = getComputedStyle(i)[Qi], u[Qi] = t, n = Pn(i, 1), u[Qi] = s), ki)(s = c[r]) !== (a = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = Qe(s) !== (h = Qe(a)) ? vn(i, r, s, h) : parseFloat(s), l = parseFloat(a), e._pt = new di(e._pt, n, r, o, l - o, zi), e._pt.u = h || 0, e._props.push(r));
                    zn(n, c)
                };
            fe("padding,margin,Width,Radius", (function(e, t) {
                var i = "Top",
                    n = "Right",
                    r = "Bottom",
                    s = "Left",
                    a = (t < 3 ? [i, n, r, s] : [i + s, i + n, r + n, r + s]).map((function(i) {
                        return t < 2 ? e + i : "border" + i + e
                    }));
                Sn[t > 1 ? "border" + e : e] = function(e, t, i, n, r) {
                    var s, o;
                    if (arguments.length < 4) return s = a.map((function(t) {
                        return bn(e, t, i)
                    })), 5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o;
                    s = (n + "").split(" "), o = {}, a.forEach((function(e, t) {
                        return o[e] = s[t] = s[t] || s[(t - 1) / 2 | 0]
                    })), e.init(t, o, r)
                }
            }));
            var Gn, Wn, jn, qn = {
                name: "css",
                register: cn,
                targetTest: function(e) {
                    return e.style && e.nodeType
                },
                init: function(e, t, i, n, r) {
                    var s, a, o, l, h, c, u, d, p, f, m, g, y, _, v, T, x, w, S, E, M = this._props,
                        C = e.style,
                        A = i.vars.startAt;
                    for (u in Ai || cn(), this.styles = this.styles || sn(e), T = this.styles.props, this.tween = i, t)
                        if ("autoRound" !== u && (a = t[u], !ae[u] || !qt(u, t, i, n, e, r)))
                            if (h = typeof a, c = Sn[u], "function" === h && (h = typeof(a = a.call(i, n, e, r))), "string" === h && ~a.indexOf("random(") && (a = ut(a)), c) c(this, e, u, a, i) && (v = 1);
                            else if ("--" === u.substr(0, 2)) s = (getComputedStyle(e).getPropertyValue(u) + "").trim(), a += "", wt.lastIndex = 0, wt.test(s) || (d = Qe(s), p = Qe(a)), p ? d !== p && (s = vn(e, u, s, p) + p) : d && (a += d), this.add(C, "setProperty", s, a, n, r, 0, 0, u), M.push(u), T.push(u, 0, C[u]);
                    else if ("undefined" !== h) {
                        if (A && u in A ? (s = "function" == typeof A[u] ? A[u].call(i, n, e, r) : A[u], I(s) && ~s.indexOf("random(") && (s = ut(s)), Qe(s + "") || (s += b.units[u] || Qe(bn(e, u)) || ""), "=" === (s + "").charAt(1) && (s = bn(e, u))) : s = bn(e, u), l = parseFloat(s), (f = "string" === h && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)), o = parseFloat(a), u in Hi && ("autoAlpha" === u && (1 === l && "hidden" === bn(e, "visibility") && o && (l = 0), T.push("visibility", 0, C.visibility), gn(this, C, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== u && "transform" !== u && ~(u = Hi[u]).indexOf(",") && (u = u.split(",")[0])), m = u in ki)
                            if (this.styles.save(u), g || ((y = e._gsap).renderTransform && !t.parseTransform || Pn(e, t.parseTransform), _ = !1 !== t.smoothOrigin && y.smooth, (g = this._pt = new di(this._pt, C, Qi, 0, 1, y.renderTransform, y, 0, -1)).dep = 1), "scale" === u) this._pt = new di(this._pt, y, "scaleY", y.scaleY, (f ? ye(y.scaleY, f + o) : o) - y.scaleY || 0, zi), this._pt.u = 0, M.push("scaleY", u), u += "X";
                            else {
                                if ("transformOrigin" === u) {
                                    T.push(en, 0, C[en]), w = void 0, S = void 0, E = void 0, w = (x = a).split(" "), S = w[0], E = w[1] || "50%", "top" !== S && "bottom" !== S && "left" !== E && "right" !== E || (x = S, S = E, E = x), w[0] = xn[S] || S, w[1] = xn[E] || E, a = w.join(" "), y.svg ? In(e, a, 0, _, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== y.zOrigin && gn(this, y, "zOrigin", y.zOrigin, p), gn(this, C, u, Rn(s), Rn(a)));
                                    continue
                                }
                                if ("svgOrigin" === u) {
                                    In(e, a, 1, _, 0, this);
                                    continue
                                }
                                if (u in Mn) {
                                    Hn(this, y, u, l, f ? ye(l, f + a) : a);
                                    continue
                                }
                                if ("smoothOrigin" === u) {
                                    gn(this, y, "smooth", y.smooth, a);
                                    continue
                                }
                                if ("force3D" === u) {
                                    y[u] = a;
                                    continue
                                }
                                if ("transform" === u) {
                                    Vn(this, a, e);
                                    continue
                                }
                            }
                        else u in C || (u = hn(u) || u);
                        if (m || (o || 0 === o) && (l || 0 === l) && !Fi.test(a) && u in C) o || (o = 0), (d = (s + "").substr((l + "").length)) !== (p = Qe(a) || (u in b.units ? b.units[u] : d)) && (l = vn(e, u, s, p)), this._pt = new di(this._pt, m ? y : C, u, l, (f ? ye(l, f + o) : o) - l, m || "px" !== p && "zIndex" !== u || !1 === t.autoRound ? zi : Wi), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = s, this._pt.r = Gi);
                        else if (u in C) Tn.call(this, e, u, s, f ? f + a : a);
                        else if (u in e) this.add(e, u, s || e[u], f ? f + a : a, n, r);
                        else if ("parseTransform" !== u) {
                            K(u, a);
                            continue
                        }
                        m || (u in C ? T.push(u, 0, C[u]) : T.push(u, 1, s || e[u])), M.push(u)
                    }
                    v && ui(this)
                },
                render: function(e, t) {
                    if (t.tween._time || !Pi())
                        for (var i = t._pt; i;) i.r(e, i.d), i = i._next;
                    else t.styles.revert()
                },
                get: bn,
                aliases: Hi,
                getSetter: function(e, t, i) {
                    var n = Hi[t];
                    return n && n.indexOf(",") < 0 && (t = n), t in ki && t !== en && (e._gsap.x || bn(e, "x")) ? i && Ii === i ? "scale" === t ? Ki : Yi : (Ii = i || {}) && ("scale" === t ? Ji : Zi) : e.style && !k(e.style[t]) ? $i : ~t.indexOf("-") ? Xi : ni(e, t)
                },
                core: {
                    _removeProperty: mn,
                    _getMatrix: Ln
                }
            };
            Si.utils.checkPrefix = hn, Si.core.getStyleSaver = sn, jn = fe((Gn = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Wn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(e) {
                ki[e] = 1
            })), fe(Wn, (function(e) {
                b.units[e] = "deg", Mn[e] = 1
            })), Hi[jn[13]] = Gn + "," + Wn, fe("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(e) {
                var t = e.split(":");
                Hi[t[1]] = jn[t[0]]
            })), fe("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(e) {
                b.units[e] = "px"
            })), Si.registerPlugin(qn);
            var $n = Si.registerPlugin(qn) || Si;
            $n.core.Tween
        },
        9350: (e, t) => {
            t.read = function(e, t, i, n, r) {
                var s, a, o = 8 * r - n - 1,
                    l = (1 << o) - 1,
                    h = l >> 1,
                    c = -7,
                    u = i ? r - 1 : 0,
                    d = i ? -1 : 1,
                    p = e[t + u];
                for (u += d, s = p & (1 << -c) - 1, p >>= -c, c += o; c > 0; s = 256 * s + e[t + u], u += d, c -= 8);
                for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + e[t + u], u += d, c -= 8);
                if (0 === s) s = 1 - h;
                else {
                    if (s === l) return a ? NaN : 1 / 0 * (p ? -1 : 1);
                    a += Math.pow(2, n), s -= h
                }
                return (p ? -1 : 1) * a * Math.pow(2, s - n)
            }, t.write = function(e, t, i, n, r, s) {
                var a, o, l, h = 8 * s - r - 1,
                    c = (1 << h) - 1,
                    u = c >> 1,
                    d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    p = n ? 0 : s - 1,
                    f = n ? 1 : -1,
                    m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, a = c) : (a = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (t += a + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 && (a++, l /= 2), a + u >= c ? (o = 0, a = c) : a + u >= 1 ? (o = (t * l - 1) * Math.pow(2, r), a += u) : (o = t * Math.pow(2, u - 1) * Math.pow(2, r), a = 0)); r >= 8; e[i + p] = 255 & o, p += f, o /= 256, r -= 8);
                for (a = a << r | o, h += r; h > 0; e[i + p] = 255 & a, p += f, a /= 256, h -= 8);
                e[i + p - f] |= 128 * m
            }
        },
        6534: e => {
            e.exports = function(e) {
                if (!e) return !1;
                var i = t.call(e);
                return "[object Function]" === i || "function" == typeof e && "[object RegExp]" !== i || "undefined" != typeof window && (e === window.setTimeout || e === window.alert || e === window.confirm || e === window.prompt)
            };
            var t = Object.prototype.toString
        },
        2895: (e, t) => {
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.default = function() {
                return !("undefined" == typeof window || !("ontouchstart" in window || window.DocumentTouch && "undefined" != typeof document && document instanceof window.DocumentTouch)) || !("undefined" == typeof navigator || !navigator.maxTouchPoints && !navigator.msMaxTouchPoints)
            }, e.exports = t.default
        },
        7815: (e, t, i) => {
            "use strict";
            i.d(t, {
                Z: () => v
            });
            var n = /iPhone/i,
                r = /iPod/i,
                s = /iPad/i,
                a = /\biOS-universal(?:.+)Mac\b/i,
                o = /\bAndroid(?:.+)Mobile\b/i,
                l = /Android/i,
                h = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
                c = /Silk/i,
                u = /Windows Phone/i,
                d = /\bWindows(?:.+)ARM\b/i,
                p = /BlackBerry/i,
                f = /BB10/i,
                m = /Opera Mini/i,
                g = /\b(CriOS|Chrome)(?:.+)Mobile/i,
                y = /Mobile(?:.+)Firefox\b/i,
                _ = function(e) {
                    return void 0 !== e && "MacIntel" === e.platform && "number" == typeof e.maxTouchPoints && e.maxTouchPoints > 1 && "undefined" == typeof MSStream
                };

            function v(e) {
                var t = {
                    userAgent: "",
                    platform: "",
                    maxTouchPoints: 0
                };
                e || "undefined" == typeof navigator ? "string" == typeof e ? t.userAgent = e : e && e.userAgent && (t = {
                    userAgent: e.userAgent,
                    platform: e.platform,
                    maxTouchPoints: e.maxTouchPoints || 0
                }) : t = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    maxTouchPoints: navigator.maxTouchPoints || 0
                };
                var i = t.userAgent,
                    v = i.split("[FBAN");
                void 0 !== v[1] && (i = v[0]), void 0 !== (v = i.split("Twitter"))[1] && (i = v[0]);
                var b = function(e) {
                        return function(t) {
                            return t.test(e)
                        }
                    }(i),
                    T = {
                        apple: {
                            phone: b(n) && !b(u),
                            ipod: b(r),
                            tablet: !b(n) && (b(s) || _(t)) && !b(u),
                            universal: b(a),
                            device: (b(n) || b(r) || b(s) || b(a) || _(t)) && !b(u)
                        },
                        amazon: {
                            phone: b(h),
                            tablet: !b(h) && b(c),
                            device: b(h) || b(c)
                        },
                        android: {
                            phone: !b(u) && b(h) || !b(u) && b(o),
                            tablet: !b(u) && !b(h) && !b(o) && (b(c) || b(l)),
                            device: !b(u) && (b(h) || b(c) || b(o) || b(l)) || b(/\bokhttp\b/i)
                        },
                        windows: {
                            phone: b(u),
                            tablet: b(d),
                            device: b(u) || b(d)
                        },
                        other: {
                            blackberry: b(p),
                            blackberry10: b(f),
                            opera: b(m),
                            firefox: b(y),
                            chrome: b(g),
                            device: b(p) || b(f) || b(m) || b(y) || b(g)
                        },
                        any: !1,
                        phone: !1,
                        tablet: !1
                    };
                return T.any = T.apple.device || T.android.device || T.windows.device || T.other.device, T.phone = T.apple.phone || T.android.phone || T.windows.phone, T.tablet = T.apple.tablet || T.android.tablet || T.windows.tablet, T
            }
        },
        1740: (e, t) => {
            function i(e) {
                if (e && "object" == typeof e) {
                    var t = e.which || e.keyCode || e.charCode;
                    t && (e = t)
                }
                if ("number" == typeof e) return a[e];
                var i, s = String(e);
                return (i = n[s.toLowerCase()]) ? i : (i = r[s.toLowerCase()]) || (1 === s.length ? s.charCodeAt(0) : void 0)
            }
            i.isEventKey = function(e, t) {
                if (e && "object" == typeof e) {
                    var i = e.which || e.keyCode || e.charCode;
                    if (null == i) return !1;
                    if ("string" == typeof t) {
                        var s;
                        if (s = n[t.toLowerCase()]) return s === i;
                        if (s = r[t.toLowerCase()]) return s === i
                    } else if ("number" == typeof t) return t === i;
                    return !1
                }
            };
            var n = (t = e.exports = i).code = t.codes = {
                    backspace: 8,
                    tab: 9,
                    enter: 13,
                    shift: 16,
                    ctrl: 17,
                    alt: 18,
                    "pause/break": 19,
                    "caps lock": 20,
                    esc: 27,
                    space: 32,
                    "page up": 33,
                    "page down": 34,
                    end: 35,
                    home: 36,
                    left: 37,
                    up: 38,
                    right: 39,
                    down: 40,
                    insert: 45,
                    delete: 46,
                    command: 91,
                    "left command": 91,
                    "right command": 93,
                    "numpad *": 106,
                    "numpad +": 107,
                    "numpad -": 109,
                    "numpad .": 110,
                    "numpad /": 111,
                    "num lock": 144,
                    "scroll lock": 145,
                    "my computer": 182,
                    "my calculator": 183,
                    ";": 186,
                    "=": 187,
                    ",": 188,
                    "-": 189,
                    ".": 190,
                    "/": 191,
                    "`": 192,
                    "[": 219,
                    "\\": 220,
                    "]": 221,
                    "'": 222
                },
                r = t.aliases = {
                    windows: 91,
                    "⇧": 16,
                    "⌥": 18,
                    "⌃": 17,
                    "⌘": 91,
                    ctl: 17,
                    control: 17,
                    option: 18,
                    pause: 19,
                    break: 19,
                    caps: 20,
                    return: 13,
                    escape: 27,
                    spc: 32,
                    spacebar: 32,
                    pgup: 33,
                    pgdn: 34,
                    ins: 45,
                    del: 46,
                    cmd: 91
                };
            for (s = 97; s < 123; s++) n[String.fromCharCode(s)] = s - 32;
            for (var s = 48; s < 58; s++) n[s - 48] = s;
            for (s = 1; s < 13; s++) n["f" + s] = s + 111;
            for (s = 0; s < 10; s++) n["numpad " + s] = s + 96;
            var a = t.names = t.title = {};
            for (s in n) a[n[s]] = s;
            for (var o in r) n[o] = r[o]
        },
        7002: e => {
            e.exports = function(e) {
                var t = {},
                    i = [];
                (e = e || this).on = function(i, n, r) {
                    return (t[i] = t[i] || []).push([n, r]), e
                }, e.off = function(n, r) {
                    n || (t = {});
                    for (var s = t[n] || i, a = s.length = r ? s.length : 0; a--;) r == s[a][0] && s.splice(a, 1);
                    return e
                }, e.emit = function(n) {
                    for (var r, s = t[n] || i, a = s.length > 0 ? s.slice(0, s.length) : s, o = 0; r = a[o++];) r[0].apply(r[1], i.slice.call(arguments, 1));
                    return e
                }
            }
        },
        3047: (e, t, i) => {
            var n = i(6109).getUint64;
            e.exports = function(e) {
                var t = new DataView(e.buffer, e.byteOffset, e.byteLength),
                    i = {
                        version: e[0],
                        flags: new Uint8Array(e.subarray(1, 4)),
                        references: [],
                        referenceId: t.getUint32(4),
                        timescale: t.getUint32(8)
                    },
                    r = 12;
                0 === i.version ? (i.earliestPresentationTime = t.getUint32(r), i.firstOffset = t.getUint32(r + 4), r += 8) : (i.earliestPresentationTime = n(e.subarray(r)), i.firstOffset = n(e.subarray(r + 8)), r += 16), r += 2;
                var s = t.getUint16(r);
                for (r += 2; s > 0; r += 12, s--) i.references.push({
                    referenceType: (128 & e[r]) >>> 7,
                    referencedSize: 2147483647 & t.getUint32(r),
                    subsegmentDuration: t.getUint32(r + 4),
                    startsWithSap: !!(128 & e[r + 8]),
                    sapType: (112 & e[r + 8]) >>> 4,
                    sapDeltaTime: 268435455 & t.getUint32(r + 8)
                });
                return i
            }
        },
        5531: e => {
            var t, i, n, r, s, a, o, l = 9e4;
            t = function(e) {
                return e * l
            }, i = function(e, t) {
                return e * t
            }, n = function(e) {
                return e / l
            }, r = function(e, t) {
                return e / t
            }, s = function(e, i) {
                return t(r(e, i))
            }, a = function(e, t) {
                return i(n(e), t)
            }, o = function(e, t, i) {
                return n(i ? e : e - t)
            }, e.exports = {
                ONE_SECOND_IN_TS: l,
                secondsToVideoTs: t,
                secondsToAudioTs: i,
                videoTsToSeconds: n,
                audioTsToSeconds: r,
                audioTsToVideoTs: s,
                videoTsToAudioTs: a,
                metadataTsToSeconds: o
            }
        },
        6109: e => {
            var t = Math.pow(2, 32);
            e.exports = {
                getUint64: function(e) {
                    var i, n = new DataView(e.buffer, e.byteOffset, e.byteLength);
                    return n.getBigUint64 ? (i = n.getBigUint64(0)) < Number.MAX_SAFE_INTEGER ? Number(i) : i : n.getUint32(0) * t + n.getUint32(4)
                },
                MAX_UINT32: t
            }
        },
        1127: e => {
            e.exports = function(e, t) {
                var i, n = null;
                try {
                    i = JSON.parse(e, t)
                } catch (e) {
                    n = e
                }
                return [n, i]
            }
        },
        8388: (e, t, i) => {
            "use strict";

            function n(e, t) {
                return Object.getOwnPropertyNames(Object(e)).reduce(((i, n) => {
                    const r = Object.getOwnPropertyDescriptor(Object(e), n),
                        s = Object.getOwnPropertyDescriptor(Object(t), n);
                    return Object.defineProperty(i, n, s || r)
                }), {})
            }

            function r(e) {
                return "string" == typeof e
            }

            function s(e) {
                return Array.isArray(e)
            }

            function a(e = {}) {
                const t = n(e);
                let i;
                return void 0 !== t.types ? i = t.types : void 0 !== t.split && (i = t.split), void 0 !== i && (t.types = (r(i) || s(i) ? String(i) : "").split(",").map((e => String(e).trim())).filter((e => /((line)|(word)|(char))/i.test(e)))), (t.absolute || t.position) && (t.absolute = t.absolute || /absolute/.test(e.position)), t
            }

            function o(e) {
                const t = r(e) || s(e) ? String(e) : "";
                return {
                    none: !t,
                    lines: /line/i.test(t),
                    words: /word/i.test(t),
                    chars: /char/i.test(t)
                }
            }

            function l(e) {
                return null !== e && "object" == typeof e
            }

            function h(e) {
                return l(e) && /^(1|3|11)$/.test(e.nodeType)
            }

            function c(e) {
                return s(e) ? e : null == e ? [] : function(e) {
                    return l(e) && function(e) {
                        return "number" == typeof e && e > -1 && e % 1 == 0
                    }(e.length)
                }(e) ? Array.prototype.slice.call(e) : [e]
            }

            function u(e) {
                let t = e;
                return r(e) && (t = /^(#[a-z]\w+)$/.test(e.trim()) ? document.getElementById(e.trim().slice(1)) : document.querySelectorAll(e)), c(t).reduce(((e, t) => [...e, ...c(t).filter(h)]), [])
            }
            i.d(t, {
                Z: () => Y
            }), (() => {
                function e(...e) {
                    const t = e.length;
                    for (let i = 0; i < t; i++) {
                        const t = e[i];
                        1 === t.nodeType || 11 === t.nodeType ? this.appendChild(t) : this.appendChild(document.createTextNode(String(t)))
                    }
                }

                function t(...e) {
                    for (; this.lastChild;) this.removeChild(this.lastChild);
                    e.length && this.append(...e)
                }

                function i(...e) {
                    const t = this.parentNode;
                    let i = e.length;
                    if (t)
                        for (i || t.removeChild(this); i--;) {
                            let n = e[i];
                            "object" != typeof n ? n = this.ownerDocument.createTextNode(n) : n.parentNode && n.parentNode.removeChild(n), i ? t.insertBefore(this.previousSibling, n) : t.replaceChild(n, this)
                        }
                }
                "undefined" != typeof Element && (Element.prototype.append || (Element.prototype.append = e, DocumentFragment.prototype.append = e), Element.prototype.replaceChildren || (Element.prototype.replaceChildren = t, DocumentFragment.prototype.replaceChildren = t), Element.prototype.replaceWith || (Element.prototype.replaceWith = i, DocumentFragment.prototype.replaceWith = i))
            })();
            const {
                entries: d,
                keys: p,
                values: f
            } = Object, m = "_splittype", g = {};
            let y = 0;

            function _(e, t, i) {
                if (!l(e)) return console.warn("[data.set] owner is not an object"), null;
                const n = e[m] || (e[m] = ++y),
                    r = g[n] || (g[n] = {});
                return void 0 === i ? t && Object.getPrototypeOf(t) === Object.prototype && (g[n] = { ...r,
                    ...t
                }) : void 0 !== t && (r[t] = i), i
            }

            function v(e, t) {
                const i = l(e) ? e[m] : null,
                    n = i && g[i] || {};
                return void 0 === t ? n : n[t]
            }

            function b(e) {
                const t = e && e[m];
                t && (delete e[t], delete g[t])
            }
            const T = "\\ud800-\\udfff",
                x = "\\u0300-\\u036f\\ufe20-\\ufe23",
                w = "\\u20d0-\\u20f0",
                S = "\\ufe0e\\ufe0f",
                E = `[${T}]`,
                M = `[${x}${w}]`,
                C = "\\ud83c[\\udffb-\\udfff]",
                A = `[^${T}]`,
                L = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                I = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                P = "\\u200d",
                R = `${`(?:${M}|${C})`}?`,
                k = `[${S}]?`,
                D = k + R + ("(?:" + P + "(?:" + [A, L, I].join("|") + ")" + k + R + ")*"),
                O = `(?:${[`${A}${M}?`,M,L,I,E].join("|")}\n)`,
                N = RegExp(`${C}(?=${C})|${O}${D}`, "g"),
                U = RegExp(`[${[P,T,x,w,S].join("")}]`);

            function B(e) {
                return U.test(e)
            }

            function F(e) {
                return B(e) ? function(e) {
                    return e.match(N) || []
                }(e) : function(e) {
                    return e.split("")
                }(e)
            }

            function H(e, t = "") {
                var i;
                return (e = null == (i = e) ? "" : String(i)) && r(e) && !t && B(e) ? F(e) : e.split(t)
            }

            function z(e, t) {
                const i = document.createElement(e);
                return t ? (Object.keys(t).forEach((e => {
                    const n = t[e],
                        s = r(n) ? n.trim() : n;
                    null !== s && "" !== s && ("children" === e ? i.append(...c(s)) : i.setAttribute(e, s))
                })), i) : i
            }
            var V = {
                splitClass: "",
                lineClass: "line",
                wordClass: "word",
                charClass: "char",
                types: ["lines", "words", "chars"],
                absolute: !1,
                tagName: "div"
            };

            function G(e, t) {
                const i = o((t = n(V, t)).types),
                    r = t.tagName,
                    s = e.nodeValue,
                    a = document.createDocumentFragment();
                let l = [],
                    h = [];
                return /^\s/.test(s) && a.append(" "), l = function(e, t = " ") {
                    return (e ? String(e) : "").trim().replace(/\s+/g, " ").split(t)
                }(s).reduce(((e, n, s, o) => {
                    let l, c;
                    return i.chars && (c = H(n).map((e => {
                        const i = z(r, {
                            class: `${t.splitClass} ${t.charClass}`,
                            style: "display: inline-block;",
                            children: e
                        });
                        return _(i, "isChar", !0), h = [...h, i], i
                    }))), i.words || i.lines ? (l = z(r, {
                        class: `${t.wordClass} ${t.splitClass}`,
                        style: "display: inline-block; " + (i.words && t.absolute ? "position: relative;" : ""),
                        children: i.chars ? c : n
                    }), _(l, {
                        isWord: !0,
                        isWordStart: !0,
                        isWordEnd: !0
                    }), a.appendChild(l)) : c.forEach((e => {
                        a.appendChild(e)
                    })), s < o.length - 1 && a.append(" "), i.words ? e.concat(l) : e
                }), []), /\s$/.test(s) && a.append(" "), e.replaceWith(a), {
                    words: l,
                    chars: h
                }
            }

            function W(e, t) {
                const i = e.nodeType,
                    n = {
                        words: [],
                        chars: []
                    };
                if (!/(1|3|11)/.test(i)) return n;
                if (3 === i && /\S/.test(e.nodeValue)) return G(e, t);
                const r = c(e.childNodes);
                if (r.length && (_(e, "isSplit", !0), !v(e).isRoot)) {
                    e.style.display = "inline-block", e.style.position = "relative";
                    const t = e.nextSibling,
                        i = e.previousSibling,
                        n = e.textContent || "",
                        r = t ? t.textContent : " ",
                        s = i ? i.textContent : " ";
                    _(e, {
                        isWordEnd: /\s$/.test(n) || /^\s/.test(r),
                        isWordStart: /^\s/.test(n) || /\s$/.test(s)
                    })
                }
                return r.reduce(((e, i) => {
                    const {
                        words: n,
                        chars: r
                    } = W(i, t);
                    return {
                        words: [...e.words, ...n],
                        chars: [...e.chars, ...r]
                    }
                }), n)
            }

            function j(e) {
                v(e).isWord ? (b(e), e.replaceWith(...e.childNodes)) : c(e.children).forEach((e => j(e)))
            }
            const q = () => document.createDocumentFragment();

            function $(e, t, i) {
                const n = o(t.types),
                    r = t.tagName,
                    s = e.getElementsByTagName("*"),
                    a = [];
                let l, h, u, d = [],
                    p = null,
                    f = [];
                const m = e.parentElement,
                    g = e.nextElementSibling,
                    y = q(),
                    b = window.getComputedStyle(e),
                    T = b.textAlign,
                    x = .2 * parseFloat(b.fontSize);
                return t.absolute && (u = {
                    left: e.offsetLeft,
                    top: e.offsetTop,
                    width: e.offsetWidth
                }, h = e.offsetWidth, l = e.offsetHeight, _(e, {
                    cssWidth: e.style.width,
                    cssHeight: e.style.height
                })), c(s).forEach((r => {
                    const s = r.parentElement === e,
                        {
                            width: o,
                            height: l,
                            top: h,
                            left: c
                        } = function(e, t, i, n) {
                            if (!i.absolute) return {
                                top: t ? e.offsetTop : null
                            };
                            const r = e.offsetParent,
                                [s, a] = n;
                            let o = 0,
                                l = 0;
                            if (r && r !== document.body) {
                                const e = r.getBoundingClientRect();
                                o = e.x + s, l = e.y + a
                            }
                            const {
                                width: h,
                                height: c,
                                x: u,
                                y: d
                            } = e.getBoundingClientRect();
                            return {
                                width: h,
                                height: c,
                                top: d + a - l,
                                left: u + s - o
                            }
                        }(r, s, t, i);
                    /^br$/i.test(r.nodeName) || (n.lines && s && ((null === p || h - p >= x) && (p = h, a.push(d = [])), d.push(r)), t.absolute && _(r, {
                        top: h,
                        left: c,
                        width: o,
                        height: l
                    }))
                })), m && m.removeChild(e), n.lines && (f = a.map((e => {
                    const i = z(r, {
                        class: `${t.splitClass} ${t.lineClass}`,
                        style: `display: block; text-align: ${T}; width: 100%;`
                    });
                    _(i, "isLine", !0);
                    const n = {
                        height: 0,
                        top: 1e4
                    };
                    return y.appendChild(i), e.forEach(((e, t, r) => {
                        const {
                            isWordEnd: s,
                            top: a,
                            height: o
                        } = v(e), l = r[t + 1];
                        n.height = Math.max(n.height, o), n.top = Math.min(n.top, a), i.appendChild(e), s && v(l).isWordStart && i.append(" ")
                    })), t.absolute && _(i, {
                        height: n.height,
                        top: n.top
                    }), i
                })), n.words || j(y), e.replaceChildren(y)), t.absolute && (e.style.width = `${e.style.width||h}px`, e.style.height = `${l}px`, c(s).forEach((e => {
                    const {
                        isLine: t,
                        top: i,
                        left: n,
                        width: r,
                        height: s
                    } = v(e), a = v(e.parentElement), o = !t && a.isLine;
                    e.style.top = `${o?i-a.top:i}px`, e.style.left = t ? `${u.left}px` : n - (o ? u.left : 0) + "px", e.style.height = `${s}px`, e.style.width = t ? `${u.width}px` : `${r}px`, e.style.position = "absolute"
                }))), m && (g ? m.insertBefore(e, g) : m.appendChild(e)), f
            }
            let X = n(V, {});
            class Y {
                static get data() {
                    return g
                }
                static get defaults() {
                    return X
                }
                static set defaults(e) {
                    X = n(X, a(e))
                }
                static setDefaults(e) {
                    return X = n(X, a(e)), V
                }
                static revert(e) {
                    u(e).forEach((e => {
                        const {
                            isSplit: t,
                            html: i,
                            cssWidth: n,
                            cssHeight: r
                        } = v(e);
                        t && (e.innerHTML = i, e.style.width = n || "", e.style.height = r || "", b(e))
                    }))
                }
                static create(e, t) {
                    return new Y(e, t)
                }
                constructor(e, t) {
                    this.isSplit = !1, this.settings = n(X, a(t)), this.elements = u(e), this.split()
                }
                split(e) {
                    this.revert(), this.elements.forEach((e => {
                        _(e, "html", e.innerHTML)
                    })), this.lines = [], this.words = [], this.chars = [];
                    const t = [window.pageXOffset, window.pageYOffset];
                    void 0 !== e && (this.settings = n(this.settings, a(e)));
                    const i = o(this.settings.types);
                    i.none || (this.elements.forEach((e => {
                        _(e, "isRoot", !0);
                        const {
                            words: t,
                            chars: i
                        } = W(e, this.settings);
                        this.words = [...this.words, ...t], this.chars = [...this.chars, ...i]
                    })), this.elements.forEach((e => {
                        if (i.lines || this.settings.absolute) {
                            const i = $(e, this.settings, t);
                            this.lines = [...this.lines, ...i]
                        }
                    })), this.isSplit = !0, window.scrollTo(t[0], t[1]), d(g).forEach((([e, {
                        isRoot: t,
                        isSplit: i
                    }]) => {
                        t && i || (g[e] = null, delete g[e])
                    })))
                }
                revert() {
                    this.isSplit && (this.lines = null, this.words = null, this.chars = null, this.isSplit = !1), Y.revert(this.elements)
                }
            }
        },
        438: e => {
            function t() {}
            t.prototype = {
                on: function(e, t, i) {
                    var n = this.e || (this.e = {});
                    return (n[e] || (n[e] = [])).push({
                        fn: t,
                        ctx: i
                    }), this
                },
                once: function(e, t, i) {
                    var n = this;

                    function r() {
                        n.off(e, r), t.apply(i, arguments)
                    }
                    return r._ = t, this.on(e, r, i)
                },
                emit: function(e) {
                    for (var t = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[e] || []).slice(), n = 0, r = i.length; n < r; n++) i[n].fn.apply(i[n].ctx, t);
                    return this
                },
                off: function(e, t) {
                    var i = this.e || (this.e = {}),
                        n = i[e],
                        r = [];
                    if (n && t)
                        for (var s = 0, a = n.length; s < a; s++) n[s].fn !== t && n[s].fn._ !== t && r.push(n[s]);
                    return r.length ? i[e] = r : delete i[e], this
                }
            }, e.exports = t, e.exports.TinyEmitter = t
        },
        5488: function(e) {
            var t, i, n, r, s;
            t = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, i = /^(?=([^\/?#]*))\1([^]*)$/, n = /(?:\/|^)\.(?=\/)/g, r = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, s = {
                buildAbsoluteURL: function(e, t, n) {
                    if (n = n || {}, e = e.trim(), !(t = t.trim())) {
                        if (!n.alwaysNormalize) return e;
                        var r = s.parseURL(e);
                        if (!r) throw new Error("Error trying to parse base URL.");
                        return r.path = s.normalizePath(r.path), s.buildURLFromParts(r)
                    }
                    var a = s.parseURL(t);
                    if (!a) throw new Error("Error trying to parse relative URL.");
                    if (a.scheme) return n.alwaysNormalize ? (a.path = s.normalizePath(a.path), s.buildURLFromParts(a)) : t;
                    var o = s.parseURL(e);
                    if (!o) throw new Error("Error trying to parse base URL.");
                    if (!o.netLoc && o.path && "/" !== o.path[0]) {
                        var l = i.exec(o.path);
                        o.netLoc = l[1], o.path = l[2]
                    }
                    o.netLoc && !o.path && (o.path = "/");
                    var h = {
                        scheme: o.scheme,
                        netLoc: a.netLoc,
                        path: null,
                        params: a.params,
                        query: a.query,
                        fragment: a.fragment
                    };
                    if (!a.netLoc && (h.netLoc = o.netLoc, "/" !== a.path[0]))
                        if (a.path) {
                            var c = o.path,
                                u = c.substring(0, c.lastIndexOf("/") + 1) + a.path;
                            h.path = s.normalizePath(u)
                        } else h.path = o.path, a.params || (h.params = o.params, a.query || (h.query = o.query));
                    return null === h.path && (h.path = n.alwaysNormalize ? s.normalizePath(a.path) : a.path), s.buildURLFromParts(h)
                },
                parseURL: function(e) {
                    var i = t.exec(e);
                    return i ? {
                        scheme: i[1] || "",
                        netLoc: i[2] || "",
                        path: i[3] || "",
                        params: i[4] || "",
                        query: i[5] || "",
                        fragment: i[6] || ""
                    } : null
                },
                normalizePath: function(e) {
                    for (e = e.split("").reverse().join("").replace(n, ""); e.length !== (e = e.replace(r, "")).length;);
                    return e.split("").reverse().join("")
                },
                buildURLFromParts: function(e) {
                    return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
                }
            }, e.exports = s
        },
        7198: (e, t, i) => {
            "use strict";
            i.d(t, {
                Z: () => Ca
            });
            var n = i(1192),
                r = i.n(n),
                s = i(930),
                a = i.n(s),
                o = i(1740),
                l = i.n(o),
                h = i(1127),
                c = i.n(h),
                u = i(3065),
                d = i.n(u),
                p = i(545),
                f = i.n(p),
                m = i(5488),
                g = i.n(m),
                y = "http://example.com";
            const _ = function(e, t) {
                if (/^[a-z]+:/i.test(t)) return t;
                /^data:/.test(e) && (e = r().location && r().location.href || "");
                var i = "function" == typeof r().URL,
                    n = /^\/\//.test(e),
                    s = !r().location && !/\/\//i.test(e);
                if (i ? e = new(r().URL)(e, r().location || y) : /\/\//i.test(e) || (e = g().buildAbsoluteURL(r().location && r().location.href || "", e)), i) {
                    var a = new URL(t, e);
                    return s ? a.href.slice(y.length) : n ? a.href.slice(a.protocol.length) : a.href
                }
                return g().buildAbsoluteURL(e, t)
            };

            function v() {
                return v = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var i = arguments[t];
                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
                    }
                    return e
                }, v.apply(this, arguments)
            }
            var b = function() {
                    function e() {
                        this.listeners = {}
                    }
                    var t = e.prototype;
                    return t.on = function(e, t) {
                        this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t)
                    }, t.off = function(e, t) {
                        if (!this.listeners[e]) return !1;
                        var i = this.listeners[e].indexOf(t);
                        return this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(i, 1), i > -1
                    }, t.trigger = function(e) {
                        var t = this.listeners[e];
                        if (t)
                            if (2 === arguments.length)
                                for (var i = t.length, n = 0; n < i; ++n) t[n].call(this, arguments[1]);
                            else
                                for (var r = Array.prototype.slice.call(arguments, 1), s = t.length, a = 0; a < s; ++a) t[a].apply(this, r)
                    }, t.dispose = function() {
                        this.listeners = {}
                    }, t.pipe = function(e) {
                        this.on("data", (function(t) {
                            e.push(t)
                        }))
                    }, e
                }(),
                T = i(5851).lW,
                x = function(e) {
                    return r().atob ? r().atob(e) : T.from(e, "base64").toString("binary")
                };

            function w(e) {
                for (var t = x(e), i = new Uint8Array(t.length), n = 0; n < t.length; n++) i[n] = t.charCodeAt(n);
                return i
            }
            class S extends b {
                constructor() {
                    super(), this.buffer = ""
                }
                push(e) {
                    let t;
                    for (this.buffer += e, t = this.buffer.indexOf("\n"); t > -1; t = this.buffer.indexOf("\n")) this.trigger("data", this.buffer.substring(0, t)), this.buffer = this.buffer.substring(t + 1)
                }
            }
            const E = String.fromCharCode(9),
                M = function(e) {
                    const t = /([0-9.]*)?@?([0-9.]*)?/.exec(e || ""),
                        i = {};
                    return t[1] && (i.length = parseInt(t[1], 10)), t[2] && (i.offset = parseInt(t[2], 10)), i
                },
                C = function(e) {
                    const t = {};
                    if (!e) return t;
                    const i = e.split(new RegExp('(?:^|,)((?:[^=]*)=(?:"[^"]*"|[^,]*))'));
                    let n, r = i.length;
                    for (; r--;) "" !== i[r] && (n = /([^=]*)=(.*)/.exec(i[r]).slice(1), n[0] = n[0].replace(/^\s+|\s+$/g, ""), n[1] = n[1].replace(/^\s+|\s+$/g, ""), n[1] = n[1].replace(/^['"](.*)['"]$/g, "$1"), t[n[0]] = n[1]);
                    return t
                };
            class A extends b {
                constructor() {
                    super(), this.customParsers = [], this.tagMappers = []
                }
                push(e) {
                    let t, i;
                    if (0 === (e = e.trim()).length) return;
                    if ("#" !== e[0]) return void this.trigger("data", {
                        type: "uri",
                        uri: e
                    });
                    this.tagMappers.reduce(((t, i) => {
                        const n = i(e);
                        return n === e ? t : t.concat([n])
                    }), [e]).forEach((e => {
                        for (let t = 0; t < this.customParsers.length; t++)
                            if (this.customParsers[t].call(this, e)) return;
                        if (0 === e.indexOf("#EXT"))
                            if (e = e.replace("\r", ""), t = /^#EXTM3U/.exec(e), t) this.trigger("data", {
                                type: "tag",
                                tagType: "m3u"
                            });
                            else {
                                if (t = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(e), t) return i = {
                                    type: "tag",
                                    tagType: "inf"
                                }, t[1] && (i.duration = parseFloat(t[1])), t[2] && (i.title = t[2]), void this.trigger("data", i);
                                if (t = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(e), t) return i = {
                                    type: "tag",
                                    tagType: "targetduration"
                                }, t[1] && (i.duration = parseInt(t[1], 10)), void this.trigger("data", i);
                                if (t = /^#EXT-X-VERSION:([0-9.]*)?/.exec(e), t) return i = {
                                    type: "tag",
                                    tagType: "version"
                                }, t[1] && (i.version = parseInt(t[1], 10)), void this.trigger("data", i);
                                if (t = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(e), t) return i = {
                                    type: "tag",
                                    tagType: "media-sequence"
                                }, t[1] && (i.number = parseInt(t[1], 10)), void this.trigger("data", i);
                                if (t = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(e), t) return i = {
                                    type: "tag",
                                    tagType: "discontinuity-sequence"
                                }, t[1] && (i.number = parseInt(t[1], 10)), void this.trigger("data", i);
                                if (t = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(e), t) return i = {
                                    type: "tag",
                                    tagType: "playlist-type"
                                }, t[1] && (i.playlistType = t[1]), void this.trigger("data", i);
                                if (t = /^#EXT-X-BYTERANGE:(.*)?$/.exec(e), t) return i = v(M(t[1]), {
                                    type: "tag",
                                    tagType: "byterange"
                                }), void this.trigger("data", i);
                                if (t = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(e), t) return i = {
                                    type: "tag",
                                    tagType: "allow-cache"
                                }, t[1] && (i.allowed = !/NO/.test(t[1])), void this.trigger("data", i);
                                if (t = /^#EXT-X-MAP:(.*)$/.exec(e), t) {
                                    if (i = {
                                            type: "tag",
                                            tagType: "map"
                                        }, t[1]) {
                                        const e = C(t[1]);
                                        e.URI && (i.uri = e.URI), e.BYTERANGE && (i.byterange = M(e.BYTERANGE))
                                    }
                                    this.trigger("data", i)
                                } else if (t = /^#EXT-X-STREAM-INF:(.*)$/.exec(e), t) {
                                    if (i = {
                                            type: "tag",
                                            tagType: "stream-inf"
                                        }, t[1]) {
                                        if (i.attributes = C(t[1]), i.attributes.RESOLUTION) {
                                            const e = i.attributes.RESOLUTION.split("x"),
                                                t = {};
                                            e[0] && (t.width = parseInt(e[0], 10)), e[1] && (t.height = parseInt(e[1], 10)), i.attributes.RESOLUTION = t
                                        }
                                        i.attributes.BANDWIDTH && (i.attributes.BANDWIDTH = parseInt(i.attributes.BANDWIDTH, 10)), i.attributes["FRAME-RATE"] && (i.attributes["FRAME-RATE"] = parseFloat(i.attributes["FRAME-RATE"])), i.attributes["PROGRAM-ID"] && (i.attributes["PROGRAM-ID"] = parseInt(i.attributes["PROGRAM-ID"], 10))
                                    }
                                    this.trigger("data", i)
                                } else {
                                    if (t = /^#EXT-X-MEDIA:(.*)$/.exec(e), t) return i = {
                                        type: "tag",
                                        tagType: "media"
                                    }, t[1] && (i.attributes = C(t[1])), void this.trigger("data", i);
                                    if (t = /^#EXT-X-ENDLIST/.exec(e), t) this.trigger("data", {
                                        type: "tag",
                                        tagType: "endlist"
                                    });
                                    else if (t = /^#EXT-X-DISCONTINUITY/.exec(e), t) this.trigger("data", {
                                        type: "tag",
                                        tagType: "discontinuity"
                                    });
                                    else {
                                        if (t = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(e), t) return i = {
                                            type: "tag",
                                            tagType: "program-date-time"
                                        }, t[1] && (i.dateTimeString = t[1], i.dateTimeObject = new Date(t[1])), void this.trigger("data", i);
                                        if (t = /^#EXT-X-KEY:(.*)$/.exec(e), t) return i = {
                                            type: "tag",
                                            tagType: "key"
                                        }, t[1] && (i.attributes = C(t[1]), i.attributes.IV && ("0x" === i.attributes.IV.substring(0, 2).toLowerCase() && (i.attributes.IV = i.attributes.IV.substring(2)), i.attributes.IV = i.attributes.IV.match(/.{8}/g), i.attributes.IV[0] = parseInt(i.attributes.IV[0], 16), i.attributes.IV[1] = parseInt(i.attributes.IV[1], 16), i.attributes.IV[2] = parseInt(i.attributes.IV[2], 16), i.attributes.IV[3] = parseInt(i.attributes.IV[3], 16), i.attributes.IV = new Uint32Array(i.attributes.IV))), void this.trigger("data", i);
                                        if (t = /^#EXT-X-START:(.*)$/.exec(e), t) return i = {
                                            type: "tag",
                                            tagType: "start"
                                        }, t[1] && (i.attributes = C(t[1]), i.attributes["TIME-OFFSET"] = parseFloat(i.attributes["TIME-OFFSET"]), i.attributes.PRECISE = /YES/.test(i.attributes.PRECISE)), void this.trigger("data", i);
                                        if (t = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(e), t) return i = {
                                            type: "tag",
                                            tagType: "cue-out-cont"
                                        }, t[1] ? i.data = t[1] : i.data = "", void this.trigger("data", i);
                                        if (t = /^#EXT-X-CUE-OUT:(.*)?$/.exec(e), t) return i = {
                                            type: "tag",
                                            tagType: "cue-out"
                                        }, t[1] ? i.data = t[1] : i.data = "", void this.trigger("data", i);
                                        if (t = /^#EXT-X-CUE-IN:(.*)?$/.exec(e), t) return i = {
                                            type: "tag",
                                            tagType: "cue-in"
                                        }, t[1] ? i.data = t[1] : i.data = "", void this.trigger("data", i);
                                        if (t = /^#EXT-X-SKIP:(.*)$/.exec(e), t && t[1]) return i = {
                                            type: "tag",
                                            tagType: "skip"
                                        }, i.attributes = C(t[1]), i.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (i.attributes["SKIPPED-SEGMENTS"] = parseInt(i.attributes["SKIPPED-SEGMENTS"], 10)), i.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (i.attributes["RECENTLY-REMOVED-DATERANGES"] = i.attributes["RECENTLY-REMOVED-DATERANGES"].split(E)), void this.trigger("data", i);
                                        if (t = /^#EXT-X-PART:(.*)$/.exec(e), t && t[1]) return i = {
                                            type: "tag",
                                            tagType: "part"
                                        }, i.attributes = C(t[1]), ["DURATION"].forEach((function(e) {
                                            i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e]))
                                        })), ["INDEPENDENT", "GAP"].forEach((function(e) {
                                            i.attributes.hasOwnProperty(e) && (i.attributes[e] = /YES/.test(i.attributes[e]))
                                        })), i.attributes.hasOwnProperty("BYTERANGE") && (i.attributes.byterange = M(i.attributes.BYTERANGE)), void this.trigger("data", i);
                                        if (t = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(e), t && t[1]) return i = {
                                            type: "tag",
                                            tagType: "server-control"
                                        }, i.attributes = C(t[1]), ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach((function(e) {
                                            i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e]))
                                        })), ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach((function(e) {
                                            i.attributes.hasOwnProperty(e) && (i.attributes[e] = /YES/.test(i.attributes[e]))
                                        })), void this.trigger("data", i);
                                        if (t = /^#EXT-X-PART-INF:(.*)$/.exec(e), t && t[1]) return i = {
                                            type: "tag",
                                            tagType: "part-inf"
                                        }, i.attributes = C(t[1]), ["PART-TARGET"].forEach((function(e) {
                                            i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseFloat(i.attributes[e]))
                                        })), void this.trigger("data", i);
                                        if (t = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(e), t && t[1]) return i = {
                                            type: "tag",
                                            tagType: "preload-hint"
                                        }, i.attributes = C(t[1]), ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach((function(e) {
                                            if (i.attributes.hasOwnProperty(e)) {
                                                i.attributes[e] = parseInt(i.attributes[e], 10);
                                                const t = "BYTERANGE-LENGTH" === e ? "length" : "offset";
                                                i.attributes.byterange = i.attributes.byterange || {}, i.attributes.byterange[t] = i.attributes[e], delete i.attributes[e]
                                            }
                                        })), void this.trigger("data", i);
                                        if (t = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(e), t && t[1]) return i = {
                                            type: "tag",
                                            tagType: "rendition-report"
                                        }, i.attributes = C(t[1]), ["LAST-MSN", "LAST-PART"].forEach((function(e) {
                                            i.attributes.hasOwnProperty(e) && (i.attributes[e] = parseInt(i.attributes[e], 10))
                                        })), void this.trigger("data", i);
                                        this.trigger("data", {
                                            type: "tag",
                                            data: e.slice(4)
                                        })
                                    }
                                }
                            }
                        else this.trigger("data", {
                            type: "comment",
                            text: e.slice(1)
                        })
                    }))
                }
                addParser({
                    expression: e,
                    customType: t,
                    dataParser: i,
                    segment: n
                }) {
                    "function" != typeof i && (i = e => e), this.customParsers.push((r => {
                        if (e.exec(r)) return this.trigger("data", {
                            type: "custom",
                            data: i(r),
                            customType: t,
                            segment: n
                        }), !0
                    }))
                }
                addTagMapper({
                    expression: e,
                    map: t
                }) {
                    this.tagMappers.push((i => e.test(i) ? t(i) : i))
                }
            }
            const L = function(e) {
                    const t = {};
                    return Object.keys(e).forEach((function(i) {
                        var n;
                        t[(n = i, n.toLowerCase().replace(/-(\w)/g, (e => e[1].toUpperCase())))] = e[i]
                    })), t
                },
                I = function(e) {
                    const {
                        serverControl: t,
                        targetDuration: i,
                        partTargetDuration: n
                    } = e;
                    if (!t) return;
                    const r = "#EXT-X-SERVER-CONTROL",
                        s = "holdBack",
                        a = "partHoldBack",
                        o = i && 3 * i,
                        l = n && 2 * n;
                    i && !t.hasOwnProperty(s) && (t[s] = o, this.trigger("info", {
                        message: `${r} defaulting HOLD-BACK to targetDuration * 3 (${o}).`
                    })), o && t[s] < o && (this.trigger("warn", {
                        message: `${r} clamping HOLD-BACK (${t[s]}) to targetDuration * 3 (${o})`
                    }), t[s] = o), n && !t.hasOwnProperty(a) && (t[a] = 3 * n, this.trigger("info", {
                        message: `${r} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${t[a]}).`
                    })), n && t[a] < l && (this.trigger("warn", {
                        message: `${r} clamping PART-HOLD-BACK (${t[a]}) to partTargetDuration * 2 (${l}).`
                    }), t[a] = l)
                };
            class P extends b {
                constructor() {
                    super(), this.lineStream = new S, this.parseStream = new A, this.lineStream.pipe(this.parseStream);
                    const e = this,
                        t = [];
                    let i, n, r = {},
                        s = !1;
                    const a = function() {},
                        o = {
                            AUDIO: {},
                            VIDEO: {},
                            "CLOSED-CAPTIONS": {},
                            SUBTITLES: {}
                        };
                    let l = 0;
                    this.manifest = {
                        allowCache: !0,
                        discontinuityStarts: [],
                        segments: []
                    };
                    let h = 0,
                        c = 0;
                    this.on("end", (() => {
                        r.uri || !r.parts && !r.preloadHints || (!r.map && i && (r.map = i), !r.key && n && (r.key = n), r.timeline || "number" != typeof l || (r.timeline = l), this.manifest.preloadSegment = r)
                    })), this.parseStream.on("data", (function(u) {
                        let d, p;
                        ({
                            tag() {
                                ({
                                    version() {
                                        u.version && (this.manifest.version = u.version)
                                    },
                                    "allow-cache" () {
                                        this.manifest.allowCache = u.allowed, "allowed" in u || (this.trigger("info", {
                                            message: "defaulting allowCache to YES"
                                        }), this.manifest.allowCache = !0)
                                    },
                                    byterange() {
                                        const e = {};
                                        "length" in u && (r.byterange = e, e.length = u.length, "offset" in u || (u.offset = h)), "offset" in u && (r.byterange = e, e.offset = u.offset), h = e.offset + e.length
                                    },
                                    endlist() {
                                        this.manifest.endList = !0
                                    },
                                    inf() {
                                        "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", {
                                            message: "defaulting media sequence to zero"
                                        })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", {
                                            message: "defaulting discontinuity sequence to zero"
                                        })), u.duration > 0 && (r.duration = u.duration), 0 === u.duration && (r.duration = .01, this.trigger("info", {
                                            message: "updating zero segment duration to a small value"
                                        })), this.manifest.segments = t
                                    },
                                    key() {
                                        if (u.attributes)
                                            if ("NONE" !== u.attributes.METHOD)
                                                if (u.attributes.URI) {
                                                    if ("com.apple.streamingkeydelivery" === u.attributes.KEYFORMAT) return this.manifest.contentProtection = this.manifest.contentProtection || {}, void(this.manifest.contentProtection["com.apple.fps.1_0"] = {
                                                        attributes: u.attributes
                                                    });
                                                    if ("com.microsoft.playready" === u.attributes.KEYFORMAT) return this.manifest.contentProtection = this.manifest.contentProtection || {}, void(this.manifest.contentProtection["com.microsoft.playready"] = {
                                                        uri: u.attributes.URI
                                                    });
                                                    if ("urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" === u.attributes.KEYFORMAT) {
                                                        return -1 === ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"].indexOf(u.attributes.METHOD) ? void this.trigger("warn", {
                                                            message: "invalid key method provided for Widevine"
                                                        }) : ("SAMPLE-AES-CENC" === u.attributes.METHOD && this.trigger("warn", {
                                                            message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                                                        }), "data:text/plain;base64," !== u.attributes.URI.substring(0, 23) ? void this.trigger("warn", {
                                                            message: "invalid key URI provided for Widevine"
                                                        }) : u.attributes.KEYID && "0x" === u.attributes.KEYID.substring(0, 2) ? (this.manifest.contentProtection = this.manifest.contentProtection || {}, void(this.manifest.contentProtection["com.widevine.alpha"] = {
                                                            attributes: {
                                                                schemeIdUri: u.attributes.KEYFORMAT,
                                                                keyId: u.attributes.KEYID.substring(2)
                                                            },
                                                            pssh: w(u.attributes.URI.split(",")[1])
                                                        })) : void this.trigger("warn", {
                                                            message: "invalid key ID provided for Widevine"
                                                        }))
                                                    }
                                                    u.attributes.METHOD || this.trigger("warn", {
                                                        message: "defaulting key method to AES-128"
                                                    }), n = {
                                                        method: u.attributes.METHOD || "AES-128",
                                                        uri: u.attributes.URI
                                                    }, void 0 !== u.attributes.IV && (n.iv = u.attributes.IV)
                                                } else this.trigger("warn", {
                                                    message: "ignoring key declaration without URI"
                                                });
                                        else n = null;
                                        else this.trigger("warn", {
                                            message: "ignoring key declaration without attribute list"
                                        })
                                    },
                                    "media-sequence" () {
                                        isFinite(u.number) ? this.manifest.mediaSequence = u.number : this.trigger("warn", {
                                            message: "ignoring invalid media sequence: " + u.number
                                        })
                                    },
                                    "discontinuity-sequence" () {
                                        isFinite(u.number) ? (this.manifest.discontinuitySequence = u.number, l = u.number) : this.trigger("warn", {
                                            message: "ignoring invalid discontinuity sequence: " + u.number
                                        })
                                    },
                                    "playlist-type" () {
                                        /VOD|EVENT/.test(u.playlistType) ? this.manifest.playlistType = u.playlistType : this.trigger("warn", {
                                            message: "ignoring unknown playlist type: " + u.playlist
                                        })
                                    },
                                    map() {
                                        i = {}, u.uri && (i.uri = u.uri), u.byterange && (i.byterange = u.byterange), n && (i.key = n)
                                    },
                                    "stream-inf" () {
                                        this.manifest.playlists = t, this.manifest.mediaGroups = this.manifest.mediaGroups || o, u.attributes ? (r.attributes || (r.attributes = {}), v(r.attributes, u.attributes)) : this.trigger("warn", {
                                            message: "ignoring empty stream-inf attributes"
                                        })
                                    },
                                    media() {
                                        if (this.manifest.mediaGroups = this.manifest.mediaGroups || o, !(u.attributes && u.attributes.TYPE && u.attributes["GROUP-ID"] && u.attributes.NAME)) return void this.trigger("warn", {
                                            message: "ignoring incomplete or missing media group"
                                        });
                                        const e = this.manifest.mediaGroups[u.attributes.TYPE];
                                        e[u.attributes["GROUP-ID"]] = e[u.attributes["GROUP-ID"]] || {}, d = e[u.attributes["GROUP-ID"]], p = {
                                            default: /yes/i.test(u.attributes.DEFAULT)
                                        }, p.default ? p.autoselect = !0 : p.autoselect = /yes/i.test(u.attributes.AUTOSELECT), u.attributes.LANGUAGE && (p.language = u.attributes.LANGUAGE), u.attributes.URI && (p.uri = u.attributes.URI), u.attributes["INSTREAM-ID"] && (p.instreamId = u.attributes["INSTREAM-ID"]), u.attributes.CHARACTERISTICS && (p.characteristics = u.attributes.CHARACTERISTICS), u.attributes.FORCED && (p.forced = /yes/i.test(u.attributes.FORCED)), d[u.attributes.NAME] = p
                                    },
                                    discontinuity() {
                                        l += 1, r.discontinuity = !0, this.manifest.discontinuityStarts.push(t.length)
                                    },
                                    "program-date-time" () {
                                        void 0 === this.manifest.dateTimeString && (this.manifest.dateTimeString = u.dateTimeString, this.manifest.dateTimeObject = u.dateTimeObject), r.dateTimeString = u.dateTimeString, r.dateTimeObject = u.dateTimeObject
                                    },
                                    targetduration() {
                                        !isFinite(u.duration) || u.duration < 0 ? this.trigger("warn", {
                                            message: "ignoring invalid target duration: " + u.duration
                                        }) : (this.manifest.targetDuration = u.duration, I.call(this, this.manifest))
                                    },
                                    start() {
                                        u.attributes && !isNaN(u.attributes["TIME-OFFSET"]) ? this.manifest.start = {
                                            timeOffset: u.attributes["TIME-OFFSET"],
                                            precise: u.attributes.PRECISE
                                        } : this.trigger("warn", {
                                            message: "ignoring start declaration without appropriate attribute list"
                                        })
                                    },
                                    "cue-out" () {
                                        r.cueOut = u.data
                                    },
                                    "cue-out-cont" () {
                                        r.cueOutCont = u.data
                                    },
                                    "cue-in" () {
                                        r.cueIn = u.data
                                    },
                                    skip() {
                                        this.manifest.skip = L(u.attributes), this.warnOnMissingAttributes_("#EXT-X-SKIP", u.attributes, ["SKIPPED-SEGMENTS"])
                                    },
                                    part() {
                                        s = !0;
                                        const e = this.manifest.segments.length,
                                            t = L(u.attributes);
                                        r.parts = r.parts || [], r.parts.push(t), t.byterange && (t.byterange.hasOwnProperty("offset") || (t.byterange.offset = c), c = t.byterange.offset + t.byterange.length);
                                        const i = r.parts.length - 1;
                                        this.warnOnMissingAttributes_(`#EXT-X-PART #${i} for segment #${e}`, u.attributes, ["URI", "DURATION"]), this.manifest.renditionReports && this.manifest.renditionReports.forEach(((e, t) => {
                                            e.hasOwnProperty("lastPart") || this.trigger("warn", {
                                                message: `#EXT-X-RENDITION-REPORT #${t} lacks required attribute(s): LAST-PART`
                                            })
                                        }))
                                    },
                                    "server-control" () {
                                        const e = this.manifest.serverControl = L(u.attributes);
                                        e.hasOwnProperty("canBlockReload") || (e.canBlockReload = !1, this.trigger("info", {
                                            message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                                        })), I.call(this, this.manifest), e.canSkipDateranges && !e.hasOwnProperty("canSkipUntil") && this.trigger("warn", {
                                            message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                                        })
                                    },
                                    "preload-hint" () {
                                        const e = this.manifest.segments.length,
                                            t = L(u.attributes),
                                            i = t.type && "PART" === t.type;
                                        r.preloadHints = r.preloadHints || [], r.preloadHints.push(t), t.byterange && (t.byterange.hasOwnProperty("offset") || (t.byterange.offset = i ? c : 0, i && (c = t.byterange.offset + t.byterange.length)));
                                        const n = r.preloadHints.length - 1;
                                        if (this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${n} for segment #${e}`, u.attributes, ["TYPE", "URI"]), t.type)
                                            for (let i = 0; i < r.preloadHints.length - 1; i++) {
                                                const s = r.preloadHints[i];
                                                s.type && (s.type === t.type && this.trigger("warn", {
                                                    message: `#EXT-X-PRELOAD-HINT #${n} for segment #${e} has the same TYPE ${t.type} as preload hint #${i}`
                                                }))
                                            }
                                    },
                                    "rendition-report" () {
                                        const e = L(u.attributes);
                                        this.manifest.renditionReports = this.manifest.renditionReports || [], this.manifest.renditionReports.push(e);
                                        const t = this.manifest.renditionReports.length - 1,
                                            i = ["LAST-MSN", "URI"];
                                        s && i.push("LAST-PART"), this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${t}`, u.attributes, i)
                                    },
                                    "part-inf" () {
                                        this.manifest.partInf = L(u.attributes), this.warnOnMissingAttributes_("#EXT-X-PART-INF", u.attributes, ["PART-TARGET"]), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), I.call(this, this.manifest)
                                    }
                                }[u.tagType] || a).call(e)
                            },
                            uri() {
                                r.uri = u.uri, t.push(r), this.manifest.targetDuration && !("duration" in r) && (this.trigger("warn", {
                                    message: "defaulting segment duration to the target duration"
                                }), r.duration = this.manifest.targetDuration), n && (r.key = n), r.timeline = l, i && (r.map = i), c = 0, r = {}
                            },
                            comment() {},
                            custom() {
                                u.segment ? (r.custom = r.custom || {}, r.custom[u.customType] = u.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[u.customType] = u.data)
                            }
                        })[u.type].call(e)
                    }))
                }
                warnOnMissingAttributes_(e, t, i) {
                    const n = [];
                    i.forEach((function(e) {
                        t.hasOwnProperty(e) || n.push(e)
                    })), n.length && this.trigger("warn", {
                        message: `${e} lacks required attribute(s): ${n.join(", ")}`
                    })
                }
                push(e) {
                    this.lineStream.push(e)
                }
                end() {
                    this.lineStream.push("\n"), this.trigger("end")
                }
                addParser(e) {
                    this.parseStream.addParser(e)
                }
                addTagMapper(e) {
                    this.parseStream.addTagMapper(e)
                }
            }
            var R, k, D = {
                    mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
                    webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
                    ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
                    video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
                    audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
                    text: /^(stpp.ttml.im1t)/,
                    muxerVideo: /^(avc0?1)/,
                    muxerAudio: /^(mp4a)/,
                    muxerText: /a^/
                },
                O = ["video", "audio", "text"],
                N = ["Video", "Audio", "Text"],
                U = function(e) {
                    return e ? e.replace(/avc1\.(\d+)\.(\d+)/i, (function(e, t, i) {
                        return "avc1." + ("00" + Number(t).toString(16)).slice(-2) + "00" + ("00" + Number(i).toString(16)).slice(-2)
                    })) : e
                },
                B = function(e) {
                    void 0 === e && (e = "");
                    var t = e.split(","),
                        i = [];
                    return t.forEach((function(e) {
                        var t;
                        e = e.trim(), O.forEach((function(n) {
                            var r = D[n].exec(e.toLowerCase());
                            if (r && !(r.length <= 1)) {
                                t = n;
                                var s = e.substring(0, r[1].length),
                                    a = e.replace(s, "");
                                i.push({
                                    type: s,
                                    details: a,
                                    mediaType: n
                                })
                            }
                        })), t || i.push({
                            type: e,
                            details: "",
                            mediaType: "unknown"
                        })
                    })), i
                },
                F = function(e) {
                    return void 0 === e && (e = ""), D.audio.test(e.trim().toLowerCase())
                },
                H = function(e) {
                    if (e && "string" == typeof e) {
                        var t, i = e.toLowerCase().split(",").map((function(e) {
                                return U(e.trim())
                            })),
                            n = "video";
                        1 === i.length && F(i[0]) ? n = "audio" : 1 === i.length && (void 0 === (t = i[0]) && (t = ""), D.text.test(t.trim().toLowerCase())) && (n = "application");
                        var r = "mp4";
                        return i.every((function(e) {
                            return D.mp4.test(e)
                        })) ? r = "mp4" : i.every((function(e) {
                            return D.webm.test(e)
                        })) ? r = "webm" : i.every((function(e) {
                            return D.ogg.test(e)
                        })) && (r = "ogg"), n + "/" + r + ';codecs="' + e + '"'
                    }
                },
                z = function(e) {
                    return void 0 === e && (e = ""), r().MediaSource && r().MediaSource.isTypeSupported && r().MediaSource.isTypeSupported(H(e)) || !1
                },
                V = function(e) {
                    return void 0 === e && (e = ""), e.toLowerCase().split(",").every((function(e) {
                        e = e.trim();
                        for (var t = 0; t < N.length; t++) {
                            if (D["muxer" + N[t]].test(e)) return !0
                        }
                        return !1
                    }))
                },
                G = "mp4a.40.2",
                W = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i,
                j = /^application\/dash\+xml/i,
                q = function(e) {
                    return W.test(e) ? "hls" : j.test(e) ? "dash" : "application/vnd.videojs.vhs+json" === e ? "vhs-json" : null
                },
                $ = function(e) {
                    return "function" === ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer
                },
                X = function(e) {
                    return e instanceof Uint8Array ? e : (Array.isArray(e) || $(e) || e instanceof ArrayBuffer || (e = "number" != typeof e || "number" == typeof e && e != e ? 0 : [e]), new Uint8Array(e && e.buffer || e, e && e.byteOffset || 0, e && e.byteLength || 0))
                },
                Y = r().BigInt || Number,
                K = [Y("0x1"), Y("0x100"), Y("0x10000"), Y("0x1000000"), Y("0x100000000"), Y("0x10000000000"), Y("0x1000000000000"), Y("0x100000000000000"), Y("0x10000000000000000")],
                J = (R = new Uint16Array([65484]), 255 === (k = new Uint8Array(R.buffer, R.byteOffset, R.byteLength))[0] || k[0], function(e, t) {
                    var i = void 0 === t ? {} : t,
                        n = i.signed,
                        r = void 0 !== n && n,
                        s = i.le,
                        a = void 0 !== s && s;
                    e = X(e);
                    var o = a ? "reduce" : "reduceRight",
                        l = (e[o] ? e[o] : Array.prototype[o]).call(e, (function(t, i, n) {
                            var r = a ? n : Math.abs(n + 1 - e.length);
                            return t + Y(i) * K[r]
                        }), Y(0));
                    if (r) {
                        var h = K[e.length] / Y(2) - Y(1);
                        (l = Y(l)) > h && (l -= h, l -= h, l -= Y(2))
                    }
                    return Number(l)
                }),
                Z = function(e, t) {
                    var i = (void 0 === t ? {} : t).le,
                        n = void 0 !== i && i;
                    ("bigint" != typeof e && "number" != typeof e || "number" == typeof e && e != e) && (e = 0), e = Y(e);
                    for (var r, s = (r = e, Math.ceil(function(e) {
                            return e.toString(2).length
                        }(r) / 8)), a = new Uint8Array(new ArrayBuffer(s)), o = 0; o < s; o++) {
                        var l = n ? o : Math.abs(o + 1 - a.length);
                        a[l] = Number(e / K[o] & Y(255)), e < 0 && (a[l] = Math.abs(~a[l]), a[l] -= 0 === o ? 1 : 2)
                    }
                    return a
                },
                Q = function(e, t) {
                    if ("string" != typeof e && e && "function" == typeof e.toString && (e = e.toString()), "string" != typeof e) return new Uint8Array;
                    t || (e = unescape(encodeURIComponent(e)));
                    for (var i = new Uint8Array(e.length), n = 0; n < e.length; n++) i[n] = e.charCodeAt(n);
                    return i
                },
                ee = function(e, t, i) {
                    var n = void 0 === i ? {} : i,
                        r = n.offset,
                        s = void 0 === r ? 0 : r,
                        a = n.mask,
                        o = void 0 === a ? [] : a;
                    e = X(e);
                    var l = (t = X(t)).every ? t.every : Array.prototype.every;
                    return t.length && e.length - s >= t.length && l.call(t, (function(t, i) {
                        return t === (o[i] ? o[i] & e[s + i] : e[s + i])
                    }))
                },
                te = "http://example.com";
            const ie = function(e, t) {
                if (/^[a-z]+:/i.test(t)) return t;
                /^data:/.test(e) && (e = r().location && r().location.href || "");
                var i = "function" == typeof r().URL,
                    n = /^\/\//.test(e),
                    s = !r().location && !/\/\//i.test(e);
                if (i ? e = new(r().URL)(e, r().location || te) : /\/\//i.test(e) || (e = g().buildAbsoluteURL(r().location && r().location.href || "", e)), i) {
                    var a = new URL(t, e);
                    return s ? a.href.slice(te.length) : n ? a.href.slice(a.protocol.length) : a.href
                }
                return g().buildAbsoluteURL(e, t)
            };
            var ne = i(8903);
            const re = e => !!e && "object" == typeof e,
                se = (...e) => e.reduce(((e, t) => ("object" != typeof t || Object.keys(t).forEach((i => {
                    Array.isArray(e[i]) && Array.isArray(t[i]) ? e[i] = e[i].concat(t[i]) : re(e[i]) && re(t[i]) ? e[i] = se(e[i], t[i]) : e[i] = t[i]
                })), e)), {}),
                ae = e => Object.keys(e).map((t => e[t])),
                oe = e => e.reduce(((e, t) => e.concat(t)), []),
                le = e => {
                    if (!e.length) return [];
                    const t = [];
                    for (let i = 0; i < e.length; i++) t.push(e[i]);
                    return t
                };
            var he = "INVALID_NUMBER_OF_PERIOD",
                ce = "DASH_EMPTY_MANIFEST",
                ue = "DASH_INVALID_XML",
                de = "NO_BASE_URL",
                pe = "SEGMENT_TIME_UNSPECIFIED",
                fe = "UNSUPPORTED_UTC_TIMING_SCHEME";
            const me = ({
                    baseUrl: e = "",
                    source: t = "",
                    range: i = "",
                    indexRange: n = ""
                }) => {
                    const s = {
                        uri: t,
                        resolvedUri: ie(e || "", t)
                    };
                    if (i || n) {
                        const e = (i || n).split("-");
                        let t, a = r().BigInt ? r().BigInt(e[0]) : parseInt(e[0], 10),
                            o = r().BigInt ? r().BigInt(e[1]) : parseInt(e[1], 10);
                        a < Number.MAX_SAFE_INTEGER && "bigint" == typeof a && (a = Number(a)), o < Number.MAX_SAFE_INTEGER && "bigint" == typeof o && (o = Number(o)), t = "bigint" == typeof o || "bigint" == typeof a ? r().BigInt(o) - r().BigInt(a) + r().BigInt(1) : o - a + 1, "bigint" == typeof t && t < Number.MAX_SAFE_INTEGER && (t = Number(t)), s.byterange = {
                            length: t,
                            offset: a
                        }
                    }
                    return s
                },
                ge = e => (e && "number" != typeof e && (e = parseInt(e, 10)), isNaN(e) ? null : e),
                ye = {
                    static(e) {
                        const {
                            duration: t,
                            timescale: i = 1,
                            sourceDuration: n,
                            periodDuration: r
                        } = e, s = ge(e.endNumber), a = t / i;
                        return "number" == typeof s ? {
                            start: 0,
                            end: s
                        } : "number" == typeof r ? {
                            start: 0,
                            end: r / a
                        } : {
                            start: 0,
                            end: n / a
                        }
                    },
                    dynamic(e) {
                        const {
                            NOW: t,
                            clientOffset: i,
                            availabilityStartTime: n,
                            timescale: r = 1,
                            duration: s,
                            periodStart: a = 0,
                            minimumUpdatePeriod: o = 0,
                            timeShiftBufferDepth: l = 1 / 0
                        } = e, h = ge(e.endNumber), c = (t + i) / 1e3, u = n + a, d = c + o - u, p = Math.ceil(d * r / s), f = Math.floor((c - u - l) * r / s), m = Math.floor((c - u) * r / s);
                        return {
                            start: Math.max(0, f),
                            end: "number" == typeof h ? h : Math.min(p, m)
                        }
                    }
                },
                _e = e => {
                    const {
                        type: t,
                        duration: i,
                        timescale: n = 1,
                        periodDuration: r,
                        sourceDuration: s
                    } = e, {
                        start: a,
                        end: o
                    } = ye[t](e), l = ((e, t) => {
                        const i = [];
                        for (let n = e; n < t; n++) i.push(n);
                        return i
                    })(a, o).map((e => t => {
                        const {
                            duration: i,
                            timescale: n = 1,
                            periodStart: r,
                            startNumber: s = 1
                        } = e;
                        return {
                            number: s + t,
                            duration: i / n,
                            timeline: r,
                            time: t * i
                        }
                    })(e));
                    if ("static" === t) {
                        const e = l.length - 1,
                            t = "number" == typeof r ? r : s;
                        l[e].duration = t - i / n * e
                    }
                    return l
                },
                ve = e => {
                    const {
                        baseUrl: t,
                        initialization: i = {},
                        sourceDuration: n,
                        indexRange: r = "",
                        periodStart: s,
                        presentationTime: a,
                        number: o = 0,
                        duration: l
                    } = e;
                    if (!t) throw new Error(de);
                    const h = me({
                            baseUrl: t,
                            source: i.sourceURL,
                            range: i.range
                        }),
                        c = me({
                            baseUrl: t,
                            source: t,
                            indexRange: r
                        });
                    if (c.map = h, l) {
                        const t = _e(e);
                        t.length && (c.duration = t[0].duration, c.timeline = t[0].timeline)
                    } else n && (c.duration = n, c.timeline = s);
                    return c.presentationTime = a || s, c.number = o, [c]
                },
                be = (e, t, i) => {
                    const n = e.sidx.map ? e.sidx.map : null,
                        s = e.sidx.duration,
                        a = e.timeline || 0,
                        o = e.sidx.byterange,
                        l = o.offset + o.length,
                        h = t.timescale,
                        c = t.references.filter((e => 1 !== e.referenceType)),
                        u = [],
                        d = e.endList ? "static" : "dynamic",
                        p = e.sidx.timeline;
                    let f, m = p,
                        g = e.mediaSequence || 0;
                    f = "bigint" == typeof t.firstOffset ? r().BigInt(l) + t.firstOffset : l + t.firstOffset;
                    for (let e = 0; e < c.length; e++) {
                        const o = t.references[e],
                            l = o.referencedSize,
                            c = o.subsegmentDuration;
                        let y;
                        y = "bigint" == typeof f ? f + r().BigInt(l) - r().BigInt(1) : f + l - 1;
                        const _ = ve({
                            baseUrl: i,
                            timescale: h,
                            timeline: a,
                            periodStart: p,
                            presentationTime: m,
                            number: g,
                            duration: c,
                            sourceDuration: s,
                            indexRange: `${f}-${y}`,
                            type: d
                        })[0];
                        n && (_.map = n), u.push(_), f += "bigint" == typeof f ? r().BigInt(l) : l, m += c / h, g++
                    }
                    return e.segments = u, e
                },
                Te = ["AUDIO", "SUBTITLES"],
                xe = e => {
                    return (t = e, i = ({
                        timeline: e
                    }) => e, ae(t.reduce(((e, t) => (t.forEach((t => {
                        e[i(t)] = t
                    })), e)), {}))).sort(((e, t) => e.timeline > t.timeline ? 1 : -1));
                    var t, i
                },
                we = e => {
                    let t = [];
                    var i, n;
                    return i = e, n = (e, i, n, r) => {
                        t = t.concat(e.playlists || [])
                    }, Te.forEach((function(e) {
                        for (var t in i.mediaGroups[e])
                            for (var r in i.mediaGroups[e][t]) {
                                var s = i.mediaGroups[e][t][r];
                                n(s, e, t, r)
                            }
                    })), t
                },
                Se = ({
                    playlist: e,
                    mediaSequence: t
                }) => {
                    e.mediaSequence = t, e.segments.forEach(((t, i) => {
                        t.number = e.mediaSequence + i
                    }))
                },
                Ee = ({
                    oldManifest: e,
                    newManifest: t
                }) => {
                    const i = e.playlists.concat(we(e)),
                        n = t.playlists.concat(we(t));
                    return t.timelineStarts = xe([e.timelineStarts, t.timelineStarts]), (({
                        oldPlaylists: e,
                        newPlaylists: t,
                        timelineStarts: i
                    }) => {
                        t.forEach((t => {
                            t.discontinuitySequence = i.findIndex((function({
                                timeline: e
                            }) {
                                return e === t.timeline
                            }));
                            const n = ((e, t) => {
                                for (let i = 0; i < e.length; i++)
                                    if (e[i].attributes.NAME === t) return e[i];
                                return null
                            })(e, t.attributes.NAME);
                            if (!n) return;
                            if (t.sidx) return;
                            const r = t.segments[0],
                                s = n.segments.findIndex((function(e) {
                                    return Math.abs(e.presentationTime - r.presentationTime) < .016666666666666666
                                }));
                            if (-1 === s) return Se({
                                playlist: t,
                                mediaSequence: n.mediaSequence + n.segments.length
                            }), t.segments[0].discontinuity = !0, t.discontinuityStarts.unshift(0), void((!n.segments.length && t.timeline > n.timeline || n.segments.length && t.timeline > n.segments[n.segments.length - 1].timeline) && t.discontinuitySequence--);
                            n.segments[s].discontinuity && !r.discontinuity && (r.discontinuity = !0, t.discontinuityStarts.unshift(0), t.discontinuitySequence--), Se({
                                playlist: t,
                                mediaSequence: n.segments[s].number
                            })
                        }))
                    })({
                        oldPlaylists: i,
                        newPlaylists: n,
                        timelineStarts: t.timelineStarts
                    }), t
                },
                Me = e => e && e.uri + "-" + (e => {
                    let t;
                    return t = "bigint" == typeof e.offset || "bigint" == typeof e.length ? r().BigInt(e.offset) + r().BigInt(e.length) - r().BigInt(1) : e.offset + e.length - 1, `${e.offset}-${t}`
                })(e.byterange),
                Ce = e => ae(e.reduce(((e, t) => {
                    const i = t.attributes.id + (t.attributes.lang || "");
                    return e[i] ? (t.segments && (t.segments[0] && (t.segments[0].discontinuity = !0), e[i].segments.push(...t.segments)), t.attributes.contentProtection && (e[i].attributes.contentProtection = t.attributes.contentProtection)) : (e[i] = t, e[i].attributes.timelineStarts = []), e[i].attributes.timelineStarts.push({
                        start: t.attributes.periodStart,
                        timeline: t.attributes.periodStart
                    }), e
                }), {})).map((e => {
                    var t, i;
                    return e.discontinuityStarts = (t = e.segments || [], i = "discontinuity", t.reduce(((e, t, n) => (t[i] && e.push(n), e)), [])), e
                })),
                Ae = (e, t) => {
                    const i = Me(e.sidx),
                        n = i && t[i] && t[i].sidx;
                    return n && be(e, n, e.sidx.resolvedUri), e
                },
                Le = (e, t = {}) => {
                    if (!Object.keys(t).length) return e;
                    for (const i in e) e[i] = Ae(e[i], t);
                    return e
                },
                Ie = ({
                    attributes: e,
                    segments: t,
                    sidx: i,
                    discontinuityStarts: n
                }) => {
                    const r = {
                        attributes: {
                            NAME: e.id,
                            AUDIO: "audio",
                            SUBTITLES: "subs",
                            RESOLUTION: {
                                width: e.width,
                                height: e.height
                            },
                            CODECS: e.codecs,
                            BANDWIDTH: e.bandwidth,
                            "PROGRAM-ID": 1
                        },
                        uri: "",
                        endList: "static" === e.type,
                        timeline: e.periodStart,
                        resolvedUri: "",
                        targetDuration: e.duration,
                        discontinuityStarts: n,
                        timelineStarts: e.timelineStarts,
                        segments: t
                    };
                    return e.frameRate && (r.attributes["FRAME-RATE"] = e.frameRate), e.contentProtection && (r.contentProtection = e.contentProtection), i && (r.sidx = i), r
                },
                Pe = ({
                    attributes: e
                }) => "video/mp4" === e.mimeType || "video/webm" === e.mimeType || "video" === e.contentType,
                Re = ({
                    attributes: e
                }) => "audio/mp4" === e.mimeType || "audio/webm" === e.mimeType || "audio" === e.contentType,
                ke = ({
                    attributes: e
                }) => "text/vtt" === e.mimeType || "text" === e.contentType,
                De = e => e ? Object.keys(e).reduce(((t, i) => {
                    const n = e[i];
                    return t.concat(n.playlists)
                }), []) : [],
                Oe = ({
                    dashPlaylists: e,
                    locations: t,
                    sidxMapping: i = {},
                    previousManifest: n
                }) => {
                    if (!e.length) return {};
                    const {
                        sourceDuration: r,
                        type: s,
                        suggestedPresentationDelay: a,
                        minimumUpdatePeriod: o
                    } = e[0].attributes, l = Ce(e.filter(Pe)).map(Ie), h = Ce(e.filter(Re)), c = Ce(e.filter(ke)), u = e.map((e => e.attributes.captionServices)).filter(Boolean), d = {
                        allowCache: !0,
                        discontinuityStarts: [],
                        segments: [],
                        endList: !0,
                        mediaGroups: {
                            AUDIO: {},
                            VIDEO: {},
                            "CLOSED-CAPTIONS": {},
                            SUBTITLES: {}
                        },
                        uri: "",
                        duration: r,
                        playlists: Le(l, i)
                    };
                    o >= 0 && (d.minimumUpdatePeriod = 1e3 * o), t && (d.locations = t), "dynamic" === s && (d.suggestedPresentationDelay = a);
                    const p = 0 === d.playlists.length,
                        f = h.length ? ((e, t = {}, i = !1) => {
                            let n;
                            const r = e.reduce(((e, r) => {
                                const s = r.attributes.role && r.attributes.role.value || "",
                                    a = r.attributes.lang || "";
                                let o = r.attributes.label || "main";
                                if (a && !r.attributes.label) {
                                    const e = s ? ` (${s})` : "";
                                    o = `${r.attributes.lang}${e}`
                                }
                                e[o] || (e[o] = {
                                    language: a,
                                    autoselect: !0,
                                    default: "main" === s,
                                    playlists: [],
                                    uri: ""
                                });
                                const l = Ae((({
                                    attributes: e,
                                    segments: t,
                                    sidx: i,
                                    mediaSequence: n,
                                    discontinuitySequence: r,
                                    discontinuityStarts: s
                                }, a) => {
                                    const o = {
                                        attributes: {
                                            NAME: e.id,
                                            BANDWIDTH: e.bandwidth,
                                            CODECS: e.codecs,
                                            "PROGRAM-ID": 1
                                        },
                                        uri: "",
                                        endList: "static" === e.type,
                                        timeline: e.periodStart,
                                        resolvedUri: "",
                                        targetDuration: e.duration,
                                        discontinuitySequence: r,
                                        discontinuityStarts: s,
                                        timelineStarts: e.timelineStarts,
                                        mediaSequence: n,
                                        segments: t
                                    };
                                    return e.contentProtection && (o.contentProtection = e.contentProtection), i && (o.sidx = i), a && (o.attributes.AUDIO = "audio", o.attributes.SUBTITLES = "subs"), o
                                })(r, i), t);
                                return e[o].playlists.push(l), void 0 === n && "main" === s && (n = r, n.default = !0), e
                            }), {});
                            n || (r[Object.keys(r)[0]].default = !0);
                            return r
                        })(h, i, p) : null,
                        m = c.length ? ((e, t = {}) => e.reduce(((e, i) => {
                            const n = i.attributes.lang || "text";
                            return e[n] || (e[n] = {
                                language: n,
                                default: !1,
                                autoselect: !1,
                                playlists: [],
                                uri: ""
                            }), e[n].playlists.push(Ae((({
                                attributes: e,
                                segments: t,
                                mediaSequence: i,
                                discontinuityStarts: n,
                                discontinuitySequence: r
                            }) => {
                                void 0 === t && (t = [{
                                    uri: e.baseUrl,
                                    timeline: e.periodStart,
                                    resolvedUri: e.baseUrl || "",
                                    duration: e.sourceDuration,
                                    number: 0
                                }], e.duration = e.sourceDuration);
                                const s = {
                                    NAME: e.id,
                                    BANDWIDTH: e.bandwidth,
                                    "PROGRAM-ID": 1
                                };
                                return e.codecs && (s.CODECS = e.codecs), {
                                    attributes: s,
                                    uri: "",
                                    endList: "static" === e.type,
                                    timeline: e.periodStart,
                                    resolvedUri: e.baseUrl || "",
                                    targetDuration: e.duration,
                                    timelineStarts: e.timelineStarts,
                                    discontinuityStarts: n,
                                    discontinuitySequence: r,
                                    mediaSequence: i,
                                    segments: t
                                }
                            })(i), t)), e
                        }), {}))(c, i) : null,
                        g = l.concat(De(f), De(m)),
                        y = g.map((({
                            timelineStarts: e
                        }) => e));
                    var _, v;
                    return d.timelineStarts = xe(y), _ = g, v = d.timelineStarts, _.forEach((e => {
                        e.mediaSequence = 0, e.discontinuitySequence = v.findIndex((function({
                            timeline: t
                        }) {
                            return t === e.timeline
                        })), e.segments && e.segments.forEach(((e, t) => {
                            e.number = t
                        }))
                    })), f && (d.mediaGroups.AUDIO.audio = f), m && (d.mediaGroups.SUBTITLES.subs = m), u.length && (d.mediaGroups["CLOSED-CAPTIONS"].cc = u.reduce(((e, t) => t ? (t.forEach((t => {
                        const {
                            channel: i,
                            language: n
                        } = t;
                        e[n] = {
                            autoselect: !1,
                            default: !1,
                            instreamId: i,
                            language: n
                        }, t.hasOwnProperty("aspectRatio") && (e[n].aspectRatio = t.aspectRatio), t.hasOwnProperty("easyReader") && (e[n].easyReader = t.easyReader), t.hasOwnProperty("3D") && (e[n]["3D"] = t["3D"])
                    })), e) : e), {})), n ? Ee({
                        oldManifest: n,
                        newManifest: d
                    }) : d
                },
                Ne = (e, t, i) => {
                    const {
                        NOW: n,
                        clientOffset: r,
                        availabilityStartTime: s,
                        timescale: a = 1,
                        periodStart: o = 0,
                        minimumUpdatePeriod: l = 0
                    } = e, h = (n + r) / 1e3 + l - (s + o);
                    return Math.ceil((h * a - t) / i)
                },
                Ue = (e, t) => {
                    const {
                        type: i,
                        minimumUpdatePeriod: n = 0,
                        media: r = "",
                        sourceDuration: s,
                        timescale: a = 1,
                        startNumber: o = 1,
                        periodStart: l
                    } = e, h = [];
                    let c = -1;
                    for (let u = 0; u < t.length; u++) {
                        const d = t[u],
                            p = d.d,
                            f = d.r || 0,
                            m = d.t || 0;
                        let g;
                        if (c < 0 && (c = m), m && m > c && (c = m), f < 0) {
                            const o = u + 1;
                            g = o === t.length ? "dynamic" === i && n > 0 && r.indexOf("$Number$") > 0 ? Ne(e, c, p) : (s * a - c) / p : (t[o].t - c) / p
                        } else g = f + 1;
                        const y = o + h.length + g;
                        let _ = o + h.length;
                        for (; _ < y;) h.push({
                            number: _,
                            duration: p / a,
                            time: c,
                            timeline: l
                        }), c += p, _++
                    }
                    return h
                },
                Be = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g,
                Fe = (e, t) => e.replace(Be, (e => (t, i, n, r) => {
                    if ("$$" === t) return "$";
                    if (void 0 === e[i]) return t;
                    const s = "" + e[i];
                    return "RepresentationID" === i ? s : (r = n ? parseInt(r, 10) : 1, s.length >= r ? s : `${new Array(r-s.length+1).join("0")}${s}`)
                })(t)),
                He = (e, t) => {
                    const i = {
                            RepresentationID: e.id,
                            Bandwidth: e.bandwidth || 0
                        },
                        {
                            initialization: n = {
                                sourceURL: "",
                                range: ""
                            }
                        } = e,
                        r = me({
                            baseUrl: e.baseUrl,
                            source: Fe(n.sourceURL, i),
                            range: n.range
                        }),
                        s = ((e, t) => e.duration || t ? e.duration ? _e(e) : Ue(e, t) : [{
                            number: e.startNumber || 1,
                            duration: e.sourceDuration,
                            time: 0,
                            timeline: e.periodStart
                        }])(e, t);
                    return s.map((t => {
                        i.Number = t.number, i.Time = t.time;
                        const n = Fe(e.media || "", i),
                            s = e.timescale || 1,
                            a = e.presentationTimeOffset || 0,
                            o = e.periodStart + (t.time - a) / s;
                        return {
                            uri: n,
                            timeline: t.timeline,
                            duration: t.duration,
                            resolvedUri: ie(e.baseUrl || "", n),
                            map: r,
                            number: t.number,
                            presentationTime: o
                        }
                    }))
                },
                ze = (e, t) => {
                    const {
                        duration: i,
                        segmentUrls: n = [],
                        periodStart: r
                    } = e;
                    if (!i && !t || i && t) throw new Error(pe);
                    const s = n.map((t => ((e, t) => {
                        const {
                            baseUrl: i,
                            initialization: n = {}
                        } = e, r = me({
                            baseUrl: i,
                            source: n.sourceURL,
                            range: n.range
                        }), s = me({
                            baseUrl: i,
                            source: t.media,
                            range: t.mediaRange
                        });
                        return s.map = r, s
                    })(e, t)));
                    let a;
                    i && (a = _e(e)), t && (a = Ue(e, t));
                    return a.map(((t, i) => {
                        if (s[i]) {
                            const n = s[i],
                                a = e.timescale || 1,
                                o = e.presentationTimeOffset || 0;
                            return n.timeline = t.timeline, n.duration = t.duration, n.number = t.number, n.presentationTime = r + (t.time - o) / a, n
                        }
                    })).filter((e => e))
                },
                Ve = ({
                    attributes: e,
                    segmentInfo: t
                }) => {
                    let i, n;
                    t.template ? (n = He, i = se(e, t.template)) : t.base ? (n = ve, i = se(e, t.base)) : t.list && (n = ze, i = se(e, t.list));
                    const r = {
                        attributes: e
                    };
                    if (!n) return r;
                    const s = n(i, t.segmentTimeline);
                    if (i.duration) {
                        const {
                            duration: e,
                            timescale: t = 1
                        } = i;
                        i.duration = e / t
                    } else s.length ? i.duration = s.reduce(((e, t) => Math.max(e, Math.ceil(t.duration))), 0) : i.duration = 0;
                    return r.attributes = i, r.segments = s, t.base && i.indexRange && (r.sidx = s[0], r.segments = []), r
                },
                Ge = (e, t) => le(e.childNodes).filter((({
                    tagName: e
                }) => e === t)),
                We = e => e.textContent.trim(),
                je = e => {
                    const t = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/.exec(e);
                    if (!t) return 0;
                    const [i, n, r, s, a, o] = t.slice(1);
                    return 31536e3 * parseFloat(i || 0) + 2592e3 * parseFloat(n || 0) + 86400 * parseFloat(r || 0) + 3600 * parseFloat(s || 0) + 60 * parseFloat(a || 0) + parseFloat(o || 0)
                },
                qe = {
                    mediaPresentationDuration: e => je(e),
                    availabilityStartTime(e) {
                        return /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(t = e) && (t += "Z"), Date.parse(t) / 1e3;
                        var t
                    },
                    minimumUpdatePeriod: e => je(e),
                    suggestedPresentationDelay: e => je(e),
                    type: e => e,
                    timeShiftBufferDepth: e => je(e),
                    start: e => je(e),
                    width: e => parseInt(e, 10),
                    height: e => parseInt(e, 10),
                    bandwidth: e => parseInt(e, 10),
                    frameRate: e => (e => parseFloat(e.split("/").reduce(((e, t) => e / t))))(e),
                    startNumber: e => parseInt(e, 10),
                    timescale: e => parseInt(e, 10),
                    presentationTimeOffset: e => parseInt(e, 10),
                    duration(e) {
                        const t = parseInt(e, 10);
                        return isNaN(t) ? je(e) : t
                    },
                    d: e => parseInt(e, 10),
                    t: e => parseInt(e, 10),
                    r: e => parseInt(e, 10),
                    DEFAULT: e => e
                },
                $e = e => e && e.attributes ? le(e.attributes).reduce(((e, t) => {
                    const i = qe[t.name] || qe.DEFAULT;
                    return e[t.name] = i(t.value), e
                }), {}) : {},
                Xe = {
                    "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
                    "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
                    "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
                    "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
                },
                Ye = (e, t) => t.length ? oe(e.map((function(e) {
                    return t.map((function(t) {
                        return ie(e, We(t))
                    }))
                }))) : e,
                Ke = e => {
                    const t = Ge(e, "SegmentTemplate")[0],
                        i = Ge(e, "SegmentList")[0],
                        n = i && Ge(i, "SegmentURL").map((e => se({
                            tag: "SegmentURL"
                        }, $e(e)))),
                        r = Ge(e, "SegmentBase")[0],
                        s = i || t,
                        a = s && Ge(s, "SegmentTimeline")[0],
                        o = i || r || t,
                        l = o && Ge(o, "Initialization")[0],
                        h = t && $e(t);
                    h && l ? h.initialization = l && $e(l) : h && h.initialization && (h.initialization = {
                        sourceURL: h.initialization
                    });
                    const c = {
                        template: h,
                        segmentTimeline: a && Ge(a, "S").map((e => $e(e))),
                        list: i && se($e(i), {
                            segmentUrls: n,
                            initialization: $e(l)
                        }),
                        base: r && se($e(r), {
                            initialization: $e(l)
                        })
                    };
                    return Object.keys(c).forEach((e => {
                        c[e] || delete c[e]
                    })), c
                },
                Je = (e, t, i) => n => {
                    const r = $e(n),
                        s = Ye(t, Ge(n, "BaseURL")),
                        a = Ge(n, "Role")[0],
                        o = {
                            role: $e(a)
                        };
                    let l = se(e, r, o);
                    const h = Ge(n, "Accessibility")[0],
                        c = (e => {
                            if ("urn:scte:dash:cc:cea-608:2015" === e.schemeIdUri) return ("string" != typeof e.value ? [] : e.value.split(";")).map((e => {
                                let t, i;
                                return i = e, /^CC\d=/.test(e) ? [t, i] = e.split("=") : /^CC\d$/.test(e) && (t = e), {
                                    channel: t,
                                    language: i
                                }
                            }));
                            if ("urn:scte:dash:cc:cea-708:2015" === e.schemeIdUri) return ("string" != typeof e.value ? [] : e.value.split(";")).map((e => {
                                const t = {
                                    channel: void 0,
                                    language: void 0,
                                    aspectRatio: 1,
                                    easyReader: 0,
                                    "3D": 0
                                };
                                if (/=/.test(e)) {
                                    const [i, n = ""] = e.split("=");
                                    t.channel = i, t.language = e, n.split(",").forEach((e => {
                                        const [i, n] = e.split(":");
                                        "lang" === i ? t.language = n : "er" === i ? t.easyReader = Number(n) : "war" === i ? t.aspectRatio = Number(n) : "3D" === i && (t["3D"] = Number(n))
                                    }))
                                } else t.language = e;
                                return t.channel && (t.channel = "SERVICE" + t.channel), t
                            }))
                        })($e(h));
                    c && (l = se(l, {
                        captionServices: c
                    }));
                    const u = Ge(n, "Label")[0];
                    if (u && u.childNodes.length) {
                        const e = u.childNodes[0].nodeValue.trim();
                        l = se(l, {
                            label: e
                        })
                    }
                    const d = Ge(n, "ContentProtection").reduce(((e, t) => {
                        const i = $e(t);
                        i.schemeIdUri && (i.schemeIdUri = i.schemeIdUri.toLowerCase());
                        const n = Xe[i.schemeIdUri];
                        if (n) {
                            e[n] = {
                                attributes: i
                            };
                            const r = Ge(t, "cenc:pssh")[0];
                            if (r) {
                                const t = We(r);
                                e[n].pssh = t && w(t)
                            }
                        }
                        return e
                    }), {});
                    Object.keys(d).length && (l = se(l, {
                        contentProtection: d
                    }));
                    const p = Ke(n),
                        f = Ge(n, "Representation"),
                        m = se(i, p);
                    return oe(f.map(((e, t, i) => n => {
                        const r = Ge(n, "BaseURL"),
                            s = Ye(t, r),
                            a = se(e, $e(n)),
                            o = Ke(n);
                        return s.map((e => ({
                            segmentInfo: se(i, o),
                            attributes: se(a, {
                                baseUrl: e
                            })
                        })))
                    })(l, s, m)))
                },
                Ze = (e, t) => (i, n) => {
                    const r = Ye(t, Ge(i.node, "BaseURL")),
                        s = se(e, {
                            periodStart: i.attributes.start
                        });
                    "number" == typeof i.attributes.duration && (s.periodDuration = i.attributes.duration);
                    const a = Ge(i.node, "AdaptationSet"),
                        o = Ke(i.node);
                    return oe(a.map(Je(s, r, o)))
                },
                Qe = e => {
                    if ("" === e) throw new Error(ce);
                    const t = new ne.DOMParser;
                    let i, n;
                    try {
                        i = t.parseFromString(e, "application/xml"), n = i && "MPD" === i.documentElement.tagName ? i.documentElement : null
                    } catch (e) {}
                    if (!n || n && n.getElementsByTagName("parsererror").length > 0) throw new Error(ue);
                    return n
                },
                et = (e, t = {}) => {
                    const i = ((e, t = {}) => {
                            const {
                                manifestUri: i = "",
                                NOW: n = Date.now(),
                                clientOffset: r = 0
                            } = t, s = Ge(e, "Period");
                            if (!s.length) throw new Error(he);
                            const a = Ge(e, "Location"),
                                o = $e(e),
                                l = Ye([i], Ge(e, "BaseURL"));
                            o.type = o.type || "static", o.sourceDuration = o.mediaPresentationDuration || 0, o.NOW = n, o.clientOffset = r, a.length && (o.locations = a.map(We));
                            const h = [];
                            return s.forEach(((e, t) => {
                                const i = $e(e),
                                    n = h[t - 1];
                                i.start = (({
                                    attributes: e,
                                    priorPeriodAttributes: t,
                                    mpdType: i
                                }) => "number" == typeof e.start ? e.start : t && "number" == typeof t.start && "number" == typeof t.duration ? t.start + t.duration : t || "static" !== i ? null : 0)({
                                    attributes: i,
                                    priorPeriodAttributes: n ? n.attributes : null,
                                    mpdType: o.type
                                }), h.push({
                                    node: e,
                                    attributes: i
                                })
                            })), {
                                locations: o.locations,
                                representationInfo: oe(h.map(Ze(o, l)))
                            }
                        })(Qe(e), t),
                        n = i.representationInfo.map(Ve);
                    return Oe({
                        dashPlaylists: n,
                        locations: i.locations,
                        sidxMapping: t.sidxMapping,
                        previousManifest: t.previousManifest
                    })
                },
                tt = e => (e => {
                    const t = Ge(e, "UTCTiming")[0];
                    if (!t) return null;
                    const i = $e(t);
                    switch (i.schemeIdUri) {
                        case "urn:mpeg:dash:utc:http-head:2014":
                        case "urn:mpeg:dash:utc:http-head:2012":
                            i.method = "HEAD";
                            break;
                        case "urn:mpeg:dash:utc:http-xsdate:2014":
                        case "urn:mpeg:dash:utc:http-iso:2014":
                        case "urn:mpeg:dash:utc:http-xsdate:2012":
                        case "urn:mpeg:dash:utc:http-iso:2012":
                            i.method = "GET";
                            break;
                        case "urn:mpeg:dash:utc:direct:2014":
                        case "urn:mpeg:dash:utc:direct:2012":
                            i.method = "DIRECT", i.value = Date.parse(i.value);
                            break;
                        default:
                            throw new Error(fe)
                    }
                    return i
                })(Qe(e));
            var it, nt = i(3047),
                rt = i.n(nt),
                st = X([73, 68, 51]),
                at = function e(t, i) {
                    return void 0 === i && (i = 0), (t = X(t)).length - i < 10 || !ee(t, st, {
                        offset: i
                    }) ? i : (i += function(e, t) {
                        void 0 === t && (t = 0);
                        var i = (e = X(e))[t + 5],
                            n = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9];
                        return (16 & i) >> 4 ? n + 20 : n + 10
                    }(t, i), e(t, i))
                },
                ot = (new Uint8Array([79, 112, 117, 115, 72, 101, 97, 100]), function(e) {
                    return "string" == typeof e ? Q(e) : e
                }),
                lt = function(e) {
                    e = X(e);
                    for (var t = [], i = 0; e.length > i;) {
                        var n = e[i],
                            r = 0,
                            s = 0,
                            a = e[++s];
                        for (s++; 128 & a;) r = (127 & a) << 7, a = e[s], s++;
                        r += 127 & a;
                        for (var o = 0; o < it.length; o++) {
                            var l = it[o],
                                h = l.id,
                                c = l.parser;
                            if (n === h) {
                                t.push(c(e.subarray(s, s + r)));
                                break
                            }
                        }
                        i += r + s
                    }
                    return t
                };
            it = [{
                id: 3,
                parser: function(e) {
                    var t = {
                        tag: 3,
                        id: e[0] << 8 | e[1],
                        flags: e[2],
                        size: 3,
                        dependsOnEsId: 0,
                        ocrEsId: 0,
                        descriptors: [],
                        url: ""
                    };
                    if (128 & t.flags && (t.dependsOnEsId = e[t.size] << 8 | e[t.size + 1], t.size += 2), 64 & t.flags) {
                        var i = e[t.size];
                        t.url = function(e) {
                            if (!e) return "";
                            e = Array.prototype.slice.call(e);
                            var t = String.fromCharCode.apply(null, X(e));
                            try {
                                return decodeURIComponent(escape(t))
                            } catch (e) {}
                            return t
                        }(e.subarray(t.size + 1, t.size + 1 + i)), t.size += i
                    }
                    return 32 & t.flags && (t.ocrEsId = e[t.size] << 8 | e[t.size + 1], t.size += 2), t.descriptors = lt(e.subarray(t.size)) || [], t
                }
            }, {
                id: 4,
                parser: function(e) {
                    return {
                        tag: 4,
                        oti: e[0],
                        streamType: e[1],
                        bufferSize: e[2] << 16 | e[3] << 8 | e[4],
                        maxBitrate: e[5] << 24 | e[6] << 16 | e[7] << 8 | e[8],
                        avgBitrate: e[9] << 24 | e[10] << 16 | e[11] << 8 | e[12],
                        descriptors: lt(e.subarray(13))
                    }
                }
            }, {
                id: 5,
                parser: function(e) {
                    return {
                        tag: 5,
                        bytes: e
                    }
                }
            }, {
                id: 6,
                parser: function(e) {
                    return {
                        tag: 6,
                        bytes: e
                    }
                }
            }];
            var ht = function e(t, i, n) {
                    void 0 === n && (n = !1), i = function(e) {
                        return Array.isArray(e) ? e.map((function(e) {
                            return ot(e)
                        })) : [ot(e)]
                    }(i), t = X(t);
                    var r = [];
                    if (!i.length) return r;
                    for (var s = 0; s < t.length;) {
                        var a = (t[s] << 24 | t[s + 1] << 16 | t[s + 2] << 8 | t[s + 3]) >>> 0,
                            o = t.subarray(s + 4, s + 8);
                        if (0 === a) break;
                        var l = s + a;
                        if (l > t.length) {
                            if (n) break;
                            l = t.length
                        }
                        var h = t.subarray(s + 8, l);
                        ee(o, i[0]) && (1 === i.length ? r.push(h) : r.push.apply(r, e(h, i.slice(1), n))), s = l
                    }
                    return r
                },
                ct = {
                    EBML: X([26, 69, 223, 163]),
                    DocType: X([66, 130]),
                    Segment: X([24, 83, 128, 103]),
                    SegmentInfo: X([21, 73, 169, 102]),
                    Tracks: X([22, 84, 174, 107]),
                    Track: X([174]),
                    TrackNumber: X([215]),
                    DefaultDuration: X([35, 227, 131]),
                    TrackEntry: X([174]),
                    TrackType: X([131]),
                    FlagDefault: X([136]),
                    CodecID: X([134]),
                    CodecPrivate: X([99, 162]),
                    VideoTrack: X([224]),
                    AudioTrack: X([225]),
                    Cluster: X([31, 67, 182, 117]),
                    Timestamp: X([231]),
                    TimestampScale: X([42, 215, 177]),
                    BlockGroup: X([160]),
                    BlockDuration: X([155]),
                    Block: X([161]),
                    SimpleBlock: X([163])
                },
                ut = [128, 64, 32, 16, 8, 4, 2, 1],
                dt = function(e, t, i, n) {
                    void 0 === i && (i = !0), void 0 === n && (n = !1);
                    var r = function(e) {
                            for (var t = 1, i = 0; i < ut.length && !(e & ut[i]); i++) t++;
                            return t
                        }(e[t]),
                        s = e.subarray(t, t + r);
                    return i && ((s = Array.prototype.slice.call(e, t, t + r))[0] ^= ut[r - 1]), {
                        length: r,
                        value: J(s, {
                            signed: n
                        }),
                        bytes: s
                    }
                },
                pt = function e(t) {
                    return "string" == typeof t ? t.match(/.{1,2}/g).map((function(t) {
                        return e(t)
                    })) : "number" == typeof t ? Z(t) : t
                },
                ft = function e(t, i, n) {
                    if (n >= i.length) return i.length;
                    var r = dt(i, n, !1);
                    if (ee(t.bytes, r.bytes)) return n;
                    var s = dt(i, n + r.length);
                    return e(t, i, n + s.length + s.value + r.length)
                },
                mt = function e(t, i) {
                    i = function(e) {
                        return Array.isArray(e) ? e.map((function(e) {
                            return pt(e)
                        })) : [pt(e)]
                    }(i), t = X(t);
                    var n = [];
                    if (!i.length) return n;
                    for (var r = 0; r < t.length;) {
                        var s = dt(t, r, !1),
                            a = dt(t, r + s.length),
                            o = r + s.length + a.length;
                        127 === a.value && (a.value = ft(s, t, o), a.value !== t.length && (a.value -= o));
                        var l = o + a.value > t.length ? t.length : o + a.value,
                            h = t.subarray(o, l);
                        ee(i[0], s.bytes) && (1 === i.length ? n.push(h) : n = n.concat(e(h, i.slice(1)))), r += s.length + a.length + h.length
                    }
                    return n
                },
                gt = X([0, 0, 0, 1]),
                yt = X([0, 0, 1]),
                _t = X([0, 0, 3]),
                vt = function(e) {
                    for (var t = [], i = 1; i < e.length - 2;) ee(e.subarray(i, i + 3), _t) && (t.push(i + 2), i++), i++;
                    if (0 === t.length) return e;
                    var n = e.length - t.length,
                        r = new Uint8Array(n),
                        s = 0;
                    for (i = 0; i < n; s++, i++) s === t[0] && (s++, t.shift()), r[i] = e[s];
                    return r
                },
                bt = function(e, t, i, n) {
                    void 0 === n && (n = 1 / 0), e = X(e), i = [].concat(i);
                    for (var r, s = 0, a = 0; s < e.length && (a < n || r);) {
                        var o = void 0;
                        if (ee(e.subarray(s), gt) ? o = 4 : ee(e.subarray(s), yt) && (o = 3), o) {
                            if (a++, r) return vt(e.subarray(r, s));
                            var l = void 0;
                            "h264" === t ? l = 31 & e[s + o] : "h265" === t && (l = e[s + o] >> 1 & 63), -1 !== i.indexOf(l) && (r = s + o), s += o + ("h264" === t ? 1 : 2)
                        } else s++
                    }
                    return e.subarray(0, 0)
                },
                Tt = {
                    webm: X([119, 101, 98, 109]),
                    matroska: X([109, 97, 116, 114, 111, 115, 107, 97]),
                    flac: X([102, 76, 97, 67]),
                    ogg: X([79, 103, 103, 83]),
                    ac3: X([11, 119]),
                    riff: X([82, 73, 70, 70]),
                    avi: X([65, 86, 73]),
                    wav: X([87, 65, 86, 69]),
                    "3gp": X([102, 116, 121, 112, 51, 103]),
                    mp4: X([102, 116, 121, 112]),
                    fmp4: X([115, 116, 121, 112]),
                    mov: X([102, 116, 121, 112, 113, 116]),
                    moov: X([109, 111, 111, 118]),
                    moof: X([109, 111, 111, 102])
                },
                xt = {
                    aac: function(e) {
                        var t = at(e);
                        return ee(e, [255, 16], {
                            offset: t,
                            mask: [255, 22]
                        })
                    },
                    mp3: function(e) {
                        var t = at(e);
                        return ee(e, [255, 2], {
                            offset: t,
                            mask: [255, 6]
                        })
                    },
                    webm: function(e) {
                        var t = mt(e, [ct.EBML, ct.DocType])[0];
                        return ee(t, Tt.webm)
                    },
                    mkv: function(e) {
                        var t = mt(e, [ct.EBML, ct.DocType])[0];
                        return ee(t, Tt.matroska)
                    },
                    mp4: function(e) {
                        return !xt["3gp"](e) && !xt.mov(e) && (!(!ee(e, Tt.mp4, {
                            offset: 4
                        }) && !ee(e, Tt.fmp4, {
                            offset: 4
                        })) || (!(!ee(e, Tt.moof, {
                            offset: 4
                        }) && !ee(e, Tt.moov, {
                            offset: 4
                        })) || void 0))
                    },
                    mov: function(e) {
                        return ee(e, Tt.mov, {
                            offset: 4
                        })
                    },
                    "3gp": function(e) {
                        return ee(e, Tt["3gp"], {
                            offset: 4
                        })
                    },
                    ac3: function(e) {
                        var t = at(e);
                        return ee(e, Tt.ac3, {
                            offset: t
                        })
                    },
                    ts: function(e) {
                        if (e.length < 189 && e.length >= 1) return 71 === e[0];
                        for (var t = 0; t + 188 < e.length && t < 188;) {
                            if (71 === e[t] && 71 === e[t + 188]) return !0;
                            t += 1
                        }
                        return !1
                    },
                    flac: function(e) {
                        var t = at(e);
                        return ee(e, Tt.flac, {
                            offset: t
                        })
                    },
                    ogg: function(e) {
                        return ee(e, Tt.ogg)
                    },
                    avi: function(e) {
                        return ee(e, Tt.riff) && ee(e, Tt.avi, {
                            offset: 8
                        })
                    },
                    wav: function(e) {
                        return ee(e, Tt.riff) && ee(e, Tt.wav, {
                            offset: 8
                        })
                    },
                    h264: function(e) {
                        return function(e, t, i) {
                            return bt(e, "h264", t, i)
                        }(e, 7, 3).length
                    },
                    h265: function(e) {
                        return function(e, t, i) {
                            return bt(e, "h265", t, i)
                        }(e, [32, 33], 3).length
                    }
                },
                wt = Object.keys(xt).filter((function(e) {
                    return "ts" !== e && "h264" !== e && "h265" !== e
                })).concat(["ts", "h264", "h265"]);
            wt.forEach((function(e) {
                var t = xt[e];
                xt[e] = function(e) {
                    return t(X(e))
                }
            }));
            var St = xt,
                Et = function(e) {
                    e = X(e);
                    for (var t = 0; t < wt.length; t++) {
                        var i = wt[t];
                        if (St[i](e)) return i
                    }
                    return ""
                },
                Mt = i(5531),
                Ct = "8.0.4";
            const At = {},
                Lt = function(e, t) {
                    return At[e] = At[e] || [], t && (At[e] = At[e].concat(t)), At[e]
                },
                It = function(e, t) {
                    const i = Lt(e).indexOf(t);
                    return !(i <= -1) && (At[e] = At[e].slice(), At[e].splice(i, 1), !0)
                },
                Pt = {
                    prefixed: !0
                },
                Rt = [
                    ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"],
                    ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"],
                    ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror", "-moz-full-screen"],
                    ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError", "-ms-fullscreen"]
                ],
                kt = Rt[0];
            let Dt;
            for (let e = 0; e < Rt.length; e++)
                if (Rt[e][1] in a()) {
                    Dt = Rt[e];
                    break
                }
            if (Dt) {
                for (let e = 0; e < Dt.length; e++) Pt[kt[e]] = Dt[e];
                Pt.prefixed = Dt[0] !== kt[0]
            }
            let Ot = [];
            const Nt = (e, t) => (i, n, s) => {
                const a = t.levels[n],
                    o = new RegExp(`^(${a})$`);
                if ("log" !== i && s.unshift(i.toUpperCase() + ":"), s.unshift(e + ":"), Ot) {
                    Ot.push([].concat(s));
                    const e = Ot.length - 1e3;
                    Ot.splice(0, e > 0 ? e : 0)
                }
                if (!r().console) return;
                let l = r().console[i];
                l || "debug" !== i || (l = r().console.info || r().console.log), l && a && o.test(i) && l[Array.isArray(s) ? "apply" : "call"](r().console, s)
            };
            const Ut = function e(t) {
                    let i, n = "info";
                    const r = function(...e) {
                        i("log", n, e)
                    };
                    return i = Nt(t, r), r.createLogger = i => e(t + ": " + i), r.levels = {
                        all: "debug|log|warn|error",
                        off: "",
                        debug: "debug|log|warn|error",
                        info: "log|warn|error",
                        warn: "warn|error",
                        error: "error",
                        DEFAULT: n
                    }, r.level = e => {
                        if ("string" == typeof e) {
                            if (!r.levels.hasOwnProperty(e)) throw new Error(`"${e}" in not a valid log level`);
                            n = e
                        }
                        return n
                    }, (r.history = () => Ot ? [].concat(Ot) : []).filter = e => (Ot || []).filter((t => new RegExp(`.*${e}.*`).test(t[0]))), r.history.clear = () => {
                        Ot && (Ot.length = 0)
                    }, r.history.disable = () => {
                        null !== Ot && (Ot.length = 0, Ot = null)
                    }, r.history.enable = () => {
                        null === Ot && (Ot = [])
                    }, r.error = (...e) => i("error", n, e), r.warn = (...e) => i("warn", n, e), r.debug = (...e) => i("debug", n, e), r
                }("VIDEOJS"),
                Bt = Ut.createLogger,
                Ft = Object.prototype.toString,
                Ht = function(e) {
                    return Gt(e) ? Object.keys(e) : []
                };

            function zt(e, t) {
                Ht(e).forEach((i => t(e[i], i)))
            }

            function Vt(e, t, i = 0) {
                return Ht(e).reduce(((i, n) => t(i, e[n], n)), i)
            }

            function Gt(e) {
                return !!e && "object" == typeof e
            }

            function Wt(e) {
                return Gt(e) && "[object Object]" === Ft.call(e) && e.constructor === Object
            }

            function jt(...e) {
                const t = {};
                return e.forEach((e => {
                    e && zt(e, ((e, i) => {
                        Wt(e) ? (Wt(t[i]) || (t[i] = {}), t[i] = jt(t[i], e)) : t[i] = e
                    }))
                })), t
            }

            function qt(e, t, i, n = !0) {
                const r = i => Object.defineProperty(e, t, {
                        value: i,
                        enumerable: !0,
                        writable: !0
                    }),
                    s = {
                        configurable: !0,
                        enumerable: !0,
                        get() {
                            const e = i();
                            return r(e), e
                        }
                    };
                return n && (s.set = r), Object.defineProperty(e, t, s)
            }
            var $t = Object.freeze({
                __proto__: null,
                each: zt,
                reduce: Vt,
                isObject: Gt,
                isPlain: Wt,
                merge: jt,
                defineLazyProperty: qt
            });
            let Xt, Yt = !1,
                Kt = null,
                Jt = !1,
                Zt = !1,
                Qt = !1,
                ei = !1,
                ti = !1,
                ii = null,
                ni = null,
                ri = null,
                si = !1,
                ai = !1,
                oi = !1,
                li = !1;
            const hi = Boolean(mi() && ("ontouchstart" in r() || r().navigator.maxTouchPoints || r().DocumentTouch && r().document instanceof r().DocumentTouch)),
                ci = r().navigator && r().navigator.userAgentData;
            if (ci && (Jt = "Android" === ci.platform, Qt = Boolean(ci.brands.find((e => "Microsoft Edge" === e.brand))), ei = Boolean(ci.brands.find((e => "Chromium" === e.brand))), ti = !Qt && ei, ii = ni = (ci.brands.find((e => "Chromium" === e.brand)) || {}).version || null, ai = "Windows" === ci.platform), !ei) {
                const e = r().navigator && r().navigator.userAgent || "";
                Yt = /iPod/i.test(e), Kt = function() {
                    const t = e.match(/OS (\d+)_/i);
                    return t && t[1] ? t[1] : null
                }(), Jt = /Android/i.test(e), Xt = function() {
                    const t = e.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
                    if (!t) return null;
                    const i = t[1] && parseFloat(t[1]),
                        n = t[2] && parseFloat(t[2]);
                    return i && n ? parseFloat(t[1] + "." + t[2]) : i || null
                }(), Zt = /Firefox/i.test(e), Qt = /Edg/i.test(e), ei = /Chrome/i.test(e) || /CriOS/i.test(e), ti = !Qt && ei, ii = ni = function() {
                    const t = e.match(/(Chrome|CriOS)\/(\d+)/);
                    return t && t[2] ? parseFloat(t[2]) : null
                }(), ri = function() {
                    const t = /MSIE\s(\d+)\.\d/.exec(e);
                    let i = t && parseFloat(t[1]);
                    return !i && /Trident\/7.0/i.test(e) && /rv:11.0/.test(e) && (i = 11), i
                }(), si = /Safari/i.test(e) && !ti && !Jt && !Qt, ai = /Windows/i.test(e), oi = /iPad/i.test(e) || si && hi && !/iPhone/i.test(e), li = /iPhone/i.test(e) && !oi
            }
            const ui = li || oi || Yt,
                di = (si || ui) && !ti;
            var pi = Object.freeze({
                __proto__: null,
                get IS_IPOD() {
                    return Yt
                },
                get IOS_VERSION() {
                    return Kt
                },
                get IS_ANDROID() {
                    return Jt
                },
                get ANDROID_VERSION() {
                    return Xt
                },
                get IS_FIREFOX() {
                    return Zt
                },
                get IS_EDGE() {
                    return Qt
                },
                get IS_CHROMIUM() {
                    return ei
                },
                get IS_CHROME() {
                    return ti
                },
                get CHROMIUM_VERSION() {
                    return ii
                },
                get CHROME_VERSION() {
                    return ni
                },
                get IE_VERSION() {
                    return ri
                },
                get IS_SAFARI() {
                    return si
                },
                get IS_WINDOWS() {
                    return ai
                },
                get IS_IPAD() {
                    return oi
                },
                get IS_IPHONE() {
                    return li
                },
                TOUCH_ENABLED: hi,
                IS_IOS: ui,
                IS_ANY_SAFARI: di
            });

            function fi(e) {
                return "string" == typeof e && Boolean(e.trim())
            }

            function mi() {
                return a() === r().document
            }

            function gi(e) {
                return Gt(e) && 1 === e.nodeType
            }

            function yi() {
                try {
                    return r().parent !== r().self
                } catch (e) {
                    return !0
                }
            }

            function _i(e) {
                return function(t, i) {
                    if (!fi(t)) return a()[e](null);
                    fi(i) && (i = a().querySelector(i));
                    const n = gi(i) ? i : a();
                    return n[e] && n[e](t)
                }
            }

            function vi(e = "div", t = {}, i = {}, n) {
                const r = a().createElement(e);
                return Object.getOwnPropertyNames(t).forEach((function(e) {
                    const i = t[e];
                    "textContent" === e ? bi(r, i) : r[e] === i && "tabIndex" !== e || (r[e] = i)
                })), Object.getOwnPropertyNames(i).forEach((function(e) {
                    r.setAttribute(e, i[e])
                })), n && Fi(r, n), r
            }

            function bi(e, t) {
                return void 0 === e.textContent ? e.innerText = t : e.textContent = t, e
            }

            function Ti(e, t) {
                t.firstChild ? t.insertBefore(e, t.firstChild) : t.appendChild(e)
            }

            function xi(e, t) {
                return function(e) {
                    if (e.indexOf(" ") >= 0) throw new Error("class has illegal whitespace characters")
                }(t), e.classList.contains(t)
            }

            function wi(e, ...t) {
                return e.classList.add(...t.reduce(((e, t) => e.concat(t.split(/\s+/))), [])), e
            }

            function Si(e, ...t) {
                return e ? (e.classList.remove(...t.reduce(((e, t) => e.concat(t.split(/\s+/))), [])), e) : (Ut.warn("removeClass was called with an element that doesn't exist"), null)
            }

            function Ei(e, t, i) {
                return "function" == typeof i && (i = i(e, t)), "boolean" != typeof i && (i = void 0), t.split(/\s+/).forEach((t => e.classList.toggle(t, i))), e
            }

            function Mi(e, t) {
                Object.getOwnPropertyNames(t).forEach((function(i) {
                    const n = t[i];
                    null == n || !1 === n ? e.removeAttribute(i) : e.setAttribute(i, !0 === n ? "" : n)
                }))
            }

            function Ci(e) {
                const t = {},
                    i = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,";
                if (e && e.attributes && e.attributes.length > 0) {
                    const n = e.attributes;
                    for (let r = n.length - 1; r >= 0; r--) {
                        const s = n[r].name;
                        let a = n[r].value;
                        "boolean" != typeof e[s] && -1 === i.indexOf("," + s + ",") || (a = null !== a), t[s] = a
                    }
                }
                return t
            }

            function Ai(e, t) {
                return e.getAttribute(t)
            }

            function Li(e, t, i) {
                e.setAttribute(t, i)
            }

            function Ii(e, t) {
                e.removeAttribute(t)
            }

            function Pi() {
                a().body.focus(), a().onselectstart = function() {
                    return !1
                }
            }

            function Ri() {
                a().onselectstart = function() {
                    return !0
                }
            }

            function ki(e) {
                if (e && e.getBoundingClientRect && e.parentNode) {
                    const t = e.getBoundingClientRect(),
                        i = {};
                    return ["bottom", "height", "left", "right", "top", "width"].forEach((e => {
                        void 0 !== t[e] && (i[e] = t[e])
                    })), i.height || (i.height = parseFloat(Wi(e, "height"))), i.width || (i.width = parseFloat(Wi(e, "width"))), i
                }
            }

            function Di(e) {
                if (!e || e && !e.offsetParent) return {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                };
                const t = e.offsetWidth,
                    i = e.offsetHeight;
                let n = 0,
                    r = 0;
                for (; e.offsetParent && e !== a()[Pt.fullscreenElement];) n += e.offsetLeft, r += e.offsetTop, e = e.offsetParent;
                return {
                    left: n,
                    top: r,
                    width: t,
                    height: i
                }
            }

            function Oi(e, t) {
                const i = {
                    x: 0,
                    y: 0
                };
                if (ui) {
                    let t = e;
                    for (; t && "html" !== t.nodeName.toLowerCase();) {
                        const e = Wi(t, "transform");
                        if (/^matrix/.test(e)) {
                            const t = e.slice(7, -1).split(/,\s/).map(Number);
                            i.x += t[4], i.y += t[5]
                        } else if (/^matrix3d/.test(e)) {
                            const t = e.slice(9, -1).split(/,\s/).map(Number);
                            i.x += t[12], i.y += t[13]
                        }
                        t = t.parentNode
                    }
                }
                const n = {},
                    r = Di(t.target),
                    s = Di(e),
                    a = s.width,
                    o = s.height;
                let l = t.offsetY - (s.top - r.top),
                    h = t.offsetX - (s.left - r.left);
                return t.changedTouches && (h = t.changedTouches[0].pageX - s.left, l = t.changedTouches[0].pageY + s.top, ui && (h -= i.x, l -= i.y)), n.y = 1 - Math.max(0, Math.min(1, l / o)), n.x = Math.max(0, Math.min(1, h / a)), n
            }

            function Ni(e) {
                return Gt(e) && 3 === e.nodeType
            }

            function Ui(e) {
                for (; e.firstChild;) e.removeChild(e.firstChild);
                return e
            }

            function Bi(e) {
                return "function" == typeof e && (e = e()), (Array.isArray(e) ? e : [e]).map((e => ("function" == typeof e && (e = e()), gi(e) || Ni(e) ? e : "string" == typeof e && /\S/.test(e) ? a().createTextNode(e) : void 0))).filter((e => e))
            }

            function Fi(e, t) {
                return Bi(t).forEach((t => e.appendChild(t))), e
            }

            function Hi(e, t) {
                return Fi(Ui(e), t)
            }

            function zi(e) {
                return void 0 === e.button && void 0 === e.buttons || (0 === e.button && void 0 === e.buttons || ("mouseup" === e.type && 0 === e.button && 0 === e.buttons || 0 === e.button && 1 === e.buttons))
            }
            const Vi = _i("querySelector"),
                Gi = _i("querySelectorAll");

            function Wi(e, t) {
                if (!e || !t) return "";
                if ("function" == typeof r().getComputedStyle) {
                    let i;
                    try {
                        i = r().getComputedStyle(e)
                    } catch (e) {
                        return ""
                    }
                    return i ? i.getPropertyValue(t) || i[t] : ""
                }
                return ""
            }
            var ji = Object.freeze({
                __proto__: null,
                isReal: mi,
                isEl: gi,
                isInFrame: yi,
                createEl: vi,
                textContent: bi,
                prependTo: Ti,
                hasClass: xi,
                addClass: wi,
                removeClass: Si,
                toggleClass: Ei,
                setAttributes: Mi,
                getAttributes: Ci,
                getAttribute: Ai,
                setAttribute: Li,
                removeAttribute: Ii,
                blockTextSelection: Pi,
                unblockTextSelection: Ri,
                getBoundingClientRect: ki,
                findPosition: Di,
                getPointerPosition: Oi,
                isTextNode: Ni,
                emptyEl: Ui,
                normalizeContent: Bi,
                appendContent: Fi,
                insertContent: Hi,
                isSingleLeftClick: zi,
                $: Vi,
                $$: Gi,
                computedStyle: Wi
            });
            let qi, $i = !1;
            const Xi = function() {
                if (!1 === qi.options.autoSetup) return;
                const e = Array.prototype.slice.call(a().getElementsByTagName("video")),
                    t = Array.prototype.slice.call(a().getElementsByTagName("audio")),
                    i = Array.prototype.slice.call(a().getElementsByTagName("video-js")),
                    n = e.concat(t, i);
                if (n && n.length > 0)
                    for (let e = 0, t = n.length; e < t; e++) {
                        const t = n[e];
                        if (!t || !t.getAttribute) {
                            Yi(1);
                            break
                        }
                        if (void 0 === t.player) {
                            null !== t.getAttribute("data-setup") && qi(t)
                        }
                    } else $i || Yi(1)
            };

            function Yi(e, t) {
                mi() && (t && (qi = t), r().setTimeout(Xi, e))
            }

            function Ki() {
                $i = !0, r().removeEventListener("load", Ki)
            }
            mi() && ("complete" === a().readyState ? Ki() : r().addEventListener("load", Ki));
            const Ji = function(e) {
                    const t = a().createElement("style");
                    return t.className = e, t
                },
                Zi = function(e, t) {
                    e.styleSheet ? e.styleSheet.cssText = t : e.textContent = t
                };
            var Qi = new WeakMap;
            let en, tn = 3;

            function nn() {
                return tn++
            }

            function rn(e, t) {
                if (!Qi.has(e)) return;
                const i = Qi.get(e);
                0 === i.handlers[t].length && (delete i.handlers[t], e.removeEventListener ? e.removeEventListener(t, i.dispatcher, !1) : e.detachEvent && e.detachEvent("on" + t, i.dispatcher)), Object.getOwnPropertyNames(i.handlers).length <= 0 && (delete i.handlers, delete i.dispatcher, delete i.disabled), 0 === Object.getOwnPropertyNames(i).length && Qi.delete(e)
            }

            function sn(e, t, i, n) {
                i.forEach((function(i) {
                    e(t, i, n)
                }))
            }

            function an(e) {
                if (e.fixed_) return e;

                function t() {
                    return !0
                }

                function i() {
                    return !1
                }
                if (!e || !e.isPropagationStopped || !e.isImmediatePropagationStopped) {
                    const n = e || r().event;
                    e = {};
                    for (const t in n) "layerX" !== t && "layerY" !== t && "keyLocation" !== t && "webkitMovementX" !== t && "webkitMovementY" !== t && "path" !== t && ("returnValue" === t && n.preventDefault || (e[t] = n[t]));
                    if (e.target || (e.target = e.srcElement || a()), e.relatedTarget || (e.relatedTarget = e.fromElement === e.target ? e.toElement : e.fromElement), e.preventDefault = function() {
                            n.preventDefault && n.preventDefault(), e.returnValue = !1, n.returnValue = !1, e.defaultPrevented = !0
                        }, e.defaultPrevented = !1, e.stopPropagation = function() {
                            n.stopPropagation && n.stopPropagation(), e.cancelBubble = !0, n.cancelBubble = !0, e.isPropagationStopped = t
                        }, e.isPropagationStopped = i, e.stopImmediatePropagation = function() {
                            n.stopImmediatePropagation && n.stopImmediatePropagation(), e.isImmediatePropagationStopped = t, e.stopPropagation()
                        }, e.isImmediatePropagationStopped = i, null !== e.clientX && void 0 !== e.clientX) {
                        const t = a().documentElement,
                            i = a().body;
                        e.pageX = e.clientX + (t && t.scrollLeft || i && i.scrollLeft || 0) - (t && t.clientLeft || i && i.clientLeft || 0), e.pageY = e.clientY + (t && t.scrollTop || i && i.scrollTop || 0) - (t && t.clientTop || i && i.clientTop || 0)
                    }
                    e.which = e.charCode || e.keyCode, null !== e.button && void 0 !== e.button && (e.button = 1 & e.button ? 0 : 4 & e.button ? 1 : 2 & e.button ? 2 : 0)
                }
                return e.fixed_ = !0, e
            }
            const on = function() {
                    if ("boolean" != typeof en) {
                        en = !1;
                        try {
                            const e = Object.defineProperty({}, "passive", {
                                get() {
                                    en = !0
                                }
                            });
                            r().addEventListener("test", null, e), r().removeEventListener("test", null, e)
                        } catch (e) {}
                    }
                    return en
                },
                ln = ["touchstart", "touchmove"];

            function hn(e, t, i) {
                if (Array.isArray(t)) return sn(hn, e, t, i);
                Qi.has(e) || Qi.set(e, {});
                const n = Qi.get(e);
                if (n.handlers || (n.handlers = {}), n.handlers[t] || (n.handlers[t] = []), i.guid || (i.guid = nn()), n.handlers[t].push(i), n.dispatcher || (n.disabled = !1, n.dispatcher = function(t, i) {
                        if (n.disabled) return;
                        t = an(t);
                        const r = n.handlers[t.type];
                        if (r) {
                            const n = r.slice(0);
                            for (let r = 0, s = n.length; r < s && !t.isImmediatePropagationStopped(); r++) try {
                                n[r].call(e, t, i)
                            } catch (e) {
                                Ut.error(e)
                            }
                        }
                    }), 1 === n.handlers[t].length)
                    if (e.addEventListener) {
                        let i = !1;
                        on() && ln.indexOf(t) > -1 && (i = {
                            passive: !0
                        }), e.addEventListener(t, n.dispatcher, i)
                    } else e.attachEvent && e.attachEvent("on" + t, n.dispatcher)
            }

            function cn(e, t, i) {
                if (!Qi.has(e)) return;
                const n = Qi.get(e);
                if (!n.handlers) return;
                if (Array.isArray(t)) return sn(cn, e, t, i);
                const r = function(e, t) {
                    n.handlers[t] = [], rn(e, t)
                };
                if (void 0 === t) {
                    for (const t in n.handlers) Object.prototype.hasOwnProperty.call(n.handlers || {}, t) && r(e, t);
                    return
                }
                const s = n.handlers[t];
                if (s)
                    if (i) {
                        if (i.guid)
                            for (let e = 0; e < s.length; e++) s[e].guid === i.guid && s.splice(e--, 1);
                        rn(e, t)
                    } else r(e, t)
            }

            function un(e, t, i) {
                const n = Qi.has(e) ? Qi.get(e) : {},
                    r = e.parentNode || e.ownerDocument;
                if ("string" == typeof t ? t = {
                        type: t,
                        target: e
                    } : t.target || (t.target = e), t = an(t), n.dispatcher && n.dispatcher.call(e, t, i), r && !t.isPropagationStopped() && !0 === t.bubbles) un.call(null, r, t, i);
                else if (!r && !t.defaultPrevented && t.target && t.target[t.type]) {
                    Qi.has(t.target) || Qi.set(t.target, {});
                    const e = Qi.get(t.target);
                    t.target[t.type] && (e.disabled = !0, "function" == typeof t.target[t.type] && t.target[t.type](), e.disabled = !1)
                }
                return !t.defaultPrevented
            }

            function dn(e, t, i) {
                if (Array.isArray(t)) return sn(dn, e, t, i);
                const n = function() {
                    cn(e, t, n), i.apply(this, arguments)
                };
                n.guid = i.guid = i.guid || nn(), hn(e, t, n)
            }

            function pn(e, t, i) {
                const n = function() {
                    cn(e, t, n), i.apply(this, arguments)
                };
                n.guid = i.guid = i.guid || nn(), hn(e, t, n)
            }
            var fn = Object.freeze({
                __proto__: null,
                fixEvent: an,
                on: hn,
                off: cn,
                trigger: un,
                one: dn,
                any: pn
            });
            const mn = 30,
                gn = function(e, t, i) {
                    t.guid || (t.guid = nn());
                    const n = t.bind(e);
                    return n.guid = i ? i + "_" + t.guid : t.guid, n
                },
                yn = function(e, t) {
                    let i = r().performance.now();
                    return function(...n) {
                        const s = r().performance.now();
                        s - i >= t && (e(...n), i = s)
                    }
                },
                _n = function(e, t, i, n = r()) {
                    let s;
                    const a = function() {
                        const r = this,
                            a = arguments;
                        let o = function() {
                            s = null, o = null, i || e.apply(r, a)
                        };
                        !s && i && e.apply(r, a), n.clearTimeout(s), s = n.setTimeout(o, t)
                    };
                    return a.cancel = () => {
                        n.clearTimeout(s), s = null
                    }, a
                };
            var vn = Object.freeze({
                __proto__: null,
                UPDATE_REFRESH_INTERVAL: mn,
                bind_: gn,
                throttle: yn,
                debounce: _n
            });
            let bn;
            class Tn {
                on(e, t) {
                    const i = this.addEventListener;
                    this.addEventListener = () => {}, hn(this, e, t), this.addEventListener = i
                }
                off(e, t) {
                    cn(this, e, t)
                }
                one(e, t) {
                    const i = this.addEventListener;
                    this.addEventListener = () => {}, dn(this, e, t), this.addEventListener = i
                }
                any(e, t) {
                    const i = this.addEventListener;
                    this.addEventListener = () => {}, pn(this, e, t), this.addEventListener = i
                }
                trigger(e) {
                    const t = e.type || e;
                    "string" == typeof e && (e = {
                        type: t
                    }), e = an(e), this.allowedEvents_[t] && this["on" + t] && this["on" + t](e), un(this, e)
                }
                queueTrigger(e) {
                    bn || (bn = new Map);
                    const t = e.type || e;
                    let i = bn.get(this);
                    i || (i = new Map, bn.set(this, i));
                    const n = i.get(t);
                    i.delete(t), r().clearTimeout(n);
                    const s = r().setTimeout((() => {
                        i.delete(t), 0 === i.size && (i = null, bn.delete(this)), this.trigger(e)
                    }), 0);
                    i.set(t, s)
                }
            }
            Tn.prototype.allowedEvents_ = {}, Tn.prototype.addEventListener = Tn.prototype.on, Tn.prototype.removeEventListener = Tn.prototype.off, Tn.prototype.dispatchEvent = Tn.prototype.trigger;
            const xn = e => "function" == typeof e.name ? e.name() : "string" == typeof e.name ? e.name : e.name_ ? e.name_ : e.constructor && e.constructor.name ? e.constructor.name : typeof e,
                wn = e => e instanceof Tn || !!e.eventBusEl_ && ["on", "one", "off", "trigger"].every((t => "function" == typeof e[t])),
                Sn = e => "string" == typeof e && /\S/.test(e) || Array.isArray(e) && !!e.length,
                En = (e, t, i) => {
                    if (!e || !e.nodeName && !wn(e)) throw new Error(`Invalid target for ${xn(t)}#${i}; must be a DOM node or evented object.`)
                },
                Mn = (e, t, i) => {
                    if (!Sn(e)) throw new Error(`Invalid event type for ${xn(t)}#${i}; must be a non-empty string or array.`)
                },
                Cn = (e, t, i) => {
                    if ("function" != typeof e) throw new Error(`Invalid listener for ${xn(t)}#${i}; must be a function.`)
                },
                An = (e, t, i) => {
                    const n = t.length < 3 || t[0] === e || t[0] === e.eventBusEl_;
                    let r, s, a;
                    return n ? (r = e.eventBusEl_, t.length >= 3 && t.shift(), [s, a] = t) : [r, s, a] = t, En(r, e, i), Mn(s, e, i), Cn(a, e, i), a = gn(e, a), {
                        isTargetingSelf: n,
                        target: r,
                        type: s,
                        listener: a
                    }
                },
                Ln = (e, t, i, n) => {
                    En(e, e, t), e.nodeName ? fn[t](e, i, n) : e[t](i, n)
                },
                In = {
                    on(...e) {
                        const {
                            isTargetingSelf: t,
                            target: i,
                            type: n,
                            listener: r
                        } = An(this, e, "on");
                        if (Ln(i, "on", n, r), !t) {
                            const e = () => this.off(i, n, r);
                            e.guid = r.guid;
                            const t = () => this.off("dispose", e);
                            t.guid = r.guid, Ln(this, "on", "dispose", e), Ln(i, "on", "dispose", t)
                        }
                    },
                    one(...e) {
                        const {
                            isTargetingSelf: t,
                            target: i,
                            type: n,
                            listener: r
                        } = An(this, e, "one");
                        if (t) Ln(i, "one", n, r);
                        else {
                            const e = (...t) => {
                                this.off(i, n, e), r.apply(null, t)
                            };
                            e.guid = r.guid, Ln(i, "one", n, e)
                        }
                    },
                    any(...e) {
                        const {
                            isTargetingSelf: t,
                            target: i,
                            type: n,
                            listener: r
                        } = An(this, e, "any");
                        if (t) Ln(i, "any", n, r);
                        else {
                            const e = (...t) => {
                                this.off(i, n, e), r.apply(null, t)
                            };
                            e.guid = r.guid, Ln(i, "any", n, e)
                        }
                    },
                    off(e, t, i) {
                        if (!e || Sn(e)) cn(this.eventBusEl_, e, t);
                        else {
                            const n = e,
                                r = t;
                            En(n, this, "off"), Mn(r, this, "off"), Cn(i, this, "off"), i = gn(this, i), this.off("dispose", i), n.nodeName ? (cn(n, r, i), cn(n, "dispose", i)) : wn(n) && (n.off(r, i), n.off("dispose", i))
                        }
                    },
                    trigger(e, t) {
                        En(this.eventBusEl_, this, "trigger");
                        const i = e && "string" != typeof e ? e.type : e;
                        if (!Sn(i)) throw new Error(`Invalid event type for ${xn(this)}#trigger; must be a non-empty string or object with a type key that has a non-empty value.`);
                        return un(this.eventBusEl_, e, t)
                    }
                };

            function Pn(e, t = {}) {
                const {
                    eventBusKey: i
                } = t;
                if (i) {
                    if (!e[i].nodeName) throw new Error(`The eventBusKey "${i}" does not refer to an element.`);
                    e.eventBusEl_ = e[i]
                } else e.eventBusEl_ = vi("span", {
                    className: "vjs-event-bus"
                });
                return Object.assign(e, In), e.eventedCallbacks && e.eventedCallbacks.forEach((e => {
                    e()
                })), e.on("dispose", (() => {
                    e.off(), [e, e.el_, e.eventBusEl_].forEach((function(e) {
                        e && Qi.has(e) && Qi.delete(e)
                    })), r().setTimeout((() => {
                        e.eventBusEl_ = null
                    }), 0)
                })), e
            }
            const Rn = {
                state: {},
                setState(e) {
                    let t;
                    return "function" == typeof e && (e = e()), zt(e, ((e, i) => {
                        this.state[i] !== e && (t = t || {}, t[i] = {
                            from: this.state[i],
                            to: e
                        }), this.state[i] = e
                    })), t && wn(this) && this.trigger({
                        changes: t,
                        type: "statechanged"
                    }), t
                }
            };

            function kn(e, t) {
                return Object.assign(e, Rn), e.state = Object.assign({}, e.state, t), "function" == typeof e.handleStateChanged && wn(e) && e.on("statechanged", e.handleStateChanged), e
            }
            const Dn = function(e) {
                    return "string" != typeof e ? e : e.replace(/./, (e => e.toLowerCase()))
                },
                On = function(e) {
                    return "string" != typeof e ? e : e.replace(/./, (e => e.toUpperCase()))
                },
                Nn = function(e, t) {
                    return On(e) === On(t)
                };
            var Un = Object.freeze({
                __proto__: null,
                toLowerCase: Dn,
                toTitleCase: On,
                titleCaseEquals: Nn
            });
            class Bn {
                constructor(e, t, i) {
                    if (!e && this.play ? this.player_ = e = this : this.player_ = e, this.isDisposed_ = !1, this.parentComponent_ = null, this.options_ = jt({}, this.options_), t = this.options_ = jt(this.options_, t), this.id_ = t.id || t.el && t.el.id, !this.id_) {
                        const t = e && e.id && e.id() || "no_player";
                        this.id_ = `${t}_component_${nn()}`
                    }
                    this.name_ = t.name || null, t.el ? this.el_ = t.el : !1 !== t.createEl && (this.el_ = this.createEl()), t.className && this.el_ && t.className.split(" ").forEach((e => this.addClass(e))), !1 !== t.evented && (Pn(this, {
                        eventBusKey: this.el_ ? "el_" : null
                    }), this.handleLanguagechange = this.handleLanguagechange.bind(this), this.on(this.player_, "languagechange", this.handleLanguagechange)), kn(this, this.constructor.defaultState), this.children_ = [], this.childIndex_ = {}, this.childNameIndex_ = {}, this.setTimeoutIds_ = new Set, this.setIntervalIds_ = new Set, this.rafIds_ = new Set, this.namedRafs_ = new Map, this.clearingTimersOnDispose_ = !1, !1 !== t.initChildren && this.initChildren(), this.ready(i), !1 !== t.reportTouchActivity && this.enableTouchActivity()
                }
                dispose(e = {}) {
                    if (!this.isDisposed_) {
                        if (this.readyQueue_ && (this.readyQueue_.length = 0), this.trigger({
                                type: "dispose",
                                bubbles: !1
                            }), this.isDisposed_ = !0, this.children_)
                            for (let e = this.children_.length - 1; e >= 0; e--) this.children_[e].dispose && this.children_[e].dispose();
                        this.children_ = null, this.childIndex_ = null, this.childNameIndex_ = null, this.parentComponent_ = null, this.el_ && (this.el_.parentNode && (e.restoreEl ? this.el_.parentNode.replaceChild(e.restoreEl, this.el_) : this.el_.parentNode.removeChild(this.el_)), this.el_ = null), this.player_ = null
                    }
                }
                isDisposed() {
                    return Boolean(this.isDisposed_)
                }
                player() {
                    return this.player_
                }
                options(e) {
                    return e ? (this.options_ = jt(this.options_, e), this.options_) : this.options_
                }
                el() {
                    return this.el_
                }
                createEl(e, t, i) {
                    return vi(e, t, i)
                }
                localize(e, t, i = e) {
                    const n = this.player_.language && this.player_.language(),
                        r = this.player_.languages && this.player_.languages(),
                        s = r && r[n],
                        a = n && n.split("-")[0],
                        o = r && r[a];
                    let l = i;
                    return s && s[e] ? l = s[e] : o && o[e] && (l = o[e]), t && (l = l.replace(/\{(\d+)\}/g, (function(e, i) {
                        const n = t[i - 1];
                        let r = n;
                        return void 0 === n && (r = e), r
                    }))), l
                }
                handleLanguagechange() {}
                contentEl() {
                    return this.contentEl_ || this.el_
                }
                id() {
                    return this.id_
                }
                name() {
                    return this.name_
                }
                children() {
                    return this.children_
                }
                getChildById(e) {
                    return this.childIndex_[e]
                }
                getChild(e) {
                    if (e) return this.childNameIndex_[e]
                }
                getDescendant(...e) {
                    e = e.reduce(((e, t) => e.concat(t)), []);
                    let t = this;
                    for (let i = 0; i < e.length; i++)
                        if (t = t.getChild(e[i]), !t || !t.getChild) return;
                    return t
                }
                addChild(e, t = {}, i = this.children_.length) {
                    let n, r;
                    if ("string" == typeof e) {
                        r = On(e);
                        const i = t.componentClass || r;
                        t.name = r;
                        const s = Bn.getComponent(i);
                        if (!s) throw new Error(`Component ${i} does not exist`);
                        if ("function" != typeof s) return null;
                        n = new s(this.player_ || this, t)
                    } else n = e;
                    if (n.parentComponent_ && n.parentComponent_.removeChild(n), this.children_.splice(i, 0, n), n.parentComponent_ = this, "function" == typeof n.id && (this.childIndex_[n.id()] = n), r = r || n.name && On(n.name()), r && (this.childNameIndex_[r] = n, this.childNameIndex_[Dn(r)] = n), "function" == typeof n.el && n.el()) {
                        let e = null;
                        this.children_[i + 1] && (this.children_[i + 1].el_ ? e = this.children_[i + 1].el_ : gi(this.children_[i + 1]) && (e = this.children_[i + 1])), this.contentEl().insertBefore(n.el(), e)
                    }
                    return n
                }
                removeChild(e) {
                    if ("string" == typeof e && (e = this.getChild(e)), !e || !this.children_) return;
                    let t = !1;
                    for (let i = this.children_.length - 1; i >= 0; i--)
                        if (this.children_[i] === e) {
                            t = !0, this.children_.splice(i, 1);
                            break
                        }
                    if (!t) return;
                    e.parentComponent_ = null, this.childIndex_[e.id()] = null, this.childNameIndex_[On(e.name())] = null, this.childNameIndex_[Dn(e.name())] = null;
                    const i = e.el();
                    i && i.parentNode === this.contentEl() && this.contentEl().removeChild(e.el())
                }
                initChildren() {
                    const e = this.options_.children;
                    if (e) {
                        const t = this.options_,
                            i = e => {
                                const i = e.name;
                                let n = e.opts;
                                if (void 0 !== t[i] && (n = t[i]), !1 === n) return;
                                !0 === n && (n = {}), n.playerOptions = this.options_.playerOptions;
                                const r = this.addChild(i, n);
                                r && (this[i] = r)
                            };
                        let n;
                        const r = Bn.getComponent("Tech");
                        n = Array.isArray(e) ? e : Object.keys(e), n.concat(Object.keys(this.options_).filter((function(e) {
                            return !n.some((function(t) {
                                return "string" == typeof t ? e === t : e === t.name
                            }))
                        }))).map((t => {
                            let i, n;
                            return "string" == typeof t ? (i = t, n = e[i] || this.options_[i] || {}) : (i = t.name, n = t), {
                                name: i,
                                opts: n
                            }
                        })).filter((e => {
                            const t = Bn.getComponent(e.opts.componentClass || On(e.name));
                            return t && !r.isTech(t)
                        })).forEach(i)
                    }
                }
                buildCSSClass() {
                    return ""
                }
                ready(e, t = !1) {
                    if (e) return this.isReady_ ? void(t ? e.call(this) : this.setTimeout(e, 1)) : (this.readyQueue_ = this.readyQueue_ || [], void this.readyQueue_.push(e))
                }
                triggerReady() {
                    this.isReady_ = !0, this.setTimeout((function() {
                        const e = this.readyQueue_;
                        this.readyQueue_ = [], e && e.length > 0 && e.forEach((function(e) {
                            e.call(this)
                        }), this), this.trigger("ready")
                    }), 1)
                }
                $(e, t) {
                    return Vi(e, t || this.contentEl())
                }
                $$(e, t) {
                    return Gi(e, t || this.contentEl())
                }
                hasClass(e) {
                    return xi(this.el_, e)
                }
                addClass(...e) {
                    wi(this.el_, ...e)
                }
                removeClass(...e) {
                    Si(this.el_, ...e)
                }
                toggleClass(e, t) {
                    Ei(this.el_, e, t)
                }
                show() {
                    this.removeClass("vjs-hidden")
                }
                hide() {
                    this.addClass("vjs-hidden")
                }
                lockShowing() {
                    this.addClass("vjs-lock-showing")
                }
                unlockShowing() {
                    this.removeClass("vjs-lock-showing")
                }
                getAttribute(e) {
                    return Ai(this.el_, e)
                }
                setAttribute(e, t) {
                    Li(this.el_, e, t)
                }
                removeAttribute(e) {
                    Ii(this.el_, e)
                }
                width(e, t) {
                    return this.dimension("width", e, t)
                }
                height(e, t) {
                    return this.dimension("height", e, t)
                }
                dimensions(e, t) {
                    this.width(e, !0), this.height(t)
                }
                dimension(e, t, i) {
                    if (void 0 !== t) return null !== t && t == t || (t = 0), -1 !== ("" + t).indexOf("%") || -1 !== ("" + t).indexOf("px") ? this.el_.style[e] = t : this.el_.style[e] = "auto" === t ? "" : t + "px", void(i || this.trigger("componentresize"));
                    if (!this.el_) return 0;
                    const n = this.el_.style[e],
                        r = n.indexOf("px");
                    return -1 !== r ? parseInt(n.slice(0, r), 10) : parseInt(this.el_["offset" + On(e)], 10)
                }
                currentDimension(e) {
                    let t = 0;
                    if ("width" !== e && "height" !== e) throw new Error("currentDimension only accepts width or height value");
                    if (t = Wi(this.el_, e), t = parseFloat(t), 0 === t || isNaN(t)) {
                        const i = `offset${On(e)}`;
                        t = this.el_[i]
                    }
                    return t
                }
                currentDimensions() {
                    return {
                        width: this.currentDimension("width"),
                        height: this.currentDimension("height")
                    }
                }
                currentWidth() {
                    return this.currentDimension("width")
                }
                currentHeight() {
                    return this.currentDimension("height")
                }
                focus() {
                    this.el_.focus()
                }
                blur() {
                    this.el_.blur()
                }
                handleKeyDown(e) {
                    this.player_ && (l().isEventKey(e, "Tab") || e.stopPropagation(), this.player_.handleKeyDown(e))
                }
                handleKeyPress(e) {
                    this.handleKeyDown(e)
                }
                emitTapEvents() {
                    let e = 0,
                        t = null;
                    let i;
                    this.on("touchstart", (function(n) {
                        1 === n.touches.length && (t = {
                            pageX: n.touches[0].pageX,
                            pageY: n.touches[0].pageY
                        }, e = r().performance.now(), i = !0)
                    })), this.on("touchmove", (function(e) {
                        if (e.touches.length > 1) i = !1;
                        else if (t) {
                            const n = e.touches[0].pageX - t.pageX,
                                r = e.touches[0].pageY - t.pageY;
                            Math.sqrt(n * n + r * r) > 10 && (i = !1)
                        }
                    }));
                    const n = function() {
                        i = !1
                    };
                    this.on("touchleave", n), this.on("touchcancel", n), this.on("touchend", (function(n) {
                        if (t = null, !0 === i) {
                            r().performance.now() - e < 200 && (n.preventDefault(), this.trigger("tap"))
                        }
                    }))
                }
                enableTouchActivity() {
                    if (!this.player() || !this.player().reportUserActivity) return;
                    const e = gn(this.player(), this.player().reportUserActivity);
                    let t;
                    this.on("touchstart", (function() {
                        e(), this.clearInterval(t), t = this.setInterval(e, 250)
                    }));
                    const i = function(i) {
                        e(), this.clearInterval(t)
                    };
                    this.on("touchmove", e), this.on("touchend", i), this.on("touchcancel", i)
                }
                setTimeout(e, t) {
                    var i;
                    return e = gn(this, e), this.clearTimersOnDispose_(), i = r().setTimeout((() => {
                        this.setTimeoutIds_.has(i) && this.setTimeoutIds_.delete(i), e()
                    }), t), this.setTimeoutIds_.add(i), i
                }
                clearTimeout(e) {
                    return this.setTimeoutIds_.has(e) && (this.setTimeoutIds_.delete(e), r().clearTimeout(e)), e
                }
                setInterval(e, t) {
                    e = gn(this, e), this.clearTimersOnDispose_();
                    const i = r().setInterval(e, t);
                    return this.setIntervalIds_.add(i), i
                }
                clearInterval(e) {
                    return this.setIntervalIds_.has(e) && (this.setIntervalIds_.delete(e), r().clearInterval(e)), e
                }
                requestAnimationFrame(e) {
                    var t;
                    return this.clearTimersOnDispose_(), e = gn(this, e), t = r().requestAnimationFrame((() => {
                        this.rafIds_.has(t) && this.rafIds_.delete(t), e()
                    })), this.rafIds_.add(t), t
                }
                requestNamedAnimationFrame(e, t) {
                    if (this.namedRafs_.has(e)) return;
                    this.clearTimersOnDispose_(), t = gn(this, t);
                    const i = this.requestAnimationFrame((() => {
                        t(), this.namedRafs_.has(e) && this.namedRafs_.delete(e)
                    }));
                    return this.namedRafs_.set(e, i), e
                }
                cancelNamedAnimationFrame(e) {
                    this.namedRafs_.has(e) && (this.cancelAnimationFrame(this.namedRafs_.get(e)), this.namedRafs_.delete(e))
                }
                cancelAnimationFrame(e) {
                    return this.rafIds_.has(e) && (this.rafIds_.delete(e), r().cancelAnimationFrame(e)), e
                }
                clearTimersOnDispose_() {
                    this.clearingTimersOnDispose_ || (this.clearingTimersOnDispose_ = !0, this.one("dispose", (() => {
                        [
                            ["namedRafs_", "cancelNamedAnimationFrame"],
                            ["rafIds_", "cancelAnimationFrame"],
                            ["setTimeoutIds_", "clearTimeout"],
                            ["setIntervalIds_", "clearInterval"]
                        ].forEach((([e, t]) => {
                            this[e].forEach(((e, i) => this[t](i)))
                        })), this.clearingTimersOnDispose_ = !1
                    })))
                }
                static registerComponent(e, t) {
                    if ("string" != typeof e || !e) throw new Error(`Illegal component name, "${e}"; must be a non-empty string.`);
                    const i = Bn.getComponent("Tech"),
                        n = i && i.isTech(t),
                        r = Bn === t || Bn.prototype.isPrototypeOf(t.prototype);
                    if (n || !r) {
                        let t;
                        throw t = n ? "techs must be registered using Tech.registerTech()" : "must be a Component subclass", new Error(`Illegal component, "${e}"; ${t}.`)
                    }
                    e = On(e), Bn.components_ || (Bn.components_ = {});
                    const s = Bn.getComponent("Player");
                    if ("Player" === e && s && s.players) {
                        const e = s.players,
                            t = Object.keys(e);
                        if (e && t.length > 0 && t.map((t => e[t])).every(Boolean)) throw new Error("Can not register Player component after player has been created.")
                    }
                    return Bn.components_[e] = t, Bn.components_[Dn(e)] = t, t
                }
                static getComponent(e) {
                    if (e && Bn.components_) return Bn.components_[e]
                }
            }

            function Fn(e, t, i, n) {
                return function(e, t, i) {
                    if ("number" != typeof t || t < 0 || t > i) throw new Error(`Failed to execute '${e}' on 'TimeRanges': The index provided (${t}) is non-numeric or out of bounds (0-${i}).`)
                }(e, n, i.length - 1), i[n][t]
            }

            function Hn(e) {
                let t;
                return t = void 0 === e || 0 === e.length ? {
                    length: 0,
                    start() {
                        throw new Error("This TimeRanges object is empty")
                    },
                    end() {
                        throw new Error("This TimeRanges object is empty")
                    }
                } : {
                    length: e.length,
                    start: Fn.bind(null, "start", 0, e),
                    end: Fn.bind(null, "end", 1, e)
                }, r().Symbol && r().Symbol.iterator && (t[r().Symbol.iterator] = () => (e || []).values()), t
            }

            function zn(e, t) {
                return Array.isArray(e) ? Hn(e) : void 0 === e || void 0 === t ? Hn() : Hn([
                    [e, t]
                ])
            }
            Bn.registerComponent("Component", Bn);
            const Vn = function(e, t) {
                e = e < 0 ? 0 : e;
                let i = Math.floor(e % 60),
                    n = Math.floor(e / 60 % 60),
                    r = Math.floor(e / 3600);
                const s = Math.floor(t / 60 % 60),
                    a = Math.floor(t / 3600);
                return (isNaN(e) || e === 1 / 0) && (r = n = i = "-"), r = r > 0 || a > 0 ? r + ":" : "", n = ((r || s >= 10) && n < 10 ? "0" + n : n) + ":", i = i < 10 ? "0" + i : i, r + n + i
            };
            let Gn = Vn;

            function Wn(e) {
                Gn = e
            }

            function jn() {
                Gn = Vn
            }

            function qn(e, t = e) {
                return Gn(e, t)
            }
            var $n = Object.freeze({
                __proto__: null,
                createTimeRanges: zn,
                createTimeRange: zn,
                setFormatTime: Wn,
                resetFormatTime: jn,
                formatTime: qn
            });

            function Xn(e, t) {
                let i, n, r = 0;
                if (!t) return 0;
                e && e.length || (e = zn(0, 0));
                for (let s = 0; s < e.length; s++) i = e.start(s), n = e.end(s), n > t && (n = t), r += n - i;
                return r / t
            }

            function Yn(e) {
                if (e instanceof Yn) return e;
                "number" == typeof e ? this.code = e : "string" == typeof e ? this.message = e : Gt(e) && ("number" == typeof e.code && (this.code = e.code), Object.assign(this, e)), this.message || (this.message = Yn.defaultMessages[this.code] || "")
            }
            Yn.prototype.code = 0, Yn.prototype.message = "", Yn.prototype.status = null, Yn.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"], Yn.defaultMessages = {
                1: "You aborted the media playback",
                2: "A network error caused the media download to fail part-way.",
                3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
                4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
                5: "The media is encrypted and we do not have the keys to decrypt it."
            };
            for (let e = 0; e < Yn.errorTypes.length; e++) Yn[Yn.errorTypes[e]] = e, Yn.prototype[Yn.errorTypes[e]] = e;

            function Kn(e) {
                return null != e && "function" == typeof e.then
            }

            function Jn(e) {
                Kn(e) && e.then(null, (e => {}))
            }
            const Zn = function(e) {
                return ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce(((t, i, n) => (e[i] && (t[i] = e[i]), t)), {
                    cues: e.cues && Array.prototype.map.call(e.cues, (function(e) {
                        return {
                            startTime: e.startTime,
                            endTime: e.endTime,
                            text: e.text,
                            id: e.id
                        }
                    }))
                })
            };
            var Qn = function(e) {
                    const t = e.$$("track"),
                        i = Array.prototype.map.call(t, (e => e.track));
                    return Array.prototype.map.call(t, (function(e) {
                        const t = Zn(e.track);
                        return e.src && (t.src = e.src), t
                    })).concat(Array.prototype.filter.call(e.textTracks(), (function(e) {
                        return -1 === i.indexOf(e)
                    })).map(Zn))
                },
                er = function(e, t) {
                    return e.forEach((function(e) {
                        const i = t.addRemoteTextTrack(e).track;
                        !e.src && e.cues && e.cues.forEach((e => i.addCue(e)))
                    })), t.textTracks()
                };
            const tr = "vjs-modal-dialog";
            class ir extends Bn {
                constructor(e, t) {
                    super(e, t), this.handleKeyDown_ = e => this.handleKeyDown(e), this.close_ = e => this.close(e), this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = !1, this.closeable(!this.options_.uncloseable), this.content(this.options_.content), this.contentEl_ = vi("div", {
                        className: `${tr}-content`
                    }, {
                        role: "document"
                    }), this.descEl_ = vi("p", {
                        className: `${tr}-description vjs-control-text`,
                        id: this.el().getAttribute("aria-describedby")
                    }), bi(this.descEl_, this.description()), this.el_.appendChild(this.descEl_), this.el_.appendChild(this.contentEl_)
                }
                createEl() {
                    return super.createEl("div", {
                        className: this.buildCSSClass(),
                        tabIndex: -1
                    }, {
                        "aria-describedby": `${this.id()}_description`,
                        "aria-hidden": "true",
                        "aria-label": this.label(),
                        role: "dialog"
                    })
                }
                dispose() {
                    this.contentEl_ = null, this.descEl_ = null, this.previouslyActiveEl_ = null, super.dispose()
                }
                buildCSSClass() {
                    return `${tr} vjs-hidden ${super.buildCSSClass()}`
                }
                label() {
                    return this.localize(this.options_.label || "Modal Window")
                }
                description() {
                    let e = this.options_.description || this.localize("This is a modal window.");
                    return this.closeable() && (e += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.")), e
                }
                open() {
                    if (!this.opened_) {
                        const e = this.player();
                        this.trigger("beforemodalopen"), this.opened_ = !0, (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) && this.fill(), this.wasPlaying_ = !e.paused(), this.options_.pauseOnOpen && this.wasPlaying_ && e.pause(), this.on("keydown", this.handleKeyDown_), this.hadControls_ = e.controls(), e.controls(!1), this.show(), this.conditionalFocus_(), this.el().setAttribute("aria-hidden", "false"), this.trigger("modalopen"), this.hasBeenOpened_ = !0
                    }
                }
                opened(e) {
                    return "boolean" == typeof e && this[e ? "open" : "close"](), this.opened_
                }
                close() {
                    if (!this.opened_) return;
                    const e = this.player();
                    this.trigger("beforemodalclose"), this.opened_ = !1, this.wasPlaying_ && this.options_.pauseOnOpen && e.play(), this.off("keydown", this.handleKeyDown_), this.hadControls_ && e.controls(!0), this.hide(), this.el().setAttribute("aria-hidden", "true"), this.trigger("modalclose"), this.conditionalBlur_(), this.options_.temporary && this.dispose()
                }
                closeable(e) {
                    if ("boolean" == typeof e) {
                        const t = this.closeable_ = !!e;
                        let i = this.getChild("closeButton");
                        if (t && !i) {
                            const e = this.contentEl_;
                            this.contentEl_ = this.el_, i = this.addChild("closeButton", {
                                controlText: "Close Modal Dialog"
                            }), this.contentEl_ = e, this.on(i, "close", this.close_)
                        }!t && i && (this.off(i, "close", this.close_), this.removeChild(i), i.dispose())
                    }
                    return this.closeable_
                }
                fill() {
                    this.fillWith(this.content())
                }
                fillWith(e) {
                    const t = this.contentEl(),
                        i = t.parentNode,
                        n = t.nextSibling;
                    this.trigger("beforemodalfill"), this.hasBeenFilled_ = !0, i.removeChild(t), this.empty(), Hi(t, e), this.trigger("modalfill"), n ? i.insertBefore(t, n) : i.appendChild(t);
                    const r = this.getChild("closeButton");
                    r && i.appendChild(r.el_)
                }
                empty() {
                    this.trigger("beforemodalempty"), Ui(this.contentEl()), this.trigger("modalempty")
                }
                content(e) {
                    return void 0 !== e && (this.content_ = e), this.content_
                }
                conditionalFocus_() {
                    const e = a().activeElement,
                        t = this.player_.el_;
                    this.previouslyActiveEl_ = null, (t.contains(e) || t === e) && (this.previouslyActiveEl_ = e, this.focus())
                }
                conditionalBlur_() {
                    this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(), this.previouslyActiveEl_ = null)
                }
                handleKeyDown(e) {
                    if (e.stopPropagation(), l().isEventKey(e, "Escape") && this.closeable()) return e.preventDefault(), void this.close();
                    if (!l().isEventKey(e, "Tab")) return;
                    const t = this.focusableEls_(),
                        i = this.el_.querySelector(":focus");
                    let n;
                    for (let e = 0; e < t.length; e++)
                        if (i === t[e]) {
                            n = e;
                            break
                        }
                    a().activeElement === this.el_ && (n = 0), e.shiftKey && 0 === n ? (t[t.length - 1].focus(), e.preventDefault()) : e.shiftKey || n !== t.length - 1 || (t[0].focus(), e.preventDefault())
                }
                focusableEls_() {
                    const e = this.el_.querySelectorAll("*");
                    return Array.prototype.filter.call(e, (e => (e instanceof r().HTMLAnchorElement || e instanceof r().HTMLAreaElement) && e.hasAttribute("href") || (e instanceof r().HTMLInputElement || e instanceof r().HTMLSelectElement || e instanceof r().HTMLTextAreaElement || e instanceof r().HTMLButtonElement) && !e.hasAttribute("disabled") || e instanceof r().HTMLIFrameElement || e instanceof r().HTMLObjectElement || e instanceof r().HTMLEmbedElement || e.hasAttribute("tabindex") && -1 !== e.getAttribute("tabindex") || e.hasAttribute("contenteditable")))
                }
            }
            ir.prototype.options_ = {
                pauseOnOpen: !0,
                temporary: !0
            }, Bn.registerComponent("ModalDialog", ir);
            class nr extends Tn {
                constructor(e = []) {
                    super(), this.tracks_ = [], Object.defineProperty(this, "length", {
                        get() {
                            return this.tracks_.length
                        }
                    });
                    for (let t = 0; t < e.length; t++) this.addTrack(e[t])
                }
                addTrack(e) {
                    const t = this.tracks_.length;
                    "" + t in this || Object.defineProperty(this, t, {
                        get() {
                            return this.tracks_[t]
                        }
                    }), -1 === this.tracks_.indexOf(e) && (this.tracks_.push(e), this.trigger({
                        track: e,
                        type: "addtrack",
                        target: this
                    })), e.labelchange_ = () => {
                        this.trigger({
                            track: e,
                            type: "labelchange",
                            target: this
                        })
                    }, wn(e) && e.addEventListener("labelchange", e.labelchange_)
                }
                removeTrack(e) {
                    let t;
                    for (let i = 0, n = this.length; i < n; i++)
                        if (this[i] === e) {
                            t = this[i], t.off && t.off(), this.tracks_.splice(i, 1);
                            break
                        }
                    t && this.trigger({
                        track: t,
                        type: "removetrack",
                        target: this
                    })
                }
                getTrackById(e) {
                    let t = null;
                    for (let i = 0, n = this.length; i < n; i++) {
                        const n = this[i];
                        if (n.id === e) {
                            t = n;
                            break
                        }
                    }
                    return t
                }
            }
            nr.prototype.allowedEvents_ = {
                change: "change",
                addtrack: "addtrack",
                removetrack: "removetrack",
                labelchange: "labelchange"
            };
            for (const e in nr.prototype.allowedEvents_) nr.prototype["on" + e] = null;
            const rr = function(e, t) {
                for (let i = 0; i < e.length; i++) Object.keys(e[i]).length && t.id !== e[i].id && (e[i].enabled = !1)
            };
            const sr = function(e, t) {
                for (let i = 0; i < e.length; i++) Object.keys(e[i]).length && t.id !== e[i].id && (e[i].selected = !1)
            };
            class ar extends nr {
                addTrack(e) {
                    super.addTrack(e), this.queueChange_ || (this.queueChange_ = () => this.queueTrigger("change")), this.triggerSelectedlanguagechange || (this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange")), e.addEventListener("modechange", this.queueChange_); - 1 === ["metadata", "chapters"].indexOf(e.kind) && e.addEventListener("modechange", this.triggerSelectedlanguagechange_)
                }
                removeTrack(e) {
                    super.removeTrack(e), e.removeEventListener && (this.queueChange_ && e.removeEventListener("modechange", this.queueChange_), this.selectedlanguagechange_ && e.removeEventListener("modechange", this.triggerSelectedlanguagechange_))
                }
            }
            class or {
                constructor(e) {
                    or.prototype.setCues_.call(this, e), Object.defineProperty(this, "length", {
                        get() {
                            return this.length_
                        }
                    })
                }
                setCues_(e) {
                    const t = this.length || 0;
                    let i = 0;
                    const n = e.length;
                    this.cues_ = e, this.length_ = e.length;
                    const r = function(e) {
                        "" + e in this || Object.defineProperty(this, "" + e, {
                            get() {
                                return this.cues_[e]
                            }
                        })
                    };
                    if (t < n)
                        for (i = t; i < n; i++) r.call(this, i)
                }
                getCueById(e) {
                    let t = null;
                    for (let i = 0, n = this.length; i < n; i++) {
                        const n = this[i];
                        if (n.id === e) {
                            t = n;
                            break
                        }
                    }
                    return t
                }
            }
            const lr = {
                    alternative: "alternative",
                    captions: "captions",
                    main: "main",
                    sign: "sign",
                    subtitles: "subtitles",
                    commentary: "commentary"
                },
                hr = {
                    alternative: "alternative",
                    descriptions: "descriptions",
                    main: "main",
                    "main-desc": "main-desc",
                    translation: "translation",
                    commentary: "commentary"
                },
                cr = {
                    subtitles: "subtitles",
                    captions: "captions",
                    descriptions: "descriptions",
                    chapters: "chapters",
                    metadata: "metadata"
                },
                ur = {
                    disabled: "disabled",
                    hidden: "hidden",
                    showing: "showing"
                };
            class dr extends Tn {
                constructor(e = {}) {
                    super();
                    const t = {
                        id: e.id || "vjs_track_" + nn(),
                        kind: e.kind || "",
                        language: e.language || ""
                    };
                    let i = e.label || "";
                    for (const e in t) Object.defineProperty(this, e, {
                        get: () => t[e],
                        set() {}
                    });
                    Object.defineProperty(this, "label", {
                        get: () => i,
                        set(e) {
                            e !== i && (i = e, this.trigger("labelchange"))
                        }
                    })
                }
            }
            const pr = function(e) {
                    const t = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"],
                        i = a().createElement("a");
                    i.href = e;
                    const n = {};
                    for (let e = 0; e < t.length; e++) n[t[e]] = i[t[e]];
                    return "http:" === n.protocol && (n.host = n.host.replace(/:80$/, "")), "https:" === n.protocol && (n.host = n.host.replace(/:443$/, "")), n.protocol || (n.protocol = r().location.protocol), n.host || (n.host = r().location.host), n
                },
                fr = function(e) {
                    if (!e.match(/^https?:\/\//)) {
                        const t = a().createElement("a");
                        t.href = e, e = t.href
                    }
                    return e
                },
                mr = function(e) {
                    if ("string" == typeof e) {
                        const t = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/.exec(e);
                        if (t) return t.pop().toLowerCase()
                    }
                    return ""
                },
                gr = function(e, t = r().location) {
                    const i = pr(e);
                    return (":" === i.protocol ? t.protocol : i.protocol) + i.host !== t.protocol + t.host
                };
            var yr = Object.freeze({
                __proto__: null,
                parseUrl: pr,
                getAbsoluteURL: fr,
                getFileExtension: mr,
                isCrossOrigin: gr
            });
            const _r = function(e, t) {
                    const i = new(r().WebVTT.Parser)(r(), r().vttjs, r().WebVTT.StringDecoder()),
                        n = [];
                    i.oncue = function(e) {
                        t.addCue(e)
                    }, i.onparsingerror = function(e) {
                        n.push(e)
                    }, i.onflush = function() {
                        t.trigger({
                            type: "loadeddata",
                            target: t
                        })
                    }, i.parse(e), n.length > 0 && (r().console && r().console.groupCollapsed && r().console.groupCollapsed(`Text Track parsing errors for ${t.src}`), n.forEach((e => Ut.error(e))), r().console && r().console.groupEnd && r().console.groupEnd()), i.flush()
                },
                vr = function(e, t) {
                    const i = {
                            uri: e
                        },
                        n = gr(e);
                    n && (i.cors = n);
                    const s = "use-credentials" === t.tech_.crossOrigin();
                    s && (i.withCredentials = s), d()(i, gn(this, (function(e, i, n) {
                        if (e) return Ut.error(e, i);
                        t.loaded_ = !0, "function" != typeof r().WebVTT ? t.tech_ && t.tech_.any(["vttjsloaded", "vttjserror"], (e => {
                            if ("vttjserror" !== e.type) return _r(n, t);
                            Ut.error(`vttjs failed to load, stopping trying to process ${t.src}`)
                        })) : _r(n, t)
                    })))
                };
            class br extends dr {
                constructor(e = {}) {
                    if (!e.tech) throw new Error("A tech was not provided.");
                    const t = jt(e, {
                        kind: cr[e.kind] || "subtitles",
                        language: e.language || e.srclang || ""
                    });
                    let i = ur[t.mode] || "disabled";
                    const n = t.default;
                    "metadata" !== t.kind && "chapters" !== t.kind || (i = "hidden"), super(t), this.tech_ = t.tech, this.cues_ = [], this.activeCues_ = [], this.preload_ = !1 !== this.tech_.preloadTextTracks;
                    const r = new or(this.cues_),
                        s = new or(this.activeCues_);
                    let a = !1;
                    this.timeupdateHandler = gn(this, (function(e = {}) {
                        this.tech_.isDisposed() || (this.tech_.isReady_ ? (this.activeCues = this.activeCues, a && (this.trigger("cuechange"), a = !1), "timeupdate" !== e.type && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler))) : "timeupdate" !== e.type && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler)))
                    }));
                    this.tech_.one("dispose", (() => {
                        this.stopTracking()
                    })), "disabled" !== i && this.startTracking(), Object.defineProperties(this, {
                        default: {
                            get: () => n,
                            set() {}
                        },
                        mode: {
                            get: () => i,
                            set(e) {
                                ur[e] && i !== e && (i = e, this.preload_ || "disabled" === i || 0 !== this.cues.length || vr(this.src, this), this.stopTracking(), "disabled" !== i && this.startTracking(), this.trigger("modechange"))
                            }
                        },
                        cues: {
                            get() {
                                return this.loaded_ ? r : null
                            },
                            set() {}
                        },
                        activeCues: {
                            get() {
                                if (!this.loaded_) return null;
                                if (0 === this.cues.length) return s;
                                const e = this.tech_.currentTime(),
                                    t = [];
                                for (let i = 0, n = this.cues.length; i < n; i++) {
                                    const n = this.cues[i];
                                    n.startTime <= e && n.endTime >= e && t.push(n)
                                }
                                if (a = !1, t.length !== this.activeCues_.length) a = !0;
                                else
                                    for (let e = 0; e < t.length; e++) - 1 === this.activeCues_.indexOf(t[e]) && (a = !0);
                                return this.activeCues_ = t, s.setCues_(this.activeCues_), s
                            },
                            set() {}
                        }
                    }), t.src ? (this.src = t.src, this.preload_ || (this.loaded_ = !0), (this.preload_ || "subtitles" !== t.kind && "captions" !== t.kind) && vr(this.src, this)) : this.loaded_ = !0
                }
                startTracking() {
                    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler), this.tech_.on("timeupdate", this.timeupdateHandler)
                }
                stopTracking() {
                    this.rvf_ && (this.tech_.cancelVideoFrameCallback(this.rvf_), this.rvf_ = void 0), this.tech_.off("timeupdate", this.timeupdateHandler)
                }
                addCue(e) {
                    let t = e;
                    if (r().vttjs && !(e instanceof r().vttjs.VTTCue)) {
                        t = new(r().vttjs.VTTCue)(e.startTime, e.endTime, e.text);
                        for (const i in e) i in t || (t[i] = e[i]);
                        t.id = e.id, t.originalCue_ = e
                    }
                    const i = this.tech_.textTracks();
                    for (let e = 0; e < i.length; e++) i[e] !== this && i[e].removeCue(t);
                    this.cues_.push(t), this.cues.setCues_(this.cues_)
                }
                removeCue(e) {
                    let t = this.cues_.length;
                    for (; t--;) {
                        const i = this.cues_[t];
                        if (i === e || i.originalCue_ && i.originalCue_ === e) {
                            this.cues_.splice(t, 1), this.cues.setCues_(this.cues_);
                            break
                        }
                    }
                }
            }
            br.prototype.allowedEvents_ = {
                cuechange: "cuechange"
            };
            class Tr extends dr {
                constructor(e = {}) {
                    const t = jt(e, {
                        kind: hr[e.kind] || ""
                    });
                    super(t);
                    let i = !1;
                    Object.defineProperty(this, "enabled", {
                        get: () => i,
                        set(e) {
                            "boolean" == typeof e && e !== i && (i = e, this.trigger("enabledchange"))
                        }
                    }), t.enabled && (this.enabled = t.enabled), this.loaded_ = !0
                }
            }
            class xr extends dr {
                constructor(e = {}) {
                    const t = jt(e, {
                        kind: lr[e.kind] || ""
                    });
                    super(t);
                    let i = !1;
                    Object.defineProperty(this, "selected", {
                        get: () => i,
                        set(e) {
                            "boolean" == typeof e && e !== i && (i = e, this.trigger("selectedchange"))
                        }
                    }), t.selected && (this.selected = t.selected)
                }
            }
            class wr extends Tn {
                constructor(e = {}) {
                    let t;
                    super();
                    const i = new br(e);
                    this.kind = i.kind, this.src = i.src, this.srclang = i.language, this.label = i.label, this.default = i.default, Object.defineProperties(this, {
                        readyState: {
                            get: () => t
                        },
                        track: {
                            get: () => i
                        }
                    }), t = wr.NONE, i.addEventListener("loadeddata", (() => {
                        t = wr.LOADED, this.trigger({
                            type: "load",
                            target: this
                        })
                    }))
                }
            }
            wr.prototype.allowedEvents_ = {
                load: "load"
            }, wr.NONE = 0, wr.LOADING = 1, wr.LOADED = 2, wr.ERROR = 3;
            const Sr = {
                audio: {
                    ListClass: class extends nr {
                        constructor(e = []) {
                            for (let t = e.length - 1; t >= 0; t--)
                                if (e[t].enabled) {
                                    rr(e, e[t]);
                                    break
                                }
                            super(e), this.changing_ = !1
                        }
                        addTrack(e) {
                            e.enabled && rr(this, e), super.addTrack(e), e.addEventListener && (e.enabledChange_ = () => {
                                this.changing_ || (this.changing_ = !0, rr(this, e), this.changing_ = !1, this.trigger("change"))
                            }, e.addEventListener("enabledchange", e.enabledChange_))
                        }
                        removeTrack(e) {
                            super.removeTrack(e), e.removeEventListener && e.enabledChange_ && (e.removeEventListener("enabledchange", e.enabledChange_), e.enabledChange_ = null)
                        }
                    },
                    TrackClass: Tr,
                    capitalName: "Audio"
                },
                video: {
                    ListClass: class extends nr {
                        constructor(e = []) {
                            for (let t = e.length - 1; t >= 0; t--)
                                if (e[t].selected) {
                                    sr(e, e[t]);
                                    break
                                }
                            super(e), this.changing_ = !1, Object.defineProperty(this, "selectedIndex", {
                                get() {
                                    for (let e = 0; e < this.length; e++)
                                        if (this[e].selected) return e;
                                    return -1
                                },
                                set() {}
                            })
                        }
                        addTrack(e) {
                            e.selected && sr(this, e), super.addTrack(e), e.addEventListener && (e.selectedChange_ = () => {
                                this.changing_ || (this.changing_ = !0, sr(this, e), this.changing_ = !1, this.trigger("change"))
                            }, e.addEventListener("selectedchange", e.selectedChange_))
                        }
                        removeTrack(e) {
                            super.removeTrack(e), e.removeEventListener && e.selectedChange_ && (e.removeEventListener("selectedchange", e.selectedChange_), e.selectedChange_ = null)
                        }
                    },
                    TrackClass: xr,
                    capitalName: "Video"
                },
                text: {
                    ListClass: ar,
                    TrackClass: br,
                    capitalName: "Text"
                }
            };
            Object.keys(Sr).forEach((function(e) {
                Sr[e].getterName = `${e}Tracks`, Sr[e].privateName = `${e}Tracks_`
            }));
            const Er = {
                    remoteText: {
                        ListClass: ar,
                        TrackClass: br,
                        capitalName: "RemoteText",
                        getterName: "remoteTextTracks",
                        privateName: "remoteTextTracks_"
                    },
                    remoteTextEl: {
                        ListClass: class {
                            constructor(e = []) {
                                this.trackElements_ = [], Object.defineProperty(this, "length", {
                                    get() {
                                        return this.trackElements_.length
                                    }
                                });
                                for (let t = 0, i = e.length; t < i; t++) this.addTrackElement_(e[t])
                            }
                            addTrackElement_(e) {
                                const t = this.trackElements_.length;
                                "" + t in this || Object.defineProperty(this, t, {
                                    get() {
                                        return this.trackElements_[t]
                                    }
                                }), -1 === this.trackElements_.indexOf(e) && this.trackElements_.push(e)
                            }
                            getTrackElementByTrack_(e) {
                                let t;
                                for (let i = 0, n = this.trackElements_.length; i < n; i++)
                                    if (e === this.trackElements_[i].track) {
                                        t = this.trackElements_[i];
                                        break
                                    }
                                return t
                            }
                            removeTrackElement_(e) {
                                for (let t = 0, i = this.trackElements_.length; t < i; t++)
                                    if (e === this.trackElements_[t]) {
                                        this.trackElements_[t].track && "function" == typeof this.trackElements_[t].track.off && this.trackElements_[t].track.off(), "function" == typeof this.trackElements_[t].off && this.trackElements_[t].off(), this.trackElements_.splice(t, 1);
                                        break
                                    }
                            }
                        },
                        TrackClass: wr,
                        capitalName: "RemoteTextTrackEls",
                        getterName: "remoteTextTrackEls",
                        privateName: "remoteTextTrackEls_"
                    }
                },
                Mr = Object.assign({}, Sr, Er);
            Er.names = Object.keys(Er), Sr.names = Object.keys(Sr), Mr.names = [].concat(Er.names).concat(Sr.names);
            class Cr extends Bn {
                constructor(e = {}, t = function() {}) {
                    e.reportTouchActivity = !1, super(null, e, t), this.onDurationChange_ = e => this.onDurationChange(e), this.trackProgress_ = e => this.trackProgress(e), this.trackCurrentTime_ = e => this.trackCurrentTime(e), this.stopTrackingCurrentTime_ = e => this.stopTrackingCurrentTime(e), this.disposeSourceHandler_ = e => this.disposeSourceHandler(e), this.queuedHanders_ = new Set, this.hasStarted_ = !1, this.on("playing", (function() {
                        this.hasStarted_ = !0
                    })), this.on("loadstart", (function() {
                        this.hasStarted_ = !1
                    })), Mr.names.forEach((t => {
                        const i = Mr[t];
                        e && e[i.getterName] && (this[i.privateName] = e[i.getterName])
                    })), this.featuresProgressEvents || this.manualProgressOn(), this.featuresTimeupdateEvents || this.manualTimeUpdatesOn(), ["Text", "Audio", "Video"].forEach((t => {
                        !1 === e[`native${t}Tracks`] && (this[`featuresNative${t}Tracks`] = !1)
                    })), !1 === e.nativeCaptions || !1 === e.nativeTextTracks ? this.featuresNativeTextTracks = !1 : !0 !== e.nativeCaptions && !0 !== e.nativeTextTracks || (this.featuresNativeTextTracks = !0), this.featuresNativeTextTracks || this.emulateTextTracks(), this.preloadTextTracks = !1 !== e.preloadTextTracks, this.autoRemoteTextTracks_ = new Mr.text.ListClass, this.initTrackListeners(), e.nativeControlsForTouch || this.emitTapEvents(), this.constructor && (this.name_ = this.constructor.name || "Unknown Tech")
                }
                triggerSourceset(e) {
                    this.isReady_ || this.one("ready", (() => this.setTimeout((() => this.triggerSourceset(e)), 1))), this.trigger({
                        src: e,
                        type: "sourceset"
                    })
                }
                manualProgressOn() {
                    this.on("durationchange", this.onDurationChange_), this.manualProgress = !0, this.one("ready", this.trackProgress_)
                }
                manualProgressOff() {
                    this.manualProgress = !1, this.stopTrackingProgress(), this.off("durationchange", this.onDurationChange_)
                }
                trackProgress(e) {
                    this.stopTrackingProgress(), this.progressInterval = this.setInterval(gn(this, (function() {
                        const e = this.bufferedPercent();
                        this.bufferedPercent_ !== e && this.trigger("progress"), this.bufferedPercent_ = e, 1 === e && this.stopTrackingProgress()
                    })), 500)
                }
                onDurationChange(e) {
                    this.duration_ = this.duration()
                }
                buffered() {
                    return zn(0, 0)
                }
                bufferedPercent() {
                    return Xn(this.buffered(), this.duration_)
                }
                stopTrackingProgress() {
                    this.clearInterval(this.progressInterval)
                }
                manualTimeUpdatesOn() {
                    this.manualTimeUpdates = !0, this.on("play", this.trackCurrentTime_), this.on("pause", this.stopTrackingCurrentTime_)
                }
                manualTimeUpdatesOff() {
                    this.manualTimeUpdates = !1, this.stopTrackingCurrentTime(), this.off("play", this.trackCurrentTime_), this.off("pause", this.stopTrackingCurrentTime_)
                }
                trackCurrentTime() {
                    this.currentTimeInterval && this.stopTrackingCurrentTime(), this.currentTimeInterval = this.setInterval((function() {
                        this.trigger({
                            type: "timeupdate",
                            target: this,
                            manuallyTriggered: !0
                        })
                    }), 250)
                }
                stopTrackingCurrentTime() {
                    this.clearInterval(this.currentTimeInterval), this.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: !0
                    })
                }
                dispose() {
                    this.clearTracks(Sr.names), this.manualProgress && this.manualProgressOff(), this.manualTimeUpdates && this.manualTimeUpdatesOff(), super.dispose()
                }
                clearTracks(e) {
                    (e = [].concat(e)).forEach((e => {
                        const t = this[`${e}Tracks`]() || [];
                        let i = t.length;
                        for (; i--;) {
                            const n = t[i];
                            "text" === e && this.removeRemoteTextTrack(n), t.removeTrack(n)
                        }
                    }))
                }
                cleanupAutoTextTracks() {
                    const e = this.autoRemoteTextTracks_ || [];
                    let t = e.length;
                    for (; t--;) {
                        const i = e[t];
                        this.removeRemoteTextTrack(i)
                    }
                }
                reset() {}
                crossOrigin() {}
                setCrossOrigin() {}
                error(e) {
                    return void 0 !== e && (this.error_ = new Yn(e), this.trigger("error")), this.error_
                }
                played() {
                    return this.hasStarted_ ? zn(0, 0) : zn()
                }
                play() {}
                setScrubbing() {}
                scrubbing() {}
                setCurrentTime() {
                    this.manualTimeUpdates && this.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: !0
                    })
                }
                initTrackListeners() {
                    Sr.names.forEach((e => {
                        const t = Sr[e],
                            i = () => {
                                this.trigger(`${e}trackchange`)
                            },
                            n = this[t.getterName]();
                        n.addEventListener("removetrack", i), n.addEventListener("addtrack", i), this.on("dispose", (() => {
                            n.removeEventListener("removetrack", i), n.removeEventListener("addtrack", i)
                        }))
                    }))
                }
                addWebVttScript_() {
                    if (!r().WebVTT)
                        if (a().body.contains(this.el())) {
                            if (!this.options_["vtt.js"] && Wt(f()) && Object.keys(f()).length > 0) return void this.trigger("vttjsloaded");
                            const e = a().createElement("script");
                            e.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js", e.onload = () => {
                                this.trigger("vttjsloaded")
                            }, e.onerror = () => {
                                this.trigger("vttjserror")
                            }, this.on("dispose", (() => {
                                e.onload = null, e.onerror = null
                            })), r().WebVTT = !0, this.el().parentNode.appendChild(e)
                        } else this.ready(this.addWebVttScript_)
                }
                emulateTextTracks() {
                    const e = this.textTracks(),
                        t = this.remoteTextTracks(),
                        i = t => e.addTrack(t.track),
                        n = t => e.removeTrack(t.track);
                    t.on("addtrack", i), t.on("removetrack", n), this.addWebVttScript_();
                    const r = () => this.trigger("texttrackchange"),
                        s = () => {
                            r();
                            for (let t = 0; t < e.length; t++) {
                                const i = e[t];
                                i.removeEventListener("cuechange", r), "showing" === i.mode && i.addEventListener("cuechange", r)
                            }
                        };
                    s(), e.addEventListener("change", s), e.addEventListener("addtrack", s), e.addEventListener("removetrack", s), this.on("dispose", (function() {
                        t.off("addtrack", i), t.off("removetrack", n), e.removeEventListener("change", s), e.removeEventListener("addtrack", s), e.removeEventListener("removetrack", s);
                        for (let t = 0; t < e.length; t++) {
                            e[t].removeEventListener("cuechange", r)
                        }
                    }))
                }
                addTextTrack(e, t, i) {
                    if (!e) throw new Error("TextTrack kind is required but was not provided");
                    return function(e, t, i, n, r = {}) {
                        const s = e.textTracks();
                        r.kind = t, i && (r.label = i), n && (r.language = n), r.tech = e;
                        const a = new Mr.text.TrackClass(r);
                        return s.addTrack(a), a
                    }(this, e, t, i)
                }
                createRemoteTextTrack(e) {
                    const t = jt(e, {
                        tech: this
                    });
                    return new Er.remoteTextEl.TrackClass(t)
                }
                addRemoteTextTrack(e = {}, t) {
                    const i = this.createRemoteTextTrack(e);
                    return "boolean" != typeof t && (t = !1), this.remoteTextTrackEls().addTrackElement_(i), this.remoteTextTracks().addTrack(i.track), !1 === t && this.ready((() => this.autoRemoteTextTracks_.addTrack(i.track))), i
                }
                removeRemoteTextTrack(e) {
                    const t = this.remoteTextTrackEls().getTrackElementByTrack_(e);
                    this.remoteTextTrackEls().removeTrackElement_(t), this.remoteTextTracks().removeTrack(e), this.autoRemoteTextTracks_.removeTrack(e)
                }
                getVideoPlaybackQuality() {
                    return {}
                }
                requestPictureInPicture() {
                    return Promise.reject()
                }
                disablePictureInPicture() {
                    return !0
                }
                setDisablePictureInPicture() {}
                requestVideoFrameCallback(e) {
                    const t = nn();
                    return !this.isReady_ || this.paused() ? (this.queuedHanders_.add(t), this.one("playing", (() => {
                        this.queuedHanders_.has(t) && (this.queuedHanders_.delete(t), e())
                    }))) : this.requestNamedAnimationFrame(t, e), t
                }
                cancelVideoFrameCallback(e) {
                    this.queuedHanders_.has(e) ? this.queuedHanders_.delete(e) : this.cancelNamedAnimationFrame(e)
                }
                setPoster() {}
                playsinline() {}
                setPlaysinline() {}
                overrideNativeAudioTracks() {}
                overrideNativeVideoTracks() {}
                canPlayType() {
                    return ""
                }
                static canPlayType() {
                    return ""
                }
                static canPlaySource(e, t) {
                    return Cr.canPlayType(e.type)
                }
                static isTech(e) {
                    return e.prototype instanceof Cr || e instanceof Cr || e === Cr
                }
                static registerTech(e, t) {
                    if (Cr.techs_ || (Cr.techs_ = {}), !Cr.isTech(t)) throw new Error(`Tech ${e} must be a Tech`);
                    if (!Cr.canPlayType) throw new Error("Techs must have a static canPlayType method on them");
                    if (!Cr.canPlaySource) throw new Error("Techs must have a static canPlaySource method on them");
                    return e = On(e), Cr.techs_[e] = t, Cr.techs_[Dn(e)] = t, "Tech" !== e && Cr.defaultTechOrder_.push(e), t
                }
                static getTech(e) {
                    if (e) return Cr.techs_ && Cr.techs_[e] ? Cr.techs_[e] : (e = On(e), r() && r().videojs && r().videojs[e] ? (Ut.warn(`The ${e} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`), r().videojs[e]) : void 0)
                }
            }
            Mr.names.forEach((function(e) {
                const t = Mr[e];
                Cr.prototype[t.getterName] = function() {
                    return this[t.privateName] = this[t.privateName] || new t.ListClass, this[t.privateName]
                }
            })), Cr.prototype.featuresVolumeControl = !0, Cr.prototype.featuresMuteControl = !0, Cr.prototype.featuresFullscreenResize = !1, Cr.prototype.featuresPlaybackRate = !1, Cr.prototype.featuresProgressEvents = !1, Cr.prototype.featuresSourceset = !1, Cr.prototype.featuresTimeupdateEvents = !1, Cr.prototype.featuresNativeTextTracks = !1, Cr.prototype.featuresVideoFrameCallback = !1, Cr.withSourceHandlers = function(e) {
                e.registerSourceHandler = function(t, i) {
                    let n = e.sourceHandlers;
                    n || (n = e.sourceHandlers = []), void 0 === i && (i = n.length), n.splice(i, 0, t)
                }, e.canPlayType = function(t) {
                    const i = e.sourceHandlers || [];
                    let n;
                    for (let e = 0; e < i.length; e++)
                        if (n = i[e].canPlayType(t), n) return n;
                    return ""
                }, e.selectSourceHandler = function(t, i) {
                    const n = e.sourceHandlers || [];
                    let r;
                    for (let e = 0; e < n.length; e++)
                        if (r = n[e].canHandleSource(t, i), r) return n[e];
                    return null
                }, e.canPlaySource = function(t, i) {
                    const n = e.selectSourceHandler(t, i);
                    return n ? n.canHandleSource(t, i) : ""
                };
                ["seekable", "seeking", "duration"].forEach((function(e) {
                    const t = this[e];
                    "function" == typeof t && (this[e] = function() {
                        return this.sourceHandler_ && this.sourceHandler_[e] ? this.sourceHandler_[e].apply(this.sourceHandler_, arguments) : t.apply(this, arguments)
                    })
                }), e.prototype), e.prototype.setSource = function(t) {
                    let i = e.selectSourceHandler(t, this.options_);
                    i || (e.nativeSourceHandler ? i = e.nativeSourceHandler : Ut.error("No source handler found for the current source.")), this.disposeSourceHandler(), this.off("dispose", this.disposeSourceHandler_), i !== e.nativeSourceHandler && (this.currentSource_ = t), this.sourceHandler_ = i.handleSource(t, this, this.options_), this.one("dispose", this.disposeSourceHandler_)
                }, e.prototype.disposeSourceHandler = function() {
                    this.currentSource_ && (this.clearTracks(["audio", "video"]), this.currentSource_ = null), this.cleanupAutoTextTracks(), this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(), this.sourceHandler_ = null)
                }
            }, Bn.registerComponent("Tech", Cr), Cr.registerTech("Tech", Cr), Cr.defaultTechOrder_ = [];
            const Ar = {},
                Lr = {},
                Ir = {};

            function Pr(e, t, i) {
                e.setTimeout((() => Ur(t, Ar[t.type], i, e)), 1)
            }

            function Rr(e, t, i, n = null) {
                const r = "call" + On(i),
                    s = e.reduce(Nr(r), n),
                    a = s === Ir,
                    o = a ? null : t[i](s);
                return function(e, t, i, n) {
                    for (let r = e.length - 1; r >= 0; r--) {
                        const s = e[r];
                        s[t] && s[t](n, i)
                    }
                }(e, i, o, a), o
            }
            const kr = {
                    buffered: 1,
                    currentTime: 1,
                    duration: 1,
                    muted: 1,
                    played: 1,
                    paused: 1,
                    seekable: 1,
                    volume: 1,
                    ended: 1
                },
                Dr = {
                    setCurrentTime: 1,
                    setMuted: 1,
                    setVolume: 1
                },
                Or = {
                    play: 1,
                    pause: 1
                };

            function Nr(e) {
                return (t, i) => t === Ir ? Ir : i[e] ? i[e](t) : t
            }

            function Ur(e = {}, t = [], i, n, r = [], s = !1) {
                const [a, ...o] = t;
                if ("string" == typeof a) Ur(e, Ar[a], i, n, r, s);
                else if (a) {
                    const t = function(e, t) {
                        const i = Lr[e.id()];
                        let n = null;
                        if (null == i) return n = t(e), Lr[e.id()] = [
                            [t, n]
                        ], n;
                        for (let e = 0; e < i.length; e++) {
                            const [r, s] = i[e];
                            r === t && (n = s)
                        }
                        return null === n && (n = t(e), i.push([t, n])), n
                    }(n, a);
                    if (!t.setSource) return r.push(t), Ur(e, o, i, n, r, s);
                    t.setSource(Object.assign({}, e), (function(a, l) {
                        if (a) return Ur(e, o, i, n, r, s);
                        r.push(t), Ur(l, e.type === l.type ? o : Ar[l.type], i, n, r, s)
                    }))
                } else o.length ? Ur(e, o, i, n, r, s) : s ? i(e, r) : Ur(e, Ar["*"], i, n, r, !0)
            }
            const Br = {
                    opus: "video/ogg",
                    ogv: "video/ogg",
                    mp4: "video/mp4",
                    mov: "video/mp4",
                    m4v: "video/mp4",
                    mkv: "video/x-matroska",
                    m4a: "audio/mp4",
                    mp3: "audio/mpeg",
                    aac: "audio/aac",
                    caf: "audio/x-caf",
                    flac: "audio/flac",
                    oga: "audio/ogg",
                    wav: "audio/wav",
                    m3u8: "application/x-mpegURL",
                    mpd: "application/dash+xml",
                    jpg: "image/jpeg",
                    jpeg: "image/jpeg",
                    gif: "image/gif",
                    png: "image/png",
                    svg: "image/svg+xml",
                    webp: "image/webp"
                },
                Fr = function(e = "") {
                    const t = mr(e);
                    return Br[t.toLowerCase()] || ""
                },
                Hr = function(e) {
                    if (Array.isArray(e)) {
                        let t = [];
                        e.forEach((function(e) {
                            e = Hr(e), Array.isArray(e) ? t = t.concat(e) : Gt(e) && t.push(e)
                        })), e = t
                    } else e = "string" == typeof e && e.trim() ? [zr({
                        src: e
                    })] : Gt(e) && "string" == typeof e.src && e.src && e.src.trim() ? [zr(e)] : [];
                    return e
                };

            function zr(e) {
                if (!e.type) {
                    const t = Fr(e.src);
                    t && (e.type = t)
                }
                return e
            }
            Bn.registerComponent("MediaLoader", class extends Bn {
                constructor(e, t, i) {
                    if (super(e, jt({
                            createEl: !1
                        }, t), i), t.playerOptions.sources && 0 !== t.playerOptions.sources.length) e.src(t.playerOptions.sources);
                    else
                        for (let i = 0, n = t.playerOptions.techOrder; i < n.length; i++) {
                            const t = On(n[i]);
                            let r = Cr.getTech(t);
                            if (t || (r = Bn.getComponent(t)), r && r.isSupported()) {
                                e.loadTech_(t);
                                break
                            }
                        }
                }
            });
            class Vr extends Bn {
                constructor(e, t) {
                    super(e, t), this.options_.controlText && this.controlText(this.options_.controlText), this.handleMouseOver_ = e => this.handleMouseOver(e), this.handleMouseOut_ = e => this.handleMouseOut(e), this.handleClick_ = e => this.handleClick(e), this.handleKeyDown_ = e => this.handleKeyDown(e), this.emitTapEvents(), this.enable()
                }
                createEl(e = "div", t = {}, i = {}) {
                    t = Object.assign({
                        className: this.buildCSSClass(),
                        tabIndex: 0
                    }, t), "button" === e && Ut.error(`Creating a ClickableComponent with an HTML element of ${e} is not supported; use a Button instead.`), i = Object.assign({
                        role: "button"
                    }, i), this.tabIndex_ = t.tabIndex;
                    const n = vi(e, t, i);
                    return n.appendChild(vi("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": !0
                    })), this.createControlTextEl(n), n
                }
                dispose() {
                    this.controlTextEl_ = null, super.dispose()
                }
                createControlTextEl(e) {
                    return this.controlTextEl_ = vi("span", {
                        className: "vjs-control-text"
                    }, {
                        "aria-live": "polite"
                    }), e && e.appendChild(this.controlTextEl_), this.controlText(this.controlText_, e), this.controlTextEl_
                }
                controlText(e, t = this.el()) {
                    if (void 0 === e) return this.controlText_ || "Need Text";
                    const i = this.localize(e);
                    this.controlText_ = e, bi(this.controlTextEl_, i), this.nonIconControl || this.player_.options_.noUITitleAttributes || t.setAttribute("title", i)
                }
                buildCSSClass() {
                    return `vjs-control vjs-button ${super.buildCSSClass()}`
                }
                enable() {
                    this.enabled_ || (this.enabled_ = !0, this.removeClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "false"), void 0 !== this.tabIndex_ && this.el_.setAttribute("tabIndex", this.tabIndex_), this.on(["tap", "click"], this.handleClick_), this.on("keydown", this.handleKeyDown_))
                }
                disable() {
                    this.enabled_ = !1, this.addClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "true"), void 0 !== this.tabIndex_ && this.el_.removeAttribute("tabIndex"), this.off("mouseover", this.handleMouseOver_), this.off("mouseout", this.handleMouseOut_), this.off(["tap", "click"], this.handleClick_), this.off("keydown", this.handleKeyDown_)
                }
                handleLanguagechange() {
                    this.controlText(this.controlText_)
                }
                handleClick(e) {
                    this.options_.clickHandler && this.options_.clickHandler.call(this, arguments)
                }
                handleKeyDown(e) {
                    l().isEventKey(e, "Space") || l().isEventKey(e, "Enter") ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e)
                }
            }
            Bn.registerComponent("ClickableComponent", Vr);
            class Gr extends Vr {
                constructor(e, t) {
                    super(e, t), this.update(), this.update_ = e => this.update(e), e.on("posterchange", this.update_)
                }
                dispose() {
                    this.player().off("posterchange", this.update_), super.dispose()
                }
                createEl() {
                    return vi("picture", {
                        className: "vjs-poster",
                        tabIndex: -1
                    }, {}, vi("img", {
                        loading: "lazy",
                        crossOrigin: this.crossOrigin()
                    }, {
                        alt: ""
                    }))
                }
                crossOrigin(e) {
                    if (void 0 === e) return this.el_ ? this.el_.querySelector("img").crossOrigin : this.player_.tech_ && this.player_.tech_.isReady_ ? this.player_.crossOrigin() : this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;
                    null === e || "anonymous" === e || "use-credentials" === e ? this.el_.querySelector("img").crossOrigin = e : this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${e}"`)
                }
                update(e) {
                    const t = this.player().poster();
                    this.setSrc(t), t ? this.show() : this.hide()
                }
                setSrc(e) {
                    this.el_.querySelector("img").src = e
                }
                handleClick(e) {
                    this.player_.controls() && (this.player_.tech(!0) && this.player_.tech(!0).focus(), this.player_.paused() ? Jn(this.player_.play()) : this.player_.pause())
                }
            }
            Gr.prototype.crossorigin = Gr.prototype.crossOrigin, Bn.registerComponent("PosterImage", Gr);
            const Wr = "#222",
                jr = "#ccc",
                qr = {
                    monospace: "monospace",
                    sansSerif: "sans-serif",
                    serif: "serif",
                    monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
                    monospaceSerif: '"Courier New", monospace',
                    proportionalSansSerif: "sans-serif",
                    proportionalSerif: "serif",
                    casual: '"Comic Sans MS", Impact, fantasy',
                    script: '"Monotype Corsiva", cursive',
                    smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
                };

            function $r(e, t) {
                let i;
                if (4 === e.length) i = e[1] + e[1] + e[2] + e[2] + e[3] + e[3];
                else {
                    if (7 !== e.length) throw new Error("Invalid color code provided, " + e + "; must be formatted as e.g. #f0e or #f604e2.");
                    i = e.slice(1)
                }
                return "rgba(" + parseInt(i.slice(0, 2), 16) + "," + parseInt(i.slice(2, 4), 16) + "," + parseInt(i.slice(4, 6), 16) + "," + t + ")"
            }

            function Xr(e, t, i) {
                try {
                    e.style[t] = i
                } catch (e) {
                    return
                }
            }
            Bn.registerComponent("TextTrackDisplay", class extends Bn {
                constructor(e, t, i) {
                    super(e, t, i);
                    const n = e => this.updateDisplay(e);
                    e.on("loadstart", (e => this.toggleDisplay(e))), e.on("texttrackchange", n), e.on("loadedmetadata", (e => this.preselectTrack(e))), e.ready(gn(this, (function() {
                        if (e.tech_ && e.tech_.featuresNativeTextTracks) return void this.hide();
                        e.on("fullscreenchange", n), e.on("playerresize", n);
                        const t = r().screen.orientation || r(),
                            i = r().screen.orientation ? "change" : "orientationchange";
                        t.addEventListener(i, n), e.on("dispose", (() => t.removeEventListener(i, n)));
                        const s = this.options_.playerOptions.tracks || [];
                        for (let e = 0; e < s.length; e++) this.player_.addRemoteTextTrack(s[e], !0);
                        this.preselectTrack()
                    })))
                }
                preselectTrack() {
                    const e = {
                            captions: 1,
                            subtitles: 1
                        },
                        t = this.player_.textTracks(),
                        i = this.player_.cache_.selectedLanguage;
                    let n, r, s;
                    for (let a = 0; a < t.length; a++) {
                        const o = t[a];
                        i && i.enabled && i.language && i.language === o.language && o.kind in e ? o.kind === i.kind ? s = o : s || (s = o) : i && !i.enabled ? (s = null, n = null, r = null) : o.default && ("descriptions" !== o.kind || n ? o.kind in e && !r && (r = o) : n = o)
                    }
                    s ? s.mode = "showing" : r ? r.mode = "showing" : n && (n.mode = "showing")
                }
                toggleDisplay() {
                    this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show()
                }
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-text-track-display"
                    }, {
                        translate: "yes",
                        "aria-live": "off",
                        "aria-atomic": "true"
                    })
                }
                clearDisplay() {
                    "function" == typeof r().WebVTT && r().WebVTT.processCues(r(), [], this.el_)
                }
                updateDisplay() {
                    const e = this.player_.textTracks(),
                        t = this.options_.allowMultipleShowingTracks;
                    if (this.clearDisplay(), t) {
                        const t = [];
                        for (let i = 0; i < e.length; ++i) {
                            const n = e[i];
                            "showing" === n.mode && t.push(n)
                        }
                        return void this.updateForTrack(t)
                    }
                    let i = null,
                        n = null,
                        r = e.length;
                    for (; r--;) {
                        const t = e[r];
                        "showing" === t.mode && ("descriptions" === t.kind ? i = t : n = t)
                    }
                    n ? ("off" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "off"), this.updateForTrack(n)) : i && ("assertive" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "assertive"), this.updateForTrack(i))
                }
                updateDisplayState(e) {
                    const t = this.player_.textTrackSettings.getValues(),
                        i = e.activeCues;
                    let n = i.length;
                    for (; n--;) {
                        const e = i[n];
                        if (!e) continue;
                        const s = e.displayState;
                        if (t.color && (s.firstChild.style.color = t.color), t.textOpacity && Xr(s.firstChild, "color", $r(t.color || "#fff", t.textOpacity)), t.backgroundColor && (s.firstChild.style.backgroundColor = t.backgroundColor), t.backgroundOpacity && Xr(s.firstChild, "backgroundColor", $r(t.backgroundColor || "#000", t.backgroundOpacity)), t.windowColor && (t.windowOpacity ? Xr(s, "backgroundColor", $r(t.windowColor, t.windowOpacity)) : s.style.backgroundColor = t.windowColor), t.edgeStyle && ("dropshadow" === t.edgeStyle ? s.firstChild.style.textShadow = `2px 2px 3px ${Wr}, 2px 2px 4px ${Wr}, 2px 2px 5px ${Wr}` : "raised" === t.edgeStyle ? s.firstChild.style.textShadow = `1px 1px ${Wr}, 2px 2px ${Wr}, 3px 3px ${Wr}` : "depressed" === t.edgeStyle ? s.firstChild.style.textShadow = `1px 1px ${jr}, 0 1px ${jr}, -1px -1px ${Wr}, 0 -1px ${Wr}` : "uniform" === t.edgeStyle && (s.firstChild.style.textShadow = `0 0 4px ${Wr}, 0 0 4px ${Wr}, 0 0 4px ${Wr}, 0 0 4px ${Wr}`)), t.fontPercent && 1 !== t.fontPercent) {
                            const e = r().parseFloat(s.style.fontSize);
                            s.style.fontSize = e * t.fontPercent + "px", s.style.height = "auto", s.style.top = "auto"
                        }
                        t.fontFamily && "default" !== t.fontFamily && ("small-caps" === t.fontFamily ? s.firstChild.style.fontVariant = "small-caps" : s.firstChild.style.fontFamily = qr[t.fontFamily])
                    }
                }
                updateForTrack(e) {
                    if (Array.isArray(e) || (e = [e]), "function" != typeof r().WebVTT || e.every((e => !e.activeCues))) return;
                    const t = [];
                    for (let i = 0; i < e.length; ++i) {
                        const n = e[i];
                        for (let e = 0; e < n.activeCues.length; ++e) t.push(n.activeCues[e])
                    }
                    r().WebVTT.processCues(r(), t, this.el_);
                    for (let t = 0; t < e.length; ++t) {
                        const i = e[t];
                        for (let e = 0; e < i.activeCues.length; ++e) {
                            const n = i.activeCues[e].displayState;
                            wi(n, "vjs-text-track-cue", "vjs-text-track-cue-" + (i.language ? i.language : t)), i.language && Li(n, "lang", i.language)
                        }
                        this.player_.textTrackSettings && this.updateDisplayState(i)
                    }
                }
            });
            Bn.registerComponent("LoadingSpinner", class extends Bn {
                createEl() {
                    const e = this.player_.isAudio(),
                        t = this.localize(e ? "Audio Player" : "Video Player"),
                        i = vi("span", {
                            className: "vjs-control-text",
                            textContent: this.localize("{1} is loading.", [t])
                        }),
                        n = super.createEl("div", {
                            className: "vjs-loading-spinner",
                            dir: "ltr"
                        });
                    return n.appendChild(i), n
                }
            });
            class Yr extends Vr {
                createEl(e, t = {}, i = {}) {
                    const n = vi("button", t = Object.assign({
                        className: this.buildCSSClass()
                    }, t), i = Object.assign({
                        type: "button"
                    }, i));
                    return n.appendChild(vi("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": !0
                    })), this.createControlTextEl(n), n
                }
                addChild(e, t = {}) {
                    const i = this.constructor.name;
                    return Ut.warn(`Adding an actionable (user controllable) child to a Button (${i}) is not supported; use a ClickableComponent instead.`), Bn.prototype.addChild.call(this, e, t)
                }
                enable() {
                    super.enable(), this.el_.removeAttribute("disabled")
                }
                disable() {
                    super.disable(), this.el_.setAttribute("disabled", "disabled")
                }
                handleKeyDown(e) {
                    l().isEventKey(e, "Space") || l().isEventKey(e, "Enter") ? e.stopPropagation() : super.handleKeyDown(e)
                }
            }
            Bn.registerComponent("Button", Yr);
            class Kr extends Yr {
                constructor(e, t) {
                    super(e, t), this.mouseused_ = !1, this.on("mousedown", (e => this.handleMouseDown(e)))
                }
                buildCSSClass() {
                    return "vjs-big-play-button"
                }
                handleClick(e) {
                    const t = this.player_.play();
                    if (this.mouseused_ && e.clientX && e.clientY) return Jn(t), void(this.player_.tech(!0) && this.player_.tech(!0).focus());
                    const i = this.player_.getChild("controlBar"),
                        n = i && i.getChild("playToggle");
                    if (!n) return void this.player_.tech(!0).focus();
                    const r = () => n.focus();
                    Kn(t) ? t.then(r, (() => {})) : this.setTimeout(r, 1)
                }
                handleKeyDown(e) {
                    this.mouseused_ = !1, super.handleKeyDown(e)
                }
                handleMouseDown(e) {
                    this.mouseused_ = !0
                }
            }
            Kr.prototype.controlText_ = "Play Video", Bn.registerComponent("BigPlayButton", Kr);
            Bn.registerComponent("CloseButton", class extends Yr {
                constructor(e, t) {
                    super(e, t), this.controlText(t && t.controlText || this.localize("Close"))
                }
                buildCSSClass() {
                    return `vjs-close-button ${super.buildCSSClass()}`
                }
                handleClick(e) {
                    this.trigger({
                        type: "close",
                        bubbles: !1
                    })
                }
                handleKeyDown(e) {
                    l().isEventKey(e, "Esc") ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e)
                }
            });
            class Jr extends Yr {
                constructor(e, t = {}) {
                    super(e, t), t.replay = void 0 === t.replay || t.replay, this.on(e, "play", (e => this.handlePlay(e))), this.on(e, "pause", (e => this.handlePause(e))), t.replay && this.on(e, "ended", (e => this.handleEnded(e)))
                }
                buildCSSClass() {
                    return `vjs-play-control ${super.buildCSSClass()}`
                }
                handleClick(e) {
                    this.player_.paused() ? Jn(this.player_.play()) : this.player_.pause()
                }
                handleSeeked(e) {
                    this.removeClass("vjs-ended"), this.player_.paused() ? this.handlePause(e) : this.handlePlay(e)
                }
                handlePlay(e) {
                    this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.controlText("Pause")
                }
                handlePause(e) {
                    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.controlText("Play")
                }
                handleEnded(e) {
                    this.removeClass("vjs-playing"), this.addClass("vjs-ended"), this.controlText("Replay"), this.one(this.player_, "seeked", (e => this.handleSeeked(e)))
                }
            }
            Jr.prototype.controlText_ = "Play", Bn.registerComponent("PlayToggle", Jr);
            class Zr extends Bn {
                constructor(e, t) {
                    super(e, t), this.on(e, ["timeupdate", "ended"], (e => this.updateContent(e))), this.updateTextNode_()
                }
                createEl() {
                    const e = this.buildCSSClass(),
                        t = super.createEl("div", {
                            className: `${e} vjs-time-control vjs-control`
                        }),
                        i = vi("span", {
                            className: "vjs-control-text",
                            textContent: `${this.localize(this.labelText_)} `
                        }, {
                            role: "presentation"
                        });
                    return t.appendChild(i), this.contentEl_ = vi("span", {
                        className: `${e}-display`
                    }, {
                        "aria-live": "off",
                        role: "presentation"
                    }), t.appendChild(this.contentEl_), t
                }
                dispose() {
                    this.contentEl_ = null, this.textNode_ = null, super.dispose()
                }
                updateTextNode_(e = 0) {
                    e = qn(e), this.formattedTime_ !== e && (this.formattedTime_ = e, this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", (() => {
                        if (!this.contentEl_) return;
                        let e = this.textNode_;
                        e && this.contentEl_.firstChild !== e && (e = null, Ut.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.")), this.textNode_ = a().createTextNode(this.formattedTime_), this.textNode_ && (e ? this.contentEl_.replaceChild(this.textNode_, e) : this.contentEl_.appendChild(this.textNode_))
                    })))
                }
                updateContent(e) {}
            }
            Zr.prototype.labelText_ = "Time", Zr.prototype.controlText_ = "Time", Bn.registerComponent("TimeDisplay", Zr);
            class Qr extends Zr {
                buildCSSClass() {
                    return "vjs-current-time"
                }
                updateContent(e) {
                    let t;
                    t = this.player_.ended() ? this.player_.duration() : this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(), this.updateTextNode_(t)
                }
            }
            Qr.prototype.labelText_ = "Current Time", Qr.prototype.controlText_ = "Current Time", Bn.registerComponent("CurrentTimeDisplay", Qr);
            class es extends Zr {
                constructor(e, t) {
                    super(e, t);
                    const i = e => this.updateContent(e);
                    this.on(e, "durationchange", i), this.on(e, "loadstart", i), this.on(e, "loadedmetadata", i)
                }
                buildCSSClass() {
                    return "vjs-duration"
                }
                updateContent(e) {
                    const t = this.player_.duration();
                    this.updateTextNode_(t)
                }
            }
            es.prototype.labelText_ = "Duration", es.prototype.controlText_ = "Duration", Bn.registerComponent("DurationDisplay", es);
            Bn.registerComponent("TimeDivider", class extends Bn {
                createEl() {
                    const e = super.createEl("div", {
                            className: "vjs-time-control vjs-time-divider"
                        }, {
                            "aria-hidden": !0
                        }),
                        t = super.createEl("div"),
                        i = super.createEl("span", {
                            textContent: "/"
                        });
                    return t.appendChild(i), e.appendChild(t), e
                }
            });
            class ts extends Zr {
                constructor(e, t) {
                    super(e, t), this.on(e, "durationchange", (e => this.updateContent(e)))
                }
                buildCSSClass() {
                    return "vjs-remaining-time"
                }
                createEl() {
                    const e = super.createEl();
                    return !1 !== this.options_.displayNegative && e.insertBefore(vi("span", {}, {
                        "aria-hidden": !0
                    }, "-"), this.contentEl_), e
                }
                updateContent(e) {
                    if ("number" != typeof this.player_.duration()) return;
                    let t;
                    t = this.player_.ended() ? 0 : this.player_.remainingTimeDisplay ? this.player_.remainingTimeDisplay() : this.player_.remainingTime(), this.updateTextNode_(t)
                }
            }
            ts.prototype.labelText_ = "Remaining Time", ts.prototype.controlText_ = "Remaining Time", Bn.registerComponent("RemainingTimeDisplay", ts);
            Bn.registerComponent("LiveDisplay", class extends Bn {
                constructor(e, t) {
                    super(e, t), this.updateShowing(), this.on(this.player(), "durationchange", (e => this.updateShowing(e)))
                }
                createEl() {
                    const e = super.createEl("div", {
                        className: "vjs-live-control vjs-control"
                    });
                    return this.contentEl_ = vi("div", {
                        className: "vjs-live-display"
                    }, {
                        "aria-live": "off"
                    }), this.contentEl_.appendChild(vi("span", {
                        className: "vjs-control-text",
                        textContent: `${this.localize("Stream Type")} `
                    })), this.contentEl_.appendChild(a().createTextNode(this.localize("LIVE"))), e.appendChild(this.contentEl_), e
                }
                dispose() {
                    this.contentEl_ = null, super.dispose()
                }
                updateShowing(e) {
                    this.player().duration() === 1 / 0 ? this.show() : this.hide()
                }
            });
            class is extends Yr {
                constructor(e, t) {
                    super(e, t), this.updateLiveEdgeStatus(), this.player_.liveTracker && (this.updateLiveEdgeStatusHandler_ = e => this.updateLiveEdgeStatus(e), this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_))
                }
                createEl() {
                    const e = super.createEl("button", {
                        className: "vjs-seek-to-live-control vjs-control"
                    });
                    return this.textEl_ = vi("span", {
                        className: "vjs-seek-to-live-text",
                        textContent: this.localize("LIVE")
                    }, {
                        "aria-hidden": "true"
                    }), e.appendChild(this.textEl_), e
                }
                updateLiveEdgeStatus() {
                    !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0), this.addClass("vjs-at-live-edge"), this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1), this.removeClass("vjs-at-live-edge"), this.controlText("Seek to live, currently behind live"))
                }
                handleClick() {
                    this.player_.liveTracker.seekToLiveEdge()
                }
                dispose() {
                    this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_), this.textEl_ = null, super.dispose()
                }
            }

            function ns(e, t, i) {
                return e = Number(e), Math.min(i, Math.max(t, isNaN(e) ? t : e))
            }
            is.prototype.controlText_ = "Seek to live, currently playing live", Bn.registerComponent("SeekToLive", is);
            var rs = Object.freeze({
                __proto__: null,
                clamp: ns
            });
            class ss extends Bn {
                constructor(e, t) {
                    super(e, t), this.handleMouseDown_ = e => this.handleMouseDown(e), this.handleMouseUp_ = e => this.handleMouseUp(e), this.handleKeyDown_ = e => this.handleKeyDown(e), this.handleClick_ = e => this.handleClick(e), this.handleMouseMove_ = e => this.handleMouseMove(e), this.update_ = e => this.update(e), this.bar = this.getChild(this.options_.barName), this.vertical(!!this.options_.vertical), this.enable()
                }
                enabled() {
                    return this.enabled_
                }
                enable() {
                    this.enabled() || (this.on("mousedown", this.handleMouseDown_), this.on("touchstart", this.handleMouseDown_), this.on("keydown", this.handleKeyDown_), this.on("click", this.handleClick_), this.on(this.player_, "controlsvisible", this.update), this.playerEvent && this.on(this.player_, this.playerEvent, this.update), this.removeClass("disabled"), this.setAttribute("tabindex", 0), this.enabled_ = !0)
                }
                disable() {
                    if (!this.enabled()) return;
                    const e = this.bar.el_.ownerDocument;
                    this.off("mousedown", this.handleMouseDown_), this.off("touchstart", this.handleMouseDown_), this.off("keydown", this.handleKeyDown_), this.off("click", this.handleClick_), this.off(this.player_, "controlsvisible", this.update_), this.off(e, "mousemove", this.handleMouseMove_), this.off(e, "mouseup", this.handleMouseUp_), this.off(e, "touchmove", this.handleMouseMove_), this.off(e, "touchend", this.handleMouseUp_), this.removeAttribute("tabindex"), this.addClass("disabled"), this.playerEvent && this.off(this.player_, this.playerEvent, this.update), this.enabled_ = !1
                }
                createEl(e, t = {}, i = {}) {
                    return t.className = t.className + " vjs-slider", t = Object.assign({
                        tabIndex: 0
                    }, t), i = Object.assign({
                        role: "slider",
                        "aria-valuenow": 0,
                        "aria-valuemin": 0,
                        "aria-valuemax": 100
                    }, i), super.createEl(e, t, i)
                }
                handleMouseDown(e) {
                    const t = this.bar.el_.ownerDocument;
                    "mousedown" === e.type && e.preventDefault(), "touchstart" !== e.type || ti || e.preventDefault(), Pi(), this.addClass("vjs-sliding"), this.trigger("slideractive"), this.on(t, "mousemove", this.handleMouseMove_), this.on(t, "mouseup", this.handleMouseUp_), this.on(t, "touchmove", this.handleMouseMove_), this.on(t, "touchend", this.handleMouseUp_), this.handleMouseMove(e, !0)
                }
                handleMouseMove(e) {}
                handleMouseUp() {
                    const e = this.bar.el_.ownerDocument;
                    Ri(), this.removeClass("vjs-sliding"), this.trigger("sliderinactive"), this.off(e, "mousemove", this.handleMouseMove_), this.off(e, "mouseup", this.handleMouseUp_), this.off(e, "touchmove", this.handleMouseMove_), this.off(e, "touchend", this.handleMouseUp_), this.update()
                }
                update() {
                    if (!this.el_ || !this.bar) return;
                    const e = this.getProgress();
                    return e === this.progress_ || (this.progress_ = e, this.requestNamedAnimationFrame("Slider#update", (() => {
                        const t = this.vertical() ? "height" : "width";
                        this.bar.el().style[t] = (100 * e).toFixed(2) + "%"
                    }))), e
                }
                getProgress() {
                    return Number(ns(this.getPercent(), 0, 1).toFixed(4))
                }
                calculateDistance(e) {
                    const t = Oi(this.el_, e);
                    return this.vertical() ? t.y : t.x
                }
                handleKeyDown(e) {
                    l().isEventKey(e, "Left") || l().isEventKey(e, "Down") ? (e.preventDefault(), e.stopPropagation(), this.stepBack()) : l().isEventKey(e, "Right") || l().isEventKey(e, "Up") ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : super.handleKeyDown(e)
                }
                handleClick(e) {
                    e.stopPropagation(), e.preventDefault()
                }
                vertical(e) {
                    if (void 0 === e) return this.vertical_ || !1;
                    this.vertical_ = !!e, this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal")
                }
            }
            Bn.registerComponent("Slider", ss);
            const as = (e, t) => ns(e / t * 100, 0, 100).toFixed(2) + "%";
            Bn.registerComponent("LoadProgressBar", class extends Bn {
                constructor(e, t) {
                    super(e, t), this.partEls_ = [], this.on(e, "progress", (e => this.update(e)))
                }
                createEl() {
                    const e = super.createEl("div", {
                            className: "vjs-load-progress"
                        }),
                        t = vi("span", {
                            className: "vjs-control-text"
                        }),
                        i = vi("span", {
                            textContent: this.localize("Loaded")
                        }),
                        n = a().createTextNode(": ");
                    return this.percentageEl_ = vi("span", {
                        className: "vjs-control-text-loaded-percentage",
                        textContent: "0%"
                    }), e.appendChild(t), t.appendChild(i), t.appendChild(n), t.appendChild(this.percentageEl_), e
                }
                dispose() {
                    this.partEls_ = null, this.percentageEl_ = null, super.dispose()
                }
                update(e) {
                    this.requestNamedAnimationFrame("LoadProgressBar#update", (() => {
                        const e = this.player_.liveTracker,
                            t = this.player_.buffered(),
                            i = e && e.isLive() ? e.seekableEnd() : this.player_.duration(),
                            n = this.player_.bufferedEnd(),
                            r = this.partEls_,
                            s = as(n, i);
                        this.percent_ !== s && (this.el_.style.width = s, bi(this.percentageEl_, s), this.percent_ = s);
                        for (let e = 0; e < t.length; e++) {
                            const i = t.start(e),
                                s = t.end(e);
                            let a = r[e];
                            a || (a = this.el_.appendChild(vi()), r[e] = a), a.dataset.start === i && a.dataset.end === s || (a.dataset.start = i, a.dataset.end = s, a.style.left = as(i, n), a.style.width = as(s - i, n))
                        }
                        for (let e = r.length; e > t.length; e--) this.el_.removeChild(r[e - 1]);
                        r.length = t.length
                    }))
                }
            });
            Bn.registerComponent("TimeTooltip", class extends Bn {
                constructor(e, t) {
                    super(e, t), this.update = yn(gn(this, this.update), mn)
                }
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-time-tooltip"
                    }, {
                        "aria-hidden": "true"
                    })
                }
                update(e, t, i) {
                    const n = Di(this.el_),
                        r = ki(this.player_.el()),
                        s = e.width * t;
                    if (!r || !n) return;
                    const a = e.left - r.left + s,
                        o = e.width - s + (r.right - e.right);
                    let l = n.width / 2;
                    a < l ? l += l - a : o < l && (l = o), l < 0 ? l = 0 : l > n.width && (l = n.width), l = Math.round(l), this.el_.style.right = `-${l}px`, this.write(i)
                }
                write(e) {
                    bi(this.el_, e)
                }
                updateTime(e, t, i, n) {
                    this.requestNamedAnimationFrame("TimeTooltip#updateTime", (() => {
                        let r;
                        const s = this.player_.duration();
                        if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
                            const e = this.player_.liveTracker.liveWindow(),
                                i = e - t * e;
                            r = (i < 1 ? "" : "-") + qn(i, e)
                        } else r = qn(i, s);
                        this.update(e, t, r), n && n()
                    }))
                }
            });
            class os extends Bn {
                constructor(e, t) {
                    super(e, t), this.update = yn(gn(this, this.update), mn)
                }
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-play-progress vjs-slider-bar"
                    }, {
                        "aria-hidden": "true"
                    })
                }
                update(e, t) {
                    const i = this.getChild("timeTooltip");
                    if (!i) return;
                    const n = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
                    i.updateTime(e, t, n)
                }
            }
            os.prototype.options_ = {
                children: []
            }, ui || Jt || os.prototype.options_.children.push("timeTooltip"), Bn.registerComponent("PlayProgressBar", os);
            class ls extends Bn {
                constructor(e, t) {
                    super(e, t), this.update = yn(gn(this, this.update), mn)
                }
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-mouse-display"
                    })
                }
                update(e, t) {
                    const i = t * this.player_.duration();
                    this.getChild("timeTooltip").updateTime(e, t, i, (() => {
                        this.el_.style.left = e.width * t + "px"
                    }))
                }
            }
            ls.prototype.options_ = {
                children: ["timeTooltip"]
            }, Bn.registerComponent("MouseTimeDisplay", ls);
            class hs extends ss {
                constructor(e, t) {
                    super(e, t), this.setEventHandlers_()
                }
                setEventHandlers_() {
                    this.update_ = gn(this, this.update), this.update = yn(this.update_, mn), this.on(this.player_, ["ended", "durationchange", "timeupdate"], this.update), this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update), this.updateInterval = null, this.enableIntervalHandler_ = e => this.enableInterval_(e), this.disableIntervalHandler_ = e => this.disableInterval_(e), this.on(this.player_, ["playing"], this.enableIntervalHandler_), this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in a() && "visibilityState" in a() && this.on(a(), "visibilitychange", this.toggleVisibility_)
                }
                toggleVisibility_(e) {
                    "hidden" === a().visibilityState ? (this.cancelNamedAnimationFrame("SeekBar#update"), this.cancelNamedAnimationFrame("Slider#update"), this.disableInterval_(e)) : (this.player_.ended() || this.player_.paused() || this.enableInterval_(), this.update())
                }
                enableInterval_() {
                    this.updateInterval || (this.updateInterval = this.setInterval(this.update, mn))
                }
                disableInterval_(e) {
                    this.player_.liveTracker && this.player_.liveTracker.isLive() && e && "ended" !== e.type || this.updateInterval && (this.clearInterval(this.updateInterval), this.updateInterval = null)
                }
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-progress-holder"
                    }, {
                        "aria-label": this.localize("Progress Bar")
                    })
                }
                update(e) {
                    if ("hidden" === a().visibilityState) return;
                    const t = super.update();
                    return this.requestNamedAnimationFrame("SeekBar#update", (() => {
                        const e = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_(),
                            i = this.player_.liveTracker;
                        let n = this.player_.duration();
                        i && i.isLive() && (n = this.player_.liveTracker.liveCurrentTime()), this.percent_ !== t && (this.el_.setAttribute("aria-valuenow", (100 * t).toFixed(2)), this.percent_ = t), this.currentTime_ === e && this.duration_ === n || (this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [qn(e, n), qn(n, n)], "{1} of {2}")), this.currentTime_ = e, this.duration_ = n), this.bar && this.bar.update(ki(this.el()), this.getProgress())
                    })), t
                }
                userSeek_(e) {
                    this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(e)
                }
                getCurrentTime_() {
                    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime()
                }
                getPercent() {
                    const e = this.getCurrentTime_();
                    let t;
                    const i = this.player_.liveTracker;
                    return i && i.isLive() ? (t = (e - i.seekableStart()) / i.liveWindow(), i.atLiveEdge() && (t = 1)) : t = e / this.player_.duration(), t
                }
                handleMouseDown(e) {
                    zi(e) && (e.stopPropagation(), this.videoWasPlaying = !this.player_.paused(), this.player_.pause(), super.handleMouseDown(e))
                }
                handleMouseMove(e, t = !1) {
                    if (!zi(e)) return;
                    let i;
                    t || this.player_.scrubbing() || this.player_.scrubbing(!0);
                    const n = this.calculateDistance(e),
                        r = this.player_.liveTracker;
                    if (r && r.isLive()) {
                        if (n >= .99) return void r.seekToLiveEdge();
                        const e = r.seekableStart(),
                            t = r.liveCurrentTime();
                        if (i = e + n * r.liveWindow(), i >= t && (i = t), i <= e && (i = e + .1), i === 1 / 0) return
                    } else i = n * this.player_.duration(), i === this.player_.duration() && (i -= .1);
                    this.userSeek_(i)
                }
                enable() {
                    super.enable();
                    const e = this.getChild("mouseTimeDisplay");
                    e && e.show()
                }
                disable() {
                    super.disable();
                    const e = this.getChild("mouseTimeDisplay");
                    e && e.hide()
                }
                handleMouseUp(e) {
                    super.handleMouseUp(e), e && e.stopPropagation(), this.player_.scrubbing(!1), this.player_.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: !0
                    }), this.videoWasPlaying ? Jn(this.player_.play()) : this.update_()
                }
                stepForward() {
                    this.userSeek_(this.player_.currentTime() + 5)
                }
                stepBack() {
                    this.userSeek_(this.player_.currentTime() - 5)
                }
                handleAction(e) {
                    this.player_.paused() ? this.player_.play() : this.player_.pause()
                }
                handleKeyDown(e) {
                    const t = this.player_.liveTracker;
                    if (l().isEventKey(e, "Space") || l().isEventKey(e, "Enter")) e.preventDefault(), e.stopPropagation(), this.handleAction(e);
                    else if (l().isEventKey(e, "Home")) e.preventDefault(), e.stopPropagation(), this.userSeek_(0);
                    else if (l().isEventKey(e, "End")) e.preventDefault(), e.stopPropagation(), t && t.isLive() ? this.userSeek_(t.liveCurrentTime()) : this.userSeek_(this.player_.duration());
                    else if (/^[0-9]$/.test(l()(e))) {
                        e.preventDefault(), e.stopPropagation();
                        const i = 10 * (l().codes[l()(e)] - l().codes[0]) / 100;
                        t && t.isLive() ? this.userSeek_(t.seekableStart() + t.liveWindow() * i) : this.userSeek_(this.player_.duration() * i)
                    } else l().isEventKey(e, "PgDn") ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() - 60)) : l().isEventKey(e, "PgUp") ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() + 60)) : super.handleKeyDown(e)
                }
                dispose() {
                    this.disableInterval_(), this.off(this.player_, ["ended", "durationchange", "timeupdate"], this.update), this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.update), this.off(this.player_, ["playing"], this.enableIntervalHandler_), this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in a() && "visibilityState" in a() && this.off(a(), "visibilitychange", this.toggleVisibility_), super.dispose()
                }
            }
            hs.prototype.options_ = {
                children: ["loadProgressBar", "playProgressBar"],
                barName: "playProgressBar"
            }, ui || Jt || hs.prototype.options_.children.splice(1, 0, "mouseTimeDisplay"), Bn.registerComponent("SeekBar", hs);
            class cs extends Bn {
                constructor(e, t) {
                    super(e, t), this.handleMouseMove = yn(gn(this, this.handleMouseMove), mn), this.throttledHandleMouseSeek = yn(gn(this, this.handleMouseSeek), mn), this.handleMouseUpHandler_ = e => this.handleMouseUp(e), this.handleMouseDownHandler_ = e => this.handleMouseDown(e), this.enable()
                }
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-progress-control vjs-control"
                    })
                }
                handleMouseMove(e) {
                    const t = this.getChild("seekBar");
                    if (!t) return;
                    const i = t.getChild("playProgressBar"),
                        n = t.getChild("mouseTimeDisplay");
                    if (!i && !n) return;
                    const r = t.el(),
                        s = Di(r);
                    let a = Oi(r, e).x;
                    a = ns(a, 0, 1), n && n.update(s, a), i && i.update(s, t.getProgress())
                }
                handleMouseSeek(e) {
                    const t = this.getChild("seekBar");
                    t && t.handleMouseMove(e)
                }
                enabled() {
                    return this.enabled_
                }
                disable() {
                    if (this.children().forEach((e => e.disable && e.disable())), this.enabled() && (this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.off(this.el_, "mousemove", this.handleMouseMove), this.removeListenersAddedOnMousedownAndTouchstart(), this.addClass("disabled"), this.enabled_ = !1, this.player_.scrubbing())) {
                        const e = this.getChild("seekBar");
                        this.player_.scrubbing(!1), e.videoWasPlaying && Jn(this.player_.play())
                    }
                }
                enable() {
                    this.children().forEach((e => e.enable && e.enable())), this.enabled() || (this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.on(this.el_, "mousemove", this.handleMouseMove), this.removeClass("disabled"), this.enabled_ = !0)
                }
                removeListenersAddedOnMousedownAndTouchstart() {
                    const e = this.el_.ownerDocument;
                    this.off(e, "mousemove", this.throttledHandleMouseSeek), this.off(e, "touchmove", this.throttledHandleMouseSeek), this.off(e, "mouseup", this.handleMouseUpHandler_), this.off(e, "touchend", this.handleMouseUpHandler_)
                }
                handleMouseDown(e) {
                    const t = this.el_.ownerDocument,
                        i = this.getChild("seekBar");
                    i && i.handleMouseDown(e), this.on(t, "mousemove", this.throttledHandleMouseSeek), this.on(t, "touchmove", this.throttledHandleMouseSeek), this.on(t, "mouseup", this.handleMouseUpHandler_), this.on(t, "touchend", this.handleMouseUpHandler_)
                }
                handleMouseUp(e) {
                    const t = this.getChild("seekBar");
                    t && t.handleMouseUp(e), this.removeListenersAddedOnMousedownAndTouchstart()
                }
            }
            cs.prototype.options_ = {
                children: ["seekBar"]
            }, Bn.registerComponent("ProgressControl", cs);
            class us extends Yr {
                constructor(e, t) {
                    super(e, t), this.on(e, ["enterpictureinpicture", "leavepictureinpicture"], (e => this.handlePictureInPictureChange(e))), this.on(e, ["disablepictureinpicturechanged", "loadedmetadata"], (e => this.handlePictureInPictureEnabledChange(e))), this.on(e, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], (() => {
                        "audio" === e.currentType().substring(0, 5) || e.audioPosterMode() || e.audioOnlyMode() ? (e.isInPictureInPicture() && e.exitPictureInPicture(), this.hide()) : this.show()
                    })), this.disable()
                }
                buildCSSClass() {
                    return `vjs-picture-in-picture-control ${super.buildCSSClass()}`
                }
                handlePictureInPictureEnabledChange() {
                    a().pictureInPictureEnabled && !1 === this.player_.disablePictureInPicture() ? this.enable() : this.disable()
                }
                handlePictureInPictureChange(e) {
                    this.player_.isInPictureInPicture() ? this.controlText("Exit Picture-in-Picture") : this.controlText("Picture-in-Picture"), this.handlePictureInPictureEnabledChange()
                }
                handleClick(e) {
                    this.player_.isInPictureInPicture() ? this.player_.exitPictureInPicture() : this.player_.requestPictureInPicture()
                }
            }
            us.prototype.controlText_ = "Picture-in-Picture", Bn.registerComponent("PictureInPictureToggle", us);
            class ds extends Yr {
                constructor(e, t) {
                    super(e, t), this.on(e, "fullscreenchange", (e => this.handleFullscreenChange(e))), !1 === a()[e.fsApi_.fullscreenEnabled] && this.disable()
                }
                buildCSSClass() {
                    return `vjs-fullscreen-control ${super.buildCSSClass()}`
                }
                handleFullscreenChange(e) {
                    this.player_.isFullscreen() ? this.controlText("Exit Fullscreen") : this.controlText("Fullscreen")
                }
                handleClick(e) {
                    this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen()
                }
            }
            ds.prototype.controlText_ = "Fullscreen", Bn.registerComponent("FullscreenToggle", ds);
            Bn.registerComponent("VolumeLevel", class extends Bn {
                createEl() {
                    const e = super.createEl("div", {
                        className: "vjs-volume-level"
                    });
                    return e.appendChild(super.createEl("span", {
                        className: "vjs-control-text"
                    })), e
                }
            });
            Bn.registerComponent("VolumeLevelTooltip", class extends Bn {
                constructor(e, t) {
                    super(e, t), this.update = yn(gn(this, this.update), mn)
                }
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-volume-tooltip"
                    }, {
                        "aria-hidden": "true"
                    })
                }
                update(e, t, i, n) {
                    if (!i) {
                        const i = ki(this.el_),
                            n = ki(this.player_.el()),
                            r = e.width * t;
                        if (!n || !i) return;
                        const s = e.left - n.left + r,
                            a = e.width - r + (n.right - e.right);
                        let o = i.width / 2;
                        s < o ? o += o - s : a < o && (o = a), o < 0 ? o = 0 : o > i.width && (o = i.width), this.el_.style.right = `-${o}px`
                    }
                    this.write(`${n}%`)
                }
                write(e) {
                    bi(this.el_, e)
                }
                updateVolume(e, t, i, n, r) {
                    this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", (() => {
                        this.update(e, t, i, n.toFixed(0)), r && r()
                    }))
                }
            });
            class ps extends Bn {
                constructor(e, t) {
                    super(e, t), this.update = yn(gn(this, this.update), mn)
                }
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-mouse-display"
                    })
                }
                update(e, t, i) {
                    const n = 100 * t;
                    this.getChild("volumeLevelTooltip").updateVolume(e, t, i, n, (() => {
                        i ? this.el_.style.bottom = e.height * t + "px" : this.el_.style.left = e.width * t + "px"
                    }))
                }
            }
            ps.prototype.options_ = {
                children: ["volumeLevelTooltip"]
            }, Bn.registerComponent("MouseVolumeLevelDisplay", ps);
            class fs extends ss {
                constructor(e, t) {
                    super(e, t), this.on("slideractive", (e => this.updateLastVolume_(e))), this.on(e, "volumechange", (e => this.updateARIAAttributes(e))), e.ready((() => this.updateARIAAttributes()))
                }
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-volume-bar vjs-slider-bar"
                    }, {
                        "aria-label": this.localize("Volume Level"),
                        "aria-live": "polite"
                    })
                }
                handleMouseDown(e) {
                    zi(e) && super.handleMouseDown(e)
                }
                handleMouseMove(e) {
                    const t = this.getChild("mouseVolumeLevelDisplay");
                    if (t) {
                        const i = this.el(),
                            n = ki(i),
                            r = this.vertical();
                        let s = Oi(i, e);
                        s = r ? s.y : s.x, s = ns(s, 0, 1), t.update(n, s, r)
                    }
                    zi(e) && (this.checkMuted(), this.player_.volume(this.calculateDistance(e)))
                }
                checkMuted() {
                    this.player_.muted() && this.player_.muted(!1)
                }
                getPercent() {
                    return this.player_.muted() ? 0 : this.player_.volume()
                }
                stepForward() {
                    this.checkMuted(), this.player_.volume(this.player_.volume() + .1)
                }
                stepBack() {
                    this.checkMuted(), this.player_.volume(this.player_.volume() - .1)
                }
                updateARIAAttributes(e) {
                    const t = this.player_.muted() ? 0 : this.volumeAsPercentage_();
                    this.el_.setAttribute("aria-valuenow", t), this.el_.setAttribute("aria-valuetext", t + "%")
                }
                volumeAsPercentage_() {
                    return Math.round(100 * this.player_.volume())
                }
                updateLastVolume_() {
                    const e = this.player_.volume();
                    this.one("sliderinactive", (() => {
                        0 === this.player_.volume() && this.player_.lastVolume_(e)
                    }))
                }
            }
            fs.prototype.options_ = {
                children: ["volumeLevel"],
                barName: "volumeLevel"
            }, ui || Jt || fs.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay"), fs.prototype.playerEvent = "volumechange", Bn.registerComponent("VolumeBar", fs);
            class ms extends Bn {
                constructor(e, t = {}) {
                    t.vertical = t.vertical || !1, (void 0 === t.volumeBar || Wt(t.volumeBar)) && (t.volumeBar = t.volumeBar || {}, t.volumeBar.vertical = t.vertical), super(e, t),
                        function(e, t) {
                            t.tech_ && !t.tech_.featuresVolumeControl && e.addClass("vjs-hidden"), e.on(t, "loadstart", (function() {
                                t.tech_.featuresVolumeControl ? e.removeClass("vjs-hidden") : e.addClass("vjs-hidden")
                            }))
                        }(this, e), this.throttledHandleMouseMove = yn(gn(this, this.handleMouseMove), mn), this.handleMouseUpHandler_ = e => this.handleMouseUp(e), this.on("mousedown", (e => this.handleMouseDown(e))), this.on("touchstart", (e => this.handleMouseDown(e))), this.on("mousemove", (e => this.handleMouseMove(e))), this.on(this.volumeBar, ["focus", "slideractive"], (() => {
                            this.volumeBar.addClass("vjs-slider-active"), this.addClass("vjs-slider-active"), this.trigger("slideractive")
                        })), this.on(this.volumeBar, ["blur", "sliderinactive"], (() => {
                            this.volumeBar.removeClass("vjs-slider-active"), this.removeClass("vjs-slider-active"), this.trigger("sliderinactive")
                        }))
                }
                createEl() {
                    let e = "vjs-volume-horizontal";
                    return this.options_.vertical && (e = "vjs-volume-vertical"), super.createEl("div", {
                        className: `vjs-volume-control vjs-control ${e}`
                    })
                }
                handleMouseDown(e) {
                    const t = this.el_.ownerDocument;
                    this.on(t, "mousemove", this.throttledHandleMouseMove), this.on(t, "touchmove", this.throttledHandleMouseMove), this.on(t, "mouseup", this.handleMouseUpHandler_), this.on(t, "touchend", this.handleMouseUpHandler_)
                }
                handleMouseUp(e) {
                    const t = this.el_.ownerDocument;
                    this.off(t, "mousemove", this.throttledHandleMouseMove), this.off(t, "touchmove", this.throttledHandleMouseMove), this.off(t, "mouseup", this.handleMouseUpHandler_), this.off(t, "touchend", this.handleMouseUpHandler_)
                }
                handleMouseMove(e) {
                    this.volumeBar.handleMouseMove(e)
                }
            }
            ms.prototype.options_ = {
                children: ["volumeBar"]
            }, Bn.registerComponent("VolumeControl", ms);
            class gs extends Yr {
                constructor(e, t) {
                    super(e, t),
                        function(e, t) {
                            t.tech_ && !t.tech_.featuresMuteControl && e.addClass("vjs-hidden"), e.on(t, "loadstart", (function() {
                                t.tech_.featuresMuteControl ? e.removeClass("vjs-hidden") : e.addClass("vjs-hidden")
                            }))
                        }(this, e), this.on(e, ["loadstart", "volumechange"], (e => this.update(e)))
                }
                buildCSSClass() {
                    return `vjs-mute-control ${super.buildCSSClass()}`
                }
                handleClick(e) {
                    const t = this.player_.volume(),
                        i = this.player_.lastVolume_();
                    if (0 === t) {
                        const e = i < .1 ? .1 : i;
                        this.player_.volume(e), this.player_.muted(!1)
                    } else this.player_.muted(!this.player_.muted())
                }
                update(e) {
                    this.updateIcon_(), this.updateControlText_()
                }
                updateIcon_() {
                    const e = this.player_.volume();
                    let t = 3;
                    ui && this.player_.tech_ && this.player_.tech_.el_ && this.player_.muted(this.player_.tech_.el_.muted), 0 === e || this.player_.muted() ? t = 0 : e < .33 ? t = 1 : e < .67 && (t = 2), Si(this.el_, [0, 1, 2, 3].reduce(((e, t) => e + `${t?" ":""}vjs-vol-${t}`), "")), wi(this.el_, `vjs-vol-${t}`)
                }
                updateControlText_() {
                    const e = this.player_.muted() || 0 === this.player_.volume() ? "Unmute" : "Mute";
                    this.controlText() !== e && this.controlText(e)
                }
            }
            gs.prototype.controlText_ = "Mute", Bn.registerComponent("MuteToggle", gs);
            class ys extends Bn {
                constructor(e, t = {}) {
                    void 0 !== t.inline ? t.inline = t.inline : t.inline = !0, (void 0 === t.volumeControl || Wt(t.volumeControl)) && (t.volumeControl = t.volumeControl || {}, t.volumeControl.vertical = !t.inline), super(e, t), this.handleKeyPressHandler_ = e => this.handleKeyPress(e), this.on(e, ["loadstart"], (e => this.volumePanelState_(e))), this.on(this.muteToggle, "keyup", (e => this.handleKeyPress(e))), this.on(this.volumeControl, "keyup", (e => this.handleVolumeControlKeyUp(e))), this.on("keydown", (e => this.handleKeyPress(e))), this.on("mouseover", (e => this.handleMouseOver(e))), this.on("mouseout", (e => this.handleMouseOut(e))), this.on(this.volumeControl, ["slideractive"], this.sliderActive_), this.on(this.volumeControl, ["sliderinactive"], this.sliderInactive_)
                }
                sliderActive_() {
                    this.addClass("vjs-slider-active")
                }
                sliderInactive_() {
                    this.removeClass("vjs-slider-active")
                }
                volumePanelState_() {
                    this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"), this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only")
                }
                createEl() {
                    let e = "vjs-volume-panel-horizontal";
                    return this.options_.inline || (e = "vjs-volume-panel-vertical"), super.createEl("div", {
                        className: `vjs-volume-panel vjs-control ${e}`
                    })
                }
                dispose() {
                    this.handleMouseOut(), super.dispose()
                }
                handleVolumeControlKeyUp(e) {
                    l().isEventKey(e, "Esc") && this.muteToggle.focus()
                }
                handleMouseOver(e) {
                    this.addClass("vjs-hover"), hn(a(), "keyup", this.handleKeyPressHandler_)
                }
                handleMouseOut(e) {
                    this.removeClass("vjs-hover"), cn(a(), "keyup", this.handleKeyPressHandler_)
                }
                handleKeyPress(e) {
                    l().isEventKey(e, "Esc") && this.handleMouseOut()
                }
            }
            ys.prototype.options_ = {
                children: ["muteToggle", "volumeControl"]
            }, Bn.registerComponent("VolumePanel", ys);
            class _s extends Bn {
                constructor(e, t) {
                    super(e, t), t && (this.menuButton_ = t.menuButton), this.focusedChild_ = -1, this.on("keydown", (e => this.handleKeyDown(e))), this.boundHandleBlur_ = e => this.handleBlur(e), this.boundHandleTapClick_ = e => this.handleTapClick(e)
                }
                addEventListenerForItem(e) {
                    e instanceof Bn && (this.on(e, "blur", this.boundHandleBlur_), this.on(e, ["tap", "click"], this.boundHandleTapClick_))
                }
                removeEventListenerForItem(e) {
                    e instanceof Bn && (this.off(e, "blur", this.boundHandleBlur_), this.off(e, ["tap", "click"], this.boundHandleTapClick_))
                }
                removeChild(e) {
                    "string" == typeof e && (e = this.getChild(e)), this.removeEventListenerForItem(e), super.removeChild(e)
                }
                addItem(e) {
                    const t = this.addChild(e);
                    t && this.addEventListenerForItem(t)
                }
                createEl() {
                    const e = this.options_.contentElType || "ul";
                    this.contentEl_ = vi(e, {
                        className: "vjs-menu-content"
                    }), this.contentEl_.setAttribute("role", "menu");
                    const t = super.createEl("div", {
                        append: this.contentEl_,
                        className: "vjs-menu"
                    });
                    return t.appendChild(this.contentEl_), hn(t, "click", (function(e) {
                        e.preventDefault(), e.stopImmediatePropagation()
                    })), t
                }
                dispose() {
                    this.contentEl_ = null, this.boundHandleBlur_ = null, this.boundHandleTapClick_ = null, super.dispose()
                }
                handleBlur(e) {
                    const t = e.relatedTarget || a().activeElement;
                    if (!this.children().some((e => e.el() === t))) {
                        const e = this.menuButton_;
                        e && e.buttonPressed_ && t !== e.el().firstChild && e.unpressButton()
                    }
                }
                handleTapClick(e) {
                    if (this.menuButton_) {
                        this.menuButton_.unpressButton();
                        const t = this.children();
                        if (!Array.isArray(t)) return;
                        const i = t.filter((t => t.el() === e.target))[0];
                        if (!i) return;
                        "CaptionSettingsMenuItem" !== i.name() && this.menuButton_.focus()
                    }
                }
                handleKeyDown(e) {
                    l().isEventKey(e, "Left") || l().isEventKey(e, "Down") ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : (l().isEventKey(e, "Right") || l().isEventKey(e, "Up")) && (e.preventDefault(), e.stopPropagation(), this.stepBack())
                }
                stepForward() {
                    let e = 0;
                    void 0 !== this.focusedChild_ && (e = this.focusedChild_ + 1), this.focus(e)
                }
                stepBack() {
                    let e = 0;
                    void 0 !== this.focusedChild_ && (e = this.focusedChild_ - 1), this.focus(e)
                }
                focus(e = 0) {
                    const t = this.children().slice();
                    t.length && t[0].hasClass("vjs-menu-title") && t.shift(), t.length > 0 && (e < 0 ? e = 0 : e >= t.length && (e = t.length - 1), this.focusedChild_ = e, t[e].el_.focus())
                }
            }
            Bn.registerComponent("Menu", _s);
            class vs extends Bn {
                constructor(e, t = {}) {
                    super(e, t), this.menuButton_ = new Yr(e, t), this.menuButton_.controlText(this.controlText_), this.menuButton_.el_.setAttribute("aria-haspopup", "true");
                    const i = Yr.prototype.buildCSSClass();
                    this.menuButton_.el_.className = this.buildCSSClass() + " " + i, this.menuButton_.removeClass("vjs-control"), this.addChild(this.menuButton_), this.update(), this.enabled_ = !0;
                    const n = e => this.handleClick(e);
                    this.handleMenuKeyUp_ = e => this.handleMenuKeyUp(e), this.on(this.menuButton_, "tap", n), this.on(this.menuButton_, "click", n), this.on(this.menuButton_, "keydown", (e => this.handleKeyDown(e))), this.on(this.menuButton_, "mouseenter", (() => {
                        this.addClass("vjs-hover"), this.menu.show(), hn(a(), "keyup", this.handleMenuKeyUp_)
                    })), this.on("mouseleave", (e => this.handleMouseLeave(e))), this.on("keydown", (e => this.handleSubmenuKeyDown(e)))
                }
                update() {
                    const e = this.createMenu();
                    this.menu && (this.menu.dispose(), this.removeChild(this.menu)), this.menu = e, this.addChild(e), this.buttonPressed_ = !1, this.menuButton_.el_.setAttribute("aria-expanded", "false"), this.items && this.items.length <= this.hideThreshold_ ? (this.hide(), this.menu.contentEl_.removeAttribute("role")) : (this.show(), this.menu.contentEl_.setAttribute("role", "menu"))
                }
                createMenu() {
                    const e = new _s(this.player_, {
                        menuButton: this
                    });
                    if (this.hideThreshold_ = 0, this.options_.title) {
                        const t = vi("li", {
                                className: "vjs-menu-title",
                                textContent: On(this.options_.title),
                                tabIndex: -1
                            }),
                            i = new Bn(this.player_, {
                                el: t
                            });
                        e.addItem(i)
                    }
                    if (this.items = this.createItems(), this.items)
                        for (let t = 0; t < this.items.length; t++) e.addItem(this.items[t]);
                    return e
                }
                createItems() {}
                createEl() {
                    return super.createEl("div", {
                        className: this.buildWrapperCSSClass()
                    }, {})
                }
                buildWrapperCSSClass() {
                    let e = "vjs-menu-button";
                    !0 === this.options_.inline ? e += "-inline" : e += "-popup";
                    return `vjs-menu-button ${e} ${Yr.prototype.buildCSSClass()} ${super.buildCSSClass()}`
                }
                buildCSSClass() {
                    let e = "vjs-menu-button";
                    return !0 === this.options_.inline ? e += "-inline" : e += "-popup", `vjs-menu-button ${e} ${super.buildCSSClass()}`
                }
                controlText(e, t = this.menuButton_.el()) {
                    return this.menuButton_.controlText(e, t)
                }
                dispose() {
                    this.handleMouseLeave(), super.dispose()
                }
                handleClick(e) {
                    this.buttonPressed_ ? this.unpressButton() : this.pressButton()
                }
                handleMouseLeave(e) {
                    this.removeClass("vjs-hover"), cn(a(), "keyup", this.handleMenuKeyUp_)
                }
                focus() {
                    this.menuButton_.focus()
                }
                blur() {
                    this.menuButton_.blur()
                }
                handleKeyDown(e) {
                    l().isEventKey(e, "Esc") || l().isEventKey(e, "Tab") ? (this.buttonPressed_ && this.unpressButton(), l().isEventKey(e, "Tab") || (e.preventDefault(), this.menuButton_.focus())) : (l().isEventKey(e, "Up") || l().isEventKey(e, "Down")) && (this.buttonPressed_ || (e.preventDefault(), this.pressButton()))
                }
                handleMenuKeyUp(e) {
                    (l().isEventKey(e, "Esc") || l().isEventKey(e, "Tab")) && this.removeClass("vjs-hover")
                }
                handleSubmenuKeyPress(e) {
                    this.handleSubmenuKeyDown(e)
                }
                handleSubmenuKeyDown(e) {
                    (l().isEventKey(e, "Esc") || l().isEventKey(e, "Tab")) && (this.buttonPressed_ && this.unpressButton(), l().isEventKey(e, "Tab") || (e.preventDefault(), this.menuButton_.focus()))
                }
                pressButton() {
                    if (this.enabled_) {
                        if (this.buttonPressed_ = !0, this.menu.show(), this.menu.lockShowing(), this.menuButton_.el_.setAttribute("aria-expanded", "true"), ui && yi()) return;
                        this.menu.focus()
                    }
                }
                unpressButton() {
                    this.enabled_ && (this.buttonPressed_ = !1, this.menu.unlockShowing(), this.menu.hide(), this.menuButton_.el_.setAttribute("aria-expanded", "false"))
                }
                disable() {
                    this.unpressButton(), this.enabled_ = !1, this.addClass("vjs-disabled"), this.menuButton_.disable()
                }
                enable() {
                    this.enabled_ = !0, this.removeClass("vjs-disabled"), this.menuButton_.enable()
                }
            }
            Bn.registerComponent("MenuButton", vs);
            class bs extends vs {
                constructor(e, t) {
                    const i = t.tracks;
                    if (super(e, t), this.items.length <= 1 && this.hide(), !i) return;
                    const n = gn(this, this.update);
                    i.addEventListener("removetrack", n), i.addEventListener("addtrack", n), i.addEventListener("labelchange", n), this.player_.on("ready", n), this.player_.on("dispose", (function() {
                        i.removeEventListener("removetrack", n), i.removeEventListener("addtrack", n), i.removeEventListener("labelchange", n)
                    }))
                }
            }
            Bn.registerComponent("TrackButton", bs);
            const Ts = ["Tab", "Esc", "Up", "Down", "Right", "Left"];
            class xs extends Vr {
                constructor(e, t) {
                    super(e, t), this.selectable = t.selectable, this.isSelected_ = t.selected || !1, this.multiSelectable = t.multiSelectable, this.selected(this.isSelected_), this.selectable ? this.multiSelectable ? this.el_.setAttribute("role", "menuitemcheckbox") : this.el_.setAttribute("role", "menuitemradio") : this.el_.setAttribute("role", "menuitem")
                }
                createEl(e, t, i) {
                    this.nonIconControl = !0;
                    const n = super.createEl("li", Object.assign({
                        className: "vjs-menu-item",
                        tabIndex: -1
                    }, t), i);
                    return n.replaceChild(vi("span", {
                        className: "vjs-menu-item-text",
                        textContent: this.localize(this.options_.label)
                    }), n.querySelector(".vjs-icon-placeholder")), n
                }
                handleKeyDown(e) {
                    Ts.some((t => l().isEventKey(e, t))) || super.handleKeyDown(e)
                }
                handleClick(e) {
                    this.selected(!0)
                }
                selected(e) {
                    this.selectable && (e ? (this.addClass("vjs-selected"), this.el_.setAttribute("aria-checked", "true"), this.controlText(", selected"), this.isSelected_ = !0) : (this.removeClass("vjs-selected"), this.el_.setAttribute("aria-checked", "false"), this.controlText(""), this.isSelected_ = !1))
                }
            }
            Bn.registerComponent("MenuItem", xs);
            class ws extends xs {
                constructor(e, t) {
                    const i = t.track,
                        n = e.textTracks();
                    t.label = i.label || i.language || "Unknown", t.selected = "showing" === i.mode, super(e, t), this.track = i, this.kinds = (t.kinds || [t.kind || this.track.kind]).filter(Boolean);
                    const s = (...e) => {
                            this.handleTracksChange.apply(this, e)
                        },
                        o = (...e) => {
                            this.handleSelectedLanguageChange.apply(this, e)
                        };
                    if (e.on(["loadstart", "texttrackchange"], s), n.addEventListener("change", s), n.addEventListener("selectedlanguagechange", o), this.on("dispose", (function() {
                            e.off(["loadstart", "texttrackchange"], s), n.removeEventListener("change", s), n.removeEventListener("selectedlanguagechange", o)
                        })), void 0 === n.onchange) {
                        let e;
                        this.on(["tap", "click"], (function() {
                            if ("object" != typeof r().Event) try {
                                e = new(r().Event)("change")
                            } catch (e) {}
                            e || (e = a().createEvent("Event"), e.initEvent("change", !0, !0)), n.dispatchEvent(e)
                        }))
                    }
                    this.handleTracksChange()
                }
                handleClick(e) {
                    const t = this.track,
                        i = this.player_.textTracks();
                    if (super.handleClick(e), i)
                        for (let e = 0; e < i.length; e++) {
                            const n = i[e]; - 1 !== this.kinds.indexOf(n.kind) && (n === t ? "showing" !== n.mode && (n.mode = "showing") : "disabled" !== n.mode && (n.mode = "disabled"))
                        }
                }
                handleTracksChange(e) {
                    const t = "showing" === this.track.mode;
                    t !== this.isSelected_ && this.selected(t)
                }
                handleSelectedLanguageChange(e) {
                    if ("showing" === this.track.mode) {
                        const e = this.player_.cache_.selectedLanguage;
                        if (e && e.enabled && e.language === this.track.language && e.kind !== this.track.kind) return;
                        this.player_.cache_.selectedLanguage = {
                            enabled: !0,
                            language: this.track.language,
                            kind: this.track.kind
                        }
                    }
                }
                dispose() {
                    this.track = null, super.dispose()
                }
            }
            Bn.registerComponent("TextTrackMenuItem", ws);
            class Ss extends ws {
                constructor(e, t) {
                    t.track = {
                        player: e,
                        kind: t.kind,
                        kinds: t.kinds,
                        default: !1,
                        mode: "disabled"
                    }, t.kinds || (t.kinds = [t.kind]), t.label ? t.track.label = t.label : t.track.label = t.kinds.join(" and ") + " off", t.selectable = !0, t.multiSelectable = !1, super(e, t)
                }
                handleTracksChange(e) {
                    const t = this.player().textTracks();
                    let i = !0;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        if (this.options_.kinds.indexOf(n.kind) > -1 && "showing" === n.mode) {
                            i = !1;
                            break
                        }
                    }
                    i !== this.isSelected_ && this.selected(i)
                }
                handleSelectedLanguageChange(e) {
                    const t = this.player().textTracks();
                    let i = !0;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        if (["captions", "descriptions", "subtitles"].indexOf(n.kind) > -1 && "showing" === n.mode) {
                            i = !1;
                            break
                        }
                    }
                    i && (this.player_.cache_.selectedLanguage = {
                        enabled: !1
                    })
                }
            }
            Bn.registerComponent("OffTextTrackMenuItem", Ss);
            class Es extends bs {
                constructor(e, t = {}) {
                    t.tracks = e.textTracks(), super(e, t)
                }
                createItems(e = [], t = ws) {
                    let i;
                    this.label_ && (i = `${this.label_} off`), e.push(new Ss(this.player_, {
                        kinds: this.kinds_,
                        kind: this.kind_,
                        label: i
                    })), this.hideThreshold_ += 1;
                    const n = this.player_.textTracks();
                    Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]);
                    for (let i = 0; i < n.length; i++) {
                        const r = n[i];
                        if (this.kinds_.indexOf(r.kind) > -1) {
                            const i = new t(this.player_, {
                                track: r,
                                kinds: this.kinds_,
                                kind: this.kind_,
                                selectable: !0,
                                multiSelectable: !1
                            });
                            i.addClass(`vjs-${r.kind}-menu-item`), e.push(i)
                        }
                    }
                    return e
                }
            }
            Bn.registerComponent("TextTrackButton", Es);
            class Ms extends xs {
                constructor(e, t) {
                    const i = t.track,
                        n = t.cue,
                        r = e.currentTime();
                    t.selectable = !0, t.multiSelectable = !1, t.label = n.text, t.selected = n.startTime <= r && r < n.endTime, super(e, t), this.track = i, this.cue = n
                }
                handleClick(e) {
                    super.handleClick(), this.player_.currentTime(this.cue.startTime)
                }
            }
            Bn.registerComponent("ChaptersTrackMenuItem", Ms);
            class Cs extends Es {
                constructor(e, t, i) {
                    super(e, t, i), this.selectCurrentItem_ = () => {
                        this.items.forEach((e => {
                            e.selected(this.track_.activeCues[0] === e.cue)
                        }))
                    }
                }
                buildCSSClass() {
                    return `vjs-chapters-button ${super.buildCSSClass()}`
                }
                buildWrapperCSSClass() {
                    return `vjs-chapters-button ${super.buildWrapperCSSClass()}`
                }
                update(e) {
                    if (e && e.track && "chapters" !== e.track.kind) return;
                    const t = this.findChaptersTrack();
                    t !== this.track_ ? (this.setTrack(t), super.update()) : (!this.items || t && t.cues && t.cues.length !== this.items.length) && super.update()
                }
                setTrack(e) {
                    if (this.track_ !== e) {
                        if (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)), this.track_) {
                            const e = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                            e && e.removeEventListener("load", this.updateHandler_), this.track_.removeEventListener("cuechange", this.selectCurrentItem_), this.track_ = null
                        }
                        if (this.track_ = e, this.track_) {
                            this.track_.mode = "hidden";
                            const e = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                            e && e.addEventListener("load", this.updateHandler_), this.track_.addEventListener("cuechange", this.selectCurrentItem_)
                        }
                    }
                }
                findChaptersTrack() {
                    const e = this.player_.textTracks() || [];
                    for (let t = e.length - 1; t >= 0; t--) {
                        const i = e[t];
                        if (i.kind === this.kind_) return i
                    }
                }
                getMenuCaption() {
                    return this.track_ && this.track_.label ? this.track_.label : this.localize(On(this.kind_))
                }
                createMenu() {
                    return this.options_.title = this.getMenuCaption(), super.createMenu()
                }
                createItems() {
                    const e = [];
                    if (!this.track_) return e;
                    const t = this.track_.cues;
                    if (!t) return e;
                    for (let i = 0, n = t.length; i < n; i++) {
                        const n = t[i],
                            r = new Ms(this.player_, {
                                track: this.track_,
                                cue: n
                            });
                        e.push(r)
                    }
                    return e
                }
            }
            Cs.prototype.kind_ = "chapters", Cs.prototype.controlText_ = "Chapters", Bn.registerComponent("ChaptersButton", Cs);
            class As extends Es {
                constructor(e, t, i) {
                    super(e, t, i);
                    const n = e.textTracks(),
                        r = gn(this, this.handleTracksChange);
                    n.addEventListener("change", r), this.on("dispose", (function() {
                        n.removeEventListener("change", r)
                    }))
                }
                handleTracksChange(e) {
                    const t = this.player().textTracks();
                    let i = !1;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        if (n.kind !== this.kind_ && "showing" === n.mode) {
                            i = !0;
                            break
                        }
                    }
                    i ? this.disable() : this.enable()
                }
                buildCSSClass() {
                    return `vjs-descriptions-button ${super.buildCSSClass()}`
                }
                buildWrapperCSSClass() {
                    return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`
                }
            }
            As.prototype.kind_ = "descriptions", As.prototype.controlText_ = "Descriptions", Bn.registerComponent("DescriptionsButton", As);
            class Ls extends Es {
                constructor(e, t, i) {
                    super(e, t, i)
                }
                buildCSSClass() {
                    return `vjs-subtitles-button ${super.buildCSSClass()}`
                }
                buildWrapperCSSClass() {
                    return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`
                }
            }
            Ls.prototype.kind_ = "subtitles", Ls.prototype.controlText_ = "Subtitles", Bn.registerComponent("SubtitlesButton", Ls);
            class Is extends ws {
                constructor(e, t) {
                    t.track = {
                        player: e,
                        kind: t.kind,
                        label: t.kind + " settings",
                        selectable: !1,
                        default: !1,
                        mode: "disabled"
                    }, t.selectable = !1, t.name = "CaptionSettingsMenuItem", super(e, t), this.addClass("vjs-texttrack-settings"), this.controlText(", opens " + t.kind + " settings dialog")
                }
                handleClick(e) {
                    this.player().getChild("textTrackSettings").open()
                }
            }
            Bn.registerComponent("CaptionSettingsMenuItem", Is);
            class Ps extends Es {
                constructor(e, t, i) {
                    super(e, t, i)
                }
                buildCSSClass() {
                    return `vjs-captions-button ${super.buildCSSClass()}`
                }
                buildWrapperCSSClass() {
                    return `vjs-captions-button ${super.buildWrapperCSSClass()}`
                }
                createItems() {
                    const e = [];
                    return this.player().tech_ && this.player().tech_.featuresNativeTextTracks || !this.player().getChild("textTrackSettings") || (e.push(new Is(this.player_, {
                        kind: this.kind_
                    })), this.hideThreshold_ += 1), super.createItems(e)
                }
            }
            Ps.prototype.kind_ = "captions", Ps.prototype.controlText_ = "Captions", Bn.registerComponent("CaptionsButton", Ps);
            class Rs extends ws {
                createEl(e, t, i) {
                    const n = super.createEl(e, t, i),
                        r = n.querySelector(".vjs-menu-item-text");
                    return "captions" === this.options_.track.kind && (r.appendChild(vi("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": !0
                    })), r.appendChild(vi("span", {
                        className: "vjs-control-text",
                        textContent: ` ${this.localize("Captions")}`
                    }))), n
                }
            }
            Bn.registerComponent("SubsCapsMenuItem", Rs);
            class ks extends Es {
                constructor(e, t = {}) {
                    super(e, t), this.label_ = "subtitles", ["en", "en-us", "en-ca", "fr-ca"].indexOf(this.player_.language_) > -1 && (this.label_ = "captions"), this.menuButton_.controlText(On(this.label_))
                }
                buildCSSClass() {
                    return `vjs-subs-caps-button ${super.buildCSSClass()}`
                }
                buildWrapperCSSClass() {
                    return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`
                }
                createItems() {
                    let e = [];
                    return this.player().tech_ && this.player().tech_.featuresNativeTextTracks || !this.player().getChild("textTrackSettings") || (e.push(new Is(this.player_, {
                        kind: this.label_
                    })), this.hideThreshold_ += 1), e = super.createItems(e, Rs), e
                }
            }
            ks.prototype.kinds_ = ["captions", "subtitles"], ks.prototype.controlText_ = "Subtitles", Bn.registerComponent("SubsCapsButton", ks);
            class Ds extends xs {
                constructor(e, t) {
                    const i = t.track,
                        n = e.audioTracks();
                    t.label = i.label || i.language || "Unknown", t.selected = i.enabled, super(e, t), this.track = i, this.addClass(`vjs-${i.kind}-menu-item`);
                    const r = (...e) => {
                        this.handleTracksChange.apply(this, e)
                    };
                    n.addEventListener("change", r), this.on("dispose", (() => {
                        n.removeEventListener("change", r)
                    }))
                }
                createEl(e, t, i) {
                    const n = super.createEl(e, t, i),
                        r = n.querySelector(".vjs-menu-item-text");
                    return "main-desc" === this.options_.track.kind && (r.appendChild(vi("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": !0
                    })), r.appendChild(vi("span", {
                        className: "vjs-control-text",
                        textContent: " " + this.localize("Descriptions")
                    }))), n
                }
                handleClick(e) {
                    if (super.handleClick(e), this.track.enabled = !0, this.player_.tech_.featuresNativeAudioTracks) {
                        const e = this.player_.audioTracks();
                        for (let t = 0; t < e.length; t++) {
                            const i = e[t];
                            i !== this.track && (i.enabled = i === this.track)
                        }
                    }
                }
                handleTracksChange(e) {
                    this.selected(this.track.enabled)
                }
            }
            Bn.registerComponent("AudioTrackMenuItem", Ds);
            class Os extends bs {
                constructor(e, t = {}) {
                    t.tracks = e.audioTracks(), super(e, t)
                }
                buildCSSClass() {
                    return `vjs-audio-button ${super.buildCSSClass()}`
                }
                buildWrapperCSSClass() {
                    return `vjs-audio-button ${super.buildWrapperCSSClass()}`
                }
                createItems(e = []) {
                    this.hideThreshold_ = 1;
                    const t = this.player_.audioTracks();
                    for (let i = 0; i < t.length; i++) {
                        const n = t[i];
                        e.push(new Ds(this.player_, {
                            track: n,
                            selectable: !0,
                            multiSelectable: !1
                        }))
                    }
                    return e
                }
            }
            Os.prototype.controlText_ = "Audio Track", Bn.registerComponent("AudioTrackButton", Os);
            class Ns extends xs {
                constructor(e, t) {
                    const i = t.rate,
                        n = parseFloat(i, 10);
                    t.label = i, t.selected = n === e.playbackRate(), t.selectable = !0, t.multiSelectable = !1, super(e, t), this.label = i, this.rate = n, this.on(e, "ratechange", (e => this.update(e)))
                }
                handleClick(e) {
                    super.handleClick(), this.player().playbackRate(this.rate)
                }
                update(e) {
                    this.selected(this.player().playbackRate() === this.rate)
                }
            }
            Ns.prototype.contentElType = "button", Bn.registerComponent("PlaybackRateMenuItem", Ns);
            class Us extends vs {
                constructor(e, t) {
                    super(e, t), this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_), this.updateVisibility(), this.updateLabel(), this.on(e, "loadstart", (e => this.updateVisibility(e))), this.on(e, "ratechange", (e => this.updateLabel(e))), this.on(e, "playbackrateschange", (e => this.handlePlaybackRateschange(e)))
                }
                createEl() {
                    const e = super.createEl();
                    return this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_, this.labelEl_ = vi("div", {
                        className: "vjs-playback-rate-value",
                        id: this.labelElId_,
                        textContent: "1x"
                    }), e.appendChild(this.labelEl_), e
                }
                dispose() {
                    this.labelEl_ = null, super.dispose()
                }
                buildCSSClass() {
                    return `vjs-playback-rate ${super.buildCSSClass()}`
                }
                buildWrapperCSSClass() {
                    return `vjs-playback-rate ${super.buildWrapperCSSClass()}`
                }
                createItems() {
                    const e = this.playbackRates(),
                        t = [];
                    for (let i = e.length - 1; i >= 0; i--) t.push(new Ns(this.player(), {
                        rate: e[i] + "x"
                    }));
                    return t
                }
                handlePlaybackRateschange(e) {
                    this.update()
                }
                playbackRates() {
                    const e = this.player();
                    return e.playbackRates && e.playbackRates() || []
                }
                playbackRateSupported() {
                    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0
                }
                updateVisibility(e) {
                    this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden")
                }
                updateLabel(e) {
                    this.playbackRateSupported() && (this.labelEl_.textContent = this.player().playbackRate() + "x")
                }
            }
            Us.prototype.controlText_ = "Playback Rate", Bn.registerComponent("PlaybackRateMenuButton", Us);
            class Bs extends Bn {
                buildCSSClass() {
                    return `vjs-spacer ${super.buildCSSClass()}`
                }
                createEl(e = "div", t = {}, i = {}) {
                    return t.className || (t.className = this.buildCSSClass()), super.createEl(e, t, i)
                }
            }
            Bn.registerComponent("Spacer", Bs);
            Bn.registerComponent("CustomControlSpacer", class extends Bs {
                buildCSSClass() {
                    return `vjs-custom-control-spacer ${super.buildCSSClass()}`
                }
                createEl() {
                    return super.createEl("div", {
                        className: this.buildCSSClass(),
                        textContent: " "
                    })
                }
            });
            class Fs extends Bn {
                createEl() {
                    return super.createEl("div", {
                        className: "vjs-control-bar",
                        dir: "ltr"
                    })
                }
            }
            Fs.prototype.options_ = {
                children: ["playToggle", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "fullscreenToggle"]
            }, "exitPictureInPicture" in a() && Fs.prototype.options_.children.splice(Fs.prototype.options_.children.length - 1, 0, "pictureInPictureToggle"), Bn.registerComponent("ControlBar", Fs);
            class Hs extends ir {
                constructor(e, t) {
                    super(e, t), this.on(e, "error", (e => this.open(e)))
                }
                buildCSSClass() {
                    return `vjs-error-display ${super.buildCSSClass()}`
                }
                content() {
                    const e = this.player().error();
                    return e ? this.localize(e.message) : ""
                }
            }
            Hs.prototype.options_ = Object.assign({}, ir.prototype.options_, {
                pauseOnOpen: !1,
                fillAlways: !0,
                temporary: !1,
                uncloseable: !0
            }), Bn.registerComponent("ErrorDisplay", Hs);
            const zs = "vjs-text-track-settings",
                Vs = ["#000", "Black"],
                Gs = ["#00F", "Blue"],
                Ws = ["#0FF", "Cyan"],
                js = ["#0F0", "Green"],
                qs = ["#F0F", "Magenta"],
                $s = ["#F00", "Red"],
                Xs = ["#FFF", "White"],
                Ys = ["#FF0", "Yellow"],
                Ks = ["1", "Opaque"],
                Js = ["0.5", "Semi-Transparent"],
                Zs = ["0", "Transparent"],
                Qs = {
                    backgroundColor: {
                        selector: ".vjs-bg-color > select",
                        id: "captions-background-color-%s",
                        label: "Color",
                        options: [Vs, Xs, $s, js, Gs, Ys, qs, Ws]
                    },
                    backgroundOpacity: {
                        selector: ".vjs-bg-opacity > select",
                        id: "captions-background-opacity-%s",
                        label: "Transparency",
                        options: [Ks, Js, Zs]
                    },
                    color: {
                        selector: ".vjs-fg-color > select",
                        id: "captions-foreground-color-%s",
                        label: "Color",
                        options: [Xs, Vs, $s, js, Gs, Ys, qs, Ws]
                    },
                    edgeStyle: {
                        selector: ".vjs-edge-style > select",
                        id: "%s",
                        label: "Text Edge Style",
                        options: [
                            ["none", "None"],
                            ["raised", "Raised"],
                            ["depressed", "Depressed"],
                            ["uniform", "Uniform"],
                            ["dropshadow", "Dropshadow"]
                        ]
                    },
                    fontFamily: {
                        selector: ".vjs-font-family > select",
                        id: "captions-font-family-%s",
                        label: "Font Family",
                        options: [
                            ["proportionalSansSerif", "Proportional Sans-Serif"],
                            ["monospaceSansSerif", "Monospace Sans-Serif"],
                            ["proportionalSerif", "Proportional Serif"],
                            ["monospaceSerif", "Monospace Serif"],
                            ["casual", "Casual"],
                            ["script", "Script"],
                            ["small-caps", "Small Caps"]
                        ]
                    },
                    fontPercent: {
                        selector: ".vjs-font-percent > select",
                        id: "captions-font-size-%s",
                        label: "Font Size",
                        options: [
                            ["0.50", "50%"],
                            ["0.75", "75%"],
                            ["1.00", "100%"],
                            ["1.25", "125%"],
                            ["1.50", "150%"],
                            ["1.75", "175%"],
                            ["2.00", "200%"],
                            ["3.00", "300%"],
                            ["4.00", "400%"]
                        ],
                        default: 2,
                        parser: e => "1.00" === e ? null : Number(e)
                    },
                    textOpacity: {
                        selector: ".vjs-text-opacity > select",
                        id: "captions-foreground-opacity-%s",
                        label: "Transparency",
                        options: [Ks, Js]
                    },
                    windowColor: {
                        selector: ".vjs-window-color > select",
                        id: "captions-window-color-%s",
                        label: "Color"
                    },
                    windowOpacity: {
                        selector: ".vjs-window-opacity > select",
                        id: "captions-window-opacity-%s",
                        label: "Transparency",
                        options: [Zs, Js, Ks]
                    }
                };

            function ea(e, t) {
                if (t && (e = t(e)), e && "none" !== e) return e
            }
            Qs.windowColor.options = Qs.backgroundColor.options;
            Bn.registerComponent("TextTrackSettings", class extends ir {
                constructor(e, t) {
                    t.temporary = !1, super(e, t), this.updateDisplay = this.updateDisplay.bind(this), this.fill(), this.hasBeenOpened_ = this.hasBeenFilled_ = !0, this.endDialog = vi("p", {
                        className: "vjs-control-text",
                        textContent: this.localize("End of dialog window.")
                    }), this.el().appendChild(this.endDialog), this.setDefaults(), void 0 === t.persistTextTrackSettings && (this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings), this.on(this.$(".vjs-done-button"), "click", (() => {
                        this.saveSettings(), this.close()
                    })), this.on(this.$(".vjs-default-button"), "click", (() => {
                        this.setDefaults(), this.updateDisplay()
                    })), zt(Qs, (e => {
                        this.on(this.$(e.selector), "change", this.updateDisplay)
                    })), this.options_.persistTextTrackSettings && this.restoreSettings()
                }
                dispose() {
                    this.endDialog = null, super.dispose()
                }
                createElSelect_(e, t = "", i = "label") {
                    const n = Qs[e],
                        r = n.id.replace("%s", this.id_),
                        s = [t, r].join(" ").trim();
                    return [`<${i} id="${r}" class="${"label"===i?"vjs-label":""}">`, this.localize(n.label), `</${i}>`, `<select aria-labelledby="${s}">`].concat(n.options.map((e => {
                        const t = r + "-" + e[1].replace(/\W+/g, "");
                        return [`<option id="${t}" value="${e[0]}" `, `aria-labelledby="${s} ${t}">`, this.localize(e[1]), "</option>"].join("")
                    }))).concat("</select>").join("")
                }
                createElFgColor_() {
                    const e = `captions-text-legend-${this.id_}`;
                    return ['<fieldset class="vjs-fg-color vjs-track-setting">', `<legend id="${e}">`, this.localize("Text"), "</legend>", this.createElSelect_("color", e), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", e), "</span>", "</fieldset>"].join("")
                }
                createElBgColor_() {
                    const e = `captions-background-${this.id_}`;
                    return ['<fieldset class="vjs-bg-color vjs-track-setting">', `<legend id="${e}">`, this.localize("Background"), "</legend>", this.createElSelect_("backgroundColor", e), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", e), "</span>", "</fieldset>"].join("")
                }
                createElWinColor_() {
                    const e = `captions-window-${this.id_}`;
                    return ['<fieldset class="vjs-window-color vjs-track-setting">', `<legend id="${e}">`, this.localize("Window"), "</legend>", this.createElSelect_("windowColor", e), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", e), "</span>", "</fieldset>"].join("")
                }
                createElColors_() {
                    return vi("div", {
                        className: "vjs-track-settings-colors",
                        innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("")
                    })
                }
                createElFont_() {
                    return vi("div", {
                        className: "vjs-track-settings-font",
                        innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("")
                    })
                }
                createElControls_() {
                    const e = this.localize("restore all settings to the default values");
                    return vi("div", {
                        className: "vjs-track-settings-controls",
                        innerHTML: [`<button type="button" class="vjs-default-button" title="${e}">`, this.localize("Reset"), `<span class="vjs-control-text"> ${e}</span>`, "</button>", `<button type="button" class="vjs-done-button">${this.localize("Done")}</button>`].join("")
                    })
                }
                content() {
                    return [this.createElColors_(), this.createElFont_(), this.createElControls_()]
                }
                label() {
                    return this.localize("Caption Settings Dialog")
                }
                description() {
                    return this.localize("Beginning of dialog window. Escape will cancel and close the window.")
                }
                buildCSSClass() {
                    return super.buildCSSClass() + " vjs-text-track-settings"
                }
                getValues() {
                    return Vt(Qs, ((e, t, i) => {
                        const n = (r = this.$(t.selector), s = t.parser, ea(r.options[r.options.selectedIndex].value, s));
                        var r, s;
                        return void 0 !== n && (e[i] = n), e
                    }), {})
                }
                setValues(e) {
                    zt(Qs, ((t, i) => {
                        ! function(e, t, i) {
                            if (t)
                                for (let n = 0; n < e.options.length; n++)
                                    if (ea(e.options[n].value, i) === t) {
                                        e.selectedIndex = n;
                                        break
                                    }
                        }(this.$(t.selector), e[i], t.parser)
                    }))
                }
                setDefaults() {
                    zt(Qs, (e => {
                        const t = e.hasOwnProperty("default") ? e.default : 0;
                        this.$(e.selector).selectedIndex = t
                    }))
                }
                restoreSettings() {
                    let e;
                    try {
                        e = JSON.parse(r().localStorage.getItem(zs))
                    } catch (e) {
                        Ut.warn(e)
                    }
                    e && this.setValues(e)
                }
                saveSettings() {
                    if (!this.options_.persistTextTrackSettings) return;
                    const e = this.getValues();
                    try {
                        Object.keys(e).length ? r().localStorage.setItem(zs, JSON.stringify(e)) : r().localStorage.removeItem(zs)
                    } catch (e) {
                        Ut.warn(e)
                    }
                }
                updateDisplay() {
                    const e = this.player_.getChild("textTrackDisplay");
                    e && e.updateDisplay()
                }
                conditionalBlur_() {
                    this.previouslyActiveEl_ = null;
                    const e = this.player_.controlBar,
                        t = e && e.subsCapsButton,
                        i = e && e.captionsButton;
                    t ? t.focus() : i && i.focus()
                }
            });
            Bn.registerComponent("ResizeManager", class extends Bn {
                constructor(e, t) {
                    let i = t.ResizeObserver || r().ResizeObserver;
                    null === t.ResizeObserver && (i = !1);
                    super(e, jt({
                        createEl: !i,
                        reportTouchActivity: !1
                    }, t)), this.ResizeObserver = t.ResizeObserver || r().ResizeObserver, this.loadListener_ = null, this.resizeObserver_ = null, this.debouncedHandler_ = _n((() => {
                        this.resizeHandler()
                    }), 100, !1, this), i ? (this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_), this.resizeObserver_.observe(e.el())) : (this.loadListener_ = () => {
                        if (!this.el_ || !this.el_.contentWindow) return;
                        const e = this.debouncedHandler_;
                        let t = this.unloadListener_ = function() {
                            cn(this, "resize", e), cn(this, "unload", t), t = null
                        };
                        hn(this.el_.contentWindow, "unload", t), hn(this.el_.contentWindow, "resize", e)
                    }, this.one("load", this.loadListener_))
                }
                createEl() {
                    return super.createEl("iframe", {
                        className: "vjs-resize-manager",
                        tabIndex: -1,
                        title: this.localize("No content")
                    }, {
                        "aria-hidden": "true"
                    })
                }
                resizeHandler() {
                    this.player_ && this.player_.trigger && this.player_.trigger("playerresize")
                }
                dispose() {
                    this.debouncedHandler_ && this.debouncedHandler_.cancel(), this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()), this.resizeObserver_.disconnect()), this.loadListener_ && this.off("load", this.loadListener_), this.el_ && this.el_.contentWindow && this.unloadListener_ && this.unloadListener_.call(this.el_.contentWindow), this.ResizeObserver = null, this.resizeObserver = null, this.debouncedHandler_ = null, this.loadListener_ = null, super.dispose()
                }
            });
            const ta = {
                trackingThreshold: 20,
                liveTolerance: 15
            };
            Bn.registerComponent("LiveTracker", class extends Bn {
                constructor(e, t) {
                    super(e, jt(ta, t, {
                        createEl: !1
                    })), this.trackLiveHandler_ = () => this.trackLive_(), this.handlePlay_ = e => this.handlePlay(e), this.handleFirstTimeupdate_ = e => this.handleFirstTimeupdate(e), this.handleSeeked_ = e => this.handleSeeked(e), this.seekToLiveEdge_ = e => this.seekToLiveEdge(e), this.reset_(), this.on(this.player_, "durationchange", (e => this.handleDurationchange(e))), this.on(this.player_, "canplay", (() => this.toggleTracking()))
                }
                trackLive_() {
                    const e = this.player_.seekable();
                    if (!e || !e.length) return;
                    const t = Number(r().performance.now().toFixed(4)),
                        i = -1 === this.lastTime_ ? 0 : (t - this.lastTime_) / 1e3;
                    this.lastTime_ = t, this.pastSeekEnd_ = this.pastSeekEnd() + i;
                    const n = this.liveCurrentTime(),
                        s = this.player_.currentTime();
                    let a = this.player_.paused() || this.seekedBehindLive_ || Math.abs(n - s) > this.options_.liveTolerance;
                    this.timeupdateSeen_ && n !== 1 / 0 || (a = !1), a !== this.behindLiveEdge_ && (this.behindLiveEdge_ = a, this.trigger("liveedgechange"))
                }
                handleDurationchange() {
                    this.toggleTracking()
                }
                toggleTracking() {
                    this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold ? (this.player_.options_.liveui && this.player_.addClass("vjs-liveui"), this.startTracking()) : (this.player_.removeClass("vjs-liveui"), this.stopTracking())
                }
                startTracking() {
                    this.isTracking() || (this.timeupdateSeen_ || (this.timeupdateSeen_ = this.player_.hasStarted()), this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, mn), this.trackLive_(), this.on(this.player_, ["play", "pause"], this.trackLiveHandler_), this.timeupdateSeen_ ? this.on(this.player_, "seeked", this.handleSeeked_) : (this.one(this.player_, "play", this.handlePlay_), this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_)))
                }
                handleFirstTimeupdate() {
                    this.timeupdateSeen_ = !0, this.on(this.player_, "seeked", this.handleSeeked_)
                }
                handleSeeked() {
                    const e = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
                    this.seekedBehindLive_ = this.nextSeekedFromUser_ && e > 2, this.nextSeekedFromUser_ = !1, this.trackLive_()
                }
                handlePlay() {
                    this.one(this.player_, "timeupdate", this.seekToLiveEdge_)
                }
                reset_() {
                    this.lastTime_ = -1, this.pastSeekEnd_ = 0, this.lastSeekEnd_ = -1, this.behindLiveEdge_ = !0, this.timeupdateSeen_ = !1, this.seekedBehindLive_ = !1, this.nextSeekedFromUser_ = !1, this.clearInterval(this.trackingInterval_), this.trackingInterval_ = null, this.off(this.player_, ["play", "pause"], this.trackLiveHandler_), this.off(this.player_, "seeked", this.handleSeeked_), this.off(this.player_, "play", this.handlePlay_), this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_), this.off(this.player_, "timeupdate", this.seekToLiveEdge_)
                }
                nextSeekedFromUser() {
                    this.nextSeekedFromUser_ = !0
                }
                stopTracking() {
                    this.isTracking() && (this.reset_(), this.trigger("liveedgechange"))
                }
                seekableEnd() {
                    const e = this.player_.seekable(),
                        t = [];
                    let i = e ? e.length : 0;
                    for (; i--;) t.push(e.end(i));
                    return t.length ? t.sort()[t.length - 1] : 1 / 0
                }
                seekableStart() {
                    const e = this.player_.seekable(),
                        t = [];
                    let i = e ? e.length : 0;
                    for (; i--;) t.push(e.start(i));
                    return t.length ? t.sort()[0] : 0
                }
                liveWindow() {
                    const e = this.liveCurrentTime();
                    return e === 1 / 0 ? 0 : e - this.seekableStart()
                }
                isLive() {
                    return this.isTracking()
                }
                atLiveEdge() {
                    return !this.behindLiveEdge()
                }
                liveCurrentTime() {
                    return this.pastSeekEnd() + this.seekableEnd()
                }
                pastSeekEnd() {
                    const e = this.seekableEnd();
                    return -1 !== this.lastSeekEnd_ && e !== this.lastSeekEnd_ && (this.pastSeekEnd_ = 0), this.lastSeekEnd_ = e, this.pastSeekEnd_
                }
                behindLiveEdge() {
                    return this.behindLiveEdge_
                }
                isTracking() {
                    return "number" == typeof this.trackingInterval_
                }
                seekToLiveEdge() {
                    this.seekedBehindLive_ = !1, this.atLiveEdge() || (this.nextSeekedFromUser_ = !1, this.player_.currentTime(this.liveCurrentTime()))
                }
                dispose() {
                    this.stopTracking(), super.dispose()
                }
            });
            Bn.registerComponent("TitleBar", class extends Bn {
                constructor(e, t) {
                    super(e, t), this.on("statechanged", (e => this.updateDom_())), this.updateDom_()
                }
                createEl() {
                    return this.els = {
                        title: vi("div", {
                            className: "vjs-title-bar-title",
                            id: `vjs-title-bar-title-${nn()}`
                        }),
                        description: vi("div", {
                            className: "vjs-title-bar-description",
                            id: `vjs-title-bar-description-${nn()}`
                        })
                    }, vi("div", {
                        className: "vjs-title-bar"
                    }, {}, Object.values(this.els))
                }
                updateDom_() {
                    const e = this.player_.tech_,
                        t = e && e.el_,
                        i = {
                            title: "aria-labelledby",
                            description: "aria-describedby"
                        };
                    ["title", "description"].forEach((e => {
                        const n = this.state[e],
                            r = this.els[e],
                            s = i[e];
                        Ui(r), n && bi(r, n), t && (t.removeAttribute(s), n && t.setAttribute(s, r.id))
                    })), this.state.title || this.state.description ? this.show() : this.hide()
                }
                update(e) {
                    this.setState(e)
                }
                dispose() {
                    const e = this.player_.tech_,
                        t = e && e.el_;
                    t && (t.removeAttribute("aria-labelledby"), t.removeAttribute("aria-describedby")), super.dispose(), this.els = null
                }
            });
            const ia = e => {
                    const t = e.el();
                    if (t.hasAttribute("src")) return e.triggerSourceset(t.src), !0;
                    const i = e.$$("source"),
                        n = [];
                    let r = "";
                    if (!i.length) return !1;
                    for (let e = 0; e < i.length; e++) {
                        const t = i[e].src;
                        t && -1 === n.indexOf(t) && n.push(t)
                    }
                    return !!n.length && (1 === n.length && (r = n[0]), e.triggerSourceset(r), !0)
                },
                na = Object.defineProperty({}, "innerHTML", {
                    get() {
                        return this.cloneNode(!0).innerHTML
                    },
                    set(e) {
                        const t = a().createElement(this.nodeName.toLowerCase());
                        t.innerHTML = e;
                        const i = a().createDocumentFragment();
                        for (; t.childNodes.length;) i.appendChild(t.childNodes[0]);
                        return this.innerText = "", r().Element.prototype.appendChild.call(this, i), this.innerHTML
                    }
                }),
                ra = (e, t) => {
                    let i = {};
                    for (let n = 0; n < e.length && (i = Object.getOwnPropertyDescriptor(e[n], t), !(i && i.set && i.get)); n++);
                    return i.enumerable = !0, i.configurable = !0, i
                },
                sa = function(e) {
                    const t = e.el();
                    if (t.resetSourceWatch_) return;
                    const i = {},
                        n = (e => ra([e.el(), r().HTMLMediaElement.prototype, r().Element.prototype, na], "innerHTML"))(e),
                        s = i => (...n) => {
                            const r = i.apply(t, n);
                            return ia(e), r
                        };
                    ["append", "appendChild", "insertAdjacentHTML"].forEach((e => {
                        t[e] && (i[e] = t[e], t[e] = s(i[e]))
                    })), Object.defineProperty(t, "innerHTML", jt(n, {
                        set: s(n.set)
                    })), t.resetSourceWatch_ = () => {
                        t.resetSourceWatch_ = null, Object.keys(i).forEach((e => {
                            t[e] = i[e]
                        })), Object.defineProperty(t, "innerHTML", n)
                    }, e.one("sourceset", t.resetSourceWatch_)
                },
                aa = Object.defineProperty({}, "src", {
                    get() {
                        return this.hasAttribute("src") ? fr(r().Element.prototype.getAttribute.call(this, "src")) : ""
                    },
                    set(e) {
                        return r().Element.prototype.setAttribute.call(this, "src", e), e
                    }
                }),
                oa = function(e) {
                    if (!e.featuresSourceset) return;
                    const t = e.el();
                    if (t.resetSourceset_) return;
                    const i = (e => ra([e.el(), r().HTMLMediaElement.prototype, aa], "src"))(e),
                        n = t.setAttribute,
                        s = t.load;
                    Object.defineProperty(t, "src", jt(i, {
                        set: n => {
                            const r = i.set.call(t, n);
                            return e.triggerSourceset(t.src), r
                        }
                    })), t.setAttribute = (i, r) => {
                        const s = n.call(t, i, r);
                        return /src/i.test(i) && e.triggerSourceset(t.src), s
                    }, t.load = () => {
                        const i = s.call(t);
                        return ia(e) || (e.triggerSourceset(""), sa(e)), i
                    }, t.currentSrc ? e.triggerSourceset(t.currentSrc) : ia(e) || sa(e), t.resetSourceset_ = () => {
                        t.resetSourceset_ = null, t.load = s, t.setAttribute = n, Object.defineProperty(t, "src", i), t.resetSourceWatch_ && t.resetSourceWatch_()
                    }
                };
            class la extends Cr {
                constructor(e, t) {
                    super(e, t);
                    const i = e.source;
                    let n = !1;
                    if (this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && "VIDEO" === this.el_.tagName, i && (this.el_.currentSrc !== i.src || e.tag && 3 === e.tag.initNetworkState_) ? this.setSource(i) : this.handleLateInit_(this.el_), e.enableSourceset && this.setupSourcesetHandling_(), this.isScrubbing_ = !1, this.el_.hasChildNodes()) {
                        const e = this.el_.childNodes;
                        let t = e.length;
                        const i = [];
                        for (; t--;) {
                            const r = e[t];
                            "track" === r.nodeName.toLowerCase() && (this.featuresNativeTextTracks ? (this.remoteTextTrackEls().addTrackElement_(r), this.remoteTextTracks().addTrack(r.track), this.textTracks().addTrack(r.track), n || this.el_.hasAttribute("crossorigin") || !gr(r.src) || (n = !0)) : i.push(r))
                        }
                        for (let e = 0; e < i.length; e++) this.el_.removeChild(i[e])
                    }
                    this.proxyNativeTracks_(), this.featuresNativeTextTracks && n && Ut.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading."), this.restoreMetadataTracksInIOSNativePlayer_(), (hi || li) && !0 === e.nativeControlsForTouch && this.setControls(!0), this.proxyWebkitFullscreen_(), this.triggerReady()
                }
                dispose() {
                    this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(), la.disposeMediaElement(this.el_), this.options_ = null, super.dispose()
                }
                setupSourcesetHandling_() {
                    oa(this)
                }
                restoreMetadataTracksInIOSNativePlayer_() {
                    const e = this.textTracks();
                    let t;
                    const i = () => {
                        t = [];
                        for (let i = 0; i < e.length; i++) {
                            const n = e[i];
                            "metadata" === n.kind && t.push({
                                track: n,
                                storedMode: n.mode
                            })
                        }
                    };
                    i(), e.addEventListener("change", i), this.on("dispose", (() => e.removeEventListener("change", i)));
                    const n = () => {
                        for (let e = 0; e < t.length; e++) {
                            const i = t[e];
                            "disabled" === i.track.mode && i.track.mode !== i.storedMode && (i.track.mode = i.storedMode)
                        }
                        e.removeEventListener("change", n)
                    };
                    this.on("webkitbeginfullscreen", (() => {
                        e.removeEventListener("change", i), e.removeEventListener("change", n), e.addEventListener("change", n)
                    })), this.on("webkitendfullscreen", (() => {
                        e.removeEventListener("change", i), e.addEventListener("change", i), e.removeEventListener("change", n)
                    }))
                }
                overrideNative_(e, t) {
                    if (t !== this[`featuresNative${e}Tracks`]) return;
                    const i = e.toLowerCase();
                    this[`${i}TracksListeners_`] && Object.keys(this[`${i}TracksListeners_`]).forEach((e => {
                        this.el()[`${i}Tracks`].removeEventListener(e, this[`${i}TracksListeners_`][e])
                    })), this[`featuresNative${e}Tracks`] = !t, this[`${i}TracksListeners_`] = null, this.proxyNativeTracksForType_(i)
                }
                overrideNativeAudioTracks(e) {
                    this.overrideNative_("Audio", e)
                }
                overrideNativeVideoTracks(e) {
                    this.overrideNative_("Video", e)
                }
                proxyNativeTracksForType_(e) {
                    const t = Sr[e],
                        i = this.el()[t.getterName],
                        n = this[t.getterName]();
                    if (!this[`featuresNative${t.capitalName}Tracks`] || !i || !i.addEventListener) return;
                    const r = {
                            change: t => {
                                const i = {
                                    type: "change",
                                    target: n,
                                    currentTarget: n,
                                    srcElement: n
                                };
                                n.trigger(i), "text" === e && this[Er.remoteText.getterName]().trigger(i)
                            },
                            addtrack(e) {
                                n.addTrack(e.track)
                            },
                            removetrack(e) {
                                n.removeTrack(e.track)
                            }
                        },
                        s = function() {
                            const e = [];
                            for (let t = 0; t < n.length; t++) {
                                let r = !1;
                                for (let e = 0; e < i.length; e++)
                                    if (i[e] === n[t]) {
                                        r = !0;
                                        break
                                    }
                                r || e.push(n[t])
                            }
                            for (; e.length;) n.removeTrack(e.shift())
                        };
                    this[t.getterName + "Listeners_"] = r, Object.keys(r).forEach((e => {
                        const t = r[e];
                        i.addEventListener(e, t), this.on("dispose", (n => i.removeEventListener(e, t)))
                    })), this.on("loadstart", s), this.on("dispose", (e => this.off("loadstart", s)))
                }
                proxyNativeTracks_() {
                    Sr.names.forEach((e => {
                        this.proxyNativeTracksForType_(e)
                    }))
                }
                createEl() {
                    let e = this.options_.tag;
                    if (!e || !this.options_.playerElIngest && !this.movingMediaElementInDOM) {
                        if (e) {
                            const t = e.cloneNode(!0);
                            e.parentNode && e.parentNode.insertBefore(t, e), la.disposeMediaElement(e), e = t
                        } else {
                            e = a().createElement("video");
                            const t = jt({}, this.options_.tag && Ci(this.options_.tag));
                            hi && !0 === this.options_.nativeControlsForTouch || delete t.controls, Mi(e, Object.assign(t, {
                                id: this.options_.techId,
                                class: "vjs-tech"
                            }))
                        }
                        e.playerId = this.options_.playerId
                    }
                    void 0 !== this.options_.preload && Li(e, "preload", this.options_.preload), void 0 !== this.options_.disablePictureInPicture && (e.disablePictureInPicture = this.options_.disablePictureInPicture);
                    const t = ["loop", "muted", "playsinline", "autoplay"];
                    for (let i = 0; i < t.length; i++) {
                        const n = t[i],
                            r = this.options_[n];
                        void 0 !== r && (r ? Li(e, n, n) : Ii(e, n), e[n] = r)
                    }
                    return e
                }
                handleLateInit_(e) {
                    if (0 === e.networkState || 3 === e.networkState) return;
                    if (0 === e.readyState) {
                        let e = !1;
                        const t = function() {
                            e = !0
                        };
                        this.on("loadstart", t);
                        const i = function() {
                            e || this.trigger("loadstart")
                        };
                        return this.on("loadedmetadata", i), void this.ready((function() {
                            this.off("loadstart", t), this.off("loadedmetadata", i), e || this.trigger("loadstart")
                        }))
                    }
                    const t = ["loadstart"];
                    t.push("loadedmetadata"), e.readyState >= 2 && t.push("loadeddata"), e.readyState >= 3 && t.push("canplay"), e.readyState >= 4 && t.push("canplaythrough"), this.ready((function() {
                        t.forEach((function(e) {
                            this.trigger(e)
                        }), this)
                    }))
                }
                setScrubbing(e) {
                    this.isScrubbing_ = e
                }
                scrubbing() {
                    return this.isScrubbing_
                }
                setCurrentTime(e) {
                    try {
                        this.isScrubbing_ && this.el_.fastSeek && di ? this.el_.fastSeek(e) : this.el_.currentTime = e
                    } catch (e) {
                        Ut(e, "Video is not ready. (Video.js)")
                    }
                }
                duration() {
                    if (this.el_.duration === 1 / 0 && Jt && ti && 0 === this.el_.currentTime) {
                        const e = () => {
                            this.el_.currentTime > 0 && (this.el_.duration === 1 / 0 && this.trigger("durationchange"), this.off("timeupdate", e))
                        };
                        return this.on("timeupdate", e), NaN
                    }
                    return this.el_.duration || NaN
                }
                width() {
                    return this.el_.offsetWidth
                }
                height() {
                    return this.el_.offsetHeight
                }
                proxyWebkitFullscreen_() {
                    if (!("webkitDisplayingFullscreen" in this.el_)) return;
                    const e = function() {
                            this.trigger("fullscreenchange", {
                                isFullscreen: !1
                            }), this.el_.controls && !this.options_.nativeControlsForTouch && this.controls() && (this.el_.controls = !1)
                        },
                        t = function() {
                            "webkitPresentationMode" in this.el_ && "picture-in-picture" !== this.el_.webkitPresentationMode && (this.one("webkitendfullscreen", e), this.trigger("fullscreenchange", {
                                isFullscreen: !0,
                                nativeIOSFullscreen: !0
                            }))
                        };
                    this.on("webkitbeginfullscreen", t), this.on("dispose", (() => {
                        this.off("webkitbeginfullscreen", t), this.off("webkitendfullscreen", e)
                    }))
                }
                supportsFullScreen() {
                    return "function" == typeof this.el_.webkitEnterFullScreen
                }
                enterFullScreen() {
                    const e = this.el_;
                    if (e.paused && e.networkState <= e.HAVE_METADATA) Jn(this.el_.play()), this.setTimeout((function() {
                        e.pause();
                        try {
                            e.webkitEnterFullScreen()
                        } catch (e) {
                            this.trigger("fullscreenerror", e)
                        }
                    }), 0);
                    else try {
                        e.webkitEnterFullScreen()
                    } catch (e) {
                        this.trigger("fullscreenerror", e)
                    }
                }
                exitFullScreen() {
                    this.el_.webkitDisplayingFullscreen ? this.el_.webkitExitFullScreen() : this.trigger("fullscreenerror", new Error("The video is not fullscreen"))
                }
                requestPictureInPicture() {
                    return this.el_.requestPictureInPicture()
                }
                requestVideoFrameCallback(e) {
                    return this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.requestVideoFrameCallback(e) : super.requestVideoFrameCallback(e)
                }
                cancelVideoFrameCallback(e) {
                    this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.cancelVideoFrameCallback(e) : super.cancelVideoFrameCallback(e)
                }
                src(e) {
                    if (void 0 === e) return this.el_.src;
                    this.setSrc(e)
                }
                reset() {
                    la.resetMediaElement(this.el_)
                }
                currentSrc() {
                    return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc
                }
                setControls(e) {
                    this.el_.controls = !!e
                }
                addTextTrack(e, t, i) {
                    return this.featuresNativeTextTracks ? this.el_.addTextTrack(e, t, i) : super.addTextTrack(e, t, i)
                }
                createRemoteTextTrack(e) {
                    if (!this.featuresNativeTextTracks) return super.createRemoteTextTrack(e);
                    const t = a().createElement("track");
                    return e.kind && (t.kind = e.kind), e.label && (t.label = e.label), (e.language || e.srclang) && (t.srclang = e.language || e.srclang), e.default && (t.default = e.default), e.id && (t.id = e.id), e.src && (t.src = e.src), t
                }
                addRemoteTextTrack(e, t) {
                    const i = super.addRemoteTextTrack(e, t);
                    return this.featuresNativeTextTracks && this.el().appendChild(i), i
                }
                removeRemoteTextTrack(e) {
                    if (super.removeRemoteTextTrack(e), this.featuresNativeTextTracks) {
                        const t = this.$$("track");
                        let i = t.length;
                        for (; i--;) e !== t[i] && e !== t[i].track || this.el().removeChild(t[i])
                    }
                }
                getVideoPlaybackQuality() {
                    if ("function" == typeof this.el().getVideoPlaybackQuality) return this.el().getVideoPlaybackQuality();
                    const e = {};
                    return void 0 !== this.el().webkitDroppedFrameCount && void 0 !== this.el().webkitDecodedFrameCount && (e.droppedVideoFrames = this.el().webkitDroppedFrameCount, e.totalVideoFrames = this.el().webkitDecodedFrameCount), r().performance && (e.creationTime = r().performance.now()), e
                }
            }
            qt(la, "TEST_VID", (function() {
                if (!mi()) return;
                const e = a().createElement("video"),
                    t = a().createElement("track");
                return t.kind = "captions", t.srclang = "en", t.label = "English", e.appendChild(t), e
            })), la.isSupported = function() {
                try {
                    la.TEST_VID.volume = .5
                } catch (e) {
                    return !1
                }
                return !(!la.TEST_VID || !la.TEST_VID.canPlayType)
            }, la.canPlayType = function(e) {
                return la.TEST_VID.canPlayType(e)
            }, la.canPlaySource = function(e, t) {
                return la.canPlayType(e.type)
            }, la.canControlVolume = function() {
                try {
                    const e = la.TEST_VID.volume;
                    la.TEST_VID.volume = e / 2 + .1;
                    const t = e !== la.TEST_VID.volume;
                    return t && ui ? (r().setTimeout((() => {
                        la && la.prototype && (la.prototype.featuresVolumeControl = e !== la.TEST_VID.volume)
                    })), !1) : t
                } catch (e) {
                    return !1
                }
            }, la.canMuteVolume = function() {
                try {
                    const e = la.TEST_VID.muted;
                    return la.TEST_VID.muted = !e, la.TEST_VID.muted ? Li(la.TEST_VID, "muted", "muted") : Ii(la.TEST_VID, "muted"), e !== la.TEST_VID.muted
                } catch (e) {
                    return !1
                }
            }, la.canControlPlaybackRate = function() {
                if (Jt && ti && ni < 58) return !1;
                try {
                    const e = la.TEST_VID.playbackRate;
                    return la.TEST_VID.playbackRate = e / 2 + .1, e !== la.TEST_VID.playbackRate
                } catch (e) {
                    return !1
                }
            }, la.canOverrideAttributes = function() {
                try {
                    const e = () => {};
                    Object.defineProperty(a().createElement("video"), "src", {
                        get: e,
                        set: e
                    }), Object.defineProperty(a().createElement("audio"), "src", {
                        get: e,
                        set: e
                    }), Object.defineProperty(a().createElement("video"), "innerHTML", {
                        get: e,
                        set: e
                    }), Object.defineProperty(a().createElement("audio"), "innerHTML", {
                        get: e,
                        set: e
                    })
                } catch (e) {
                    return !1
                }
                return !0
            }, la.supportsNativeTextTracks = function() {
                return di || ui && ti
            }, la.supportsNativeVideoTracks = function() {
                return !(!la.TEST_VID || !la.TEST_VID.videoTracks)
            }, la.supportsNativeAudioTracks = function() {
                return !(!la.TEST_VID || !la.TEST_VID.audioTracks)
            }, la.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"], [
                ["featuresMuteControl", "canMuteVolume"],
                ["featuresPlaybackRate", "canControlPlaybackRate"],
                ["featuresSourceset", "canOverrideAttributes"],
                ["featuresNativeTextTracks", "supportsNativeTextTracks"],
                ["featuresNativeVideoTracks", "supportsNativeVideoTracks"],
                ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]
            ].forEach((function([e, t]) {
                qt(la.prototype, e, (() => la[t]()), !0)
            })), la.prototype.featuresVolumeControl = la.canControlVolume(), la.prototype.movingMediaElementInDOM = !ui, la.prototype.featuresFullscreenResize = !0, la.prototype.featuresProgressEvents = !0, la.prototype.featuresTimeupdateEvents = !0, la.prototype.featuresVideoFrameCallback = !(!la.TEST_VID || !la.TEST_VID.requestVideoFrameCallback), la.disposeMediaElement = function(e) {
                if (e) {
                    for (e.parentNode && e.parentNode.removeChild(e); e.hasChildNodes();) e.removeChild(e.firstChild);
                    e.removeAttribute("src"), "function" == typeof e.load && function() {
                        try {
                            e.load()
                        } catch (e) {}
                    }()
                }
            }, la.resetMediaElement = function(e) {
                if (!e) return;
                const t = e.querySelectorAll("source");
                let i = t.length;
                for (; i--;) e.removeChild(t[i]);
                e.removeAttribute("src"), "function" == typeof e.load && function() {
                    try {
                        e.load()
                    } catch (e) {}
                }()
            }, ["muted", "defaultMuted", "autoplay", "controls", "loop", "playsinline"].forEach((function(e) {
                la.prototype[e] = function() {
                    return this.el_[e] || this.el_.hasAttribute(e)
                }
            })), ["muted", "defaultMuted", "autoplay", "loop", "playsinline"].forEach((function(e) {
                la.prototype["set" + On(e)] = function(t) {
                    this.el_[e] = t, t ? this.el_.setAttribute(e, e) : this.el_.removeAttribute(e)
                }
            })), ["paused", "currentTime", "buffered", "volume", "poster", "preload", "error", "seeking", "seekable", "ended", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "played", "networkState", "readyState", "videoWidth", "videoHeight", "crossOrigin"].forEach((function(e) {
                la.prototype[e] = function() {
                    return this.el_[e]
                }
            })), ["volume", "src", "poster", "preload", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "crossOrigin"].forEach((function(e) {
                la.prototype["set" + On(e)] = function(t) {
                    this.el_[e] = t
                }
            })), ["pause", "load", "play"].forEach((function(e) {
                la.prototype[e] = function() {
                    return this.el_[e]()
                }
            })), Cr.withSourceHandlers(la), la.nativeSourceHandler = {}, la.nativeSourceHandler.canPlayType = function(e) {
                try {
                    return la.TEST_VID.canPlayType(e)
                } catch (e) {
                    return ""
                }
            }, la.nativeSourceHandler.canHandleSource = function(e, t) {
                if (e.type) return la.nativeSourceHandler.canPlayType(e.type);
                if (e.src) {
                    const t = mr(e.src);
                    return la.nativeSourceHandler.canPlayType(`video/${t}`)
                }
                return ""
            }, la.nativeSourceHandler.handleSource = function(e, t, i) {
                t.setSrc(e.src)
            }, la.nativeSourceHandler.dispose = function() {}, la.registerSourceHandler(la.nativeSourceHandler), Cr.registerTech("Html5", la);
            const ha = ["progress", "abort", "suspend", "emptied", "stalled", "loadedmetadata", "loadeddata", "timeupdate", "resize", "volumechange", "texttrackchange"],
                ca = {
                    canplay: "CanPlay",
                    canplaythrough: "CanPlayThrough",
                    playing: "Playing",
                    seeked: "Seeked"
                },
                ua = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"],
                da = {};
            ua.forEach((e => {
                const t = "x" === e.charAt(0) ? `x-${e.substring(1)}` : e;
                da[e] = `vjs-layout-${t}`
            }));
            const pa = {
                tiny: 210,
                xsmall: 320,
                small: 425,
                medium: 768,
                large: 1440,
                xlarge: 2560,
                huge: 1 / 0
            };
            class fa extends Bn {
                constructor(e, t, i) {
                    if (e.id = e.id || t.id || `vjs_video_${nn()}`, (t = Object.assign(fa.getTagSettings(e), t)).initChildren = !1, t.createEl = !1, t.evented = !1, t.reportTouchActivity = !1, !t.language) {
                        const i = e.closest("[lang]");
                        i && (t.language = i.getAttribute("lang"))
                    }
                    if (super(null, t, i), this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e), this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e), this.boundUpdateStyleEl_ = e => this.updateStyleEl_(e), this.boundApplyInitTime_ = e => this.applyInitTime_(e), this.boundUpdateCurrentBreakpoint_ = e => this.updateCurrentBreakpoint_(e), this.boundHandleTechClick_ = e => this.handleTechClick_(e), this.boundHandleTechDoubleClick_ = e => this.handleTechDoubleClick_(e), this.boundHandleTechTouchStart_ = e => this.handleTechTouchStart_(e), this.boundHandleTechTouchMove_ = e => this.handleTechTouchMove_(e), this.boundHandleTechTouchEnd_ = e => this.handleTechTouchEnd_(e), this.boundHandleTechTap_ = e => this.handleTechTap_(e), this.isFullscreen_ = !1, this.log = Bt(this.id_), this.fsApi_ = Pt, this.isPosterFromTech_ = !1, this.queuedCallbacks_ = [], this.isReady_ = !1, this.hasStarted_ = !1, this.userActive_ = !1, this.debugEnabled_ = !1, this.audioOnlyMode_ = !1, this.audioPosterMode_ = !1, this.audioOnlyCache_ = {
                            playerHeight: null,
                            hiddenChildren: []
                        }, !this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
                    if (this.tag = e, this.tagAttributes = e && Ci(e), this.language(this.options_.language), t.languages) {
                        const e = {};
                        Object.getOwnPropertyNames(t.languages).forEach((function(i) {
                            e[i.toLowerCase()] = t.languages[i]
                        })), this.languages_ = e
                    } else this.languages_ = fa.prototype.options_.languages;
                    this.resetCache_(), this.poster_ = t.poster || "", this.controls_ = !!t.controls, e.controls = !1, e.removeAttribute("controls"), this.changingSrc_ = !1, this.playCallbacks_ = [], this.playTerminatedQueue_ = [], e.hasAttribute("autoplay") ? this.autoplay(!0) : this.autoplay(this.options_.autoplay), t.plugins && Object.keys(t.plugins).forEach((e => {
                        if ("function" != typeof this[e]) throw new Error(`plugin "${e}" does not exist`)
                    })), this.scrubbing_ = !1, this.el_ = this.createEl(), Pn(this, {
                        eventBusKey: "el_"
                    }), this.fsApi_.requestFullscreen && (hn(a(), this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_)), this.fluid_ && this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
                    const n = jt(this.options_);
                    t.plugins && Object.keys(t.plugins).forEach((e => {
                        this[e](t.plugins[e])
                    })), t.debug && this.debug(!0), this.options_.playerOptions = n, this.middleware_ = [], this.playbackRates(t.playbackRates), this.initChildren(), this.isAudio("audio" === e.nodeName.toLowerCase()), this.controls() ? this.addClass("vjs-controls-enabled") : this.addClass("vjs-controls-disabled"), this.el_.setAttribute("role", "region"), this.isAudio() ? this.el_.setAttribute("aria-label", this.localize("Audio Player")) : this.el_.setAttribute("aria-label", this.localize("Video Player")), this.isAudio() && this.addClass("vjs-audio"), hi && this.addClass("vjs-touch-enabled"), ui || this.addClass("vjs-workinghover"), fa.players[this.id_] = this;
                    const r = Ct.split(".")[0];
                    this.addClass(`vjs-v${r}`), this.userActive(!0), this.reportUserActivity(), this.one("play", (e => this.listenForUserActivity_(e))), this.on("keydown", (e => this.handleKeyDown(e))), this.on("languagechange", (e => this.handleLanguagechange(e))), this.breakpoints(this.options_.breakpoints), this.responsive(this.options_.responsive), this.on("ready", (() => {
                        this.audioPosterMode(this.options_.audioPosterMode), this.audioOnlyMode(this.options_.audioOnlyMode)
                    }))
                }
                dispose() {
                    this.trigger("dispose"), this.off("dispose"), cn(a(), this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), cn(a(), "keydown", this.boundFullWindowOnEscKey_), this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_), this.styleEl_ = null), fa.players[this.id_] = null, this.tag && this.tag.player && (this.tag.player = null), this.el_ && this.el_.player && (this.el_.player = null), this.tech_ && (this.tech_.dispose(), this.isPosterFromTech_ = !1, this.poster_ = ""), this.playerElIngest_ && (this.playerElIngest_ = null), this.tag && (this.tag = null), Lr[this.id()] = null, Mr.names.forEach((e => {
                        const t = this[Mr[e].getterName]();
                        t && t.off && t.off()
                    })), super.dispose({
                        restoreEl: this.options_.restoreEl
                    })
                }
                createEl() {
                    let e, t = this.tag,
                        i = this.playerElIngest_ = t.parentNode && t.parentNode.hasAttribute && t.parentNode.hasAttribute("data-vjs-player");
                    const n = "video-js" === this.tag.tagName.toLowerCase();
                    i ? e = this.el_ = t.parentNode : n || (e = this.el_ = super.createEl("div"));
                    const s = Ci(t);
                    if (n) {
                        for (e = this.el_ = t, t = this.tag = a().createElement("video"); e.children.length;) t.appendChild(e.firstChild);
                        xi(e, "video-js") || wi(e, "video-js"), e.appendChild(t), i = this.playerElIngest_ = e, Object.keys(e).forEach((i => {
                            try {
                                t[i] = e[i]
                            } catch (e) {}
                        }))
                    }
                    if (t.setAttribute("tabindex", "-1"), s.tabindex = "-1", ti && ai && (t.setAttribute("role", "application"), s.role = "application"), t.removeAttribute("width"), t.removeAttribute("height"), "width" in s && delete s.width, "height" in s && delete s.height, Object.getOwnPropertyNames(s).forEach((function(i) {
                            n && "class" === i || e.setAttribute(i, s[i]), n && t.setAttribute(i, s[i])
                        })), t.playerId = t.id, t.id += "_html5_api", t.className = "vjs-tech", t.player = e.player = this, this.addClass("vjs-paused"), !0 !== r().VIDEOJS_NO_DYNAMIC_STYLE) {
                        this.styleEl_ = Ji("vjs-styles-dimensions");
                        const e = Vi(".vjs-styles-defaults"),
                            t = Vi("head");
                        t.insertBefore(this.styleEl_, e ? e.nextSibling : t.firstChild)
                    }
                    this.fill_ = !1, this.fluid_ = !1, this.width(this.options_.width), this.height(this.options_.height), this.fill(this.options_.fill), this.fluid(this.options_.fluid), this.aspectRatio(this.options_.aspectRatio), this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
                    const o = t.getElementsByTagName("a");
                    for (let e = 0; e < o.length; e++) {
                        const t = o.item(e);
                        wi(t, "vjs-hidden"), t.setAttribute("hidden", "hidden")
                    }
                    return t.initNetworkState_ = t.networkState, t.parentNode && !i && t.parentNode.insertBefore(e, t), Ti(t, e), this.children_.unshift(t), this.el_.setAttribute("lang", this.language_), this.el_.setAttribute("translate", "no"), this.el_ = e, e
                }
                crossOrigin(e) {
                    if (void 0 === e) return this.techGet_("crossOrigin");
                    null === e || "anonymous" === e || "use-credentials" === e ? (this.techCall_("setCrossOrigin", e), this.posterImage && this.posterImage.crossOrigin(e)) : Ut.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${e}"`)
                }
                width(e) {
                    return this.dimension("width", e)
                }
                height(e) {
                    return this.dimension("height", e)
                }
                dimension(e, t) {
                    const i = e + "_";
                    if (void 0 === t) return this[i] || 0;
                    if ("" === t || "auto" === t) return this[i] = void 0, void this.updateStyleEl_();
                    const n = parseFloat(t);
                    isNaN(n) ? Ut.error(`Improper value "${t}" supplied for for ${e}`) : (this[i] = n, this.updateStyleEl_())
                }
                fluid(e) {
                    if (void 0 === e) return !!this.fluid_;
                    var t, i;
                    this.fluid_ = !!e, wn(this) && this.off(["playerreset", "resize"], this.boundUpdateStyleEl_), e ? (this.addClass("vjs-fluid"), this.fill(!1), i = () => {
                        this.on(["playerreset", "resize"], this.boundUpdateStyleEl_)
                    }, wn(t = this) ? i() : (t.eventedCallbacks || (t.eventedCallbacks = []), t.eventedCallbacks.push(i))) : this.removeClass("vjs-fluid"), this.updateStyleEl_()
                }
                fill(e) {
                    if (void 0 === e) return !!this.fill_;
                    this.fill_ = !!e, e ? (this.addClass("vjs-fill"), this.fluid(!1)) : this.removeClass("vjs-fill")
                }
                aspectRatio(e) {
                    if (void 0 === e) return this.aspectRatio_;
                    if (!/^\d+\:\d+$/.test(e)) throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
                    this.aspectRatio_ = e, this.fluid(!0), this.updateStyleEl_()
                }
                updateStyleEl_() {
                    if (!0 === r().VIDEOJS_NO_DYNAMIC_STYLE) {
                        const e = "number" == typeof this.width_ ? this.width_ : this.options_.width,
                            t = "number" == typeof this.height_ ? this.height_ : this.options_.height,
                            i = this.tech_ && this.tech_.el();
                        return void(i && (e >= 0 && (i.width = e), t >= 0 && (i.height = t)))
                    }
                    let e, t, i, n;
                    i = void 0 !== this.aspectRatio_ && "auto" !== this.aspectRatio_ ? this.aspectRatio_ : this.videoWidth() > 0 ? this.videoWidth() + ":" + this.videoHeight() : "16:9";
                    const s = i.split(":"),
                        a = s[1] / s[0];
                    e = void 0 !== this.width_ ? this.width_ : void 0 !== this.height_ ? this.height_ / a : this.videoWidth() || 300, t = void 0 !== this.height_ ? this.height_ : e * a, n = /^[^a-zA-Z]/.test(this.id()) ? "dimensions-" + this.id() : this.id() + "-dimensions", this.addClass(n), Zi(this.styleEl_, `\n      .${n} {\n        width: ${e}px;\n        height: ${t}px;\n      }\n\n      .${n}.vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: ${100*a}%;\n      }\n    `)
                }
                loadTech_(e, t) {
                    this.tech_ && this.unloadTech_();
                    const i = On(e),
                        n = e.charAt(0).toLowerCase() + e.slice(1);
                    "Html5" !== i && this.tag && (Cr.getTech("Html5").disposeMediaElement(this.tag), this.tag.player = null, this.tag = null), this.techName_ = i, this.isReady_ = !1;
                    let r = this.autoplay();
                    ("string" == typeof this.autoplay() || !0 === this.autoplay() && this.options_.normalizeAutoplay) && (r = !1);
                    const s = {
                        source: t,
                        autoplay: r,
                        nativeControlsForTouch: this.options_.nativeControlsForTouch,
                        playerId: this.id(),
                        techId: `${this.id()}_${n}_api`,
                        playsinline: this.options_.playsinline,
                        preload: this.options_.preload,
                        loop: this.options_.loop,
                        disablePictureInPicture: this.options_.disablePictureInPicture,
                        muted: this.options_.muted,
                        poster: this.poster(),
                        language: this.language(),
                        playerElIngest: this.playerElIngest_ || !1,
                        "vtt.js": this.options_["vtt.js"],
                        canOverridePoster: !!this.options_.techCanOverridePoster,
                        enableSourceset: this.options_.enableSourceset
                    };
                    Mr.names.forEach((e => {
                        const t = Mr[e];
                        s[t.getterName] = this[t.privateName]
                    })), Object.assign(s, this.options_[i]), Object.assign(s, this.options_[n]), Object.assign(s, this.options_[e.toLowerCase()]), this.tag && (s.tag = this.tag), t && t.src === this.cache_.src && this.cache_.currentTime > 0 && (s.startTime = this.cache_.currentTime);
                    const a = Cr.getTech(e);
                    if (!a) throw new Error(`No Tech named '${i}' exists! '${i}' should be registered using videojs.registerTech()'`);
                    this.tech_ = new a(s), this.tech_.ready(gn(this, this.handleTechReady_), !0), er(this.textTracksJson_ || [], this.tech_), ha.forEach((e => {
                        this.on(this.tech_, e, (t => this[`handleTech${On(e)}_`](t)))
                    })), Object.keys(ca).forEach((e => {
                        this.on(this.tech_, e, (t => {
                            0 === this.tech_.playbackRate() && this.tech_.seeking() ? this.queuedCallbacks_.push({
                                callback: this[`handleTech${ca[e]}_`].bind(this),
                                event: t
                            }) : this[`handleTech${ca[e]}_`](t)
                        }))
                    })), this.on(this.tech_, "loadstart", (e => this.handleTechLoadStart_(e))), this.on(this.tech_, "sourceset", (e => this.handleTechSourceset_(e))), this.on(this.tech_, "waiting", (e => this.handleTechWaiting_(e))), this.on(this.tech_, "ended", (e => this.handleTechEnded_(e))), this.on(this.tech_, "seeking", (e => this.handleTechSeeking_(e))), this.on(this.tech_, "play", (e => this.handleTechPlay_(e))), this.on(this.tech_, "pause", (e => this.handleTechPause_(e))), this.on(this.tech_, "durationchange", (e => this.handleTechDurationChange_(e))), this.on(this.tech_, "fullscreenchange", ((e, t) => this.handleTechFullscreenChange_(e, t))), this.on(this.tech_, "fullscreenerror", ((e, t) => this.handleTechFullscreenError_(e, t))), this.on(this.tech_, "enterpictureinpicture", (e => this.handleTechEnterPictureInPicture_(e))), this.on(this.tech_, "leavepictureinpicture", (e => this.handleTechLeavePictureInPicture_(e))), this.on(this.tech_, "error", (e => this.handleTechError_(e))), this.on(this.tech_, "posterchange", (e => this.handleTechPosterChange_(e))), this.on(this.tech_, "textdata", (e => this.handleTechTextData_(e))), this.on(this.tech_, "ratechange", (e => this.handleTechRateChange_(e))), this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_), this.usingNativeControls(this.techGet_("controls")), this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(), this.tech_.el().parentNode === this.el() || "Html5" === i && this.tag || Ti(this.tech_.el(), this.el()), this.tag && (this.tag.player = null, this.tag = null)
                }
                unloadTech_() {
                    Mr.names.forEach((e => {
                        const t = Mr[e];
                        this[t.privateName] = this[t.getterName]()
                    })), this.textTracksJson_ = Qn(this.tech_), this.isReady_ = !1, this.tech_.dispose(), this.tech_ = !1, this.isPosterFromTech_ && (this.poster_ = "", this.trigger("posterchange")), this.isPosterFromTech_ = !1
                }
                tech(e) {
                    return void 0 === e && Ut.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n"), this.tech_
                }
                addTechControlsListeners_() {
                    this.removeTechControlsListeners_(), this.on(this.tech_, "click", this.boundHandleTechClick_), this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_), this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.on(this.tech_, "tap", this.boundHandleTechTap_)
                }
                removeTechControlsListeners_() {
                    this.off(this.tech_, "tap", this.boundHandleTechTap_), this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.off(this.tech_, "click", this.boundHandleTechClick_), this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_)
                }
                handleTechReady_() {
                    this.triggerReady(), this.cache_.volume && this.techCall_("setVolume", this.cache_.volume), this.handleTechPosterChange_(), this.handleTechDurationChange_()
                }
                handleTechLoadStart_() {
                    this.removeClass("vjs-ended", "vjs-seeking"), this.error(null), this.handleTechDurationChange_(), this.paused() ? (this.hasStarted(!1), this.trigger("loadstart")) : this.trigger("loadstart"), this.manualAutoplay_(!0 === this.autoplay() && this.options_.normalizeAutoplay ? "play" : this.autoplay())
                }
                manualAutoplay_(e) {
                    if (!this.tech_ || "string" != typeof e) return;
                    const t = () => {
                        const e = this.muted();
                        this.muted(!0);
                        const t = () => {
                            this.muted(e)
                        };
                        this.playTerminatedQueue_.push(t);
                        const i = this.play();
                        if (Kn(i)) return i.catch((e => {
                            throw t(), new Error(`Rejection at manualAutoplay. Restoring muted value. ${e||""}`)
                        }))
                    };
                    let i;
                    return "any" !== e || this.muted() ? i = "muted" !== e || this.muted() ? this.play() : t() : (i = this.play(), Kn(i) && (i = i.catch(t))), Kn(i) ? i.then((() => {
                        this.trigger({
                            type: "autoplay-success",
                            autoplay: e
                        })
                    })).catch((() => {
                        this.trigger({
                            type: "autoplay-failure",
                            autoplay: e
                        })
                    })) : void 0
                }
                updateSourceCaches_(e = "") {
                    let t = e,
                        i = "";
                    "string" != typeof t && (t = e.src, i = e.type), this.cache_.source = this.cache_.source || {}, this.cache_.sources = this.cache_.sources || [], t && !i && (i = ((e, t) => {
                        if (!t) return "";
                        if (e.cache_.source.src === t && e.cache_.source.type) return e.cache_.source.type;
                        const i = e.cache_.sources.filter((e => e.src === t));
                        if (i.length) return i[0].type;
                        const n = e.$$("source");
                        for (let e = 0; e < n.length; e++) {
                            const i = n[e];
                            if (i.type && i.src && i.src === t) return i.type
                        }
                        return Fr(t)
                    })(this, t)), this.cache_.source = jt({}, e, {
                        src: t,
                        type: i
                    });
                    const n = this.cache_.sources.filter((e => e.src && e.src === t)),
                        r = [],
                        s = this.$$("source"),
                        a = [];
                    for (let e = 0; e < s.length; e++) {
                        const i = Ci(s[e]);
                        r.push(i), i.src && i.src === t && a.push(i.src)
                    }
                    a.length && !n.length ? this.cache_.sources = r : n.length || (this.cache_.sources = [this.cache_.source]), this.cache_.src = t
                }
                handleTechSourceset_(e) {
                    if (!this.changingSrc_) {
                        let t = e => this.updateSourceCaches_(e);
                        const i = this.currentSource().src,
                            n = e.src;
                        i && !/^blob:/.test(i) && /^blob:/.test(n) && (!this.lastSource_ || this.lastSource_.tech !== n && this.lastSource_.player !== i) && (t = () => {}), t(n), e.src || this.tech_.any(["sourceset", "loadstart"], (e => {
                            if ("sourceset" === e.type) return;
                            const t = this.techGet("currentSrc");
                            this.lastSource_.tech = t, this.updateSourceCaches_(t)
                        }))
                    }
                    this.lastSource_ = {
                        player: this.currentSource().src,
                        tech: e.src
                    }, this.trigger({
                        src: e.src,
                        type: "sourceset"
                    })
                }
                hasStarted(e) {
                    if (void 0 === e) return this.hasStarted_;
                    e !== this.hasStarted_ && (this.hasStarted_ = e, this.hasStarted_ ? this.addClass("vjs-has-started") : this.removeClass("vjs-has-started"))
                }
                handleTechPlay_() {
                    this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.hasStarted(!0), this.trigger("play")
                }
                handleTechRateChange_() {
                    this.tech_.playbackRate() > 0 && 0 === this.cache_.lastPlaybackRate && (this.queuedCallbacks_.forEach((e => e.callback(e.event))), this.queuedCallbacks_ = []), this.cache_.lastPlaybackRate = this.tech_.playbackRate(), this.trigger("ratechange")
                }
                handleTechWaiting_() {
                    this.addClass("vjs-waiting"), this.trigger("waiting");
                    const e = this.currentTime(),
                        t = () => {
                            e !== this.currentTime() && (this.removeClass("vjs-waiting"), this.off("timeupdate", t))
                        };
                    this.on("timeupdate", t)
                }
                handleTechCanPlay_() {
                    this.removeClass("vjs-waiting"), this.trigger("canplay")
                }
                handleTechCanPlayThrough_() {
                    this.removeClass("vjs-waiting"), this.trigger("canplaythrough")
                }
                handleTechPlaying_() {
                    this.removeClass("vjs-waiting"), this.trigger("playing")
                }
                handleTechSeeking_() {
                    this.addClass("vjs-seeking"), this.trigger("seeking")
                }
                handleTechSeeked_() {
                    this.removeClass("vjs-seeking", "vjs-ended"), this.trigger("seeked")
                }
                handleTechPause_() {
                    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.trigger("pause")
                }
                handleTechEnded_() {
                    this.addClass("vjs-ended"), this.removeClass("vjs-waiting"), this.options_.loop ? (this.currentTime(0), this.play()) : this.paused() || this.pause(), this.trigger("ended")
                }
                handleTechDurationChange_() {
                    this.duration(this.techGet_("duration"))
                }
                handleTechClick_(e) {
                    this.controls_ && (void 0 !== this.options_ && void 0 !== this.options_.userActions && void 0 !== this.options_.userActions.click && !1 === this.options_.userActions.click || (void 0 !== this.options_ && void 0 !== this.options_.userActions && "function" == typeof this.options_.userActions.click ? this.options_.userActions.click.call(this, e) : this.paused() ? Jn(this.play()) : this.pause()))
                }
                handleTechDoubleClick_(e) {
                    if (!this.controls_) return;
                    Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), (t => t.contains(e.target))) || void 0 !== this.options_ && void 0 !== this.options_.userActions && void 0 !== this.options_.userActions.doubleClick && !1 === this.options_.userActions.doubleClick || (void 0 !== this.options_ && void 0 !== this.options_.userActions && "function" == typeof this.options_.userActions.doubleClick ? this.options_.userActions.doubleClick.call(this, e) : this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen())
                }
                handleTechTap_() {
                    this.userActive(!this.userActive())
                }
                handleTechTouchStart_() {
                    this.userWasActive = this.userActive()
                }
                handleTechTouchMove_() {
                    this.userWasActive && this.reportUserActivity()
                }
                handleTechTouchEnd_(e) {
                    e.cancelable && e.preventDefault()
                }
                toggleFullscreenClass_() {
                    this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen")
                }
                documentFullscreenChange_(e) {
                    const t = e.target.player;
                    if (t && t !== this) return;
                    const i = this.el();
                    let n = a()[this.fsApi_.fullscreenElement] === i;
                    !n && i.matches ? n = i.matches(":" + this.fsApi_.fullscreen) : !n && i.msMatchesSelector && (n = i.msMatchesSelector(":" + this.fsApi_.fullscreen)), this.isFullscreen(n)
                }
                handleTechFullscreenChange_(e, t) {
                    t && (t.nativeIOSFullscreen && (this.addClass("vjs-ios-native-fs"), this.tech_.one("webkitendfullscreen", (() => {
                        this.removeClass("vjs-ios-native-fs")
                    }))), this.isFullscreen(t.isFullscreen))
                }
                handleTechFullscreenError_(e, t) {
                    this.trigger("fullscreenerror", t)
                }
                togglePictureInPictureClass_() {
                    this.isInPictureInPicture() ? this.addClass("vjs-picture-in-picture") : this.removeClass("vjs-picture-in-picture")
                }
                handleTechEnterPictureInPicture_(e) {
                    this.isInPictureInPicture(!0)
                }
                handleTechLeavePictureInPicture_(e) {
                    this.isInPictureInPicture(!1)
                }
                handleTechError_() {
                    const e = this.tech_.error();
                    this.error(e)
                }
                handleTechTextData_() {
                    let e = null;
                    arguments.length > 1 && (e = arguments[1]), this.trigger("textdata", e)
                }
                getCache() {
                    return this.cache_
                }
                resetCache_() {
                    this.cache_ = {
                        currentTime: 0,
                        initTime: 0,
                        inactivityTimeout: this.options_.inactivityTimeout,
                        duration: NaN,
                        lastVolume: 1,
                        lastPlaybackRate: this.defaultPlaybackRate(),
                        media: null,
                        src: "",
                        source: {},
                        sources: [],
                        playbackRates: [],
                        volume: 1
                    }
                }
                techCall_(e, t) {
                    this.ready((function() {
                        if (e in Dr) return function(e, t, i, n) {
                            return t[i](e.reduce(Nr(i), n))
                        }(this.middleware_, this.tech_, e, t);
                        if (e in Or) return Rr(this.middleware_, this.tech_, e, t);
                        try {
                            this.tech_ && this.tech_[e](t)
                        } catch (e) {
                            throw Ut(e), e
                        }
                    }), !0)
                }
                techGet_(e) {
                    if (this.tech_ && this.tech_.isReady_) {
                        if (e in kr) return function(e, t, i) {
                            return e.reduceRight(Nr(i), t[i]())
                        }(this.middleware_, this.tech_, e);
                        if (e in Or) return Rr(this.middleware_, this.tech_, e);
                        try {
                            return this.tech_[e]()
                        } catch (t) {
                            if (void 0 === this.tech_[e]) throw Ut(`Video.js: ${e} method not defined for ${this.techName_} playback technology.`, t), t;
                            if ("TypeError" === t.name) throw Ut(`Video.js: ${e} unavailable on ${this.techName_} playback technology element.`, t), this.tech_.isReady_ = !1, t;
                            throw Ut(t), t
                        }
                    }
                }
                play() {
                    return new Promise((e => {
                        this.play_(e)
                    }))
                }
                play_(e = Jn) {
                    this.playCallbacks_.push(e);
                    const t = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
                    if (this.waitToPlay_ && (this.off(["ready", "loadstart"], this.waitToPlay_), this.waitToPlay_ = null), !this.isReady_ || !t) return this.waitToPlay_ = e => {
                        this.play_()
                    }, this.one(["ready", "loadstart"], this.waitToPlay_), void(t || !di && !ui || this.load());
                    const i = this.techGet_("play");
                    null === i ? this.runPlayTerminatedQueue_() : this.runPlayCallbacks_(i)
                }
                runPlayTerminatedQueue_() {
                    const e = this.playTerminatedQueue_.slice(0);
                    this.playTerminatedQueue_ = [], e.forEach((function(e) {
                        e()
                    }))
                }
                runPlayCallbacks_(e) {
                    const t = this.playCallbacks_.slice(0);
                    this.playCallbacks_ = [], this.playTerminatedQueue_ = [], t.forEach((function(t) {
                        t(e)
                    }))
                }
                pause() {
                    this.techCall_("pause")
                }
                paused() {
                    return !1 !== this.techGet_("paused")
                }
                played() {
                    return this.techGet_("played") || zn(0, 0)
                }
                scrubbing(e) {
                    if (void 0 === e) return this.scrubbing_;
                    this.scrubbing_ = !!e, this.techCall_("setScrubbing", this.scrubbing_), e ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing")
                }
                currentTime(e) {
                    return void 0 !== e ? (e < 0 && (e = 0), this.isReady_ && !this.changingSrc_ && this.tech_ && this.tech_.isReady_ ? (this.techCall_("setCurrentTime", e), void(this.cache_.initTime = 0)) : (this.cache_.initTime = e, this.off("canplay", this.boundApplyInitTime_), void this.one("canplay", this.boundApplyInitTime_))) : (this.cache_.currentTime = this.techGet_("currentTime") || 0, this.cache_.currentTime)
                }
                applyInitTime_() {
                    this.currentTime(this.cache_.initTime)
                }
                duration(e) {
                    if (void 0 === e) return void 0 !== this.cache_.duration ? this.cache_.duration : NaN;
                    (e = parseFloat(e)) < 0 && (e = 1 / 0), e !== this.cache_.duration && (this.cache_.duration = e, e === 1 / 0 ? this.addClass("vjs-live") : this.removeClass("vjs-live"), isNaN(e) || this.trigger("durationchange"))
                }
                remainingTime() {
                    return this.duration() - this.currentTime()
                }
                remainingTimeDisplay() {
                    return Math.floor(this.duration()) - Math.floor(this.currentTime())
                }
                buffered() {
                    let e = this.techGet_("buffered");
                    return e && e.length || (e = zn(0, 0)), e
                }
                bufferedPercent() {
                    return Xn(this.buffered(), this.duration())
                }
                bufferedEnd() {
                    const e = this.buffered(),
                        t = this.duration();
                    let i = e.end(e.length - 1);
                    return i > t && (i = t), i
                }
                volume(e) {
                    let t;
                    return void 0 !== e ? (t = Math.max(0, Math.min(1, parseFloat(e))), this.cache_.volume = t, this.techCall_("setVolume", t), void(t > 0 && this.lastVolume_(t))) : (t = parseFloat(this.techGet_("volume")), isNaN(t) ? 1 : t)
                }
                muted(e) {
                    if (void 0 === e) return this.techGet_("muted") || !1;
                    this.techCall_("setMuted", e)
                }
                defaultMuted(e) {
                    return void 0 !== e ? this.techCall_("setDefaultMuted", e) : this.techGet_("defaultMuted") || !1
                }
                lastVolume_(e) {
                    if (void 0 === e || 0 === e) return this.cache_.lastVolume;
                    this.cache_.lastVolume = e
                }
                supportsFullScreen() {
                    return this.techGet_("supportsFullScreen") || !1
                }
                isFullscreen(e) {
                    if (void 0 !== e) {
                        const t = this.isFullscreen_;
                        return this.isFullscreen_ = Boolean(e), this.isFullscreen_ !== t && this.fsApi_.prefixed && this.trigger("fullscreenchange"), void this.toggleFullscreenClass_()
                    }
                    return this.isFullscreen_
                }
                requestFullscreen(e) {
                    this.isInPictureInPicture() && this.exitPictureInPicture();
                    const t = this;
                    return new Promise(((i, n) => {
                        function r() {
                            t.off("fullscreenerror", a), t.off("fullscreenchange", s)
                        }

                        function s() {
                            r(), i()
                        }

                        function a(e, t) {
                            r(), n(t)
                        }
                        t.one("fullscreenchange", s), t.one("fullscreenerror", a);
                        const o = t.requestFullscreenHelper_(e);
                        o && (o.then(r, r), o.then(i, n))
                    }))
                }
                requestFullscreenHelper_(e) {
                    let t;
                    if (this.fsApi_.prefixed || (t = this.options_.fullscreen && this.options_.fullscreen.options || {}, void 0 !== e && (t = e)), this.fsApi_.requestFullscreen) {
                        const e = this.el_[this.fsApi_.requestFullscreen](t);
                        return e && e.then((() => this.isFullscreen(!0)), (() => this.isFullscreen(!1))), e
                    }
                    this.tech_.supportsFullScreen() && !0 == !this.options_.preferFullWindow ? this.techCall_("enterFullScreen") : this.enterFullWindow()
                }
                exitFullscreen() {
                    const e = this;
                    return new Promise(((t, i) => {
                        function n() {
                            e.off("fullscreenerror", s), e.off("fullscreenchange", r)
                        }

                        function r() {
                            n(), t()
                        }

                        function s(e, t) {
                            n(), i(t)
                        }
                        e.one("fullscreenchange", r), e.one("fullscreenerror", s);
                        const a = e.exitFullscreenHelper_();
                        a && (a.then(n, n), a.then(t, i))
                    }))
                }
                exitFullscreenHelper_() {
                    if (this.fsApi_.requestFullscreen) {
                        const e = a()[this.fsApi_.exitFullscreen]();
                        return e && Jn(e.then((() => this.isFullscreen(!1)))), e
                    }
                    this.tech_.supportsFullScreen() && !0 == !this.options_.preferFullWindow ? this.techCall_("exitFullScreen") : this.exitFullWindow()
                }
                enterFullWindow() {
                    this.isFullscreen(!0), this.isFullWindow = !0, this.docOrigOverflow = a().documentElement.style.overflow, hn(a(), "keydown", this.boundFullWindowOnEscKey_), a().documentElement.style.overflow = "hidden", wi(a().body, "vjs-full-window"), this.trigger("enterFullWindow")
                }
                fullWindowOnEscKey(e) {
                    l().isEventKey(e, "Esc") && !0 === this.isFullscreen() && (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen())
                }
                exitFullWindow() {
                    this.isFullscreen(!1), this.isFullWindow = !1, cn(a(), "keydown", this.boundFullWindowOnEscKey_), a().documentElement.style.overflow = this.docOrigOverflow, Si(a().body, "vjs-full-window"), this.trigger("exitFullWindow")
                }
                disablePictureInPicture(e) {
                    if (void 0 === e) return this.techGet_("disablePictureInPicture");
                    this.techCall_("setDisablePictureInPicture", e), this.options_.disablePictureInPicture = e, this.trigger("disablepictureinpicturechanged")
                }
                isInPictureInPicture(e) {
                    return void 0 !== e ? (this.isInPictureInPicture_ = !!e, void this.togglePictureInPictureClass_()) : !!this.isInPictureInPicture_
                }
                requestPictureInPicture() {
                    if ("pictureInPictureEnabled" in a() && !1 === this.disablePictureInPicture()) return this.techGet_("requestPictureInPicture")
                }
                exitPictureInPicture() {
                    if ("pictureInPictureEnabled" in a()) return a().exitPictureInPicture()
                }
                handleKeyDown(e) {
                    const {
                        userActions: t
                    } = this.options_;
                    if (!t || !t.hotkeys) return;
                    (e => {
                        const t = e.tagName.toLowerCase();
                        if (e.isContentEditable) return !0;
                        if ("input" === t) return -1 === ["button", "checkbox", "hidden", "radio", "reset", "submit"].indexOf(e.type);
                        return -1 !== ["textarea"].indexOf(t)
                    })(this.el_.ownerDocument.activeElement) || ("function" == typeof t.hotkeys ? t.hotkeys.call(this, e) : this.handleHotkeys(e))
                }
                handleHotkeys(e) {
                    const t = this.options_.userActions ? this.options_.userActions.hotkeys : {},
                        {
                            fullscreenKey: i = (e => l().isEventKey(e, "f")),
                            muteKey: n = (e => l().isEventKey(e, "m")),
                            playPauseKey: r = (e => l().isEventKey(e, "k") || l().isEventKey(e, "Space"))
                        } = t;
                    if (i.call(this, e)) {
                        e.preventDefault(), e.stopPropagation();
                        const t = Bn.getComponent("FullscreenToggle");
                        !1 !== a()[this.fsApi_.fullscreenEnabled] && t.prototype.handleClick.call(this, e)
                    } else if (n.call(this, e)) {
                        e.preventDefault(), e.stopPropagation();
                        Bn.getComponent("MuteToggle").prototype.handleClick.call(this, e)
                    } else if (r.call(this, e)) {
                        e.preventDefault(), e.stopPropagation();
                        Bn.getComponent("PlayToggle").prototype.handleClick.call(this, e)
                    }
                }
                canPlayType(e) {
                    let t;
                    for (let i = 0, n = this.options_.techOrder; i < n.length; i++) {
                        const r = n[i];
                        let s = Cr.getTech(r);
                        if (s || (s = Bn.getComponent(r)), s) {
                            if (s.isSupported() && (t = s.canPlayType(e), t)) return t
                        } else Ut.error(`The "${r}" tech is undefined. Skipped browser support check for that tech.`)
                    }
                    return ""
                }
                selectSource(e) {
                    const t = this.options_.techOrder.map((e => [e, Cr.getTech(e)])).filter((([e, t]) => t ? t.isSupported() : (Ut.error(`The "${e}" tech is undefined. Skipped browser support check for that tech.`), !1))),
                        i = function(e, t, i) {
                            let n;
                            return e.some((e => t.some((t => {
                                if (n = i(e, t), n) return !0
                            })))), n
                        };
                    let n;
                    const r = ([e, t], i) => {
                        if (t.canPlaySource(i, this.options_[e.toLowerCase()])) return {
                            source: i,
                            tech: e
                        }
                    };
                    var s;
                    return n = this.options_.sourceOrder ? i(e, t, (s = r, (e, t) => s(t, e))) : i(t, e, r), n || !1
                }
                handleSrc_(e, t) {
                    if (void 0 === e) return this.cache_.src || "";
                    this.resetRetryOnError_ && this.resetRetryOnError_();
                    const i = Hr(e);
                    if (i.length) {
                        if (this.changingSrc_ = !0, t || (this.cache_.sources = i), this.updateSourceCaches_(i[0]), Pr(this, i[0], ((e, n) => {
                                this.middleware_ = n, t || (this.cache_.sources = i), this.updateSourceCaches_(e);
                                if (this.src_(e)) return i.length > 1 ? this.handleSrc_(i.slice(1)) : (this.changingSrc_ = !1, this.setTimeout((function() {
                                    this.error({
                                        code: 4,
                                        message: this.options_.notSupportedMessage
                                    })
                                }), 0), void this.triggerReady());
                                var r, s;
                                r = n, s = this.tech_, r.forEach((e => e.setTech && e.setTech(s)))
                            })), i.length > 1) {
                            const e = () => {
                                    this.error(null), this.handleSrc_(i.slice(1), !0)
                                },
                                t = () => {
                                    this.off("error", e)
                                };
                            this.one("error", e), this.one("playing", t), this.resetRetryOnError_ = () => {
                                this.off("error", e), this.off("playing", t)
                            }
                        }
                    } else this.setTimeout((function() {
                        this.error({
                            code: 4,
                            message: this.options_.notSupportedMessage
                        })
                    }), 0)
                }
                src(e) {
                    return this.handleSrc_(e, !1)
                }
                src_(e) {
                    const t = this.selectSource([e]);
                    return !t || (Nn(t.tech, this.techName_) ? (this.ready((function() {
                        this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", e) : this.techCall_("src", e.src), this.changingSrc_ = !1
                    }), !0), !1) : (this.changingSrc_ = !0, this.loadTech_(t.tech, t.source), this.tech_.ready((() => {
                        this.changingSrc_ = !1
                    })), !1))
                }
                load() {
                    this.techCall_("load")
                }
                reset() {
                    if (this.paused()) this.doReset_();
                    else {
                        Jn(this.play().then((() => this.doReset_())))
                    }
                }
                doReset_() {
                    this.tech_ && this.tech_.clearTracks("text"), this.resetCache_(), this.poster(""), this.loadTech_(this.options_.techOrder[0], null), this.techCall_("reset"), this.resetControlBarUI_(), wn(this) && this.trigger("playerreset")
                }
                resetControlBarUI_() {
                    this.resetProgressBar_(), this.resetPlaybackRate_(), this.resetVolumeBar_()
                }
                resetProgressBar_() {
                    this.currentTime(0);
                    const {
                        durationDisplay: e,
                        remainingTimeDisplay: t
                    } = this.controlBar || {};
                    e && e.updateContent(), t && t.updateContent()
                }
                resetPlaybackRate_() {
                    this.playbackRate(this.defaultPlaybackRate()), this.handleTechRateChange_()
                }
                resetVolumeBar_() {
                    this.volume(1), this.trigger("volumechange")
                }
                currentSources() {
                    const e = this.currentSource(),
                        t = [];
                    return 0 !== Object.keys(e).length && t.push(e), this.cache_.sources || t
                }
                currentSource() {
                    return this.cache_.source || {}
                }
                currentSrc() {
                    return this.currentSource() && this.currentSource().src || ""
                }
                currentType() {
                    return this.currentSource() && this.currentSource().type || ""
                }
                preload(e) {
                    return void 0 !== e ? (this.techCall_("setPreload", e), void(this.options_.preload = e)) : this.techGet_("preload")
                }
                autoplay(e) {
                    if (void 0 === e) return this.options_.autoplay || !1;
                    let t;
                    "string" == typeof e && /(any|play|muted)/.test(e) || !0 === e && this.options_.normalizeAutoplay ? (this.options_.autoplay = e, this.manualAutoplay_("string" == typeof e ? e : "play"), t = !1) : this.options_.autoplay = !!e, t = void 0 === t ? this.options_.autoplay : t, this.tech_ && this.techCall_("setAutoplay", t)
                }
                playsinline(e) {
                    return void 0 !== e ? (this.techCall_("setPlaysinline", e), this.options_.playsinline = e, this) : this.techGet_("playsinline")
                }
                loop(e) {
                    return void 0 !== e ? (this.techCall_("setLoop", e), void(this.options_.loop = e)) : this.techGet_("loop")
                }
                poster(e) {
                    if (void 0 === e) return this.poster_;
                    e || (e = ""), e !== this.poster_ && (this.poster_ = e, this.techCall_("setPoster", e), this.isPosterFromTech_ = !1, this.trigger("posterchange"))
                }
                handleTechPosterChange_() {
                    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
                        const e = this.tech_.poster() || "";
                        e !== this.poster_ && (this.poster_ = e, this.isPosterFromTech_ = !0, this.trigger("posterchange"))
                    }
                }
                controls(e) {
                    if (void 0 === e) return !!this.controls_;
                    e = !!e, this.controls_ !== e && (this.controls_ = e, this.usingNativeControls() && this.techCall_("setControls", e), this.controls_ ? (this.removeClass("vjs-controls-disabled"), this.addClass("vjs-controls-enabled"), this.trigger("controlsenabled"), this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"), this.addClass("vjs-controls-disabled"), this.trigger("controlsdisabled"), this.usingNativeControls() || this.removeTechControlsListeners_()))
                }
                usingNativeControls(e) {
                    if (void 0 === e) return !!this.usingNativeControls_;
                    e = !!e, this.usingNativeControls_ !== e && (this.usingNativeControls_ = e, this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"), this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"), this.trigger("usingcustomcontrols")))
                }
                error(e) {
                    if (void 0 === e) return this.error_ || null;
                    if (Lt("beforeerror").forEach((t => {
                            const i = t(this, e);
                            Gt(i) && !Array.isArray(i) || "string" == typeof i || "number" == typeof i || null === i ? e = i : this.log.error("please return a value that MediaError expects in beforeerror hooks")
                        })), this.options_.suppressNotSupportedError && e && 4 === e.code) {
                        const t = function() {
                            this.error(e)
                        };
                        return this.options_.suppressNotSupportedError = !1, this.any(["click", "touchstart"], t), void this.one("loadstart", (function() {
                            this.off(["click", "touchstart"], t)
                        }))
                    }
                    if (null === e) return this.error_ = e, this.removeClass("vjs-error"), void(this.errorDisplay && this.errorDisplay.close());
                    this.error_ = new Yn(e), this.addClass("vjs-error"), Ut.error(`(CODE:${this.error_.code} ${Yn.errorTypes[this.error_.code]})`, this.error_.message, this.error_), this.trigger("error"), Lt("error").forEach((e => e(this, this.error_)))
                }
                reportUserActivity(e) {
                    this.userActivity_ = !0
                }
                userActive(e) {
                    if (void 0 === e) return this.userActive_;
                    if ((e = !!e) !== this.userActive_) {
                        if (this.userActive_ = e, this.userActive_) return this.userActivity_ = !0, this.removeClass("vjs-user-inactive"), this.addClass("vjs-user-active"), void this.trigger("useractive");
                        this.tech_ && this.tech_.one("mousemove", (function(e) {
                            e.stopPropagation(), e.preventDefault()
                        })), this.userActivity_ = !1, this.removeClass("vjs-user-active"), this.addClass("vjs-user-inactive"), this.trigger("userinactive")
                    }
                }
                listenForUserActivity_() {
                    let e, t, i;
                    const n = gn(this, this.reportUserActivity),
                        r = function(t) {
                            n(), this.clearInterval(e)
                        };
                    this.on("mousedown", (function() {
                        n(), this.clearInterval(e), e = this.setInterval(n, 250)
                    })), this.on("mousemove", (function(e) {
                        e.screenX === t && e.screenY === i || (t = e.screenX, i = e.screenY, n())
                    })), this.on("mouseup", r), this.on("mouseleave", r);
                    const s = this.getChild("controlBar");
                    let a;
                    !s || ui || Jt || (s.on("mouseenter", (function(e) {
                        0 !== this.player().options_.inactivityTimeout && (this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout), this.player().options_.inactivityTimeout = 0
                    })), s.on("mouseleave", (function(e) {
                        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout
                    }))), this.on("keydown", n), this.on("keyup", n), this.setInterval((function() {
                        if (!this.userActivity_) return;
                        this.userActivity_ = !1, this.userActive(!0), this.clearTimeout(a);
                        const e = this.options_.inactivityTimeout;
                        e <= 0 || (a = this.setTimeout((function() {
                            this.userActivity_ || this.userActive(!1)
                        }), e))
                    }), 250)
                }
                playbackRate(e) {
                    if (void 0 === e) return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1;
                    this.techCall_("setPlaybackRate", e)
                }
                defaultPlaybackRate(e) {
                    return void 0 !== e ? this.techCall_("setDefaultPlaybackRate", e) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1
                }
                isAudio(e) {
                    if (void 0 === e) return !!this.isAudio_;
                    this.isAudio_ = !!e
                }
                enableAudioOnlyUI_() {
                    this.addClass("vjs-audio-only-mode");
                    const e = this.children(),
                        t = this.getChild("ControlBar"),
                        i = t && t.currentHeight();
                    e.forEach((e => {
                        e !== t && e.el_ && !e.hasClass("vjs-hidden") && (e.hide(), this.audioOnlyCache_.hiddenChildren.push(e))
                    })), this.audioOnlyCache_.playerHeight = this.currentHeight(), this.height(i), this.trigger("audioonlymodechange")
                }
                disableAudioOnlyUI_() {
                    this.removeClass("vjs-audio-only-mode"), this.audioOnlyCache_.hiddenChildren.forEach((e => e.show())), this.height(this.audioOnlyCache_.playerHeight), this.trigger("audioonlymodechange")
                }
                audioOnlyMode(e) {
                    if ("boolean" != typeof e || e === this.audioOnlyMode_) return this.audioOnlyMode_;
                    if (this.audioOnlyMode_ = e, e) {
                        const e = [];
                        return this.isInPictureInPicture() && e.push(this.exitPictureInPicture()), this.isFullscreen() && e.push(this.exitFullscreen()), this.audioPosterMode() && e.push(this.audioPosterMode(!1)), Promise.all(e).then((() => this.enableAudioOnlyUI_()))
                    }
                    return Promise.resolve().then((() => this.disableAudioOnlyUI_()))
                }
                enablePosterModeUI_() {
                    (this.tech_ && this.tech_).hide(), this.addClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange")
                }
                disablePosterModeUI_() {
                    (this.tech_ && this.tech_).show(), this.removeClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange")
                }
                audioPosterMode(e) {
                    if ("boolean" != typeof e || e === this.audioPosterMode_) return this.audioPosterMode_;
                    if (this.audioPosterMode_ = e, e) {
                        if (this.audioOnlyMode()) {
                            return this.audioOnlyMode(!1).then((() => {
                                this.enablePosterModeUI_()
                            }))
                        }
                        return Promise.resolve().then((() => {
                            this.enablePosterModeUI_()
                        }))
                    }
                    return Promise.resolve().then((() => {
                        this.disablePosterModeUI_()
                    }))
                }
                addTextTrack(e, t, i) {
                    if (this.tech_) return this.tech_.addTextTrack(e, t, i)
                }
                addRemoteTextTrack(e, t) {
                    if (this.tech_) return this.tech_.addRemoteTextTrack(e, t)
                }
                removeRemoteTextTrack(e = {}) {
                    let {
                        track: t
                    } = e;
                    if (t || (t = e), this.tech_) return this.tech_.removeRemoteTextTrack(t)
                }
                getVideoPlaybackQuality() {
                    return this.techGet_("getVideoPlaybackQuality")
                }
                videoWidth() {
                    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0
                }
                videoHeight() {
                    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0
                }
                language(e) {
                    if (void 0 === e) return this.language_;
                    this.language_ !== String(e).toLowerCase() && (this.language_ = String(e).toLowerCase(), wn(this) && this.trigger("languagechange"))
                }
                languages() {
                    return jt(fa.prototype.options_.languages, this.languages_)
                }
                toJSON() {
                    const e = jt(this.options_),
                        t = e.tracks;
                    e.tracks = [];
                    for (let i = 0; i < t.length; i++) {
                        let n = t[i];
                        n = jt(n), n.player = void 0, e.tracks[i] = n
                    }
                    return e
                }
                createModal(e, t) {
                    (t = t || {}).content = e || "";
                    const i = new ir(this, t);
                    return this.addChild(i), i.on("dispose", (() => {
                        this.removeChild(i)
                    })), i.open(), i
                }
                updateCurrentBreakpoint_() {
                    if (!this.responsive()) return;
                    const e = this.currentBreakpoint(),
                        t = this.currentWidth();
                    for (let i = 0; i < ua.length; i++) {
                        const n = ua[i];
                        if (t <= this.breakpoints_[n]) {
                            if (e === n) return;
                            e && this.removeClass(da[e]), this.addClass(da[n]), this.breakpoint_ = n;
                            break
                        }
                    }
                }
                removeCurrentBreakpoint_() {
                    const e = this.currentBreakpointClass();
                    this.breakpoint_ = "", e && this.removeClass(e)
                }
                breakpoints(e) {
                    return void 0 === e || (this.breakpoint_ = "", this.breakpoints_ = Object.assign({}, pa, e), this.updateCurrentBreakpoint_()), Object.assign(this.breakpoints_)
                }
                responsive(e) {
                    if (void 0 === e) return this.responsive_;
                    return (e = Boolean(e)) !== this.responsive_ ? (this.responsive_ = e, e ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_), this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_), this.removeCurrentBreakpoint_()), e) : void 0
                }
                currentBreakpoint() {
                    return this.breakpoint_
                }
                currentBreakpointClass() {
                    return da[this.breakpoint_] || ""
                }
                loadMedia(e, t) {
                    if (!e || "object" != typeof e) return;
                    this.reset(), this.cache_.media = jt(e);
                    const {
                        artist: i,
                        artwork: n,
                        description: r,
                        poster: s,
                        src: a,
                        textTracks: o,
                        title: l
                    } = this.cache_.media;
                    !n && s && (this.cache_.media.artwork = [{
                        src: s,
                        type: Fr(s)
                    }]), a && this.src(a), s && this.poster(s), Array.isArray(o) && o.forEach((e => this.addRemoteTextTrack(e, !1))), this.titleBar && this.titleBar.update({
                        title: l,
                        description: r || i || ""
                    }), this.ready(t)
                }
                getMedia() {
                    if (!this.cache_.media) {
                        const e = this.poster(),
                            t = {
                                src: this.currentSources(),
                                textTracks: Array.prototype.map.call(this.remoteTextTracks(), (e => ({
                                    kind: e.kind,
                                    label: e.label,
                                    language: e.language,
                                    src: e.src
                                })))
                            };
                        return e && (t.poster = e, t.artwork = [{
                            src: t.poster,
                            type: Fr(t.poster)
                        }]), t
                    }
                    return jt(this.cache_.media)
                }
                static getTagSettings(e) {
                    const t = {
                            sources: [],
                            tracks: []
                        },
                        i = Ci(e),
                        n = i["data-setup"];
                    if (xi(e, "vjs-fill") && (i.fill = !0), xi(e, "vjs-fluid") && (i.fluid = !0), null !== n) {
                        const [e, t] = c()(n || "{}");
                        e && Ut.error(e), Object.assign(i, t)
                    }
                    if (Object.assign(t, i), e.hasChildNodes()) {
                        const i = e.childNodes;
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e],
                                r = n.nodeName.toLowerCase();
                            "source" === r ? t.sources.push(Ci(n)) : "track" === r && t.tracks.push(Ci(n))
                        }
                    }
                    return t
                }
                debug(e) {
                    if (void 0 === e) return this.debugEnabled_;
                    e ? (this.trigger("debugon"), this.previousLogLevel_ = this.log.level, this.log.level("debug"), this.debugEnabled_ = !0) : (this.trigger("debugoff"), this.log.level(this.previousLogLevel_), this.previousLogLevel_ = void 0, this.debugEnabled_ = !1)
                }
                playbackRates(e) {
                    if (void 0 === e) return this.cache_.playbackRates;
                    Array.isArray(e) && e.every((e => "number" == typeof e)) && (this.cache_.playbackRates = e, this.trigger("playbackrateschange"))
                }
            }
            Mr.names.forEach((function(e) {
                const t = Mr[e];
                fa.prototype[t.getterName] = function() {
                    return this.tech_ ? this.tech_[t.getterName]() : (this[t.privateName] = this[t.privateName] || new t.ListClass, this[t.privateName])
                }
            })), fa.prototype.crossorigin = fa.prototype.crossOrigin, fa.players = {};
            const ma = r().navigator;
            fa.prototype.options_ = {
                techOrder: Cr.defaultTechOrder_,
                html5: {},
                enableSourceset: !0,
                inactivityTimeout: 2e3,
                playbackRates: [],
                liveui: !1,
                children: ["mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
                language: ma && (ma.languages && ma.languages[0] || ma.userLanguage || ma.language) || "en",
                languages: {},
                notSupportedMessage: "No compatible source was found for this media.",
                normalizeAutoplay: !1,
                fullscreen: {
                    options: {
                        navigationUI: "hide"
                    }
                },
                breakpoints: {},
                responsive: !1,
                audioOnlyMode: !1,
                audioPosterMode: !1
            }, ["ended", "seeking", "seekable", "networkState", "readyState"].forEach((function(e) {
                fa.prototype[e] = function() {
                    return this.techGet_(e)
                }
            })), ha.forEach((function(e) {
                fa.prototype[`handleTech${On(e)}_`] = function() {
                    return this.trigger(e)
                }
            })), Bn.registerComponent("Player", fa);
            const ga = "plugin",
                ya = "activePlugins_",
                _a = {},
                va = e => _a.hasOwnProperty(e),
                ba = e => va(e) ? _a[e] : void 0,
                Ta = (e, t) => {
                    e[ya] = e[ya] || {}, e[ya][t] = !0
                },
                xa = (e, t, i) => {
                    const n = (i ? "before" : "") + "pluginsetup";
                    e.trigger(n, t), e.trigger(n + ":" + t.name, t)
                },
                wa = (e, t) => (t.prototype.name = e, function(...i) {
                    xa(this, {
                        name: e,
                        plugin: t,
                        instance: null
                    }, !0);
                    const n = new t(...[this, ...i]);
                    return this[e] = () => n, xa(this, n.getEventHash()), n
                });
            class Sa {
                constructor(e) {
                    if (this.constructor === Sa) throw new Error("Plugin must be sub-classed; not directly instantiated.");
                    this.player = e, this.log || (this.log = this.player.log.createLogger(this.name)), Pn(this), delete this.trigger, kn(this, this.constructor.defaultState), Ta(e, this.name), this.dispose = this.dispose.bind(this), e.on("dispose", this.dispose)
                }
                version() {
                    return this.constructor.VERSION
                }
                getEventHash(e = {}) {
                    return e.name = this.name, e.plugin = this.constructor, e.instance = this, e
                }
                trigger(e, t = {}) {
                    return un(this.eventBusEl_, e, this.getEventHash(t))
                }
                handleStateChanged(e) {}
                dispose() {
                    const {
                        name: e,
                        player: t
                    } = this;
                    this.trigger("dispose"), this.off(), t.off("dispose", this.dispose), t[ya][e] = !1, this.player = this.state = null, t[e] = wa(e, _a[e])
                }
                static isBasic(e) {
                    const t = "string" == typeof e ? ba(e) : e;
                    return "function" == typeof t && !Sa.prototype.isPrototypeOf(t.prototype)
                }
                static registerPlugin(e, t) {
                    if ("string" != typeof e) throw new Error(`Illegal plugin name, "${e}", must be a string, was ${typeof e}.`);
                    if (va(e)) Ut.warn(`A plugin named "${e}" already exists. You may want to avoid re-registering plugins!`);
                    else if (fa.prototype.hasOwnProperty(e)) throw new Error(`Illegal plugin name, "${e}", cannot share a name with an existing player method!`);
                    if ("function" != typeof t) throw new Error(`Illegal plugin for "${e}", must be a function, was ${typeof t}.`);
                    return _a[e] = t, e !== ga && (Sa.isBasic(t) ? fa.prototype[e] = function(e, t) {
                        const i = function() {
                            xa(this, {
                                name: e,
                                plugin: t,
                                instance: null
                            }, !0);
                            const i = t.apply(this, arguments);
                            return Ta(this, e), xa(this, {
                                name: e,
                                plugin: t,
                                instance: i
                            }), i
                        };
                        return Object.keys(t).forEach((function(e) {
                            i[e] = t[e]
                        })), i
                    }(e, t) : fa.prototype[e] = wa(e, t)), t
                }
                static deregisterPlugin(e) {
                    if (e === ga) throw new Error("Cannot de-register base plugin.");
                    va(e) && (delete _a[e], delete fa.prototype[e])
                }
                static getPlugins(e = Object.keys(_a)) {
                    let t;
                    return e.forEach((e => {
                        const i = ba(e);
                        i && (t = t || {}, t[e] = i)
                    })), t
                }
                static getPluginVersion(e) {
                    const t = ba(e);
                    return t && t.VERSION || ""
                }
            }

            function Ea(e, t, i, n) {
                return function(e, t) {
                    let i = !1;
                    return function(...n) {
                        return i || Ut.warn(e), i = !0, t.apply(this, n)
                    }
                }(`${t} is deprecated and will be removed in ${e}.0; please use ${i} instead.`, n)
            }
            Sa.getPlugin = ba, Sa.BASE_PLUGIN_NAME = ga, Sa.registerPlugin(ga, Sa), fa.prototype.usingPlugin = function(e) {
                return !!this[ya] && !0 === this[ya][e]
            }, fa.prototype.hasPlugin = function(e) {
                return !!va(e)
            };
            const Ma = e => 0 === e.indexOf("#") ? e.slice(1) : e;

            function Ca(e, t, i) {
                let n = Ca.getPlayer(e);
                if (n) return t && Ut.warn(`Player "${e}" is already initialised. Options will not be applied.`), i && n.ready(i), n;
                const r = "string" == typeof e ? Vi("#" + Ma(e)) : e;
                if (!gi(r)) throw new TypeError("The element or ID supplied is not valid. (videojs)");
                r.ownerDocument.defaultView && r.ownerDocument.body.contains(r) || Ut.warn("The element supplied is not included in the DOM"), !0 === (t = t || {}).restoreEl && (t.restoreEl = (r.parentNode && r.parentNode.hasAttribute("data-vjs-player") ? r.parentNode : r).cloneNode(!0)), Lt("beforesetup").forEach((e => {
                    const i = e(r, jt(t));
                    Gt(i) && !Array.isArray(i) ? t = jt(t, i) : Ut.error("please return an object in beforesetup hooks")
                }));
                const s = Bn.getComponent("Player");
                return n = new s(r, t, i), Lt("setup").forEach((e => e(n))), n
            }
            if (Ca.hooks_ = At, Ca.hooks = Lt, Ca.hook = function(e, t) {
                    Lt(e, t)
                }, Ca.hookOnce = function(e, t) {
                    Lt(e, [].concat(t).map((t => {
                        const i = (...n) => (It(e, i), t(...n));
                        return i
                    })))
                }, Ca.removeHook = It, !0 !== r().VIDEOJS_NO_DYNAMIC_STYLE && mi()) {
                let e = Vi(".vjs-styles-defaults");
                if (!e) {
                    e = Ji("vjs-styles-defaults");
                    const t = Vi("head");
                    t && t.insertBefore(e, t.firstChild), Zi(e, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    ")
                }
            }
            Yi(1, Ca), Ca.VERSION = Ct, Ca.options = fa.prototype.options_, Ca.getPlayers = () => fa.players, Ca.getPlayer = e => {
                const t = fa.players;
                let i;
                if ("string" == typeof e) {
                    const n = Ma(e),
                        r = t[n];
                    if (r) return r;
                    i = Vi("#" + n)
                } else i = e;
                if (gi(i)) {
                    const {
                        player: e,
                        playerId: n
                    } = i;
                    if (e || t[n]) return e || t[n]
                }
            }, Ca.getAllPlayers = () => Object.keys(fa.players).map((e => fa.players[e])).filter(Boolean), Ca.players = fa.players, Ca.getComponent = Bn.getComponent, Ca.registerComponent = (e, t) => {
                Cr.isTech(t) && Ut.warn(`The ${e} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`), Bn.registerComponent.call(Bn, e, t)
            }, Ca.getTech = Cr.getTech, Ca.registerTech = Cr.registerTech, Ca.use = function(e, t) {
                Ar[e] = Ar[e] || [], Ar[e].push(t)
            }, Object.defineProperty(Ca, "middleware", {
                value: {},
                writeable: !1,
                enumerable: !0
            }), Object.defineProperty(Ca.middleware, "TERMINATOR", {
                value: Ir,
                writeable: !1,
                enumerable: !0
            }), Ca.browser = pi, Ca.obj = $t, Ca.mergeOptions = Ea(9, "videojs.mergeOptions", "videojs.obj.merge", jt), Ca.defineLazyProperty = Ea(9, "videojs.defineLazyProperty", "videojs.obj.defineLazyProperty", qt), Ca.bind = Ea(9, "videojs.bind", "native Function.prototype.bind", gn), Ca.registerPlugin = Sa.registerPlugin, Ca.deregisterPlugin = Sa.deregisterPlugin, Ca.plugin = (e, t) => (Ut.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead"), Sa.registerPlugin(e, t)), Ca.getPlugins = Sa.getPlugins, Ca.getPlugin = Sa.getPlugin, Ca.getPluginVersion = Sa.getPluginVersion, Ca.addLanguage = function(e, t) {
                return e = ("" + e).toLowerCase(), Ca.options.languages = jt(Ca.options.languages, {
                    [e]: t
                }), Ca.options.languages[e]
            }, Ca.log = Ut, Ca.createLogger = Bt, Ca.time = $n, Ca.createTimeRange = Ea(9, "videojs.createTimeRange", "videojs.time.createTimeRanges", zn), Ca.createTimeRanges = Ea(9, "videojs.createTimeRanges", "videojs.time.createTimeRanges", zn), Ca.formatTime = Ea(9, "videojs.formatTime", "videojs.time.formatTime", qn), Ca.setFormatTime = Ea(9, "videojs.setFormatTime", "videojs.time.setFormatTime", Wn), Ca.resetFormatTime = Ea(9, "videojs.resetFormatTime", "videojs.time.resetFormatTime", jn), Ca.parseUrl = Ea(9, "videojs.parseUrl", "videojs.url.parseUrl", pr), Ca.isCrossOrigin = Ea(9, "videojs.isCrossOrigin", "videojs.url.isCrossOrigin", gr), Ca.EventTarget = Tn, Ca.any = pn, Ca.on = hn, Ca.one = dn, Ca.off = cn, Ca.trigger = un, Ca.xhr = d(), Ca.TextTrack = br, Ca.AudioTrack = Tr, Ca.VideoTrack = xr, ["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach((e => {
                Ca[e] = function() {
                    return Ut.warn(`videojs.${e}() is deprecated; use videojs.dom.${e}() instead`), ji[e].apply(null, arguments)
                }
            })), Ca.computedStyle = Ea(9, "videojs.computedStyle", "videojs.dom.computedStyle", Wi), Ca.dom = ji, Ca.fn = vn, Ca.num = rs, Ca.str = Un, Ca.url = yr;
            class Aa {
                constructor(e) {
                    let t = this;
                    return t.id = e.id, t.label = t.id, t.width = e.width, t.height = e.height, t.bitrate = e.bandwidth, t.frameRate = e.frameRate, t.enabled_ = e.enabled, Object.defineProperty(t, "enabled", {
                        get: () => t.enabled_(),
                        set(e) {
                            t.enabled_(e)
                        }
                    }), t
                }
            }
            class La extends Ca.EventTarget {
                constructor() {
                    super();
                    let e = this;
                    return e.levels_ = [], e.selectedIndex_ = -1, Object.defineProperty(e, "selectedIndex", {
                        get: () => e.selectedIndex_
                    }), Object.defineProperty(e, "length", {
                        get: () => e.levels_.length
                    }), e
                }
                addQualityLevel(e) {
                    let t = this.getQualityLevelById(e.id);
                    if (t) return t;
                    const i = this.levels_.length;
                    return t = new Aa(e), "" + i in this || Object.defineProperty(this, i, {
                        get() {
                            return this.levels_[i]
                        }
                    }), this.levels_.push(t), this.trigger({
                        qualityLevel: t,
                        type: "addqualitylevel"
                    }), t
                }
                removeQualityLevel(e) {
                    let t = null;
                    for (let i = 0, n = this.length; i < n; i++)
                        if (this[i] === e) {
                            t = this.levels_.splice(i, 1)[0], this.selectedIndex_ === i ? this.selectedIndex_ = -1 : this.selectedIndex_ > i && this.selectedIndex_--;
                            break
                        }
                    return t && this.trigger({
                        qualityLevel: e,
                        type: "removequalitylevel"
                    }), t
                }
                getQualityLevelById(e) {
                    for (let t = 0, i = this.length; t < i; t++) {
                        const i = this[t];
                        if (i.id === e) return i
                    }
                    return null
                }
                dispose() {
                    this.selectedIndex_ = -1, this.levels_.length = 0
                }
            }
            La.prototype.allowedEvents_ = {
                change: "change",
                addqualitylevel: "addqualitylevel",
                removequalitylevel: "removequalitylevel"
            };
            for (const e in La.prototype.allowedEvents_) La.prototype["on" + e] = null;
            var Ia = "3.0.0";
            const Pa = Ca.registerPlugin || Ca.plugin,
                Ra = function(e) {
                    return function(e, t) {
                        const i = e.qualityLevels,
                            n = new La,
                            r = function() {
                                n.dispose(), e.qualityLevels = i, e.off("dispose", r)
                            };
                        return e.on("dispose", r), e.qualityLevels = () => n, e.qualityLevels.VERSION = Ia, n
                    }(this, Ca.mergeOptions({}, e))
                };
            Pa("qualityLevels", Ra), Ra.VERSION = Ia;
            const ka = _,
                Da = (e, t) => t && t.responseURL && e !== t.responseURL ? t.responseURL : e,
                Oa = e => Ca.log.debug ? Ca.log.debug.bind(Ca, "VHS:", `${e} >`) : function() {};

            function Na(...e) {
                const t = Ca.obj || Ca;
                return (t.merge || t.mergeOptions).apply(t, e)
            }

            function Ua(...e) {
                const t = Ca.time || Ca;
                return (t.createTimeRanges || t.createTimeRanges).apply(t, e)
            }
            const Ba = 1 / 30,
                Fa = .1,
                Ha = function(e, t) {
                    const i = [];
                    let n;
                    if (e && e.length)
                        for (n = 0; n < e.length; n++) t(e.start(n), e.end(n)) && i.push([e.start(n), e.end(n)]);
                    return Ua(i)
                },
                za = function(e, t) {
                    return Ha(e, (function(e, i) {
                        return e - Fa <= t && i + Fa >= t
                    }))
                },
                Va = function(e, t) {
                    return Ha(e, (function(e) {
                        return e - Ba >= t
                    }))
                },
                Ga = e => {
                    const t = [];
                    if (!e || !e.length) return "";
                    for (let i = 0; i < e.length; i++) t.push(e.start(i) + " => " + e.end(i));
                    return t.join(", ")
                },
                Wa = e => {
                    const t = [];
                    for (let i = 0; i < e.length; i++) t.push({
                        start: e.start(i),
                        end: e.end(i)
                    });
                    return t
                },
                ja = function(e) {
                    if (e && e.length && e.end) return e.end(e.length - 1)
                },
                qa = function(e, t) {
                    let i = 0;
                    if (!e || !e.length) return i;
                    for (let n = 0; n < e.length; n++) {
                        const r = e.start(n),
                            s = e.end(n);
                        t > s || (i += t > r && t <= s ? s - t : s - r)
                    }
                    return i
                },
                $a = (e, t) => {
                    if (!t.preload) return t.duration;
                    let i = 0;
                    return (t.parts || []).forEach((function(e) {
                        i += e.duration
                    })), (t.preloadHints || []).forEach((function(t) {
                        "PART" === t.type && (i += e.partTargetDuration)
                    })), i
                },
                Xa = e => (e.segments || []).reduce(((e, t, i) => (t.parts ? t.parts.forEach((function(n, r) {
                    e.push({
                        duration: n.duration,
                        segmentIndex: i,
                        partIndex: r,
                        part: n,
                        segment: t
                    })
                })) : e.push({
                    duration: t.duration,
                    segmentIndex: i,
                    partIndex: null,
                    segment: t,
                    part: null
                }), e)), []),
                Ya = e => {
                    const t = e.segments && e.segments.length && e.segments[e.segments.length - 1];
                    return t && t.parts || []
                },
                Ka = ({
                    preloadSegment: e
                }) => {
                    if (!e) return;
                    const {
                        parts: t,
                        preloadHints: i
                    } = e;
                    let n = (i || []).reduce(((e, t) => e + ("PART" === t.type ? 1 : 0)), 0);
                    return n += t && t.length ? t.length : 0, n
                },
                Ja = (e, t) => {
                    if (t.endList) return 0;
                    if (e && e.suggestedPresentationDelay) return e.suggestedPresentationDelay;
                    const i = Ya(t).length > 0;
                    return i && t.serverControl && t.serverControl.partHoldBack ? t.serverControl.partHoldBack : i && t.partTargetDuration ? 3 * t.partTargetDuration : t.serverControl && t.serverControl.holdBack ? t.serverControl.holdBack : t.targetDuration ? 3 * t.targetDuration : 0
                },
                Za = function(e, t, i) {
                    if (void 0 === t && (t = e.mediaSequence + e.segments.length), t < e.mediaSequence) return 0;
                    const n = function(e, t) {
                        let i = 0,
                            n = t - e.mediaSequence,
                            r = e.segments[n];
                        if (r) {
                            if (void 0 !== r.start) return {
                                result: r.start,
                                precise: !0
                            };
                            if (void 0 !== r.end) return {
                                result: r.end - r.duration,
                                precise: !0
                            }
                        }
                        for (; n--;) {
                            if (r = e.segments[n], void 0 !== r.end) return {
                                result: i + r.end,
                                precise: !0
                            };
                            if (i += $a(e, r), void 0 !== r.start) return {
                                result: i + r.start,
                                precise: !0
                            }
                        }
                        return {
                            result: i,
                            precise: !1
                        }
                    }(e, t);
                    if (n.precise) return n.result;
                    const r = function(e, t) {
                        let i, n = 0,
                            r = t - e.mediaSequence;
                        for (; r < e.segments.length; r++) {
                            if (i = e.segments[r], void 0 !== i.start) return {
                                result: i.start - n,
                                precise: !0
                            };
                            if (n += $a(e, i), void 0 !== i.end) return {
                                result: i.end - n,
                                precise: !0
                            }
                        }
                        return {
                            result: -1,
                            precise: !1
                        }
                    }(e, t);
                    return r.precise ? r.result : n.result + i
                },
                Qa = function(e, t, i) {
                    if (!e) return 0;
                    if ("number" != typeof i && (i = 0), void 0 === t) {
                        if (e.totalDuration) return e.totalDuration;
                        if (!e.endList) return r()[1 / 0]
                    }
                    return Za(e, t, i)
                },
                eo = function({
                    defaultDuration: e,
                    durationList: t,
                    startIndex: i,
                    endIndex: n
                }) {
                    let r = 0;
                    if (i > n && ([i, n] = [n, i]), i < 0) {
                        for (let t = i; t < Math.min(0, n); t++) r += e;
                        i = 0
                    }
                    for (let e = i; e < n; e++) r += t[e].duration;
                    return r
                },
                to = function(e, t, i, n) {
                    if (!e || !e.segments) return null;
                    if (e.endList) return Qa(e);
                    if (null === t) return null;
                    t = t || 0;
                    let r = Za(e, e.mediaSequence + e.segments.length, t);
                    return i && (r -= n = "number" == typeof n ? n : Ja(null, e)), Math.max(0, r)
                },
                io = function(e) {
                    return e.excludeUntil && e.excludeUntil > Date.now()
                },
                no = function(e) {
                    return e.excludeUntil && e.excludeUntil === 1 / 0
                },
                ro = function(e) {
                    const t = io(e);
                    return !e.disabled && !t
                },
                so = function(e, t) {
                    return t.attributes && t.attributes[e]
                },
                ao = (e, t) => {
                    if (1 === e.playlists.length) return !0;
                    const i = t.attributes.BANDWIDTH || Number.MAX_VALUE;
                    return 0 === e.playlists.filter((e => !!ro(e) && (e.attributes.BANDWIDTH || 0) < i)).length
                },
                oo = (e, t) => !(!e && !t || !e && t || e && !t) && (e === t || (!(!e.id || !t.id || e.id !== t.id) || (!(!e.resolvedUri || !t.resolvedUri || e.resolvedUri !== t.resolvedUri) || !(!e.uri || !t.uri || e.uri !== t.uri)))),
                lo = function(e, t) {
                    const i = e && e.mediaGroups && e.mediaGroups.AUDIO || {};
                    let n = !1;
                    for (const e in i) {
                        for (const r in i[e])
                            if (n = t(i[e][r]), n) break;
                        if (n) break
                    }
                    return !!n
                },
                ho = e => {
                    if (!e || !e.playlists || !e.playlists.length) {
                        return lo(e, (e => e.playlists && e.playlists.length || e.uri))
                    }
                    for (let t = 0; t < e.playlists.length; t++) {
                        const i = e.playlists[t],
                            n = i.attributes && i.attributes.CODECS;
                        if (n && n.split(",").every((e => F(e)))) continue;
                        if (!lo(e, (e => oo(i, e)))) return !1
                    }
                    return !0
                };
            var co = {
                liveEdgeDelay: Ja,
                duration: Qa,
                seekable: function(e, t, i) {
                    const n = t || 0,
                        r = to(e, t, !0, i);
                    return null === r ? Ua() : Ua(n, r)
                },
                getMediaInfoForTime: function({
                    playlist: e,
                    currentTime: t,
                    startingSegmentIndex: i,
                    startingPartIndex: n,
                    startTime: r,
                    exactManifestTimings: s
                }) {
                    let a = t - r;
                    const o = Xa(e);
                    let l = 0;
                    for (let e = 0; e < o.length; e++) {
                        const t = o[e];
                        if (i === t.segmentIndex && ("number" != typeof n || "number" != typeof t.partIndex || n === t.partIndex)) {
                            l = e;
                            break
                        }
                    }
                    if (a < 0) {
                        if (l > 0)
                            for (let t = l - 1; t >= 0; t--) {
                                const i = o[t];
                                if (a += i.duration, s) {
                                    if (a < 0) continue
                                } else if (a + Ba <= 0) continue;
                                return {
                                    partIndex: i.partIndex,
                                    segmentIndex: i.segmentIndex,
                                    startTime: r - eo({
                                        defaultDuration: e.targetDuration,
                                        durationList: o,
                                        startIndex: l,
                                        endIndex: t
                                    })
                                }
                            }
                        return {
                            partIndex: o[0] && o[0].partIndex || null,
                            segmentIndex: o[0] && o[0].segmentIndex || 0,
                            startTime: t
                        }
                    }
                    if (l < 0) {
                        for (let i = l; i < 0; i++)
                            if (a -= e.targetDuration, a < 0) return {
                                partIndex: o[0] && o[0].partIndex || null,
                                segmentIndex: o[0] && o[0].segmentIndex || 0,
                                startTime: t
                            };
                        l = 0
                    }
                    for (let t = l; t < o.length; t++) {
                        const i = o[t];
                        if (a -= i.duration, s) {
                            if (a > 0) continue
                        } else if (a - Ba >= 0) continue;
                        return {
                            partIndex: i.partIndex,
                            segmentIndex: i.segmentIndex,
                            startTime: r + eo({
                                defaultDuration: e.targetDuration,
                                durationList: o,
                                startIndex: l,
                                endIndex: t
                            })
                        }
                    }
                    return {
                        segmentIndex: o[o.length - 1].segmentIndex,
                        partIndex: o[o.length - 1].partIndex,
                        startTime: t
                    }
                },
                isEnabled: ro,
                isDisabled: function(e) {
                    return e.disabled
                },
                isExcluded: io,
                isIncompatible: no,
                playlistEnd: to,
                isAes: function(e) {
                    for (let t = 0; t < e.segments.length; t++)
                        if (e.segments[t].key) return !0;
                    return !1
                },
                hasAttribute: so,
                estimateSegmentRequestTime: function(e, t, i, n = 0) {
                    if (!so("BANDWIDTH", i)) return NaN;
                    return (e * i.attributes.BANDWIDTH - 8 * n) / t
                },
                isLowestEnabledRendition: ao,
                isAudioOnly: ho,
                playlistMatch: oo,
                segmentDurationWithParts: $a
            };
            const {
                log: uo
            } = Ca, po = (e, t) => `${e}-${t}`, fo = (e, t) => {
                e.mediaGroups && ["AUDIO", "SUBTITLES"].forEach((i => {
                    if (e.mediaGroups[i])
                        for (const n in e.mediaGroups[i])
                            for (const r in e.mediaGroups[i][n]) {
                                const s = e.mediaGroups[i][n][r];
                                t(s, i, n, r)
                            }
                }))
            }, mo = ({
                playlist: e,
                uri: t,
                id: i
            }) => {
                e.id = i, e.playlistErrors_ = 0, t && (e.uri = t), e.attributes = e.attributes || {}
            }, go = (e, t) => {
                e.uri = t;
                for (let t = 0; t < e.playlists.length; t++)
                    if (!e.playlists[t].uri) {
                        const i = `placeholder-uri-${t}`;
                        e.playlists[t].uri = i
                    }
                const i = ho(e);
                fo(e, ((t, n, r, s) => {
                    const a = `placeholder-uri-${n}-${r}-${s}`;
                    if (!t.playlists || !t.playlists.length) {
                        if (i && "AUDIO" === n && !t.uri)
                            for (let t = 0; t < e.playlists.length; t++) {
                                const i = e.playlists[t];
                                if (i.attributes && i.attributes.AUDIO && i.attributes.AUDIO === r) return
                            }
                        t.playlists = [v({}, t)]
                    }
                    t.playlists.forEach((function(t, i) {
                        const n = po(i, a);
                        t.uri ? t.resolvedUri = t.resolvedUri || ka(e.uri, t.uri) : (t.uri = 0 === i ? a : n, t.resolvedUri = t.uri), t.id = t.id || n, t.attributes = t.attributes || {}, e.playlists[t.id] = t, e.playlists[t.uri] = t
                    }))
                })), (e => {
                    let t = e.playlists.length;
                    for (; t--;) {
                        const i = e.playlists[t];
                        mo({
                            playlist: i,
                            id: po(t, i.uri)
                        }), i.resolvedUri = ka(e.uri, i.uri), e.playlists[i.id] = i, e.playlists[i.uri] = i, i.attributes.BANDWIDTH || uo.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.")
                    }
                })(e), (e => {
                    fo(e, (t => {
                        t.uri && (t.resolvedUri = ka(e.uri, t.uri))
                    }))
                })(e)
            }, {
                EventTarget: yo
            } = Ca, _o = (e, t) => {
                if (!e) return t;
                const i = Na(e, t);
                if (e.preloadHints && !t.preloadHints && delete i.preloadHints, e.parts && !t.parts) delete i.parts;
                else if (e.parts && t.parts)
                    for (let n = 0; n < t.parts.length; n++) e.parts && e.parts[n] && (i.parts[n] = Na(e.parts[n], t.parts[n]));
                return !e.skipped && t.skipped && (i.skipped = !1), e.preload && !t.preload && (i.preload = !1), i
            }, vo = (e, t) => {
                !e.resolvedUri && e.uri && (e.resolvedUri = ka(t, e.uri)), e.key && !e.key.resolvedUri && (e.key.resolvedUri = ka(t, e.key.uri)), e.map && !e.map.resolvedUri && (e.map.resolvedUri = ka(t, e.map.uri)), e.map && e.map.key && !e.map.key.resolvedUri && (e.map.key.resolvedUri = ka(t, e.map.key.uri)), e.parts && e.parts.length && e.parts.forEach((e => {
                    e.resolvedUri || (e.resolvedUri = ka(t, e.uri))
                })), e.preloadHints && e.preloadHints.length && e.preloadHints.forEach((e => {
                    e.resolvedUri || (e.resolvedUri = ka(t, e.uri))
                }))
            }, bo = function(e) {
                const t = e.segments || [],
                    i = e.preloadSegment;
                if (i && i.parts && i.parts.length) {
                    if (i.preloadHints)
                        for (let e = 0; e < i.preloadHints.length; e++)
                            if ("MAP" === i.preloadHints[e].type) return t;
                    i.duration = e.targetDuration, i.preload = !0, t.push(i)
                }
                return t
            }, To = (e, t) => e === t || e.segments && t.segments && e.segments.length === t.segments.length && e.endList === t.endList && e.mediaSequence === t.mediaSequence && e.preloadSegment === t.preloadSegment, xo = (e, t, i = To) => {
                const n = Na(e, {}),
                    r = n.playlists[t.id];
                if (!r) return null;
                if (i(r, t)) return null;
                t.segments = bo(t);
                const s = Na(r, t);
                if (s.preloadSegment && !t.preloadSegment && delete s.preloadSegment, r.segments) {
                    if (t.skip) {
                        t.segments = t.segments || [];
                        for (let e = 0; e < t.skip.skippedSegments; e++) t.segments.unshift({
                            skipped: !0
                        })
                    }
                    s.segments = ((e, t, i) => {
                        const n = e.slice(),
                            r = t.slice();
                        i = i || 0;
                        const s = [];
                        let a;
                        for (let e = 0; e < r.length; e++) {
                            const t = n[e + i],
                                o = r[e];
                            t ? (a = t.map || a, s.push(_o(t, o))) : (a && !o.map && (o.map = a), s.push(o))
                        }
                        return s
                    })(r.segments, t.segments, t.mediaSequence - r.mediaSequence)
                }
                s.segments.forEach((e => {
                    vo(e, s.resolvedUri)
                }));
                for (let e = 0; e < n.playlists.length; e++) n.playlists[e].id === t.id && (n.playlists[e] = s);
                return n.playlists[t.id] = s, n.playlists[t.uri] = s, fo(e, ((e, i, n, r) => {
                    if (e.playlists)
                        for (let i = 0; i < e.playlists.length; i++) t.id === e.playlists[i].id && (e.playlists[i] = s)
                })), n
            }, wo = (e, t) => {
                const i = e.segments || [],
                    n = i[i.length - 1],
                    r = n && n.parts && n.parts[n.parts.length - 1],
                    s = r && r.duration || n && n.duration;
                return t && s ? 1e3 * s : 500 * (e.partTargetDuration || e.targetDuration || 10)
            };
            class So extends yo {
                constructor(e, t, i = {}) {
                    if (super(), !e) throw new Error("A non-empty playlist URL or object is required");
                    this.logger_ = Oa("PlaylistLoader");
                    const {
                        withCredentials: n = !1
                    } = i;
                    this.src = e, this.vhs_ = t, this.withCredentials = n;
                    const r = t.options_;
                    this.customTagParsers = r && r.customTagParsers || [], this.customTagMappers = r && r.customTagMappers || [], this.llhls = r && r.llhls, this.state = "HAVE_NOTHING", this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this), this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_)
                }
                handleMediaupdatetimeout_() {
                    if ("HAVE_METADATA" !== this.state) return;
                    const e = this.media();
                    let t = ka(this.main.uri, e.uri);
                    this.llhls && (t = ((e, t) => {
                        if (t.endList || !t.serverControl) return e;
                        const i = {};
                        if (t.serverControl.canBlockReload) {
                            const {
                                preloadSegment: e
                            } = t;
                            let n = t.mediaSequence + t.segments.length;
                            if (e) {
                                const r = e.parts || [],
                                    s = Ka(t) - 1;
                                s > -1 && s !== r.length - 1 && (i._HLS_part = s), (s > -1 || r.length) && n--
                            }
                            i._HLS_msn = n
                        }
                        if (t.serverControl && t.serverControl.canSkipUntil && (i._HLS_skip = t.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(i).length) {
                            const t = new(r().URL)(e);
                            ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach((function(e) {
                                i.hasOwnProperty(e) && t.searchParams.set(e, i[e])
                            })), e = t.toString()
                        }
                        return e
                    })(t, e)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr({
                        uri: t,
                        withCredentials: this.withCredentials
                    }, ((e, t) => {
                        if (this.request) return e ? this.playlistRequestError(this.request, this.media(), "HAVE_METADATA") : void this.haveMetadata({
                            playlistString: this.request.responseText,
                            url: this.media().uri,
                            id: this.media().id
                        })
                    }))
                }
                playlistRequestError(e, t, i) {
                    const {
                        uri: n,
                        id: r
                    } = t;
                    this.request = null, i && (this.state = i), this.error = {
                        playlist: this.main.playlists[r],
                        status: e.status,
                        message: `HLS playlist request error at URL: ${n}.`,
                        responseText: e.responseText,
                        code: e.status >= 500 ? 4 : 2
                    }, this.trigger("error")
                }
                parseManifest_({
                    url: e,
                    manifestString: t
                }) {
                    return (({
                        onwarn: e,
                        oninfo: t,
                        manifestString: i,
                        customTagParsers: n = [],
                        customTagMappers: r = [],
                        llhls: s
                    }) => {
                        const a = new P;
                        e && a.on("warn", e), t && a.on("info", t), n.forEach((e => a.addParser(e))), r.forEach((e => a.addTagMapper(e))), a.push(i), a.end();
                        const o = a.manifest;
                        if (s || (["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach((function(e) {
                                o.hasOwnProperty(e) && delete o[e]
                            })), o.segments && o.segments.forEach((function(e) {
                                ["parts", "preloadHints"].forEach((function(t) {
                                    e.hasOwnProperty(t) && delete e[t]
                                }))
                            }))), !o.targetDuration) {
                            let t = 10;
                            o.segments && o.segments.length && (t = o.segments.reduce(((e, t) => Math.max(e, t.duration)), 0)), e && e(`manifest has no targetDuration defaulting to ${t}`), o.targetDuration = t
                        }
                        const l = Ya(o);
                        if (l.length && !o.partTargetDuration) {
                            const t = l.reduce(((e, t) => Math.max(e, t.duration)), 0);
                            e && (e(`manifest has no partTargetDuration defaulting to ${t}`), uo.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.")), o.partTargetDuration = t
                        }
                        return o
                    })({
                        onwarn: ({
                            message: t
                        }) => this.logger_(`m3u8-parser warn for ${e}: ${t}`),
                        oninfo: ({
                            message: t
                        }) => this.logger_(`m3u8-parser info for ${e}: ${t}`),
                        manifestString: t,
                        customTagParsers: this.customTagParsers,
                        customTagMappers: this.customTagMappers,
                        llhls: this.llhls
                    })
                }
                haveMetadata({
                    playlistString: e,
                    playlistObject: t,
                    url: i,
                    id: n
                }) {
                    this.request = null, this.state = "HAVE_METADATA";
                    const r = t || this.parseManifest_({
                        url: i,
                        manifestString: e
                    });
                    r.lastRequest = Date.now(), mo({
                        playlist: r,
                        uri: i,
                        id: n
                    });
                    const s = xo(this.main, r);
                    this.targetDuration = r.partTargetDuration || r.targetDuration, this.pendingMedia_ = null, s ? (this.main = s, this.media_ = this.main.playlists[n]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(wo(this.media(), !!s)), this.trigger("loadedplaylist")
                }
                dispose() {
                    this.trigger("dispose"), this.stopRequest(), r().clearTimeout(this.mediaUpdateTimeout), r().clearTimeout(this.finalRenditionTimeout), this.off()
                }
                stopRequest() {
                    if (this.request) {
                        const e = this.request;
                        this.request = null, e.onreadystatechange = null, e.abort()
                    }
                }
                media(e, t) {
                    if (!e) return this.media_;
                    if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state);
                    if ("string" == typeof e) {
                        if (!this.main.playlists[e]) throw new Error("Unknown playlist URI: " + e);
                        e = this.main.playlists[e]
                    }
                    if (r().clearTimeout(this.finalRenditionTimeout), t) {
                        const t = (e.partTargetDuration || e.targetDuration) / 2 * 1e3 || 5e3;
                        return void(this.finalRenditionTimeout = r().setTimeout(this.media.bind(this, e, !1), t))
                    }
                    const i = this.state,
                        n = !this.media_ || e.id !== this.media_.id,
                        s = this.main.playlists[e.id];
                    if (s && s.endList || e.endList && e.segments.length) return this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = e, void(n && (this.trigger("mediachanging"), "HAVE_MAIN_MANIFEST" === i ? this.trigger("loadedmetadata") : this.trigger("mediachange")));
                    if (this.updateMediaUpdateTimeout_(wo(e, !0)), n) {
                        if (this.state = "SWITCHING_MEDIA", this.request) {
                            if (e.resolvedUri === this.request.url) return;
                            this.request.onreadystatechange = null, this.request.abort(), this.request = null
                        }
                        this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = e, this.request = this.vhs_.xhr({
                            uri: e.resolvedUri,
                            withCredentials: this.withCredentials
                        }, ((t, n) => {
                            if (this.request) {
                                if (e.lastRequest = Date.now(), e.resolvedUri = Da(e.resolvedUri, n), t) return this.playlistRequestError(this.request, e, i);
                                this.haveMetadata({
                                    playlistString: n.responseText,
                                    url: e.uri,
                                    id: e.id
                                }), "HAVE_MAIN_MANIFEST" === i ? this.trigger("loadedmetadata") : this.trigger("mediachange")
                            }
                        }))
                    }
                }
                pause() {
                    this.mediaUpdateTimeout && (r().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), "HAVE_NOTHING" === this.state && (this.started = !1), "SWITCHING_MEDIA" === this.state ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MAIN_MANIFEST" : "HAVE_CURRENT_METADATA" === this.state && (this.state = "HAVE_METADATA")
                }
                load(e) {
                    this.mediaUpdateTimeout && (r().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null);
                    const t = this.media();
                    if (e) {
                        const e = t ? (t.partTargetDuration || t.targetDuration) / 2 * 1e3 : 5e3;
                        this.mediaUpdateTimeout = r().setTimeout((() => {
                            this.mediaUpdateTimeout = null, this.load()
                        }), e)
                    } else this.started ? t && !t.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist") : this.start()
                }
                updateMediaUpdateTimeout_(e) {
                    this.mediaUpdateTimeout && (r().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.media() && !this.media().endList && (this.mediaUpdateTimeout = r().setTimeout((() => {
                        this.mediaUpdateTimeout = null, this.trigger("mediaupdatetimeout"), this.updateMediaUpdateTimeout_(e)
                    }), e))
                }
                start() {
                    if (this.started = !0, "object" == typeof this.src) return this.src.uri || (this.src.uri = r().location.href), this.src.resolvedUri = this.src.uri, void setTimeout((() => {
                        this.setupInitialPlaylist(this.src)
                    }), 0);
                    this.request = this.vhs_.xhr({
                        uri: this.src,
                        withCredentials: this.withCredentials
                    }, ((e, t) => {
                        if (!this.request) return;
                        if (this.request = null, e) return this.error = {
                            status: t.status,
                            message: `HLS playlist request error at URL: ${this.src}.`,
                            responseText: t.responseText,
                            code: 2
                        }, "HAVE_NOTHING" === this.state && (this.started = !1), this.trigger("error");
                        this.src = Da(this.src, t);
                        const i = this.parseManifest_({
                            manifestString: t.responseText,
                            url: this.src
                        });
                        this.setupInitialPlaylist(i)
                    }))
                }
                srcUri() {
                    return "string" == typeof this.src ? this.src : this.src.uri
                }
                setupInitialPlaylist(e) {
                    if (this.state = "HAVE_MAIN_MANIFEST", e.playlists) return this.main = e, go(this.main, this.srcUri()), e.playlists.forEach((e => {
                        e.segments = bo(e), e.segments.forEach((t => {
                            vo(t, e.resolvedUri)
                        }))
                    })), this.trigger("loadedplaylist"), void(this.request || this.media(this.main.playlists[0]));
                    const t = this.srcUri() || r().location.href;
                    this.main = ((e, t) => {
                        const i = po(0, t),
                            n = {
                                mediaGroups: {
                                    AUDIO: {},
                                    VIDEO: {},
                                    "CLOSED-CAPTIONS": {},
                                    SUBTITLES: {}
                                },
                                uri: r().location.href,
                                resolvedUri: r().location.href,
                                playlists: [{
                                    uri: t,
                                    id: i,
                                    resolvedUri: t,
                                    attributes: {}
                                }]
                            };
                        return n.playlists[i] = n.playlists[0], n.playlists[t] = n.playlists[0], n
                    })(0, t), this.haveMetadata({
                        playlistObject: e,
                        url: t,
                        id: this.main.playlists[0].id
                    }), this.trigger("loadedmetadata")
                }
            }
            const {
                xhr: Eo
            } = Ca, Mo = function(e, t, i, n) {
                const r = "arraybuffer" === e.responseType ? e.response : e.responseText;
                !t && r && (e.responseTime = Date.now(), e.roundTripTime = e.responseTime - e.requestTime, e.bytesReceived = r.byteLength || r.length, e.bandwidth || (e.bandwidth = Math.floor(e.bytesReceived / e.roundTripTime * 8 * 1e3))), i.headers && (e.responseHeaders = i.headers), t && "ETIMEDOUT" === t.code && (e.timedout = !0), t || e.aborted || 200 === i.statusCode || 206 === i.statusCode || 0 === i.statusCode || (t = new Error("XHR Failed with a response of: " + (e && (r || e.responseText)))), n(t, e)
            }, Co = function() {
                const e = function e(t, i) {
                    t = Na({
                        timeout: 45e3
                    }, t);
                    const n = e.beforeRequest || Ca.Vhs.xhr.beforeRequest;
                    if (n && "function" == typeof n) {
                        const e = n(t);
                        e && (t = e)
                    }
                    const r = (!0 === Ca.Vhs.xhr.original ? Eo : Ca.Vhs.xhr)(t, (function(e, t) {
                            return Mo(r, e, t, i)
                        })),
                        s = r.abort;
                    return r.abort = function() {
                        return r.aborted = !0, s.apply(r, arguments)
                    }, r.uri = t.uri, r.requestTime = Date.now(), r
                };
                return e.original = !0, e
            }, Ao = function(e) {
                const t = {};
                return e.byterange && (t.Range = function(e) {
                    let t;
                    const i = e.offset;
                    return t = "bigint" == typeof e.offset || "bigint" == typeof e.length ? r().BigInt(e.offset) + r().BigInt(e.length) - r().BigInt(1) : e.offset + e.length - 1, "bytes=" + i + "-" + t
                }(e.byterange)), t
            }, Lo = function(e, t) {
                return e.start(t) + "-" + e.end(t)
            }, Io = function(e, t) {
                const i = e.toString(16);
                return "00".substring(0, 2 - i.length) + i + (t % 2 ? " " : "")
            }, Po = function(e) {
                return e >= 32 && e < 126 ? String.fromCharCode(e) : "."
            }, Ro = function(e) {
                const t = {};
                return Object.keys(e).forEach((i => {
                    const n = e[i];
                    $(n) ? t[i] = {
                        bytes: n.buffer,
                        byteOffset: n.byteOffset,
                        byteLength: n.byteLength
                    } : t[i] = n
                })), t
            }, ko = function(e) {
                const t = e.byterange || {
                    length: 1 / 0,
                    offset: 0
                };
                return [t.length, t.offset, e.resolvedUri].join(",")
            }, Do = function(e) {
                return e.resolvedUri
            }, Oo = e => {
                const t = Array.prototype.slice.call(e),
                    i = 16;
                let n, r, s = "";
                for (let e = 0; e < t.length / i; e++) n = t.slice(e * i, e * i + i).map(Io).join(""), r = t.slice(e * i, e * i + i).map(Po).join(""), s += n + " " + r + "\n";
                return s
            };
            var No = Object.freeze({
                __proto__: null,
                createTransferableMessage: Ro,
                initSegmentId: ko,
                segmentKeyId: Do,
                hexDump: Oo,
                tagDump: ({
                    bytes: e
                }) => Oo(e),
                textRanges: e => {
                    let t, i = "";
                    for (t = 0; t < e.length; t++) i += Lo(e, t) + " ";
                    return i
                }
            });
            const Uo = ({
                    playlist: e,
                    time: t,
                    callback: i
                }) => {
                    if (!i) throw new Error("getProgramTime: callback must be provided");
                    if (!e || void 0 === t) return i({
                        message: "getProgramTime: playlist and time must be provided"
                    });
                    const n = ((e, t) => {
                        if (!t || !t.segments || 0 === t.segments.length) return null;
                        let i, n = 0;
                        for (let r = 0; r < t.segments.length && (i = t.segments[r], n = i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationEnd : n + i.duration, !(e <= n)); r++);
                        const r = t.segments[t.segments.length - 1];
                        if (r.videoTimingInfo && r.videoTimingInfo.transmuxedPresentationEnd < e) return null;
                        if (e > n) {
                            if (e > n + .25 * r.duration) return null;
                            i = r
                        }
                        return {
                            segment: i,
                            estimatedStart: i.videoTimingInfo ? i.videoTimingInfo.transmuxedPresentationStart : n - i.duration,
                            type: i.videoTimingInfo ? "accurate" : "estimate"
                        }
                    })(t, e);
                    if (!n) return i({
                        message: "valid programTime was not found"
                    });
                    if ("estimate" === n.type) return i({
                        message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
                        seekTime: n.estimatedStart
                    });
                    const r = {
                            mediaSeconds: t
                        },
                        s = ((e, t) => {
                            if (!t.dateTimeObject) return null;
                            const i = t.videoTimingInfo.transmuxerPrependedSeconds,
                                n = e - (t.videoTimingInfo.transmuxedPresentationStart + i);
                            return new Date(t.dateTimeObject.getTime() + 1e3 * n)
                        })(t, n.segment);
                    return s && (r.programDateTime = s.toISOString()), i(null, r)
                },
                Bo = ({
                    programTime: e,
                    playlist: t,
                    retryCount: i = 2,
                    seekTo: n,
                    pauseAfterSeek: r = !0,
                    tech: s,
                    callback: a
                }) => {
                    if (!a) throw new Error("seekToProgramTime: callback must be provided");
                    if (void 0 === e || !t || !n) return a({
                        message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
                    });
                    if (!t.endList && !s.hasStarted_) return a({
                        message: "player must be playing a live stream to start buffering"
                    });
                    if (!(e => {
                            if (!e.segments || 0 === e.segments.length) return !1;
                            for (let t = 0; t < e.segments.length; t++)
                                if (!e.segments[t].dateTimeObject) return !1;
                            return !0
                        })(t)) return a({
                        message: "programDateTime tags must be provided in the manifest " + t.resolvedUri
                    });
                    const o = ((e, t) => {
                        let i;
                        try {
                            i = new Date(e)
                        } catch (e) {
                            return null
                        }
                        if (!t || !t.segments || 0 === t.segments.length) return null;
                        let n = t.segments[0];
                        if (i < n.dateTimeObject) return null;
                        for (let e = 0; e < t.segments.length - 1 && (n = t.segments[e], !(i < t.segments[e + 1].dateTimeObject)); e++);
                        const r = t.segments[t.segments.length - 1],
                            s = r.dateTimeObject,
                            a = r.videoTimingInfo ? (o = r.videoTimingInfo).transmuxedPresentationEnd - o.transmuxedPresentationStart - o.transmuxerPrependedSeconds : r.duration + .25 * r.duration;
                        var o;
                        return i > new Date(s.getTime() + 1e3 * a) ? null : (i > s && (n = r), {
                            segment: n,
                            estimatedStart: n.videoTimingInfo ? n.videoTimingInfo.transmuxedPresentationStart : co.duration(t, t.mediaSequence + t.segments.indexOf(n)),
                            type: n.videoTimingInfo ? "accurate" : "estimate"
                        })
                    })(e, t);
                    if (!o) return a({
                        message: `${e} was not found in the stream`
                    });
                    const l = o.segment,
                        h = ((e, t) => {
                            let i, n;
                            try {
                                i = new Date(e), n = new Date(t)
                            } catch (e) {}
                            const r = i.getTime();
                            return (n.getTime() - r) / 1e3
                        })(l.dateTimeObject, e);
                    if ("estimate" === o.type) return 0 === i ? a({
                        message: `${e} is not buffered yet. Try again`
                    }) : (n(o.estimatedStart + h), void s.one("seeked", (() => {
                        Bo({
                            programTime: e,
                            playlist: t,
                            retryCount: i - 1,
                            seekTo: n,
                            pauseAfterSeek: r,
                            tech: s,
                            callback: a
                        })
                    })));
                    const c = l.start + h;
                    s.one("seeked", (() => a(null, s.currentTime()))), r && s.pause(), n(c)
                },
                Fo = (e, t) => {
                    if (4 === e.readyState) return t()
                },
                Ho = (e, t, i) => {
                    let n, r = [],
                        s = !1;
                    const a = function(e, t, n, r) {
                            return t.abort(), s = !0, i(e, t, n, r)
                        },
                        o = function(e, t) {
                            if (s) return;
                            if (e) return a(e, t, "", r);
                            const i = t.responseText.substring(r && r.byteLength || 0, t.responseText.length);
                            if (r = function() {
                                    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                                    if (t = t.filter((function(e) {
                                            return e && (e.byteLength || e.length) && "string" != typeof e
                                        })), t.length <= 1) return X(t[0]);
                                    var n = t.reduce((function(e, t, i) {
                                            return e + (t.byteLength || t.length)
                                        }), 0),
                                        r = new Uint8Array(n),
                                        s = 0;
                                    return t.forEach((function(e) {
                                        e = X(e), r.set(e, s), s += e.byteLength
                                    })), r
                                }(r, Q(i, !0)), n = n || at(r), r.length < 10 || n && r.length < n + 2) return Fo(t, (() => a(e, t, "", r)));
                            const o = Et(r);
                            return "ts" === o && r.length < 188 || !o && r.length < 376 ? Fo(t, (() => a(e, t, "", r))) : a(null, t, o, r)
                        },
                        l = {
                            uri: e,
                            beforeSend(e) {
                                e.overrideMimeType("text/plain; charset=x-user-defined"), e.addEventListener("progress", (function({
                                    total: t,
                                    loaded: i
                                }) {
                                    return Mo(e, null, {
                                        statusCode: e.status
                                    }, o)
                                }))
                            }
                        },
                        h = t(l, (function(e, t) {
                            return Mo(h, e, t, o)
                        }));
                    return h
                },
                {
                    EventTarget: zo
                } = Ca,
                Vo = function(e, t) {
                    if (!To(e, t)) return !1;
                    if (e.sidx && t.sidx && (e.sidx.offset !== t.sidx.offset || e.sidx.length !== t.sidx.length)) return !1;
                    if (!e.sidx && t.sidx || e.sidx && !t.sidx) return !1;
                    if (e.segments && !t.segments || !e.segments && t.segments) return !1;
                    if (!e.segments && !t.segments) return !0;
                    for (let i = 0; i < e.segments.length; i++) {
                        const n = e.segments[i],
                            r = t.segments[i];
                        if (n.uri !== r.uri) return !1;
                        if (!n.byterange && !r.byterange) continue;
                        const s = n.byterange,
                            a = r.byterange;
                        if (s && !a || !s && a) return !1;
                        if (s.offset !== a.offset || s.length !== a.length) return !1
                    }
                    return !0
                },
                Go = (e, t) => (Boolean(!e.map && !t.map) || Boolean(e.map && t.map && e.map.byterange.offset === t.map.byterange.offset && e.map.byterange.length === t.map.byterange.length)) && e.uri === t.uri && e.byterange.offset === t.byterange.offset && e.byterange.length === t.byterange.length,
                Wo = (e, t) => {
                    const i = {};
                    for (const n in e) {
                        const r = e[n].sidx;
                        if (r) {
                            const e = Me(r);
                            if (!t[e]) break;
                            const n = t[e].sidxInfo;
                            Go(n, r) && (i[e] = t[e])
                        }
                    }
                    return i
                };
            class jo extends zo {
                constructor(e, t, i = {}, n) {
                    super(), this.mainPlaylistLoader_ = n || this, n || (this.isMain_ = !0);
                    const {
                        withCredentials: r = !1
                    } = i;
                    if (this.vhs_ = t, this.withCredentials = r, !e) throw new Error("A non-empty playlist URL or object is required");
                    this.on("minimumUpdatePeriod", (() => {
                        this.refreshXml_()
                    })), this.on("mediaupdatetimeout", (() => {
                        this.refreshMedia_(this.media().id)
                    })), this.state = "HAVE_NOTHING", this.loadedPlaylists_ = {}, this.logger_ = Oa("DashPlaylistLoader"), this.isMain_ ? (this.mainPlaylistLoader_.srcUrl = e, this.mainPlaylistLoader_.sidxMapping_ = {}) : this.childPlaylist_ = e
                }
                requestErrored_(e, t, i) {
                    return !this.request || (this.request = null, e ? (this.error = "object" != typeof e || e instanceof Error ? {
                        status: t.status,
                        message: "DASH request error at URL: " + t.uri,
                        response: t.response,
                        code: 2
                    } : e, i && (this.state = i), this.trigger("error"), !0) : void 0)
                }
                addSidxSegments_(e, t, i) {
                    const n = e.sidx && Me(e.sidx);
                    if (!e.sidx || !n || this.mainPlaylistLoader_.sidxMapping_[n]) return void(this.mediaRequest_ = r().setTimeout((() => i(!1)), 0));
                    const s = Da(e.sidx.resolvedUri),
                        a = (r, s) => {
                            if (this.requestErrored_(r, s, t)) return;
                            const a = this.mainPlaylistLoader_.sidxMapping_;
                            let o;
                            try {
                                o = rt()(X(s.response).subarray(8))
                            } catch (e) {
                                return void this.requestErrored_(e, s, t)
                            }
                            return a[n] = {
                                sidxInfo: e.sidx,
                                sidx: o
                            }, be(e, o, e.sidx.resolvedUri), i(!0)
                        };
                    this.request = Ho(s, this.vhs_.xhr, ((t, i, n, r) => {
                        if (t) return a(t, i);
                        if (!n || "mp4" !== n) return a({
                            status: i.status,
                            message: `Unsupported ${n||"unknown"} container type for sidx segment at URL: ${s}`,
                            response: "",
                            playlist: e,
                            internal: !0,
                            playlistExclusionDuration: 1 / 0,
                            code: 2
                        }, i);
                        const {
                            offset: o,
                            length: l
                        } = e.sidx.byterange;
                        if (r.length >= l + o) return a(t, {
                            response: r.subarray(o, o + l),
                            status: i.status,
                            uri: i.uri
                        });
                        this.request = this.vhs_.xhr({
                            uri: s,
                            responseType: "arraybuffer",
                            headers: Ao({
                                byterange: e.sidx.byterange
                            })
                        }, a)
                    }))
                }
                dispose() {
                    this.trigger("dispose"), this.stopRequest(), this.loadedPlaylists_ = {}, r().clearTimeout(this.minimumUpdatePeriodTimeout_), r().clearTimeout(this.mediaRequest_), r().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.mediaRequest_ = null, this.minimumUpdatePeriodTimeout_ = null, this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.off()
                }
                hasPendingRequest() {
                    return this.request || this.mediaRequest_
                }
                stopRequest() {
                    if (this.request) {
                        const e = this.request;
                        this.request = null, e.onreadystatechange = null, e.abort()
                    }
                }
                media(e) {
                    if (!e) return this.media_;
                    if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state);
                    const t = this.state;
                    if ("string" == typeof e) {
                        if (!this.mainPlaylistLoader_.main.playlists[e]) throw new Error("Unknown playlist URI: " + e);
                        e = this.mainPlaylistLoader_.main.playlists[e]
                    }
                    const i = !this.media_ || e.id !== this.media_.id;
                    if (i && this.loadedPlaylists_[e.id] && this.loadedPlaylists_[e.id].endList) return this.state = "HAVE_METADATA", this.media_ = e, void(i && (this.trigger("mediachanging"), this.trigger("mediachange")));
                    i && (this.media_ && this.trigger("mediachanging"), this.addSidxSegments_(e, t, (i => {
                        this.haveMetadata({
                            startingState: t,
                            playlist: e
                        })
                    })))
                }
                haveMetadata({
                    startingState: e,
                    playlist: t
                }) {
                    this.state = "HAVE_METADATA", this.loadedPlaylists_[t.id] = t, this.mediaRequest_ = null, this.refreshMedia_(t.id), "HAVE_MAIN_MANIFEST" === e ? this.trigger("loadedmetadata") : this.trigger("mediachange")
                }
                pause() {
                    this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.stopRequest(), r().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.isMain_ && (r().clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_), this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null), "HAVE_NOTHING" === this.state && (this.started = !1)
                }
                load(e) {
                    r().clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null;
                    const t = this.media();
                    if (e) {
                        const e = t ? t.targetDuration / 2 * 1e3 : 5e3;
                        this.mediaUpdateTimeout = r().setTimeout((() => this.load()), e)
                    } else this.started ? t && !t.endList ? (this.isMain_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"), this.updateMinimumUpdatePeriodTimeout_()), this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist") : this.start()
                }
                start() {
                    this.started = !0, this.isMain_ ? this.requestMain_(((e, t) => {
                        this.haveMain_(), this.hasPendingRequest() || this.media_ || this.media(this.mainPlaylistLoader_.main.playlists[0])
                    })) : this.mediaRequest_ = r().setTimeout((() => this.haveMain_()), 0)
                }
                requestMain_(e) {
                    this.request = this.vhs_.xhr({
                        uri: this.mainPlaylistLoader_.srcUrl,
                        withCredentials: this.withCredentials
                    }, ((t, i) => {
                        if (this.requestErrored_(t, i)) return void("HAVE_NOTHING" === this.state && (this.started = !1));
                        const n = i.responseText !== this.mainPlaylistLoader_.mainXml_;
                        return this.mainPlaylistLoader_.mainXml_ = i.responseText, i.responseHeaders && i.responseHeaders.date ? this.mainLoaded_ = Date.parse(i.responseHeaders.date) : this.mainLoaded_ = Date.now(), this.mainPlaylistLoader_.srcUrl = Da(this.mainPlaylistLoader_.srcUrl, i), n ? (this.handleMain_(), void this.syncClientServerClock_((() => e(i, n)))) : e(i, n)
                    }))
                }
                syncClientServerClock_(e) {
                    const t = tt(this.mainPlaylistLoader_.mainXml_);
                    return null === t ? (this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e()) : "DIRECT" === t.method ? (this.mainPlaylistLoader_.clientOffset_ = t.value - Date.now(), e()) : void(this.request = this.vhs_.xhr({
                        uri: ka(this.mainPlaylistLoader_.srcUrl, t.value),
                        method: t.method,
                        withCredentials: this.withCredentials
                    }, ((i, n) => {
                        if (!this.request) return;
                        if (i) return this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e();
                        let r;
                        r = "HEAD" === t.method ? n.responseHeaders && n.responseHeaders.date ? Date.parse(n.responseHeaders.date) : this.mainLoaded_ : Date.parse(n.responseText), this.mainPlaylistLoader_.clientOffset_ = r - Date.now(), e()
                    })))
                }
                haveMain_() {
                    this.state = "HAVE_MAIN_MANIFEST", this.isMain_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_)
                }
                handleMain_() {
                    this.mediaRequest_ = null;
                    const e = this.mainPlaylistLoader_.main;
                    let t = (({
                        mainXml: e,
                        srcUrl: t,
                        clientOffset: i,
                        sidxMapping: n,
                        previousManifest: r
                    }) => {
                        const s = et(e, {
                            manifestUri: t,
                            clientOffset: i,
                            sidxMapping: n,
                            previousManifest: r
                        });
                        return go(s, t), s
                    })({
                        mainXml: this.mainPlaylistLoader_.mainXml_,
                        srcUrl: this.mainPlaylistLoader_.srcUrl,
                        clientOffset: this.mainPlaylistLoader_.clientOffset_,
                        sidxMapping: this.mainPlaylistLoader_.sidxMapping_,
                        previousManifest: e
                    });
                    e && (t = ((e, t, i) => {
                        let n = !0,
                            r = Na(e, {
                                duration: t.duration,
                                minimumUpdatePeriod: t.minimumUpdatePeriod,
                                timelineStarts: t.timelineStarts
                            });
                        for (let e = 0; e < t.playlists.length; e++) {
                            const s = t.playlists[e];
                            if (s.sidx) {
                                const e = Me(s.sidx);
                                i && i[e] && i[e].sidx && be(s, i[e].sidx, s.sidx.resolvedUri)
                            }
                            const a = xo(r, s, Vo);
                            a && (r = a, n = !1)
                        }
                        return fo(t, ((e, t, i, s) => {
                            if (e.playlists && e.playlists.length) {
                                const a = e.playlists[0].id,
                                    o = xo(r, e.playlists[0], Vo);
                                o && (r = o, r.mediaGroups[t][i][s].playlists[0] = r.playlists[a], n = !1)
                            }
                        })), t.minimumUpdatePeriod !== e.minimumUpdatePeriod && (n = !1), n ? null : r
                    })(e, t, this.mainPlaylistLoader_.sidxMapping_)), this.mainPlaylistLoader_.main = t || e;
                    const i = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];
                    return i && i !== this.mainPlaylistLoader_.srcUrl && (this.mainPlaylistLoader_.srcUrl = i), (!e || t && t.minimumUpdatePeriod !== e.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(), Boolean(t)
                }
                updateMinimumUpdatePeriodTimeout_() {
                    const e = this.mainPlaylistLoader_;
                    e.createMupOnMedia_ && (e.off("loadedmetadata", e.createMupOnMedia_), e.createMupOnMedia_ = null), e.minimumUpdatePeriodTimeout_ && (r().clearTimeout(e.minimumUpdatePeriodTimeout_), e.minimumUpdatePeriodTimeout_ = null);
                    let t = e.main && e.main.minimumUpdatePeriod;
                    0 === t && (e.media() ? t = 1e3 * e.media().targetDuration : (e.createMupOnMedia_ = e.updateMinimumUpdatePeriodTimeout_, e.one("loadedmetadata", e.createMupOnMedia_))), "number" != typeof t || t <= 0 ? t < 0 && this.logger_(`found invalid minimumUpdatePeriod of ${t}, not setting a timeout`) : this.createMUPTimeout_(t)
                }
                createMUPTimeout_(e) {
                    const t = this.mainPlaylistLoader_;
                    t.minimumUpdatePeriodTimeout_ = r().setTimeout((() => {
                        t.minimumUpdatePeriodTimeout_ = null, t.trigger("minimumUpdatePeriod"), t.createMUPTimeout_(e)
                    }), e)
                }
                refreshXml_() {
                    this.requestMain_(((e, t) => {
                        t && (this.media_ && (this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id]), this.mainPlaylistLoader_.sidxMapping_ = ((e, t) => {
                            let i = Wo(e.playlists, t);
                            return fo(e, ((e, n, r, s) => {
                                if (e.playlists && e.playlists.length) {
                                    const n = e.playlists;
                                    i = Na(i, Wo(n, t))
                                }
                            })), i
                        })(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_), this.addSidxSegments_(this.media(), this.state, (e => {
                            this.refreshMedia_(this.media().id)
                        })))
                    }))
                }
                refreshMedia_(e) {
                    if (!e) throw new Error("refreshMedia_ must take a media id");
                    this.media_ && this.isMain_ && this.handleMain_();
                    const t = this.mainPlaylistLoader_.main.playlists,
                        i = !this.media_ || this.media_ !== t[e];
                    if (i ? this.media_ = t[e] : this.trigger("playlistunchanged"), !this.mediaUpdateTimeout) {
                        const e = () => {
                            this.media().endList || (this.mediaUpdateTimeout = r().setTimeout((() => {
                                this.trigger("mediaupdatetimeout"), e()
                            }), wo(this.media(), Boolean(i))))
                        };
                        e()
                    }
                    this.trigger("loadedplaylist")
                }
            }
            var qo = {
                GOAL_BUFFER_LENGTH: 30,
                MAX_GOAL_BUFFER_LENGTH: 60,
                BACK_BUFFER_LENGTH: 30,
                GOAL_BUFFER_LENGTH_RATE: 1,
                INITIAL_BANDWIDTH: 4194304,
                BANDWIDTH_VARIANCE: 1.2,
                BUFFER_LOW_WATER_LINE: 0,
                MAX_BUFFER_LOW_WATER_LINE: 30,
                EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
                BUFFER_LOW_WATER_LINE_RATE: 1,
                BUFFER_HIGH_WATER_LINE: 30
            };
            const $o = function(e) {
                    return e.on = e.addEventListener, e.off = e.removeEventListener, e
                },
                Xo = function(e) {
                    return function() {
                        const t = function(e) {
                                try {
                                    return URL.createObjectURL(new Blob([e], {
                                        type: "application/javascript"
                                    }))
                                } catch (t) {
                                    const i = new BlobBuilder;
                                    return i.append(e), URL.createObjectURL(i.getBlob())
                                }
                            }(e),
                            i = $o(new Worker(t));
                        i.objURL = t;
                        const n = i.terminate;
                        return i.on = i.addEventListener, i.off = i.removeEventListener, i.terminate = function() {
                            return URL.revokeObjectURL(t), n.call(this)
                        }, i
                    }
                },
                Yo = function(e) {
                    return `var browserWorkerPolyFill = ${$o.toString()};\nbrowserWorkerPolyFill(self);\n` + e
                },
                Ko = function(e) {
                    return e.toString().replace(/^function.+?{/, "").slice(0, -1)
                },
                Jo = Yo(Ko((function() {
                    var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self ? self : {},
                        t = function() {
                            this.init = function() {
                                var e = {};
                                this.on = function(t, i) {
                                    e[t] || (e[t] = []), e[t] = e[t].concat(i)
                                }, this.off = function(t, i) {
                                    var n;
                                    return !!e[t] && (n = e[t].indexOf(i), e[t] = e[t].slice(), e[t].splice(n, 1), n > -1)
                                }, this.trigger = function(t) {
                                    var i, n, r, s;
                                    if (i = e[t])
                                        if (2 === arguments.length)
                                            for (r = i.length, n = 0; n < r; ++n) i[n].call(this, arguments[1]);
                                        else {
                                            for (s = [], n = arguments.length, n = 1; n < arguments.length; ++n) s.push(arguments[n]);
                                            for (r = i.length, n = 0; n < r; ++n) i[n].apply(this, s)
                                        }
                                }, this.dispose = function() {
                                    e = {}
                                }
                            }
                        };
                    t.prototype.pipe = function(e) {
                        return this.on("data", (function(t) {
                            e.push(t)
                        })), this.on("done", (function(t) {
                            e.flush(t)
                        })), this.on("partialdone", (function(t) {
                            e.partialFlush(t)
                        })), this.on("endedtimeline", (function(t) {
                            e.endTimeline(t)
                        })), this.on("reset", (function(t) {
                            e.reset(t)
                        })), e
                    }, t.prototype.push = function(e) {
                        this.trigger("data", e)
                    }, t.prototype.flush = function(e) {
                        this.trigger("done", e)
                    }, t.prototype.partialFlush = function(e) {
                        this.trigger("partialdone", e)
                    }, t.prototype.endTimeline = function(e) {
                        this.trigger("endedtimeline", e)
                    }, t.prototype.reset = function(e) {
                        this.trigger("reset", e)
                    };
                    var n, r, s, a, o, l, h, c, u, d, p, f, m, g, y, _, v, b, T, x, w, S, E, M, C, A, L, I, P, R, k, D, O, N, U, B, F, H, z, V, G = t,
                        W = Math.pow(2, 32),
                        j = {
                            getUint64: function(e) {
                                var t, i = new DataView(e.buffer, e.byteOffset, e.byteLength);
                                return i.getBigUint64 ? (t = i.getBigUint64(0)) < Number.MAX_SAFE_INTEGER ? Number(t) : t : i.getUint32(0) * W + i.getUint32(4)
                            },
                            MAX_UINT32: W
                        },
                        q = j.MAX_UINT32;
                    ! function() {
                        var e;
                        if (S = {
                                avc1: [],
                                avcC: [],
                                btrt: [],
                                dinf: [],
                                dref: [],
                                esds: [],
                                ftyp: [],
                                hdlr: [],
                                mdat: [],
                                mdhd: [],
                                mdia: [],
                                mfhd: [],
                                minf: [],
                                moof: [],
                                moov: [],
                                mp4a: [],
                                mvex: [],
                                mvhd: [],
                                pasp: [],
                                sdtp: [],
                                smhd: [],
                                stbl: [],
                                stco: [],
                                stsc: [],
                                stsd: [],
                                stsz: [],
                                stts: [],
                                styp: [],
                                tfdt: [],
                                tfhd: [],
                                traf: [],
                                trak: [],
                                trun: [],
                                trex: [],
                                tkhd: [],
                                vmhd: []
                            }, "undefined" != typeof Uint8Array) {
                            for (e in S) S.hasOwnProperty(e) && (S[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
                            E = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]), C = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]), M = new Uint8Array([0, 0, 0, 1]), A = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), L = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), I = {
                                video: A,
                                audio: L
                            }, k = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), R = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), D = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), O = D, N = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), U = D, P = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])
                        }
                    }(), n = function(e) {
                        var t, i, n = [],
                            r = 0;
                        for (t = 1; t < arguments.length; t++) n.push(arguments[t]);
                        for (t = n.length; t--;) r += n[t].byteLength;
                        for (i = new Uint8Array(r + 8), new DataView(i.buffer, i.byteOffset, i.byteLength).setUint32(0, i.byteLength), i.set(e, 4), t = 0, r = 8; t < n.length; t++) i.set(n[t], r), r += n[t].byteLength;
                        return i
                    }, r = function() {
                        return n(S.dinf, n(S.dref, k))
                    }, s = function(e) {
                        return n(S.esds, new Uint8Array([0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, e.audioobjecttype << 3 | e.samplingfrequencyindex >>> 1, e.samplingfrequencyindex << 7 | e.channelcount << 3, 6, 1, 2]))
                    }, y = function(e) {
                        return n(S.hdlr, I[e])
                    }, g = function(e) {
                        var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, e.duration >>> 24 & 255, e.duration >>> 16 & 255, e.duration >>> 8 & 255, 255 & e.duration, 85, 196, 0, 0]);
                        return e.samplerate && (t[12] = e.samplerate >>> 24 & 255, t[13] = e.samplerate >>> 16 & 255, t[14] = e.samplerate >>> 8 & 255, t[15] = 255 & e.samplerate), n(S.mdhd, t)
                    }, m = function(e) {
                        return n(S.mdia, g(e), y(e.type), l(e))
                    }, o = function(e) {
                        return n(S.mfhd, new Uint8Array([0, 0, 0, 0, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e]))
                    }, l = function(e) {
                        return n(S.minf, "video" === e.type ? n(S.vmhd, P) : n(S.smhd, R), r(), v(e))
                    }, h = function(e, t) {
                        for (var i = [], r = t.length; r--;) i[r] = T(t[r]);
                        return n.apply(null, [S.moof, o(e)].concat(i))
                    }, c = function(e) {
                        for (var t = e.length, i = []; t--;) i[t] = p(e[t]);
                        return n.apply(null, [S.moov, d(4294967295)].concat(i).concat(u(e)))
                    }, u = function(e) {
                        for (var t = e.length, i = []; t--;) i[t] = x(e[t]);
                        return n.apply(null, [S.mvex].concat(i))
                    }, d = function(e) {
                        var t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                        return n(S.mvhd, t)
                    }, _ = function(e) {
                        var t, i, r = e.samples || [],
                            s = new Uint8Array(4 + r.length);
                        for (i = 0; i < r.length; i++) t = r[i].flags, s[i + 4] = t.dependsOn << 4 | t.isDependedOn << 2 | t.hasRedundancy;
                        return n(S.sdtp, s)
                    }, v = function(e) {
                        return n(S.stbl, b(e), n(S.stts, U), n(S.stsc, O), n(S.stsz, N), n(S.stco, D))
                    }, b = function(e) {
                        return n(S.stsd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), "video" === e.type ? B(e) : F(e))
                    }, B = function(e) {
                        var t, i, r = e.sps || [],
                            s = e.pps || [],
                            a = [],
                            o = [];
                        for (t = 0; t < r.length; t++) a.push((65280 & r[t].byteLength) >>> 8), a.push(255 & r[t].byteLength), a = a.concat(Array.prototype.slice.call(r[t]));
                        for (t = 0; t < s.length; t++) o.push((65280 & s[t].byteLength) >>> 8), o.push(255 & s[t].byteLength), o = o.concat(Array.prototype.slice.call(s[t]));
                        if (i = [S.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, (65280 & e.height) >> 8, 255 & e.height, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), n(S.avcC, new Uint8Array([1, e.profileIdc, e.profileCompatibility, e.levelIdc, 255].concat([r.length], a, [s.length], o))), n(S.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192]))], e.sarRatio) {
                            var l = e.sarRatio[0],
                                h = e.sarRatio[1];
                            i.push(n(S.pasp, new Uint8Array([(4278190080 & l) >> 24, (16711680 & l) >> 16, (65280 & l) >> 8, 255 & l, (4278190080 & h) >> 24, (16711680 & h) >> 16, (65280 & h) >> 8, 255 & h])))
                        }
                        return n.apply(null, i)
                    }, F = function(e) {
                        return n(S.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.channelcount) >> 8, 255 & e.channelcount, (65280 & e.samplesize) >> 8, 255 & e.samplesize, 0, 0, 0, 0, (65280 & e.samplerate) >> 8, 255 & e.samplerate, 0, 0]), s(e))
                    }, f = function(e) {
                        var t = new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 0, (4278190080 & e.duration) >> 24, (16711680 & e.duration) >> 16, (65280 & e.duration) >> 8, 255 & e.duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, 0, 0, (65280 & e.height) >> 8, 255 & e.height, 0, 0]);
                        return n(S.tkhd, t)
                    }, T = function(e) {
                        var t, i, r, s, a, o;
                        return t = n(S.tfhd, new Uint8Array([0, 0, 0, 58, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), a = Math.floor(e.baseMediaDecodeTime / q), o = Math.floor(e.baseMediaDecodeTime % q), i = n(S.tfdt, new Uint8Array([1, 0, 0, 0, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o])), 92, "audio" === e.type ? (r = w(e, 92), n(S.traf, t, i, r)) : (s = _(e), r = w(e, s.length + 92), n(S.traf, t, i, r, s))
                    }, p = function(e) {
                        return e.duration = e.duration || 4294967295, n(S.trak, f(e), m(e))
                    }, x = function(e) {
                        var t = new Uint8Array([0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]);
                        return "video" !== e.type && (t[t.length - 1] = 0), n(S.trex, t)
                    }, V = function(e, t) {
                        var i = 0,
                            n = 0,
                            r = 0,
                            s = 0;
                        return e.length && (void 0 !== e[0].duration && (i = 1), void 0 !== e[0].size && (n = 2), void 0 !== e[0].flags && (r = 4), void 0 !== e[0].compositionTimeOffset && (s = 8)), [0, 0, i | n | r | s, 1, (4278190080 & e.length) >>> 24, (16711680 & e.length) >>> 16, (65280 & e.length) >>> 8, 255 & e.length, (4278190080 & t) >>> 24, (16711680 & t) >>> 16, (65280 & t) >>> 8, 255 & t]
                    }, z = function(e, t) {
                        var i, r, s, a, o, l;
                        for (t += 20 + 16 * (a = e.samples || []).length, s = V(a, t), (r = new Uint8Array(s.length + 16 * a.length)).set(s), i = s.length, l = 0; l < a.length; l++) o = a[l], r[i++] = (4278190080 & o.duration) >>> 24, r[i++] = (16711680 & o.duration) >>> 16, r[i++] = (65280 & o.duration) >>> 8, r[i++] = 255 & o.duration, r[i++] = (4278190080 & o.size) >>> 24, r[i++] = (16711680 & o.size) >>> 16, r[i++] = (65280 & o.size) >>> 8, r[i++] = 255 & o.size, r[i++] = o.flags.isLeading << 2 | o.flags.dependsOn, r[i++] = o.flags.isDependedOn << 6 | o.flags.hasRedundancy << 4 | o.flags.paddingValue << 1 | o.flags.isNonSyncSample, r[i++] = 61440 & o.flags.degradationPriority, r[i++] = 15 & o.flags.degradationPriority, r[i++] = (4278190080 & o.compositionTimeOffset) >>> 24, r[i++] = (16711680 & o.compositionTimeOffset) >>> 16, r[i++] = (65280 & o.compositionTimeOffset) >>> 8, r[i++] = 255 & o.compositionTimeOffset;
                        return n(S.trun, r)
                    }, H = function(e, t) {
                        var i, r, s, a, o, l;
                        for (t += 20 + 8 * (a = e.samples || []).length, s = V(a, t), (i = new Uint8Array(s.length + 8 * a.length)).set(s), r = s.length, l = 0; l < a.length; l++) o = a[l], i[r++] = (4278190080 & o.duration) >>> 24, i[r++] = (16711680 & o.duration) >>> 16, i[r++] = (65280 & o.duration) >>> 8, i[r++] = 255 & o.duration, i[r++] = (4278190080 & o.size) >>> 24, i[r++] = (16711680 & o.size) >>> 16, i[r++] = (65280 & o.size) >>> 8, i[r++] = 255 & o.size;
                        return n(S.trun, i)
                    }, w = function(e, t) {
                        return "audio" === e.type ? H(e, t) : z(e, t)
                    };
                    var $, X, Y, K, J, Z, Q, ee, te = {
                            ftyp: a = function() {
                                return n(S.ftyp, E, M, E, C)
                            },
                            mdat: function(e) {
                                return n(S.mdat, e)
                            },
                            moof: h,
                            moov: c,
                            initSegment: function(e) {
                                var t, i = a(),
                                    n = c(e);
                                return (t = new Uint8Array(i.byteLength + n.byteLength)).set(i), t.set(n, i.byteLength), t
                            }
                        },
                        ie = function(e, t) {
                            var i = {
                                size: 0,
                                flags: {
                                    isLeading: 0,
                                    dependsOn: 1,
                                    isDependedOn: 0,
                                    hasRedundancy: 0,
                                    degradationPriority: 0,
                                    isNonSyncSample: 1
                                }
                            };
                            return i.dataOffset = t, i.compositionTimeOffset = e.pts - e.dts, i.duration = e.duration, i.size = 4 * e.length, i.size += e.byteLength, e.keyFrame && (i.flags.dependsOn = 2, i.flags.isNonSyncSample = 0), i
                        },
                        ne = {
                            groupNalsIntoFrames: function(e) {
                                var t, i, n = [],
                                    r = [];
                                for (r.byteLength = 0, r.nalCount = 0, r.duration = 0, n.byteLength = 0, t = 0; t < e.length; t++) "access_unit_delimiter_rbsp" === (i = e[t]).nalUnitType ? (n.length && (n.duration = i.dts - n.dts, r.byteLength += n.byteLength, r.nalCount += n.length, r.duration += n.duration, r.push(n)), (n = [i]).byteLength = i.data.byteLength, n.pts = i.pts, n.dts = i.dts) : ("slice_layer_without_partitioning_rbsp_idr" === i.nalUnitType && (n.keyFrame = !0), n.duration = i.dts - n.dts, n.byteLength += i.data.byteLength, n.push(i));
                                return r.length && (!n.duration || n.duration <= 0) && (n.duration = r[r.length - 1].duration), r.byteLength += n.byteLength, r.nalCount += n.length, r.duration += n.duration, r.push(n), r
                            },
                            groupFramesIntoGops: function(e) {
                                var t, i, n = [],
                                    r = [];
                                for (n.byteLength = 0, n.nalCount = 0, n.duration = 0, n.pts = e[0].pts, n.dts = e[0].dts, r.byteLength = 0, r.nalCount = 0, r.duration = 0, r.pts = e[0].pts, r.dts = e[0].dts, t = 0; t < e.length; t++)(i = e[t]).keyFrame ? (n.length && (r.push(n), r.byteLength += n.byteLength, r.nalCount += n.nalCount, r.duration += n.duration), (n = [i]).nalCount = i.length, n.byteLength = i.byteLength, n.pts = i.pts, n.dts = i.dts, n.duration = i.duration) : (n.duration += i.duration, n.nalCount += i.length, n.byteLength += i.byteLength, n.push(i));
                                return r.length && n.duration <= 0 && (n.duration = r[r.length - 1].duration), r.byteLength += n.byteLength, r.nalCount += n.nalCount, r.duration += n.duration, r.push(n), r
                            },
                            extendFirstKeyFrame: function(e) {
                                var t;
                                return !e[0][0].keyFrame && e.length > 1 && (t = e.shift(), e.byteLength -= t.byteLength, e.nalCount -= t.nalCount, e[0][0].dts = t.dts, e[0][0].pts = t.pts, e[0][0].duration += t.duration), e
                            },
                            generateSampleTable: function(e, t) {
                                var i, n, r, s, a, o = t || 0,
                                    l = [];
                                for (i = 0; i < e.length; i++)
                                    for (s = e[i], n = 0; n < s.length; n++) a = s[n], o += (r = ie(a, o)).size, l.push(r);
                                return l
                            },
                            concatenateNalData: function(e) {
                                var t, i, n, r, s, a, o = 0,
                                    l = e.byteLength,
                                    h = e.nalCount,
                                    c = new Uint8Array(l + 4 * h),
                                    u = new DataView(c.buffer);
                                for (t = 0; t < e.length; t++)
                                    for (r = e[t], i = 0; i < r.length; i++)
                                        for (s = r[i], n = 0; n < s.length; n++) a = s[n], u.setUint32(o, a.data.byteLength), o += 4, c.set(a.data, o), o += a.data.byteLength;
                                return c
                            },
                            generateSampleTableForFrame: function(e, t) {
                                var i, n = [];
                                return i = ie(e, t || 0), n.push(i), n
                            },
                            concatenateNalDataForFrame: function(e) {
                                var t, i, n = 0,
                                    r = e.byteLength,
                                    s = e.length,
                                    a = new Uint8Array(r + 4 * s),
                                    o = new DataView(a.buffer);
                                for (t = 0; t < e.length; t++) i = e[t], o.setUint32(n, i.data.byteLength), n += 4, a.set(i.data, n), n += i.data.byteLength;
                                return a
                            }
                        },
                        re = [33, 16, 5, 32, 164, 27],
                        se = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252],
                        ae = function(e) {
                            for (var t = []; e--;) t.push(0);
                            return t
                        },
                        oe = 9e4;
                    Z = function(e, t) {
                        return X(J(e, t))
                    }, Q = function(e, t) {
                        return Y(K(e), t)
                    }, ee = function(e, t, i) {
                        return K(i ? e : e - t)
                    };
                    var le = {
                            ONE_SECOND_IN_TS: oe,
                            secondsToVideoTs: X = function(e) {
                                return e * oe
                            },
                            secondsToAudioTs: Y = function(e, t) {
                                return e * t
                            },
                            videoTsToSeconds: K = function(e) {
                                return e / oe
                            },
                            audioTsToSeconds: J = function(e, t) {
                                return e / t
                            },
                            audioTsToVideoTs: Z,
                            videoTsToAudioTs: Q,
                            metadataTsToSeconds: ee
                        },
                        he = function() {
                            if (!$) {
                                var e = {
                                    96e3: [re, [227, 64], ae(154), [56]],
                                    88200: [re, [231], ae(170), [56]],
                                    64e3: [re, [248, 192], ae(240), [56]],
                                    48e3: [re, [255, 192], ae(268), [55, 148, 128], ae(54), [112]],
                                    44100: [re, [255, 192], ae(268), [55, 163, 128], ae(84), [112]],
                                    32e3: [re, [255, 192], ae(268), [55, 234], ae(226), [112]],
                                    24e3: [re, [255, 192], ae(268), [55, 255, 128], ae(268), [111, 112], ae(126), [224]],
                                    16e3: [re, [255, 192], ae(268), [55, 255, 128], ae(268), [111, 255], ae(269), [223, 108], ae(195), [1, 192]],
                                    12e3: [se, ae(268), [3, 127, 248], ae(268), [6, 255, 240], ae(268), [13, 255, 224], ae(268), [27, 253, 128], ae(259), [56]],
                                    11025: [se, ae(268), [3, 127, 248], ae(268), [6, 255, 240], ae(268), [13, 255, 224], ae(268), [27, 255, 192], ae(268), [55, 175, 128], ae(108), [112]],
                                    8e3: [se, ae(268), [3, 121, 16], ae(47), [7]]
                                };
                                t = e, $ = Object.keys(t).reduce((function(e, i) {
                                    return e[i] = new Uint8Array(t[i].reduce((function(e, t) {
                                        return e.concat(t)
                                    }), [])), e
                                }), {})
                            }
                            var t;
                            return $
                        },
                        ce = le,
                        ue = {
                            prefixWithSilence: function(e, t, i, n) {
                                var r, s, a, o, l, h = 0,
                                    c = 0,
                                    u = 0;
                                if (t.length && (r = ce.audioTsToVideoTs(e.baseMediaDecodeTime, e.samplerate), s = Math.ceil(ce.ONE_SECOND_IN_TS / (e.samplerate / 1024)), i && n && (h = r - Math.max(i, n), u = (c = Math.floor(h / s)) * s), !(c < 1 || u > ce.ONE_SECOND_IN_TS / 2))) {
                                    for ((a = he()[e.samplerate]) || (a = t[0].data), o = 0; o < c; o++) l = t[0], t.splice(0, 0, {
                                        data: a,
                                        dts: l.dts - s,
                                        pts: l.pts - s
                                    });
                                    return e.baseMediaDecodeTime -= Math.floor(ce.videoTsToAudioTs(u, e.samplerate)), u
                                }
                            },
                            trimAdtsFramesByEarliestDts: function(e, t, i) {
                                return t.minSegmentDts >= i ? e : (t.minSegmentDts = 1 / 0, e.filter((function(e) {
                                    return e.dts >= i && (t.minSegmentDts = Math.min(t.minSegmentDts, e.dts), t.minSegmentPts = t.minSegmentDts, !0)
                                })))
                            },
                            generateSampleTable: function(e) {
                                var t, i, n = [];
                                for (t = 0; t < e.length; t++) i = e[t], n.push({
                                    size: i.data.byteLength,
                                    duration: 1024
                                });
                                return n
                            },
                            concatenateFrameData: function(e) {
                                var t, i, n = 0,
                                    r = new Uint8Array(function(e) {
                                        var t, i = 0;
                                        for (t = 0; t < e.length; t++) i += e[t].data.byteLength;
                                        return i
                                    }(e));
                                for (t = 0; t < e.length; t++) i = e[t], r.set(i.data, n), n += i.data.byteLength;
                                return r
                            }
                        },
                        de = le.ONE_SECOND_IN_TS,
                        pe = {
                            clearDtsInfo: function(e) {
                                delete e.minSegmentDts, delete e.maxSegmentDts, delete e.minSegmentPts, delete e.maxSegmentPts
                            },
                            calculateTrackBaseMediaDecodeTime: function(e, t) {
                                var i, n = e.minSegmentDts;
                                return t || (n -= e.timelineStartInfo.dts), i = e.timelineStartInfo.baseMediaDecodeTime, i += n, i = Math.max(0, i), "audio" === e.type && (i *= e.samplerate / de, i = Math.floor(i)), i
                            },
                            collectDtsInfo: function(e, t) {
                                "number" == typeof t.pts && (void 0 === e.timelineStartInfo.pts && (e.timelineStartInfo.pts = t.pts), void 0 === e.minSegmentPts ? e.minSegmentPts = t.pts : e.minSegmentPts = Math.min(e.minSegmentPts, t.pts), void 0 === e.maxSegmentPts ? e.maxSegmentPts = t.pts : e.maxSegmentPts = Math.max(e.maxSegmentPts, t.pts)), "number" == typeof t.dts && (void 0 === e.timelineStartInfo.dts && (e.timelineStartInfo.dts = t.dts), void 0 === e.minSegmentDts ? e.minSegmentDts = t.dts : e.minSegmentDts = Math.min(e.minSegmentDts, t.dts), void 0 === e.maxSegmentDts ? e.maxSegmentDts = t.dts : e.maxSegmentDts = Math.max(e.maxSegmentDts, t.dts))
                            }
                        },
                        fe = {
                            parseSei: function(e) {
                                for (var t = 0, i = {
                                        payloadType: -1,
                                        payloadSize: 0
                                    }, n = 0, r = 0; t < e.byteLength && 128 !== e[t];) {
                                    for (; 255 === e[t];) n += 255, t++;
                                    for (n += e[t++]; 255 === e[t];) r += 255, t++;
                                    if (r += e[t++], !i.payload && 4 === n) {
                                        if ("GA94" === String.fromCharCode(e[t + 3], e[t + 4], e[t + 5], e[t + 6])) {
                                            i.payloadType = n, i.payloadSize = r, i.payload = e.subarray(t, t + r);
                                            break
                                        }
                                        i.payload = void 0
                                    }
                                    t += r, n = 0, r = 0
                                }
                                return i
                            },
                            parseUserData: function(e) {
                                return 181 !== e.payload[0] || 49 != (e.payload[1] << 8 | e.payload[2]) || "GA94" !== String.fromCharCode(e.payload[3], e.payload[4], e.payload[5], e.payload[6]) || 3 !== e.payload[7] ? null : e.payload.subarray(8, e.payload.length - 1)
                            },
                            parseCaptionPackets: function(e, t) {
                                var i, n, r, s, a = [];
                                if (!(64 & t[0])) return a;
                                for (n = 31 & t[0], i = 0; i < n; i++) s = {
                                    type: 3 & t[(r = 3 * i) + 2],
                                    pts: e
                                }, 4 & t[r + 2] && (s.ccData = t[r + 3] << 8 | t[r + 4], a.push(s));
                                return a
                            },
                            discardEmulationPreventionBytes: function(e) {
                                for (var t, i, n = e.byteLength, r = [], s = 1; s < n - 2;) 0 === e[s] && 0 === e[s + 1] && 3 === e[s + 2] ? (r.push(s + 2), s += 2) : s++;
                                if (0 === r.length) return e;
                                t = n - r.length, i = new Uint8Array(t);
                                var a = 0;
                                for (s = 0; s < t; a++, s++) a === r[0] && (a++, r.shift()), i[s] = e[a];
                                return i
                            },
                            USER_DATA_REGISTERED_ITU_T_T35: 4
                        },
                        me = G,
                        ge = fe,
                        ye = function(e) {
                            e = e || {}, ye.prototype.init.call(this), this.parse708captions_ = "boolean" != typeof e.parse708captions || e.parse708captions, this.captionPackets_ = [], this.ccStreams_ = [new Ce(0, 0), new Ce(0, 1), new Ce(1, 0), new Ce(1, 1)], this.parse708captions_ && (this.cc708Stream_ = new xe({
                                captionServices: e.captionServices
                            })), this.reset(), this.ccStreams_.forEach((function(e) {
                                e.on("data", this.trigger.bind(this, "data")), e.on("partialdone", this.trigger.bind(this, "partialdone")), e.on("done", this.trigger.bind(this, "done"))
                            }), this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone")), this.cc708Stream_.on("done", this.trigger.bind(this, "done")))
                        };
                    ye.prototype = new me, ye.prototype.push = function(e) {
                        var t, i, n;
                        if ("sei_rbsp" === e.nalUnitType && (t = ge.parseSei(e.escapedRBSP)).payload && t.payloadType === ge.USER_DATA_REGISTERED_ITU_T_T35 && (i = ge.parseUserData(t)))
                            if (e.dts < this.latestDts_) this.ignoreNextEqualDts_ = !0;
                            else {
                                if (e.dts === this.latestDts_ && this.ignoreNextEqualDts_) return this.numSameDts_--, void(this.numSameDts_ || (this.ignoreNextEqualDts_ = !1));
                                n = ge.parseCaptionPackets(e.pts, i), this.captionPackets_ = this.captionPackets_.concat(n), this.latestDts_ !== e.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = e.dts
                            }
                    }, ye.prototype.flushCCStreams = function(e) {
                        this.ccStreams_.forEach((function(t) {
                            return "flush" === e ? t.flush() : t.partialFlush()
                        }), this)
                    }, ye.prototype.flushStream = function(e) {
                        this.captionPackets_.length ? (this.captionPackets_.forEach((function(e, t) {
                            e.presortIndex = t
                        })), this.captionPackets_.sort((function(e, t) {
                            return e.pts === t.pts ? e.presortIndex - t.presortIndex : e.pts - t.pts
                        })), this.captionPackets_.forEach((function(e) {
                            e.type < 2 ? this.dispatchCea608Packet(e) : this.dispatchCea708Packet(e)
                        }), this), this.captionPackets_.length = 0, this.flushCCStreams(e)) : this.flushCCStreams(e)
                    }, ye.prototype.flush = function() {
                        return this.flushStream("flush")
                    }, ye.prototype.partialFlush = function() {
                        return this.flushStream("partialFlush")
                    }, ye.prototype.reset = function() {
                        this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach((function(e) {
                            e.reset()
                        }))
                    }, ye.prototype.dispatchCea608Packet = function(e) {
                        this.setsTextOrXDSActive(e) ? this.activeCea608Channel_[e.type] = null : this.setsChannel1Active(e) ? this.activeCea608Channel_[e.type] = 0 : this.setsChannel2Active(e) && (this.activeCea608Channel_[e.type] = 1), null !== this.activeCea608Channel_[e.type] && this.ccStreams_[(e.type << 1) + this.activeCea608Channel_[e.type]].push(e)
                    }, ye.prototype.setsChannel1Active = function(e) {
                        return 4096 == (30720 & e.ccData)
                    }, ye.prototype.setsChannel2Active = function(e) {
                        return 6144 == (30720 & e.ccData)
                    }, ye.prototype.setsTextOrXDSActive = function(e) {
                        return 256 == (28928 & e.ccData) || 4138 == (30974 & e.ccData) || 6186 == (30974 & e.ccData)
                    }, ye.prototype.dispatchCea708Packet = function(e) {
                        this.parse708captions_ && this.cc708Stream_.push(e)
                    };
                    var _e = {
                            127: 9834,
                            4128: 32,
                            4129: 160,
                            4133: 8230,
                            4138: 352,
                            4140: 338,
                            4144: 9608,
                            4145: 8216,
                            4146: 8217,
                            4147: 8220,
                            4148: 8221,
                            4149: 8226,
                            4153: 8482,
                            4154: 353,
                            4156: 339,
                            4157: 8480,
                            4159: 376,
                            4214: 8539,
                            4215: 8540,
                            4216: 8541,
                            4217: 8542,
                            4218: 9168,
                            4219: 9124,
                            4220: 9123,
                            4221: 9135,
                            4222: 9126,
                            4223: 9121,
                            4256: 12600
                        },
                        ve = function(e) {
                            return 32 <= e && e <= 127 || 160 <= e && e <= 255
                        },
                        be = function(e) {
                            this.windowNum = e, this.reset()
                        };
                    be.prototype.reset = function() {
                        this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0
                    }, be.prototype.getText = function() {
                        return this.rows.join("\n")
                    }, be.prototype.clearText = function() {
                        this.rows = [""], this.rowIdx = 0
                    }, be.prototype.newLine = function(e) {
                        for (this.rows.length >= this.virtualRowCount && "function" == typeof this.beforeRowOverflow && this.beforeRowOverflow(e), this.rows.length > 0 && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount;) this.rows.shift(), this.rowIdx--
                    }, be.prototype.isEmpty = function() {
                        return 0 === this.rows.length || 1 === this.rows.length && "" === this.rows[0]
                    }, be.prototype.addText = function(e) {
                        this.rows[this.rowIdx] += e
                    }, be.prototype.backspace = function() {
                        if (!this.isEmpty()) {
                            var e = this.rows[this.rowIdx];
                            this.rows[this.rowIdx] = e.substr(0, e.length - 1)
                        }
                    };
                    var Te = function(e, t, i) {
                        this.serviceNum = e, this.text = "", this.currentWindow = new be(-1), this.windows = [], this.stream = i, "string" == typeof t && this.createTextDecoder(t)
                    };
                    Te.prototype.init = function(e, t) {
                        this.startPts = e;
                        for (var i = 0; i < 8; i++) this.windows[i] = new be(i), "function" == typeof t && (this.windows[i].beforeRowOverflow = t)
                    }, Te.prototype.setCurrentWindow = function(e) {
                        this.currentWindow = this.windows[e]
                    }, Te.prototype.createTextDecoder = function(e) {
                        if ("undefined" == typeof TextDecoder) this.stream.trigger("log", {
                            level: "warn",
                            message: "The `encoding` option is unsupported without TextDecoder support"
                        });
                        else try {
                            this.textDecoder_ = new TextDecoder(e)
                        } catch (t) {
                            this.stream.trigger("log", {
                                level: "warn",
                                message: "TextDecoder could not be created with " + e + " encoding. " + t
                            })
                        }
                    };
                    var xe = function(e) {
                        e = e || {}, xe.prototype.init.call(this);
                        var t, i = this,
                            n = e.captionServices || {},
                            r = {};
                        Object.keys(n).forEach((e => {
                            t = n[e], /^SERVICE/.test(e) && (r[e] = t.encoding)
                        })), this.serviceEncodings = r, this.current708Packet = null, this.services = {}, this.push = function(e) {
                            3 === e.type ? (i.new708Packet(), i.add708Bytes(e)) : (null === i.current708Packet && i.new708Packet(), i.add708Bytes(e))
                        }
                    };
                    xe.prototype = new me, xe.prototype.new708Packet = function() {
                        null !== this.current708Packet && this.push708Packet(), this.current708Packet = {
                            data: [],
                            ptsVals: []
                        }
                    }, xe.prototype.add708Bytes = function(e) {
                        var t = e.ccData,
                            i = t >>> 8,
                            n = 255 & t;
                        this.current708Packet.ptsVals.push(e.pts), this.current708Packet.data.push(i), this.current708Packet.data.push(n)
                    }, xe.prototype.push708Packet = function() {
                        var e = this.current708Packet,
                            t = e.data,
                            i = null,
                            n = null,
                            r = 0,
                            s = t[r++];
                        for (e.seq = s >> 6, e.sizeCode = 63 & s; r < t.length; r++) n = 31 & (s = t[r++]), 7 === (i = s >> 5) && n > 0 && (i = s = t[r++]), this.pushServiceBlock(i, r, n), n > 0 && (r += n - 1)
                    }, xe.prototype.pushServiceBlock = function(e, t, i) {
                        var n, r = t,
                            s = this.current708Packet.data,
                            a = this.services[e];
                        for (a || (a = this.initService(e, r)); r < t + i && r < s.length; r++) n = s[r], ve(n) ? r = this.handleText(r, a) : 24 === n ? r = this.multiByteCharacter(r, a) : 16 === n ? r = this.extendedCommands(r, a) : 128 <= n && n <= 135 ? r = this.setCurrentWindow(r, a) : 152 <= n && n <= 159 ? r = this.defineWindow(r, a) : 136 === n ? r = this.clearWindows(r, a) : 140 === n ? r = this.deleteWindows(r, a) : 137 === n ? r = this.displayWindows(r, a) : 138 === n ? r = this.hideWindows(r, a) : 139 === n ? r = this.toggleWindows(r, a) : 151 === n ? r = this.setWindowAttributes(r, a) : 144 === n ? r = this.setPenAttributes(r, a) : 145 === n ? r = this.setPenColor(r, a) : 146 === n ? r = this.setPenLocation(r, a) : 143 === n ? a = this.reset(r, a) : 8 === n ? a.currentWindow.backspace() : 12 === n ? a.currentWindow.clearText() : 13 === n ? a.currentWindow.pendingNewLine = !0 : 14 === n ? a.currentWindow.clearText() : 141 === n && r++
                    }, xe.prototype.extendedCommands = function(e, t) {
                        var i = this.current708Packet.data[++e];
                        return ve(i) && (e = this.handleText(e, t, {
                            isExtended: !0
                        })), e
                    }, xe.prototype.getPts = function(e) {
                        return this.current708Packet.ptsVals[Math.floor(e / 2)]
                    }, xe.prototype.initService = function(e, t) {
                        var i, n, r = this;
                        return (i = "SERVICE" + e) in this.serviceEncodings && (n = this.serviceEncodings[i]), this.services[e] = new Te(e, n, r), this.services[e].init(this.getPts(t), (function(t) {
                            r.flushDisplayed(t, r.services[e])
                        })), this.services[e]
                    }, xe.prototype.handleText = function(e, t, i) {
                        var n, r, s, a, o = i && i.isExtended,
                            l = i && i.isMultiByte,
                            h = this.current708Packet.data,
                            c = o ? 4096 : 0,
                            u = h[e],
                            d = h[e + 1],
                            p = t.currentWindow;
                        return t.textDecoder_ && !o ? (l ? (r = [u, d], e++) : r = [u], n = t.textDecoder_.decode(new Uint8Array(r))) : (a = _e[s = c | u] || s, n = 4096 & s && s === a ? "" : String.fromCharCode(a)), p.pendingNewLine && !p.isEmpty() && p.newLine(this.getPts(e)), p.pendingNewLine = !1, p.addText(n), e
                    }, xe.prototype.multiByteCharacter = function(e, t) {
                        var i = this.current708Packet.data,
                            n = i[e + 1],
                            r = i[e + 2];
                        return ve(n) && ve(r) && (e = this.handleText(++e, t, {
                            isMultiByte: !0
                        })), e
                    }, xe.prototype.setCurrentWindow = function(e, t) {
                        var i = 7 & this.current708Packet.data[e];
                        return t.setCurrentWindow(i), e
                    }, xe.prototype.defineWindow = function(e, t) {
                        var i = this.current708Packet.data,
                            n = i[e],
                            r = 7 & n;
                        t.setCurrentWindow(r);
                        var s = t.currentWindow;
                        return n = i[++e], s.visible = (32 & n) >> 5, s.rowLock = (16 & n) >> 4, s.columnLock = (8 & n) >> 3, s.priority = 7 & n, n = i[++e], s.relativePositioning = (128 & n) >> 7, s.anchorVertical = 127 & n, n = i[++e], s.anchorHorizontal = n, n = i[++e], s.anchorPoint = (240 & n) >> 4, s.rowCount = 15 & n, n = i[++e], s.columnCount = 63 & n, n = i[++e], s.windowStyle = (56 & n) >> 3, s.penStyle = 7 & n, s.virtualRowCount = s.rowCount + 1, e
                    }, xe.prototype.setWindowAttributes = function(e, t) {
                        var i = this.current708Packet.data,
                            n = i[e],
                            r = t.currentWindow.winAttr;
                        return n = i[++e], r.fillOpacity = (192 & n) >> 6, r.fillRed = (48 & n) >> 4, r.fillGreen = (12 & n) >> 2, r.fillBlue = 3 & n, n = i[++e], r.borderType = (192 & n) >> 6, r.borderRed = (48 & n) >> 4, r.borderGreen = (12 & n) >> 2, r.borderBlue = 3 & n, n = i[++e], r.borderType += (128 & n) >> 5, r.wordWrap = (64 & n) >> 6, r.printDirection = (48 & n) >> 4, r.scrollDirection = (12 & n) >> 2, r.justify = 3 & n, n = i[++e], r.effectSpeed = (240 & n) >> 4, r.effectDirection = (12 & n) >> 2, r.displayEffect = 3 & n, e
                    }, xe.prototype.flushDisplayed = function(e, t) {
                        for (var i = [], n = 0; n < 8; n++) t.windows[n].visible && !t.windows[n].isEmpty() && i.push(t.windows[n].getText());
                        t.endPts = e, t.text = i.join("\n\n"), this.pushCaption(t), t.startPts = e
                    }, xe.prototype.pushCaption = function(e) {
                        "" !== e.text && (this.trigger("data", {
                            startPts: e.startPts,
                            endPts: e.endPts,
                            text: e.text,
                            stream: "cc708_" + e.serviceNum
                        }), e.text = "", e.startPts = e.endPts)
                    }, xe.prototype.displayWindows = function(e, t) {
                        var i = this.current708Packet.data[++e],
                            n = this.getPts(e);
                        this.flushDisplayed(n, t);
                        for (var r = 0; r < 8; r++) i & 1 << r && (t.windows[r].visible = 1);
                        return e
                    }, xe.prototype.hideWindows = function(e, t) {
                        var i = this.current708Packet.data[++e],
                            n = this.getPts(e);
                        this.flushDisplayed(n, t);
                        for (var r = 0; r < 8; r++) i & 1 << r && (t.windows[r].visible = 0);
                        return e
                    }, xe.prototype.toggleWindows = function(e, t) {
                        var i = this.current708Packet.data[++e],
                            n = this.getPts(e);
                        this.flushDisplayed(n, t);
                        for (var r = 0; r < 8; r++) i & 1 << r && (t.windows[r].visible ^= 1);
                        return e
                    }, xe.prototype.clearWindows = function(e, t) {
                        var i = this.current708Packet.data[++e],
                            n = this.getPts(e);
                        this.flushDisplayed(n, t);
                        for (var r = 0; r < 8; r++) i & 1 << r && t.windows[r].clearText();
                        return e
                    }, xe.prototype.deleteWindows = function(e, t) {
                        var i = this.current708Packet.data[++e],
                            n = this.getPts(e);
                        this.flushDisplayed(n, t);
                        for (var r = 0; r < 8; r++) i & 1 << r && t.windows[r].reset();
                        return e
                    }, xe.prototype.setPenAttributes = function(e, t) {
                        var i = this.current708Packet.data,
                            n = i[e],
                            r = t.currentWindow.penAttr;
                        return n = i[++e], r.textTag = (240 & n) >> 4, r.offset = (12 & n) >> 2, r.penSize = 3 & n, n = i[++e], r.italics = (128 & n) >> 7, r.underline = (64 & n) >> 6, r.edgeType = (56 & n) >> 3, r.fontStyle = 7 & n, e
                    }, xe.prototype.setPenColor = function(e, t) {
                        var i = this.current708Packet.data,
                            n = i[e],
                            r = t.currentWindow.penColor;
                        return n = i[++e], r.fgOpacity = (192 & n) >> 6, r.fgRed = (48 & n) >> 4, r.fgGreen = (12 & n) >> 2, r.fgBlue = 3 & n, n = i[++e], r.bgOpacity = (192 & n) >> 6, r.bgRed = (48 & n) >> 4, r.bgGreen = (12 & n) >> 2, r.bgBlue = 3 & n, n = i[++e], r.edgeRed = (48 & n) >> 4, r.edgeGreen = (12 & n) >> 2, r.edgeBlue = 3 & n, e
                    }, xe.prototype.setPenLocation = function(e, t) {
                        var i = this.current708Packet.data,
                            n = i[e],
                            r = t.currentWindow.penLoc;
                        return t.currentWindow.pendingNewLine = !0, n = i[++e], r.row = 15 & n, n = i[++e], r.column = 63 & n, e
                    }, xe.prototype.reset = function(e, t) {
                        var i = this.getPts(e);
                        return this.flushDisplayed(i, t), this.initService(t.serviceNum, e)
                    };
                    var we = {
                            42: 225,
                            92: 233,
                            94: 237,
                            95: 243,
                            96: 250,
                            123: 231,
                            124: 247,
                            125: 209,
                            126: 241,
                            127: 9608,
                            304: 174,
                            305: 176,
                            306: 189,
                            307: 191,
                            308: 8482,
                            309: 162,
                            310: 163,
                            311: 9834,
                            312: 224,
                            313: 160,
                            314: 232,
                            315: 226,
                            316: 234,
                            317: 238,
                            318: 244,
                            319: 251,
                            544: 193,
                            545: 201,
                            546: 211,
                            547: 218,
                            548: 220,
                            549: 252,
                            550: 8216,
                            551: 161,
                            552: 42,
                            553: 39,
                            554: 8212,
                            555: 169,
                            556: 8480,
                            557: 8226,
                            558: 8220,
                            559: 8221,
                            560: 192,
                            561: 194,
                            562: 199,
                            563: 200,
                            564: 202,
                            565: 203,
                            566: 235,
                            567: 206,
                            568: 207,
                            569: 239,
                            570: 212,
                            571: 217,
                            572: 249,
                            573: 219,
                            574: 171,
                            575: 187,
                            800: 195,
                            801: 227,
                            802: 205,
                            803: 204,
                            804: 236,
                            805: 210,
                            806: 242,
                            807: 213,
                            808: 245,
                            809: 123,
                            810: 125,
                            811: 92,
                            812: 94,
                            813: 95,
                            814: 124,
                            815: 126,
                            816: 196,
                            817: 228,
                            818: 214,
                            819: 246,
                            820: 223,
                            821: 165,
                            822: 164,
                            823: 9474,
                            824: 197,
                            825: 229,
                            826: 216,
                            827: 248,
                            828: 9484,
                            829: 9488,
                            830: 9492,
                            831: 9496
                        },
                        Se = function(e) {
                            return null === e ? "" : (e = we[e] || e, String.fromCharCode(e))
                        },
                        Ee = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152],
                        Me = function() {
                            for (var e = [], t = 15; t--;) e.push("");
                            return e
                        },
                        Ce = function(e, t) {
                            Ce.prototype.init.call(this), this.field_ = e || 0, this.dataChannel_ = t || 0, this.name_ = "CC" + (1 + (this.field_ << 1 | this.dataChannel_)), this.setConstants(), this.reset(), this.push = function(e) {
                                var t, i, n, r, s;
                                if ((t = 32639 & e.ccData) !== this.lastControlCode_) {
                                    if (4096 == (61440 & t) ? this.lastControlCode_ = t : t !== this.PADDING_ && (this.lastControlCode_ = null), n = t >>> 8, r = 255 & t, t !== this.PADDING_)
                                        if (t === this.RESUME_CAPTION_LOADING_) this.mode_ = "popOn";
                                        else if (t === this.END_OF_CAPTION_) this.mode_ = "popOn", this.clearFormatting(e.pts), this.flushDisplayed(e.pts), i = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = i, this.startPts_ = e.pts;
                                    else if (t === this.ROLL_UP_2_ROWS_) this.rollUpRows_ = 2, this.setRollUp(e.pts);
                                    else if (t === this.ROLL_UP_3_ROWS_) this.rollUpRows_ = 3, this.setRollUp(e.pts);
                                    else if (t === this.ROLL_UP_4_ROWS_) this.rollUpRows_ = 4, this.setRollUp(e.pts);
                                    else if (t === this.CARRIAGE_RETURN_) this.clearFormatting(e.pts), this.flushDisplayed(e.pts), this.shiftRowsUp_(), this.startPts_ = e.pts;
                                    else if (t === this.BACKSPACE_) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
                                    else if (t === this.ERASE_DISPLAYED_MEMORY_) this.flushDisplayed(e.pts), this.displayed_ = Me();
                                    else if (t === this.ERASE_NON_DISPLAYED_MEMORY_) this.nonDisplayed_ = Me();
                                    else if (t === this.RESUME_DIRECT_CAPTIONING_) "paintOn" !== this.mode_ && (this.flushDisplayed(e.pts), this.displayed_ = Me()), this.mode_ = "paintOn", this.startPts_ = e.pts;
                                    else if (this.isSpecialCharacter(n, r)) s = Se((n = (3 & n) << 8) | r), this[this.mode_](e.pts, s), this.column_++;
                                    else if (this.isExtCharacter(n, r)) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1), s = Se((n = (3 & n) << 8) | r), this[this.mode_](e.pts, s), this.column_++;
                                    else if (this.isMidRowCode(n, r)) this.clearFormatting(e.pts), this[this.mode_](e.pts, " "), this.column_++, 14 == (14 & r) && this.addFormatting(e.pts, ["i"]), 1 == (1 & r) && this.addFormatting(e.pts, ["u"]);
                                    else if (this.isOffsetControlCode(n, r)) this.column_ += 3 & r;
                                    else if (this.isPAC(n, r)) {
                                        var a = Ee.indexOf(7968 & t);
                                        "rollUp" === this.mode_ && (a - this.rollUpRows_ + 1 < 0 && (a = this.rollUpRows_ - 1), this.setRollUp(e.pts, a)), a !== this.row_ && (this.clearFormatting(e.pts), this.row_ = a), 1 & r && -1 === this.formatting_.indexOf("u") && this.addFormatting(e.pts, ["u"]), 16 == (16 & t) && (this.column_ = 4 * ((14 & t) >> 1)), this.isColorPAC(r) && 14 == (14 & r) && this.addFormatting(e.pts, ["i"])
                                    } else this.isNormalChar(n) && (0 === r && (r = null), s = Se(n), s += Se(r), this[this.mode_](e.pts, s), this.column_ += s.length)
                                } else this.lastControlCode_ = null
                            }
                        };
                    Ce.prototype = new me, Ce.prototype.flushDisplayed = function(e) {
                        var t = this.displayed_.map((function(e, t) {
                            try {
                                return e.trim()
                            } catch (e) {
                                return this.trigger("log", {
                                    level: "warn",
                                    message: "Skipping a malformed 608 caption at index " + t + "."
                                }), ""
                            }
                        }), this).join("\n").replace(/^\n+|\n+$/g, "");
                        t.length && this.trigger("data", {
                            startPts: this.startPts_,
                            endPts: e,
                            text: t,
                            stream: this.name_
                        })
                    }, Ce.prototype.reset = function() {
                        this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = Me(), this.nonDisplayed_ = Me(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = 14, this.rollUpRows_ = 2, this.formatting_ = []
                    }, Ce.prototype.setConstants = function() {
                        0 === this.dataChannel_ ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : 1 === this.dataChannel_ && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = 32 | this.CONTROL_, this.END_OF_CAPTION_ = 47 | this.CONTROL_, this.ROLL_UP_2_ROWS_ = 37 | this.CONTROL_, this.ROLL_UP_3_ROWS_ = 38 | this.CONTROL_, this.ROLL_UP_4_ROWS_ = 39 | this.CONTROL_, this.CARRIAGE_RETURN_ = 45 | this.CONTROL_, this.RESUME_DIRECT_CAPTIONING_ = 41 | this.CONTROL_, this.BACKSPACE_ = 33 | this.CONTROL_, this.ERASE_DISPLAYED_MEMORY_ = 44 | this.CONTROL_, this.ERASE_NON_DISPLAYED_MEMORY_ = 46 | this.CONTROL_
                    }, Ce.prototype.isSpecialCharacter = function(e, t) {
                        return e === this.EXT_ && t >= 48 && t <= 63
                    }, Ce.prototype.isExtCharacter = function(e, t) {
                        return (e === this.EXT_ + 1 || e === this.EXT_ + 2) && t >= 32 && t <= 63
                    }, Ce.prototype.isMidRowCode = function(e, t) {
                        return e === this.EXT_ && t >= 32 && t <= 47
                    }, Ce.prototype.isOffsetControlCode = function(e, t) {
                        return e === this.OFFSET_ && t >= 33 && t <= 35
                    }, Ce.prototype.isPAC = function(e, t) {
                        return e >= this.BASE_ && e < this.BASE_ + 8 && t >= 64 && t <= 127
                    }, Ce.prototype.isColorPAC = function(e) {
                        return e >= 64 && e <= 79 || e >= 96 && e <= 127
                    }, Ce.prototype.isNormalChar = function(e) {
                        return e >= 32 && e <= 127
                    }, Ce.prototype.setRollUp = function(e, t) {
                        if ("rollUp" !== this.mode_ && (this.row_ = 14, this.mode_ = "rollUp", this.flushDisplayed(e), this.nonDisplayed_ = Me(), this.displayed_ = Me()), void 0 !== t && t !== this.row_)
                            for (var i = 0; i < this.rollUpRows_; i++) this.displayed_[t - i] = this.displayed_[this.row_ - i], this.displayed_[this.row_ - i] = "";
                        void 0 === t && (t = this.row_), this.topRow_ = t - this.rollUpRows_ + 1
                    }, Ce.prototype.addFormatting = function(e, t) {
                        this.formatting_ = this.formatting_.concat(t);
                        var i = t.reduce((function(e, t) {
                            return e + "<" + t + ">"
                        }), "");
                        this[this.mode_](e, i)
                    }, Ce.prototype.clearFormatting = function(e) {
                        if (this.formatting_.length) {
                            var t = this.formatting_.reverse().reduce((function(e, t) {
                                return e + "</" + t + ">"
                            }), "");
                            this.formatting_ = [], this[this.mode_](e, t)
                        }
                    }, Ce.prototype.popOn = function(e, t) {
                        var i = this.nonDisplayed_[this.row_];
                        i += t, this.nonDisplayed_[this.row_] = i
                    }, Ce.prototype.rollUp = function(e, t) {
                        var i = this.displayed_[this.row_];
                        i += t, this.displayed_[this.row_] = i
                    }, Ce.prototype.shiftRowsUp_ = function() {
                        var e;
                        for (e = 0; e < this.topRow_; e++) this.displayed_[e] = "";
                        for (e = this.row_ + 1; e < 15; e++) this.displayed_[e] = "";
                        for (e = this.topRow_; e < this.row_; e++) this.displayed_[e] = this.displayed_[e + 1];
                        this.displayed_[this.row_] = ""
                    }, Ce.prototype.paintOn = function(e, t) {
                        var i = this.displayed_[this.row_];
                        i += t, this.displayed_[this.row_] = i
                    };
                    var Ae = {
                            CaptionStream: ye,
                            Cea608Stream: Ce,
                            Cea708Stream: xe
                        },
                        Le = {
                            H264_STREAM_TYPE: 27,
                            ADTS_STREAM_TYPE: 15,
                            METADATA_STREAM_TYPE: 21
                        },
                        Ie = G,
                        Pe = "shared",
                        Re = function(e, t) {
                            var i = 1;
                            for (e > t && (i = -1); Math.abs(t - e) > 4294967296;) e += 8589934592 * i;
                            return e
                        },
                        ke = function(e) {
                            var t, i;
                            ke.prototype.init.call(this), this.type_ = e || Pe, this.push = function(e) {
                                this.type_ !== Pe && e.type !== this.type_ || (void 0 === i && (i = e.dts), e.dts = Re(e.dts, i), e.pts = Re(e.pts, i), t = e.dts, this.trigger("data", e))
                            }, this.flush = function() {
                                i = t, this.trigger("done")
                            }, this.endTimeline = function() {
                                this.flush(), this.trigger("endedtimeline")
                            }, this.discontinuity = function() {
                                i = void 0, t = void 0
                            }, this.reset = function() {
                                this.discontinuity(), this.trigger("reset")
                            }
                        };
                    ke.prototype = new Ie;
                    var De, Oe = {
                            TimestampRolloverStream: ke,
                            handleRollover: Re
                        },
                        Ne = (e, t, i) => {
                            if (!e) return -1;
                            for (var n = i; n < e.length; n++)
                                if (e[n] === t) return n;
                            return -1
                        },
                        Ue = Le,
                        Be = Ne,
                        Fe = 3,
                        He = function(e, t, i) {
                            var n, r = "";
                            for (n = t; n < i; n++) r += "%" + ("00" + e[n].toString(16)).slice(-2);
                            return r
                        },
                        ze = function(e, t, i) {
                            return decodeURIComponent(He(e, t, i))
                        },
                        Ve = function(e, t, i) {
                            return unescape(He(e, t, i))
                        },
                        Ge = function(e) {
                            return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3]
                        },
                        We = {
                            APIC: function(e) {
                                var t, i, n = 1;
                                e.data[0] === Fe && ((t = Be(e.data, 0, n)) < 0 || (e.mimeType = Ve(e.data, n, t), n = t + 1, e.pictureType = e.data[n], n++, (i = Be(e.data, 0, n)) < 0 || (e.description = ze(e.data, n, i), n = i + 1, "--\x3e" === e.mimeType ? e.url = Ve(e.data, n, e.data.length) : e.pictureData = e.data.subarray(n, e.data.length))))
                            },
                            "T*": function(e) {
                                e.data[0] === Fe && (e.value = ze(e.data, 1, e.data.length).replace(/\0*$/, ""), e.values = e.value.split("\0"))
                            },
                            TXXX: function(e) {
                                var t;
                                e.data[0] === Fe && -1 !== (t = Be(e.data, 0, 1)) && (e.description = ze(e.data, 1, t), e.value = ze(e.data, t + 1, e.data.length).replace(/\0*$/, ""), e.data = e.value)
                            },
                            "W*": function(e) {
                                e.url = Ve(e.data, 0, e.data.length).replace(/\0.*$/, "")
                            },
                            WXXX: function(e) {
                                var t;
                                e.data[0] === Fe && -1 !== (t = Be(e.data, 0, 1)) && (e.description = ze(e.data, 1, t), e.url = Ve(e.data, t + 1, e.data.length).replace(/\0.*$/, ""))
                            },
                            PRIV: function(e) {
                                var t;
                                for (t = 0; t < e.data.length; t++)
                                    if (0 === e.data[t]) {
                                        e.owner = Ve(e.data, 0, t);
                                        break
                                    }
                                e.privateData = e.data.subarray(t + 1), e.data = e.privateData
                            }
                        };
                    (De = function(e) {
                        var t, i = {
                                descriptor: e && e.descriptor
                            },
                            n = 0,
                            r = [],
                            s = 0;
                        if (De.prototype.init.call(this), this.dispatchType = Ue.METADATA_STREAM_TYPE.toString(16), i.descriptor)
                            for (t = 0; t < i.descriptor.length; t++) this.dispatchType += ("00" + i.descriptor[t].toString(16)).slice(-2);
                        this.push = function(e) {
                            var t, i, a, o, l;
                            if ("timed-metadata" === e.type)
                                if (e.dataAlignmentIndicator && (s = 0, r.length = 0), 0 === r.length && (e.data.length < 10 || e.data[0] !== "I".charCodeAt(0) || e.data[1] !== "D".charCodeAt(0) || e.data[2] !== "3".charCodeAt(0))) this.trigger("log", {
                                    level: "warn",
                                    message: "Skipping unrecognized metadata packet"
                                });
                                else if (r.push(e), s += e.data.byteLength, 1 === r.length && (n = Ge(e.data.subarray(6, 10)), n += 10), !(s < n)) {
                                for (t = {
                                        data: new Uint8Array(n),
                                        frames: [],
                                        pts: r[0].pts,
                                        dts: r[0].dts
                                    }, l = 0; l < n;) t.data.set(r[0].data.subarray(0, n - l), l), l += r[0].data.byteLength, s -= r[0].data.byteLength, r.shift();
                                i = 10, 64 & t.data[5] && (i += 4, i += Ge(t.data.subarray(10, 14)), n -= Ge(t.data.subarray(16, 20)));
                                do {
                                    if ((a = Ge(t.data.subarray(i + 4, i + 8))) < 1) {
                                        this.trigger("log", {
                                            level: "warn",
                                            message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing."
                                        });
                                        break
                                    }
                                    if ((o = {
                                            id: String.fromCharCode(t.data[i], t.data[i + 1], t.data[i + 2], t.data[i + 3]),
                                            data: t.data.subarray(i + 10, i + a + 10)
                                        }).key = o.id, We[o.id] ? We[o.id](o) : "T" === o.id[0] ? We["T*"](o) : "W" === o.id[0] && We["W*"](o), "com.apple.streaming.transportStreamTimestamp" === o.owner) {
                                        var h = o.data,
                                            c = (1 & h[3]) << 30 | h[4] << 22 | h[5] << 14 | h[6] << 6 | h[7] >>> 2;
                                        c *= 4, c += 3 & h[7], o.timeStamp = c, void 0 === t.pts && void 0 === t.dts && (t.pts = o.timeStamp, t.dts = o.timeStamp), this.trigger("timestamp", o)
                                    }
                                    t.frames.push(o), i += 10, i += a
                                } while (i < n);
                                this.trigger("data", t)
                            }
                        }
                    }).prototype = new G;
                    var je, qe, $e, Xe = De,
                        Ye = G,
                        Ke = Ae,
                        Je = Le,
                        Ze = Oe.TimestampRolloverStream,
                        Qe = 188;
                    (je = function() {
                        var e = new Uint8Array(Qe),
                            t = 0;
                        je.prototype.init.call(this), this.push = function(i) {
                            var n, r = 0,
                                s = Qe;
                            for (t ? ((n = new Uint8Array(i.byteLength + t)).set(e.subarray(0, t)), n.set(i, t), t = 0) : n = i; s < n.byteLength;) 71 !== n[r] || 71 !== n[s] ? (r++, s++) : (this.trigger("data", n.subarray(r, s)), r += Qe, s += Qe);
                            r < n.byteLength && (e.set(n.subarray(r), 0), t = n.byteLength - r)
                        }, this.flush = function() {
                            t === Qe && 71 === e[0] && (this.trigger("data", e), t = 0), this.trigger("done")
                        }, this.endTimeline = function() {
                            this.flush(), this.trigger("endedtimeline")
                        }, this.reset = function() {
                            t = 0, this.trigger("reset")
                        }
                    }).prototype = new Ye, qe = function() {
                        var e, t, i, n;
                        qe.prototype.init.call(this), n = this, this.packetsWaitingForPmt = [], this.programMapTable = void 0, e = function(e, n) {
                            var r = 0;
                            n.payloadUnitStartIndicator && (r += e[r] + 1), "pat" === n.type ? t(e.subarray(r), n) : i(e.subarray(r), n)
                        }, t = function(e, t) {
                            t.section_number = e[7], t.last_section_number = e[8], n.pmtPid = (31 & e[10]) << 8 | e[11], t.pmtPid = n.pmtPid
                        }, i = function(e, t) {
                            var i, r;
                            if (1 & e[5]) {
                                for (n.programMapTable = {
                                        video: null,
                                        audio: null,
                                        "timed-metadata": {}
                                    }, i = 3 + ((15 & e[1]) << 8 | e[2]) - 4, r = 12 + ((15 & e[10]) << 8 | e[11]); r < i;) {
                                    var s = e[r],
                                        a = (31 & e[r + 1]) << 8 | e[r + 2];
                                    s === Je.H264_STREAM_TYPE && null === n.programMapTable.video ? n.programMapTable.video = a : s === Je.ADTS_STREAM_TYPE && null === n.programMapTable.audio ? n.programMapTable.audio = a : s === Je.METADATA_STREAM_TYPE && (n.programMapTable["timed-metadata"][a] = s), r += 5 + ((15 & e[r + 3]) << 8 | e[r + 4])
                                }
                                t.programMapTable = n.programMapTable
                            }
                        }, this.push = function(t) {
                            var i = {},
                                n = 4;
                            if (i.payloadUnitStartIndicator = !!(64 & t[1]), i.pid = 31 & t[1], i.pid <<= 8, i.pid |= t[2], (48 & t[3]) >>> 4 > 1 && (n += t[n] + 1), 0 === i.pid) i.type = "pat", e(t.subarray(n), i), this.trigger("data", i);
                            else if (i.pid === this.pmtPid)
                                for (i.type = "pmt", e(t.subarray(n), i), this.trigger("data", i); this.packetsWaitingForPmt.length;) this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
                            else void 0 === this.programMapTable ? this.packetsWaitingForPmt.push([t, n, i]) : this.processPes_(t, n, i)
                        }, this.processPes_ = function(e, t, i) {
                            i.pid === this.programMapTable.video ? i.streamType = Je.H264_STREAM_TYPE : i.pid === this.programMapTable.audio ? i.streamType = Je.ADTS_STREAM_TYPE : i.streamType = this.programMapTable["timed-metadata"][i.pid], i.type = "pes", i.data = e.subarray(t), this.trigger("data", i)
                        }
                    }, qe.prototype = new Ye, qe.STREAM_TYPES = {
                        h264: 27,
                        adts: 15
                    }, $e = function() {
                        var e, t = this,
                            i = !1,
                            n = {
                                data: [],
                                size: 0
                            },
                            r = {
                                data: [],
                                size: 0
                            },
                            s = {
                                data: [],
                                size: 0
                            },
                            a = function(e, i, n) {
                                var r, s, a = new Uint8Array(e.size),
                                    o = {
                                        type: i
                                    },
                                    l = 0,
                                    h = 0;
                                if (e.data.length && !(e.size < 9)) {
                                    for (o.trackId = e.data[0].pid, l = 0; l < e.data.length; l++) s = e.data[l], a.set(s.data, h), h += s.data.byteLength;
                                    ! function(e, t) {
                                        var i;
                                        const n = e[0] << 16 | e[1] << 8 | e[2];
                                        t.data = new Uint8Array, 1 === n && (t.packetLength = 6 + (e[4] << 8 | e[5]), t.dataAlignmentIndicator = 0 != (4 & e[6]), 192 & (i = e[7]) && (t.pts = (14 & e[9]) << 27 | (255 & e[10]) << 20 | (254 & e[11]) << 12 | (255 & e[12]) << 5 | (254 & e[13]) >>> 3, t.pts *= 4, t.pts += (6 & e[13]) >>> 1, t.dts = t.pts, 64 & i && (t.dts = (14 & e[14]) << 27 | (255 & e[15]) << 20 | (254 & e[16]) << 12 | (255 & e[17]) << 5 | (254 & e[18]) >>> 3, t.dts *= 4, t.dts += (6 & e[18]) >>> 1)), t.data = e.subarray(9 + e[8]))
                                    }(a, o), r = "video" === i || o.packetLength <= e.size, (n || r) && (e.size = 0, e.data.length = 0), r && t.trigger("data", o)
                                }
                            };
                        $e.prototype.init.call(this), this.push = function(o) {
                            ({
                                pat: function() {},
                                pes: function() {
                                    var e, t;
                                    switch (o.streamType) {
                                        case Je.H264_STREAM_TYPE:
                                            e = n, t = "video";
                                            break;
                                        case Je.ADTS_STREAM_TYPE:
                                            e = r, t = "audio";
                                            break;
                                        case Je.METADATA_STREAM_TYPE:
                                            e = s, t = "timed-metadata";
                                            break;
                                        default:
                                            return
                                    }
                                    o.payloadUnitStartIndicator && a(e, t, !0), e.data.push(o), e.size += o.data.byteLength
                                },
                                pmt: function() {
                                    var n = {
                                        type: "metadata",
                                        tracks: []
                                    };
                                    null !== (e = o.programMapTable).video && n.tracks.push({
                                        timelineStartInfo: {
                                            baseMediaDecodeTime: 0
                                        },
                                        id: +e.video,
                                        codec: "avc",
                                        type: "video"
                                    }), null !== e.audio && n.tracks.push({
                                        timelineStartInfo: {
                                            baseMediaDecodeTime: 0
                                        },
                                        id: +e.audio,
                                        codec: "adts",
                                        type: "audio"
                                    }), i = !0, t.trigger("data", n)
                                }
                            })[o.type]()
                        }, this.reset = function() {
                            n.size = 0, n.data.length = 0, r.size = 0, r.data.length = 0, this.trigger("reset")
                        }, this.flushStreams_ = function() {
                            a(n, "video"), a(r, "audio"), a(s, "timed-metadata")
                        }, this.flush = function() {
                            if (!i && e) {
                                var n = {
                                    type: "metadata",
                                    tracks: []
                                };
                                null !== e.video && n.tracks.push({
                                    timelineStartInfo: {
                                        baseMediaDecodeTime: 0
                                    },
                                    id: +e.video,
                                    codec: "avc",
                                    type: "video"
                                }), null !== e.audio && n.tracks.push({
                                    timelineStartInfo: {
                                        baseMediaDecodeTime: 0
                                    },
                                    id: +e.audio,
                                    codec: "adts",
                                    type: "audio"
                                }), t.trigger("data", n)
                            }
                            i = !1, this.flushStreams_(), this.trigger("done")
                        }
                    }, $e.prototype = new Ye;
                    var et = {
                        PAT_PID: 0,
                        MP2T_PACKET_LENGTH: Qe,
                        TransportPacketStream: je,
                        TransportParseStream: qe,
                        ElementaryStream: $e,
                        TimestampRolloverStream: Ze,
                        CaptionStream: Ke.CaptionStream,
                        Cea608Stream: Ke.Cea608Stream,
                        Cea708Stream: Ke.Cea708Stream,
                        MetadataStream: Xe
                    };
                    for (var tt in Je) Je.hasOwnProperty(tt) && (et[tt] = Je[tt]);
                    var it, nt = et,
                        rt = le.ONE_SECOND_IN_TS,
                        st = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                    (it = function(e) {
                        var t, i = 0;
                        it.prototype.init.call(this), this.skipWarn_ = function(e, t) {
                            this.trigger("log", {
                                level: "warn",
                                message: `adts skiping bytes ${e} to ${t} in frame ${i} outside syncword`
                            })
                        }, this.push = function(n) {
                            var r, s, a, o, l, h = 0;
                            if (e || (i = 0), "audio" === n.type) {
                                var c;
                                for (t && t.length ? (a = t, (t = new Uint8Array(a.byteLength + n.data.byteLength)).set(a), t.set(n.data, a.byteLength)) : t = n.data; h + 7 < t.length;)
                                    if (255 === t[h] && 240 == (246 & t[h + 1])) {
                                        if ("number" == typeof c && (this.skipWarn_(c, h), c = null), s = 2 * (1 & ~t[h + 1]), r = (3 & t[h + 3]) << 11 | t[h + 4] << 3 | (224 & t[h + 5]) >> 5, l = (o = 1024 * (1 + (3 & t[h + 6]))) * rt / st[(60 & t[h + 2]) >>> 2], t.byteLength - h < r) break;
                                        this.trigger("data", {
                                            pts: n.pts + i * l,
                                            dts: n.dts + i * l,
                                            sampleCount: o,
                                            audioobjecttype: 1 + (t[h + 2] >>> 6 & 3),
                                            channelcount: (1 & t[h + 2]) << 2 | (192 & t[h + 3]) >>> 6,
                                            samplerate: st[(60 & t[h + 2]) >>> 2],
                                            samplingfrequencyindex: (60 & t[h + 2]) >>> 2,
                                            samplesize: 16,
                                            data: t.subarray(h + 7 + s, h + r)
                                        }), i++, h += r
                                    } else "number" != typeof c && (c = h), h++;
                                "number" == typeof c && (this.skipWarn_(c, h), c = null), t = t.subarray(h)
                            }
                        }, this.flush = function() {
                            i = 0, this.trigger("done")
                        }, this.reset = function() {
                            t = void 0, this.trigger("reset")
                        }, this.endTimeline = function() {
                            t = void 0, this.trigger("endedtimeline")
                        }
                    }).prototype = new G;
                    var at, ot, lt, ht = it,
                        ct = G,
                        ut = function(e) {
                            var t = e.byteLength,
                                i = 0,
                                n = 0;
                            this.length = function() {
                                return 8 * t
                            }, this.bitsAvailable = function() {
                                return 8 * t + n
                            }, this.loadWord = function() {
                                var r = e.byteLength - t,
                                    s = new Uint8Array(4),
                                    a = Math.min(4, t);
                                if (0 === a) throw new Error("no bytes available");
                                s.set(e.subarray(r, r + a)), i = new DataView(s.buffer).getUint32(0), n = 8 * a, t -= a
                            }, this.skipBits = function(e) {
                                var r;
                                n > e ? (i <<= e, n -= e) : (e -= n, e -= 8 * (r = Math.floor(e / 8)), t -= r, this.loadWord(), i <<= e, n -= e)
                            }, this.readBits = function(e) {
                                var r = Math.min(n, e),
                                    s = i >>> 32 - r;
                                return (n -= r) > 0 ? i <<= r : t > 0 && this.loadWord(), (r = e - r) > 0 ? s << r | this.readBits(r) : s
                            }, this.skipLeadingZeros = function() {
                                var e;
                                for (e = 0; e < n; ++e)
                                    if (0 != (i & 2147483648 >>> e)) return i <<= e, n -= e, e;
                                return this.loadWord(), e + this.skipLeadingZeros()
                            }, this.skipUnsignedExpGolomb = function() {
                                this.skipBits(1 + this.skipLeadingZeros())
                            }, this.skipExpGolomb = function() {
                                this.skipBits(1 + this.skipLeadingZeros())
                            }, this.readUnsignedExpGolomb = function() {
                                var e = this.skipLeadingZeros();
                                return this.readBits(e + 1) - 1
                            }, this.readExpGolomb = function() {
                                var e = this.readUnsignedExpGolomb();
                                return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
                            }, this.readBoolean = function() {
                                return 1 === this.readBits(1)
                            }, this.readUnsignedByte = function() {
                                return this.readBits(8)
                            }, this.loadWord()
                        };
                    (ot = function() {
                        var e, t, i = 0;
                        ot.prototype.init.call(this), this.push = function(n) {
                            var r;
                            t ? ((r = new Uint8Array(t.byteLength + n.data.byteLength)).set(t), r.set(n.data, t.byteLength), t = r) : t = n.data;
                            for (var s = t.byteLength; i < s - 3; i++)
                                if (1 === t[i + 2]) {
                                    e = i + 5;
                                    break
                                }
                            for (; e < s;) switch (t[e]) {
                                case 0:
                                    if (0 !== t[e - 1]) {
                                        e += 2;
                                        break
                                    }
                                    if (0 !== t[e - 2]) {
                                        e++;
                                        break
                                    }
                                    i + 3 !== e - 2 && this.trigger("data", t.subarray(i + 3, e - 2));
                                    do {
                                        e++
                                    } while (1 !== t[e] && e < s);
                                    i = e - 2, e += 3;
                                    break;
                                case 1:
                                    if (0 !== t[e - 1] || 0 !== t[e - 2]) {
                                        e += 3;
                                        break
                                    }
                                    this.trigger("data", t.subarray(i + 3, e - 2)), i = e - 2, e += 3;
                                    break;
                                default:
                                    e += 3
                            }
                            t = t.subarray(i), e -= i, i = 0
                        }, this.reset = function() {
                            t = null, i = 0, this.trigger("reset")
                        }, this.flush = function() {
                            t && t.byteLength > 3 && this.trigger("data", t.subarray(i + 3)), t = null, i = 0, this.trigger("done")
                        }, this.endTimeline = function() {
                            this.flush(), this.trigger("endedtimeline")
                        }
                    }).prototype = new ct, lt = {
                        100: !0,
                        110: !0,
                        122: !0,
                        244: !0,
                        44: !0,
                        83: !0,
                        86: !0,
                        118: !0,
                        128: !0,
                        138: !0,
                        139: !0,
                        134: !0
                    }, at = function() {
                        var e, t, i, n, r, s, a, o = new ot;
                        at.prototype.init.call(this), e = this, this.push = function(e) {
                            "video" === e.type && (t = e.trackId, i = e.pts, n = e.dts, o.push(e))
                        }, o.on("data", (function(a) {
                            var o = {
                                trackId: t,
                                pts: i,
                                dts: n,
                                data: a,
                                nalUnitTypeCode: 31 & a[0]
                            };
                            switch (o.nalUnitTypeCode) {
                                case 5:
                                    o.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
                                    break;
                                case 6:
                                    o.nalUnitType = "sei_rbsp", o.escapedRBSP = r(a.subarray(1));
                                    break;
                                case 7:
                                    o.nalUnitType = "seq_parameter_set_rbsp", o.escapedRBSP = r(a.subarray(1)), o.config = s(o.escapedRBSP);
                                    break;
                                case 8:
                                    o.nalUnitType = "pic_parameter_set_rbsp";
                                    break;
                                case 9:
                                    o.nalUnitType = "access_unit_delimiter_rbsp"
                            }
                            e.trigger("data", o)
                        })), o.on("done", (function() {
                            e.trigger("done")
                        })), o.on("partialdone", (function() {
                            e.trigger("partialdone")
                        })), o.on("reset", (function() {
                            e.trigger("reset")
                        })), o.on("endedtimeline", (function() {
                            e.trigger("endedtimeline")
                        })), this.flush = function() {
                            o.flush()
                        }, this.partialFlush = function() {
                            o.partialFlush()
                        }, this.reset = function() {
                            o.reset()
                        }, this.endTimeline = function() {
                            o.endTimeline()
                        }, a = function(e, t) {
                            var i, n = 8,
                                r = 8;
                            for (i = 0; i < e; i++) 0 !== r && (r = (n + t.readExpGolomb() + 256) % 256), n = 0 === r ? n : r
                        }, r = function(e) {
                            for (var t, i, n = e.byteLength, r = [], s = 1; s < n - 2;) 0 === e[s] && 0 === e[s + 1] && 3 === e[s + 2] ? (r.push(s + 2), s += 2) : s++;
                            if (0 === r.length) return e;
                            t = n - r.length, i = new Uint8Array(t);
                            var a = 0;
                            for (s = 0; s < t; a++, s++) a === r[0] && (a++, r.shift()), i[s] = e[a];
                            return i
                        }, s = function(e) {
                            var t, i, n, r, s, o, l, h, c, u, d, p, f = 0,
                                m = 0,
                                g = 0,
                                y = 0,
                                _ = [1, 1];
                            if (i = (t = new ut(e)).readUnsignedByte(), r = t.readUnsignedByte(), n = t.readUnsignedByte(), t.skipUnsignedExpGolomb(), lt[i] && (3 === (s = t.readUnsignedExpGolomb()) && t.skipBits(1), t.skipUnsignedExpGolomb(), t.skipUnsignedExpGolomb(), t.skipBits(1), t.readBoolean()))
                                for (d = 3 !== s ? 8 : 12, p = 0; p < d; p++) t.readBoolean() && a(p < 6 ? 16 : 64, t);
                            if (t.skipUnsignedExpGolomb(), 0 === (o = t.readUnsignedExpGolomb())) t.readUnsignedExpGolomb();
                            else if (1 === o)
                                for (t.skipBits(1), t.skipExpGolomb(), t.skipExpGolomb(), l = t.readUnsignedExpGolomb(), p = 0; p < l; p++) t.skipExpGolomb();
                            if (t.skipUnsignedExpGolomb(), t.skipBits(1), h = t.readUnsignedExpGolomb(), c = t.readUnsignedExpGolomb(), 0 === (u = t.readBits(1)) && t.skipBits(1), t.skipBits(1), t.readBoolean() && (f = t.readUnsignedExpGolomb(), m = t.readUnsignedExpGolomb(), g = t.readUnsignedExpGolomb(), y = t.readUnsignedExpGolomb()), t.readBoolean() && t.readBoolean()) {
                                switch (t.readUnsignedByte()) {
                                    case 1:
                                        _ = [1, 1];
                                        break;
                                    case 2:
                                        _ = [12, 11];
                                        break;
                                    case 3:
                                        _ = [10, 11];
                                        break;
                                    case 4:
                                        _ = [16, 11];
                                        break;
                                    case 5:
                                        _ = [40, 33];
                                        break;
                                    case 6:
                                        _ = [24, 11];
                                        break;
                                    case 7:
                                        _ = [20, 11];
                                        break;
                                    case 8:
                                        _ = [32, 11];
                                        break;
                                    case 9:
                                        _ = [80, 33];
                                        break;
                                    case 10:
                                        _ = [18, 11];
                                        break;
                                    case 11:
                                        _ = [15, 11];
                                        break;
                                    case 12:
                                        _ = [64, 33];
                                        break;
                                    case 13:
                                        _ = [160, 99];
                                        break;
                                    case 14:
                                        _ = [4, 3];
                                        break;
                                    case 15:
                                        _ = [3, 2];
                                        break;
                                    case 16:
                                        _ = [2, 1];
                                        break;
                                    case 255:
                                        _ = [t.readUnsignedByte() << 8 | t.readUnsignedByte(), t.readUnsignedByte() << 8 | t.readUnsignedByte()]
                                }
                                _ && (_[0], _[1])
                            }
                            return {
                                profileIdc: i,
                                levelIdc: n,
                                profileCompatibility: r,
                                width: 16 * (h + 1) - 2 * f - 2 * m,
                                height: (2 - u) * (c + 1) * 16 - 2 * g - 2 * y,
                                sarRatio: _
                            }
                        }
                    }, at.prototype = new ct;
                    var dt, pt = {
                            H264Stream: at,
                            NalByteStream: ot
                        },
                        ft = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350],
                        mt = function(e, t) {
                            var i = e[t + 6] << 21 | e[t + 7] << 14 | e[t + 8] << 7 | e[t + 9];
                            return i = i >= 0 ? i : 0, (16 & e[t + 5]) >> 4 ? i + 20 : i + 10
                        },
                        gt = function(e, t) {
                            return e.length - t < 10 || e[t] !== "I".charCodeAt(0) || e[t + 1] !== "D".charCodeAt(0) || e[t + 2] !== "3".charCodeAt(0) ? t : (t += mt(e, t), gt(e, t))
                        },
                        yt = function(e) {
                            return e[0] << 21 | e[1] << 14 | e[2] << 7 | e[3]
                        },
                        _t = {
                            isLikelyAacData: function(e) {
                                var t = gt(e, 0);
                                return e.length >= t + 2 && 255 == (255 & e[t]) && 240 == (240 & e[t + 1]) && 16 == (22 & e[t + 1])
                            },
                            parseId3TagSize: mt,
                            parseAdtsSize: function(e, t) {
                                var i = (224 & e[t + 5]) >> 5,
                                    n = e[t + 4] << 3;
                                return 6144 & e[t + 3] | n | i
                            },
                            parseType: function(e, t) {
                                return e[t] === "I".charCodeAt(0) && e[t + 1] === "D".charCodeAt(0) && e[t + 2] === "3".charCodeAt(0) ? "timed-metadata" : !0 & e[t] && 240 == (240 & e[t + 1]) ? "audio" : null
                            },
                            parseSampleRate: function(e) {
                                for (var t = 0; t + 5 < e.length;) {
                                    if (255 === e[t] && 240 == (246 & e[t + 1])) return ft[(60 & e[t + 2]) >>> 2];
                                    t++
                                }
                                return null
                            },
                            parseAacTimestamp: function(e) {
                                var t, i, n;
                                t = 10, 64 & e[5] && (t += 4, t += yt(e.subarray(10, 14)));
                                do {
                                    if ((i = yt(e.subarray(t + 4, t + 8))) < 1) return null;
                                    if ("PRIV" === String.fromCharCode(e[t], e[t + 1], e[t + 2], e[t + 3])) {
                                        n = e.subarray(t + 10, t + i + 10);
                                        for (var r = 0; r < n.byteLength; r++)
                                            if (0 === n[r]) {
                                                var s = unescape(function(e, t, i) {
                                                    var n, r = "";
                                                    for (n = t; n < i; n++) r += "%" + ("00" + e[n].toString(16)).slice(-2);
                                                    return r
                                                }(n, 0, r));
                                                if ("com.apple.streaming.transportStreamTimestamp" === s) {
                                                    var a = n.subarray(r + 1),
                                                        o = (1 & a[3]) << 30 | a[4] << 22 | a[5] << 14 | a[6] << 6 | a[7] >>> 2;
                                                    return o *= 4, o += 3 & a[7]
                                                }
                                                break
                                            }
                                    }
                                    t += 10, t += i
                                } while (t < e.byteLength);
                                return null
                            }
                        },
                        vt = _t;
                    (dt = function() {
                        var e = new Uint8Array,
                            t = 0;
                        dt.prototype.init.call(this), this.setTimestamp = function(e) {
                            t = e
                        }, this.push = function(i) {
                            var n, r, s, a, o = 0,
                                l = 0;
                            for (e.length ? (a = e.length, (e = new Uint8Array(i.byteLength + a)).set(e.subarray(0, a)), e.set(i, a)) : e = i; e.length - l >= 3;)
                                if (e[l] !== "I".charCodeAt(0) || e[l + 1] !== "D".charCodeAt(0) || e[l + 2] !== "3".charCodeAt(0))
                                    if (255 != (255 & e[l]) || 240 != (240 & e[l + 1])) l++;
                                    else {
                                        if (e.length - l < 7) break;
                                        if (l + (o = vt.parseAdtsSize(e, l)) > e.length) break;
                                        s = {
                                            type: "audio",
                                            data: e.subarray(l, l + o),
                                            pts: t,
                                            dts: t
                                        }, this.trigger("data", s), l += o
                                    }
                            else {
                                if (e.length - l < 10) break;
                                if (l + (o = vt.parseId3TagSize(e, l)) > e.length) break;
                                r = {
                                    type: "timed-metadata",
                                    data: e.subarray(l, l + o)
                                }, this.trigger("data", r), l += o
                            }
                            n = e.length - l, e = n > 0 ? e.subarray(l) : new Uint8Array
                        }, this.reset = function() {
                            e = new Uint8Array, this.trigger("reset")
                        }, this.endTimeline = function() {
                            e = new Uint8Array, this.trigger("endedtimeline")
                        }
                    }).prototype = new G;
                    var bt, Tt, xt, wt, St = G,
                        Et = te,
                        Mt = ne,
                        Ct = ue,
                        At = pe,
                        Lt = nt,
                        It = le,
                        Pt = ht,
                        Rt = pt.H264Stream,
                        kt = dt,
                        Dt = _t.isLikelyAacData,
                        Ot = le.ONE_SECOND_IN_TS,
                        Nt = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"],
                        Ut = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"],
                        Bt = function(e, t) {
                            t.stream = e, this.trigger("log", t)
                        },
                        Ft = function(e, t) {
                            for (var i = Object.keys(t), n = 0; n < i.length; n++) {
                                var r = i[n];
                                "headOfPipeline" !== r && t[r].on && t[r].on("log", Bt.bind(e, r))
                            }
                        },
                        Ht = function(e, t) {
                            var i;
                            if (e.length !== t.length) return !1;
                            for (i = 0; i < e.length; i++)
                                if (e[i] !== t[i]) return !1;
                            return !0
                        },
                        zt = function(e, t, i, n, r, s) {
                            return {
                                start: {
                                    dts: e,
                                    pts: e + (i - t)
                                },
                                end: {
                                    dts: e + (n - t),
                                    pts: e + (r - i)
                                },
                                prependedContentDuration: s,
                                baseMediaDecodeTime: e
                            }
                        };
                    Tt = function(e, t) {
                        var i, n = [],
                            r = 0,
                            s = 0,
                            a = 1 / 0;
                        i = (t = t || {}).firstSequenceNumber || 0, Tt.prototype.init.call(this), this.push = function(t) {
                            At.collectDtsInfo(e, t), e && Nt.forEach((function(i) {
                                e[i] = t[i]
                            })), n.push(t)
                        }, this.setEarliestDts = function(e) {
                            r = e
                        }, this.setVideoBaseMediaDecodeTime = function(e) {
                            a = e
                        }, this.setAudioAppendStart = function(e) {
                            s = e
                        }, this.flush = function() {
                            var o, l, h, c, u, d, p;
                            0 !== n.length ? (o = Ct.trimAdtsFramesByEarliestDts(n, e, r), e.baseMediaDecodeTime = At.calculateTrackBaseMediaDecodeTime(e, t.keepOriginalTimestamps), p = Ct.prefixWithSilence(e, o, s, a), e.samples = Ct.generateSampleTable(o), h = Et.mdat(Ct.concatenateFrameData(o)), n = [], l = Et.moof(i, [e]), c = new Uint8Array(l.byteLength + h.byteLength), i++, c.set(l), c.set(h, l.byteLength), At.clearDtsInfo(e), u = Math.ceil(1024 * Ot / e.samplerate), o.length && (d = o.length * u, this.trigger("segmentTimingInfo", zt(It.audioTsToVideoTs(e.baseMediaDecodeTime, e.samplerate), o[0].dts, o[0].pts, o[0].dts + d, o[0].pts + d, p || 0)), this.trigger("timingInfo", {
                                start: o[0].pts,
                                end: o[0].pts + d
                            })), this.trigger("data", {
                                track: e,
                                boxes: c
                            }), this.trigger("done", "AudioSegmentStream")) : this.trigger("done", "AudioSegmentStream")
                        }, this.reset = function() {
                            At.clearDtsInfo(e), n = [], this.trigger("reset")
                        }
                    }, Tt.prototype = new St, bt = function(e, t) {
                        var i, n, r, s = [],
                            a = [];
                        i = (t = t || {}).firstSequenceNumber || 0, bt.prototype.init.call(this), delete e.minPTS, this.gopCache_ = [], this.push = function(t) {
                            At.collectDtsInfo(e, t), "seq_parameter_set_rbsp" !== t.nalUnitType || n || (n = t.config, e.sps = [t.data], Ut.forEach((function(t) {
                                e[t] = n[t]
                            }), this)), "pic_parameter_set_rbsp" !== t.nalUnitType || r || (r = t.data, e.pps = [t.data]), s.push(t)
                        }, this.flush = function() {
                            for (var n, r, o, l, h, c, u, d, p = 0; s.length && "access_unit_delimiter_rbsp" !== s[0].nalUnitType;) s.shift();
                            if (0 === s.length) return this.resetStream_(), void this.trigger("done", "VideoSegmentStream");
                            if (n = Mt.groupNalsIntoFrames(s), (o = Mt.groupFramesIntoGops(n))[0][0].keyFrame || ((r = this.getGopForFusion_(s[0], e)) ? (p = r.duration, o.unshift(r), o.byteLength += r.byteLength, o.nalCount += r.nalCount, o.pts = r.pts, o.dts = r.dts, o.duration += r.duration) : o = Mt.extendFirstKeyFrame(o)), a.length) {
                                var f;
                                if (!(f = t.alignGopsAtEnd ? this.alignGopsAtEnd_(o) : this.alignGopsAtStart_(o))) return this.gopCache_.unshift({
                                    gop: o.pop(),
                                    pps: e.pps,
                                    sps: e.sps
                                }), this.gopCache_.length = Math.min(6, this.gopCache_.length), s = [], this.resetStream_(), void this.trigger("done", "VideoSegmentStream");
                                At.clearDtsInfo(e), o = f
                            }
                            At.collectDtsInfo(e, o), e.samples = Mt.generateSampleTable(o), h = Et.mdat(Mt.concatenateNalData(o)), e.baseMediaDecodeTime = At.calculateTrackBaseMediaDecodeTime(e, t.keepOriginalTimestamps), this.trigger("processedGopsInfo", o.map((function(e) {
                                return {
                                    pts: e.pts,
                                    dts: e.dts,
                                    byteLength: e.byteLength
                                }
                            }))), u = o[0], d = o[o.length - 1], this.trigger("segmentTimingInfo", zt(e.baseMediaDecodeTime, u.dts, u.pts, d.dts + d.duration, d.pts + d.duration, p)), this.trigger("timingInfo", {
                                start: o[0].pts,
                                end: o[o.length - 1].pts + o[o.length - 1].duration
                            }), this.gopCache_.unshift({
                                gop: o.pop(),
                                pps: e.pps,
                                sps: e.sps
                            }), this.gopCache_.length = Math.min(6, this.gopCache_.length), s = [], this.trigger("baseMediaDecodeTime", e.baseMediaDecodeTime), this.trigger("timelineStartInfo", e.timelineStartInfo), l = Et.moof(i, [e]), c = new Uint8Array(l.byteLength + h.byteLength), i++, c.set(l), c.set(h, l.byteLength), this.trigger("data", {
                                track: e,
                                boxes: c
                            }), this.resetStream_(), this.trigger("done", "VideoSegmentStream")
                        }, this.reset = function() {
                            this.resetStream_(), s = [], this.gopCache_.length = 0, a.length = 0, this.trigger("reset")
                        }, this.resetStream_ = function() {
                            At.clearDtsInfo(e), n = void 0, r = void 0
                        }, this.getGopForFusion_ = function(t) {
                            var i, n, r, s, a, o = 1 / 0;
                            for (a = 0; a < this.gopCache_.length; a++) r = (s = this.gopCache_[a]).gop, e.pps && Ht(e.pps[0], s.pps[0]) && e.sps && Ht(e.sps[0], s.sps[0]) && (r.dts < e.timelineStartInfo.dts || (i = t.dts - r.dts - r.duration) >= -1e4 && i <= 45e3 && (!n || o > i) && (n = s, o = i));
                            return n ? n.gop : null
                        }, this.alignGopsAtStart_ = function(e) {
                            var t, i, n, r, s, o, l, h;
                            for (s = e.byteLength, o = e.nalCount, l = e.duration, t = i = 0; t < a.length && i < e.length && (n = a[t], r = e[i], n.pts !== r.pts);) r.pts > n.pts ? t++ : (i++, s -= r.byteLength, o -= r.nalCount, l -= r.duration);
                            return 0 === i ? e : i === e.length ? null : ((h = e.slice(i)).byteLength = s, h.duration = l, h.nalCount = o, h.pts = h[0].pts, h.dts = h[0].dts, h)
                        }, this.alignGopsAtEnd_ = function(e) {
                            var t, i, n, r, s, o, l;
                            for (t = a.length - 1, i = e.length - 1, s = null, o = !1; t >= 0 && i >= 0;) {
                                if (n = a[t], r = e[i], n.pts === r.pts) {
                                    o = !0;
                                    break
                                }
                                n.pts > r.pts ? t-- : (t === a.length - 1 && (s = i), i--)
                            }
                            if (!o && null === s) return null;
                            if (0 === (l = o ? i : s)) return e;
                            var h = e.slice(l),
                                c = h.reduce((function(e, t) {
                                    return e.byteLength += t.byteLength, e.duration += t.duration, e.nalCount += t.nalCount, e
                                }), {
                                    byteLength: 0,
                                    duration: 0,
                                    nalCount: 0
                                });
                            return h.byteLength = c.byteLength, h.duration = c.duration, h.nalCount = c.nalCount, h.pts = h[0].pts, h.dts = h[0].dts, h
                        }, this.alignGopsWith = function(e) {
                            a = e
                        }
                    }, bt.prototype = new St, wt = function(e, t) {
                        this.numberOfTracks = 0, this.metadataStream = t, void 0 !== (e = e || {}).remux ? this.remuxTracks = !!e.remux : this.remuxTracks = !0, "boolean" == typeof e.keepOriginalTimestamps ? this.keepOriginalTimestamps = e.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, wt.prototype.init.call(this), this.push = function(e) {
                            return e.text ? this.pendingCaptions.push(e) : e.frames ? this.pendingMetadata.push(e) : (this.pendingTracks.push(e.track), this.pendingBytes += e.boxes.byteLength, "video" === e.track.type && (this.videoTrack = e.track, this.pendingBoxes.push(e.boxes)), void("audio" === e.track.type && (this.audioTrack = e.track, this.pendingBoxes.unshift(e.boxes))))
                        }
                    }, wt.prototype = new St, wt.prototype.flush = function(e) {
                        var t, i, n, r, s = 0,
                            a = {
                                captions: [],
                                captionStreams: {},
                                metadata: [],
                                info: {}
                            },
                            o = 0;
                        if (this.pendingTracks.length < this.numberOfTracks) {
                            if ("VideoSegmentStream" !== e && "AudioSegmentStream" !== e) return;
                            if (this.remuxTracks) return;
                            if (0 === this.pendingTracks.length) return this.emittedTracks++, void(this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0))
                        }
                        if (this.videoTrack ? (o = this.videoTrack.timelineStartInfo.pts, Ut.forEach((function(e) {
                                a.info[e] = this.videoTrack[e]
                            }), this)) : this.audioTrack && (o = this.audioTrack.timelineStartInfo.pts, Nt.forEach((function(e) {
                                a.info[e] = this.audioTrack[e]
                            }), this)), this.videoTrack || this.audioTrack) {
                            for (1 === this.pendingTracks.length ? a.type = this.pendingTracks[0].type : a.type = "combined", this.emittedTracks += this.pendingTracks.length, n = Et.initSegment(this.pendingTracks), a.initSegment = new Uint8Array(n.byteLength), a.initSegment.set(n), a.data = new Uint8Array(this.pendingBytes), r = 0; r < this.pendingBoxes.length; r++) a.data.set(this.pendingBoxes[r], s), s += this.pendingBoxes[r].byteLength;
                            for (r = 0; r < this.pendingCaptions.length; r++)(t = this.pendingCaptions[r]).startTime = It.metadataTsToSeconds(t.startPts, o, this.keepOriginalTimestamps), t.endTime = It.metadataTsToSeconds(t.endPts, o, this.keepOriginalTimestamps), a.captionStreams[t.stream] = !0, a.captions.push(t);
                            for (r = 0; r < this.pendingMetadata.length; r++)(i = this.pendingMetadata[r]).cueTime = It.metadataTsToSeconds(i.pts, o, this.keepOriginalTimestamps), a.metadata.push(i);
                            for (a.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", a), r = 0; r < a.captions.length; r++) t = a.captions[r], this.trigger("caption", t);
                            for (r = 0; r < a.metadata.length; r++) i = a.metadata[r], this.trigger("id3Frame", i)
                        }
                        this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0)
                    }, wt.prototype.setRemux = function(e) {
                        this.remuxTracks = e
                    }, (xt = function(e) {
                        var t, i, n = this,
                            r = !0;
                        xt.prototype.init.call(this), e = e || {}, this.baseMediaDecodeTime = e.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function() {
                            var r = {};
                            this.transmuxPipeline_ = r, r.type = "aac", r.metadataStream = new Lt.MetadataStream, r.aacStream = new kt, r.audioTimestampRolloverStream = new Lt.TimestampRolloverStream("audio"), r.timedMetadataTimestampRolloverStream = new Lt.TimestampRolloverStream("timed-metadata"), r.adtsStream = new Pt, r.coalesceStream = new wt(e, r.metadataStream), r.headOfPipeline = r.aacStream, r.aacStream.pipe(r.audioTimestampRolloverStream).pipe(r.adtsStream), r.aacStream.pipe(r.timedMetadataTimestampRolloverStream).pipe(r.metadataStream).pipe(r.coalesceStream), r.metadataStream.on("timestamp", (function(e) {
                                r.aacStream.setTimestamp(e.timeStamp)
                            })), r.aacStream.on("data", (function(s) {
                                "timed-metadata" !== s.type && "audio" !== s.type || r.audioSegmentStream || (i = i || {
                                    timelineStartInfo: {
                                        baseMediaDecodeTime: n.baseMediaDecodeTime
                                    },
                                    codec: "adts",
                                    type: "audio"
                                }, r.coalesceStream.numberOfTracks++, r.audioSegmentStream = new Tt(i, e), r.audioSegmentStream.on("log", n.getLogTrigger_("audioSegmentStream")), r.audioSegmentStream.on("timingInfo", n.trigger.bind(n, "audioTimingInfo")), r.adtsStream.pipe(r.audioSegmentStream).pipe(r.coalesceStream), n.trigger("trackinfo", {
                                    hasAudio: !!i,
                                    hasVideo: !!t
                                }))
                            })), r.coalesceStream.on("data", this.trigger.bind(this, "data")), r.coalesceStream.on("done", this.trigger.bind(this, "done")), Ft(this, r)
                        }, this.setupTsPipeline = function() {
                            var r = {};
                            this.transmuxPipeline_ = r, r.type = "ts", r.metadataStream = new Lt.MetadataStream, r.packetStream = new Lt.TransportPacketStream, r.parseStream = new Lt.TransportParseStream, r.elementaryStream = new Lt.ElementaryStream, r.timestampRolloverStream = new Lt.TimestampRolloverStream, r.adtsStream = new Pt, r.h264Stream = new Rt, r.captionStream = new Lt.CaptionStream(e), r.coalesceStream = new wt(e, r.metadataStream), r.headOfPipeline = r.packetStream, r.packetStream.pipe(r.parseStream).pipe(r.elementaryStream).pipe(r.timestampRolloverStream), r.timestampRolloverStream.pipe(r.h264Stream), r.timestampRolloverStream.pipe(r.adtsStream), r.timestampRolloverStream.pipe(r.metadataStream).pipe(r.coalesceStream), r.h264Stream.pipe(r.captionStream).pipe(r.coalesceStream), r.elementaryStream.on("data", (function(s) {
                                var a;
                                if ("metadata" === s.type) {
                                    for (a = s.tracks.length; a--;) t || "video" !== s.tracks[a].type ? i || "audio" !== s.tracks[a].type || ((i = s.tracks[a]).timelineStartInfo.baseMediaDecodeTime = n.baseMediaDecodeTime) : (t = s.tracks[a]).timelineStartInfo.baseMediaDecodeTime = n.baseMediaDecodeTime;
                                    t && !r.videoSegmentStream && (r.coalesceStream.numberOfTracks++, r.videoSegmentStream = new bt(t, e), r.videoSegmentStream.on("log", n.getLogTrigger_("videoSegmentStream")), r.videoSegmentStream.on("timelineStartInfo", (function(t) {
                                        i && !e.keepOriginalTimestamps && (i.timelineStartInfo = t, r.audioSegmentStream.setEarliestDts(t.dts - n.baseMediaDecodeTime))
                                    })), r.videoSegmentStream.on("processedGopsInfo", n.trigger.bind(n, "gopInfo")), r.videoSegmentStream.on("segmentTimingInfo", n.trigger.bind(n, "videoSegmentTimingInfo")), r.videoSegmentStream.on("baseMediaDecodeTime", (function(e) {
                                        i && r.audioSegmentStream.setVideoBaseMediaDecodeTime(e)
                                    })), r.videoSegmentStream.on("timingInfo", n.trigger.bind(n, "videoTimingInfo")), r.h264Stream.pipe(r.videoSegmentStream).pipe(r.coalesceStream)), i && !r.audioSegmentStream && (r.coalesceStream.numberOfTracks++, r.audioSegmentStream = new Tt(i, e), r.audioSegmentStream.on("log", n.getLogTrigger_("audioSegmentStream")), r.audioSegmentStream.on("timingInfo", n.trigger.bind(n, "audioTimingInfo")), r.audioSegmentStream.on("segmentTimingInfo", n.trigger.bind(n, "audioSegmentTimingInfo")), r.adtsStream.pipe(r.audioSegmentStream).pipe(r.coalesceStream)), n.trigger("trackinfo", {
                                        hasAudio: !!i,
                                        hasVideo: !!t
                                    })
                                }
                            })), r.coalesceStream.on("data", this.trigger.bind(this, "data")), r.coalesceStream.on("id3Frame", (function(e) {
                                e.dispatchType = r.metadataStream.dispatchType, n.trigger("id3Frame", e)
                            })), r.coalesceStream.on("caption", this.trigger.bind(this, "caption")), r.coalesceStream.on("done", this.trigger.bind(this, "done")), Ft(this, r)
                        }, this.setBaseMediaDecodeTime = function(n) {
                            var r = this.transmuxPipeline_;
                            e.keepOriginalTimestamps || (this.baseMediaDecodeTime = n), i && (i.timelineStartInfo.dts = void 0, i.timelineStartInfo.pts = void 0, At.clearDtsInfo(i), r.audioTimestampRolloverStream && r.audioTimestampRolloverStream.discontinuity()), t && (r.videoSegmentStream && (r.videoSegmentStream.gopCache_ = []), t.timelineStartInfo.dts = void 0, t.timelineStartInfo.pts = void 0, At.clearDtsInfo(t), r.captionStream.reset()), r.timestampRolloverStream && r.timestampRolloverStream.discontinuity()
                        }, this.setAudioAppendStart = function(e) {
                            i && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(e)
                        }, this.setRemux = function(t) {
                            var i = this.transmuxPipeline_;
                            e.remux = t, i && i.coalesceStream && i.coalesceStream.setRemux(t)
                        }, this.alignGopsWith = function(e) {
                            t && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(e)
                        }, this.getLogTrigger_ = function(e) {
                            var t = this;
                            return function(i) {
                                i.stream = e, t.trigger("log", i)
                            }
                        }, this.push = function(e) {
                            if (r) {
                                var t = Dt(e);
                                t && "aac" !== this.transmuxPipeline_.type ? this.setupAacPipeline() : t || "ts" === this.transmuxPipeline_.type || this.setupTsPipeline(), r = !1
                            }
                            this.transmuxPipeline_.headOfPipeline.push(e)
                        }, this.flush = function() {
                            r = !0, this.transmuxPipeline_.headOfPipeline.flush()
                        }, this.endTimeline = function() {
                            this.transmuxPipeline_.headOfPipeline.endTimeline()
                        }, this.reset = function() {
                            this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset()
                        }, this.resetCaptions = function() {
                            this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset()
                        }
                    }).prototype = new St;
                    var Vt, Gt, Wt, jt, qt = {
                            Transmuxer: xt,
                            VideoSegmentStream: bt,
                            AudioSegmentStream: Tt,
                            AUDIO_PROPERTIES: Nt,
                            VIDEO_PROPERTIES: Ut,
                            generateSegmentTimingInfo: zt
                        },
                        $t = function(e) {
                            return e >>> 0
                        },
                        Xt = function(e) {
                            var t = "";
                            return t += String.fromCharCode(e[0]), t += String.fromCharCode(e[1]), t += String.fromCharCode(e[2]), t += String.fromCharCode(e[3])
                        },
                        Yt = $t,
                        Kt = Xt,
                        Jt = function(e, t) {
                            var i, n, r, s, a, o = [];
                            if (!t.length) return null;
                            for (i = 0; i < e.byteLength;) n = Yt(e[i] << 24 | e[i + 1] << 16 | e[i + 2] << 8 | e[i + 3]), r = Kt(e.subarray(i + 4, i + 8)), s = n > 1 ? i + n : e.byteLength, r === t[0] && (1 === t.length ? o.push(e.subarray(i + 8, s)) : (a = Jt(e.subarray(i + 8, s), t.slice(1))).length && (o = o.concat(a))), i = s;
                            return o
                        },
                        Zt = $t,
                        Qt = j.getUint64,
                        ei = function(e) {
                            var t = {
                                version: e[0],
                                flags: new Uint8Array(e.subarray(1, 4))
                            };
                            return 1 === t.version ? t.baseMediaDecodeTime = Qt(e.subarray(4)) : t.baseMediaDecodeTime = Zt(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7]), t
                        },
                        ti = function(e) {
                            return {
                                isLeading: (12 & e[0]) >>> 2,
                                dependsOn: 3 & e[0],
                                isDependedOn: (192 & e[1]) >>> 6,
                                hasRedundancy: (48 & e[1]) >>> 4,
                                paddingValue: (14 & e[1]) >>> 1,
                                isNonSyncSample: 1 & e[1],
                                degradationPriority: e[2] << 8 | e[3]
                            }
                        },
                        ii = function(e) {
                            var t, i = {
                                    version: e[0],
                                    flags: new Uint8Array(e.subarray(1, 4)),
                                    samples: []
                                },
                                n = new DataView(e.buffer, e.byteOffset, e.byteLength),
                                r = 1 & i.flags[2],
                                s = 4 & i.flags[2],
                                a = 1 & i.flags[1],
                                o = 2 & i.flags[1],
                                l = 4 & i.flags[1],
                                h = 8 & i.flags[1],
                                c = n.getUint32(4),
                                u = 8;
                            for (r && (i.dataOffset = n.getInt32(u), u += 4), s && c && (t = {
                                    flags: ti(e.subarray(u, u + 4))
                                }, u += 4, a && (t.duration = n.getUint32(u), u += 4), o && (t.size = n.getUint32(u), u += 4), h && (1 === i.version ? t.compositionTimeOffset = n.getInt32(u) : t.compositionTimeOffset = n.getUint32(u), u += 4), i.samples.push(t), c--); c--;) t = {}, a && (t.duration = n.getUint32(u), u += 4), o && (t.size = n.getUint32(u), u += 4), l && (t.flags = ti(e.subarray(u, u + 4)), u += 4), h && (1 === i.version ? t.compositionTimeOffset = n.getInt32(u) : t.compositionTimeOffset = n.getUint32(u), u += 4), i.samples.push(t);
                            return i
                        },
                        ni = function(e) {
                            var t, i = new DataView(e.buffer, e.byteOffset, e.byteLength),
                                n = {
                                    version: e[0],
                                    flags: new Uint8Array(e.subarray(1, 4)),
                                    trackId: i.getUint32(4)
                                },
                                r = 1 & n.flags[2],
                                s = 2 & n.flags[2],
                                a = 8 & n.flags[2],
                                o = 16 & n.flags[2],
                                l = 32 & n.flags[2],
                                h = 65536 & n.flags[0],
                                c = 131072 & n.flags[0];
                            return t = 8, r && (t += 4, n.baseDataOffset = i.getUint32(12), t += 4), s && (n.sampleDescriptionIndex = i.getUint32(t), t += 4), a && (n.defaultSampleDuration = i.getUint32(t), t += 4), o && (n.defaultSampleSize = i.getUint32(t), t += 4), l && (n.defaultSampleFlags = i.getUint32(t)), h && (n.durationIsEmpty = !0), !r && c && (n.baseDataOffsetIsMoof = !0), n
                        },
                        ri = (Vt = "undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : {}, fe.discardEmulationPreventionBytes),
                        si = Ae.CaptionStream,
                        ai = Jt,
                        oi = ei,
                        li = ii,
                        hi = ni,
                        ci = Vt,
                        ui = function(e, t) {
                            for (var i = e, n = 0; n < t.length; n++) {
                                var r = t[n];
                                if (i < r.size) return r;
                                i -= r.size
                            }
                            return null
                        },
                        di = function(e, t) {
                            var i = ai(e, ["moof", "traf"]),
                                n = ai(e, ["mdat"]),
                                r = {},
                                s = [];
                            return n.forEach((function(e, t) {
                                var n = i[t];
                                s.push({
                                    mdat: e,
                                    traf: n
                                })
                            })), s.forEach((function(e) {
                                var i, n, s = e.mdat,
                                    a = e.traf,
                                    o = ai(a, ["tfhd"]),
                                    l = hi(o[0]),
                                    h = l.trackId,
                                    c = ai(a, ["tfdt"]),
                                    u = c.length > 0 ? oi(c[0]).baseMediaDecodeTime : 0,
                                    d = ai(a, ["trun"]);
                                t === h && d.length > 0 && (i = function(e, t, i) {
                                    var n = t,
                                        r = i.defaultSampleDuration || 0,
                                        s = i.defaultSampleSize || 0,
                                        a = i.trackId,
                                        o = [];
                                    return e.forEach((function(e) {
                                        var t = li(e).samples;
                                        t.forEach((function(e) {
                                            void 0 === e.duration && (e.duration = r), void 0 === e.size && (e.size = s), e.trackId = a, e.dts = n, void 0 === e.compositionTimeOffset && (e.compositionTimeOffset = 0), "bigint" == typeof n ? (e.pts = n + ci.BigInt(e.compositionTimeOffset), n += ci.BigInt(e.duration)) : (e.pts = n + e.compositionTimeOffset, n += e.duration)
                                        })), o = o.concat(t)
                                    })), o
                                }(d, u, l), n = function(e, t, i) {
                                    var n, r, s, a, o = new DataView(e.buffer, e.byteOffset, e.byteLength),
                                        l = {
                                            logs: [],
                                            seiNals: []
                                        };
                                    for (r = 0; r + 4 < e.length; r += s)
                                        if (s = o.getUint32(r), r += 4, !(s <= 0)) switch (31 & e[r]) {
                                            case 6:
                                                var h = e.subarray(r + 1, r + 1 + s),
                                                    c = ui(r, t);
                                                if (n = {
                                                        nalUnitType: "sei_rbsp",
                                                        size: s,
                                                        data: h,
                                                        escapedRBSP: ri(h),
                                                        trackId: i
                                                    }, c) n.pts = c.pts, n.dts = c.dts, a = c;
                                                else {
                                                    if (!a) {
                                                        l.logs.push({
                                                            level: "warn",
                                                            message: "We've encountered a nal unit without data at " + r + " for trackId " + i + ". See mux.js#223."
                                                        });
                                                        break
                                                    }
                                                    n.pts = a.pts, n.dts = a.dts
                                                }
                                                l.seiNals.push(n)
                                        }
                                    return l
                                }(s, i, h), r[h] || (r[h] = {
                                    seiNals: [],
                                    logs: []
                                }), r[h].seiNals = r[h].seiNals.concat(n.seiNals), r[h].logs = r[h].logs.concat(n.logs))
                            })), r
                        },
                        pi = function() {
                            var e, t, i, n, r, s, a = !1;
                            this.isInitialized = function() {
                                return a
                            }, this.init = function(t) {
                                e = new si, a = !0, s = !!t && t.isPartial, e.on("data", (function(e) {
                                    e.startTime = e.startPts / n, e.endTime = e.endPts / n, r.captions.push(e), r.captionStreams[e.stream] = !0
                                })), e.on("log", (function(e) {
                                    r.logs.push(e)
                                }))
                            }, this.isNewInit = function(e, t) {
                                return !(e && 0 === e.length || t && "object" == typeof t && 0 === Object.keys(t).length) && (i !== e[0] || n !== t[i])
                            }, this.parse = function(e, s, a) {
                                var o;
                                if (!this.isInitialized()) return null;
                                if (!s || !a) return null;
                                if (this.isNewInit(s, a)) i = s[0], n = a[i];
                                else if (null === i || !n) return t.push(e), null;
                                for (; t.length > 0;) {
                                    var l = t.shift();
                                    this.parse(l, s, a)
                                }
                                return o = function(e, t, i) {
                                    if (null === t) return null;
                                    var n = di(e, t)[t] || {};
                                    return {
                                        seiNals: n.seiNals,
                                        logs: n.logs,
                                        timescale: i
                                    }
                                }(e, i, n), o && o.logs && (r.logs = r.logs.concat(o.logs)), null !== o && o.seiNals ? (this.pushNals(o.seiNals), this.flushStream(), r) : r.logs.length ? {
                                    logs: r.logs,
                                    captions: [],
                                    captionStreams: []
                                } : null
                            }, this.pushNals = function(t) {
                                if (!this.isInitialized() || !t || 0 === t.length) return null;
                                t.forEach((function(t) {
                                    e.push(t)
                                }))
                            }, this.flushStream = function() {
                                if (!this.isInitialized()) return null;
                                s ? e.partialFlush() : e.flush()
                            }, this.clearParsedCaptions = function() {
                                r.captions = [], r.captionStreams = {}, r.logs = []
                            }, this.resetCaptionStream = function() {
                                if (!this.isInitialized()) return null;
                                e.reset()
                            }, this.clearAllCaptions = function() {
                                this.clearParsedCaptions(), this.resetCaptionStream()
                            }, this.reset = function() {
                                t = [], i = null, n = null, r ? this.clearParsedCaptions() : r = {
                                    captions: [],
                                    captionStreams: {},
                                    logs: []
                                }, this.resetCaptionStream()
                            }, this.reset()
                        },
                        fi = $t,
                        mi = function(e) {
                            return ("00" + e.toString(16)).slice(-2)
                        },
                        gi = Jt,
                        yi = Xt,
                        _i = ni,
                        vi = ii,
                        bi = ei,
                        Ti = j.getUint64,
                        xi = Vt;
                    Gt = function(e, t) {
                        var i = gi(t, ["moof", "traf"]).reduce((function(t, i) {
                            var n, r = gi(i, ["tfhd"])[0],
                                s = fi(r[4] << 24 | r[5] << 16 | r[6] << 8 | r[7]),
                                a = e[s] || 9e4,
                                o = gi(i, ["tfdt"])[0],
                                l = new DataView(o.buffer, o.byteOffset, o.byteLength);
                            let h;
                            return "bigint" == typeof(n = 1 === o[0] ? Ti(o.subarray(4, 12)) : l.getUint32(4)) ? h = n / xi.BigInt(a) : "number" != typeof n || isNaN(n) || (h = n / a), h < Number.MAX_SAFE_INTEGER && (h = Number(h)), h < t && (t = h), t
                        }), 1 / 0);
                        return "bigint" == typeof i || isFinite(i) ? i : 0
                    }, jt = function(e) {
                        var t = 0 === e[0] ? 12 : 20;
                        return fi(e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3])
                    }, Wt = function(e) {
                        var t = gi(e, ["moov", "trak"]),
                            i = [];
                        return t.forEach((function(e) {
                            var t, n, r = {},
                                s = gi(e, ["tkhd"])[0];
                            s && (n = (t = new DataView(s.buffer, s.byteOffset, s.byteLength)).getUint8(0), r.id = 0 === n ? t.getUint32(12) : t.getUint32(20));
                            var a = gi(e, ["mdia", "hdlr"])[0];
                            if (a) {
                                var o = yi(a.subarray(8, 12));
                                r.type = "vide" === o ? "video" : "soun" === o ? "audio" : o
                            }
                            var l = gi(e, ["mdia", "minf", "stbl", "stsd"])[0];
                            if (l) {
                                var h = l.subarray(8);
                                r.codec = yi(h.subarray(4, 8));
                                var c, u = gi(h, [r.codec])[0];
                                u && (/^[asm]vc[1-9]$/i.test(r.codec) ? (c = u.subarray(78), "avcC" === yi(c.subarray(4, 8)) && c.length > 11 ? (r.codec += ".", r.codec += mi(c[9]), r.codec += mi(c[10]), r.codec += mi(c[11])) : r.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(r.codec) ? (c = u.subarray(28), "esds" === yi(c.subarray(4, 8)) && c.length > 20 && 0 !== c[19] ? (r.codec += "." + mi(c[19]), r.codec += "." + mi(c[20] >>> 2 & 63).replace(/^0/, "")) : r.codec = "mp4a.40.2") : r.codec = r.codec.toLowerCase())
                            }
                            var d = gi(e, ["mdia", "mdhd"])[0];
                            d && (r.timescale = jt(d)), i.push(r)
                        })), i
                    };
                    var wi = Gt,
                        Si = Wt,
                        Ei = Le,
                        Mi = function(e) {
                            var t = 31 & e[1];
                            return t <<= 8, t |= e[2]
                        },
                        Ci = function(e) {
                            return !!(64 & e[1])
                        },
                        Ai = function(e) {
                            var t = 0;
                            return (48 & e[3]) >>> 4 > 1 && (t += e[4] + 1), t
                        },
                        Li = function(e) {
                            switch (e) {
                                case 5:
                                    return "slice_layer_without_partitioning_rbsp_idr";
                                case 6:
                                    return "sei_rbsp";
                                case 7:
                                    return "seq_parameter_set_rbsp";
                                case 8:
                                    return "pic_parameter_set_rbsp";
                                case 9:
                                    return "access_unit_delimiter_rbsp";
                                default:
                                    return null
                            }
                        },
                        Ii = {
                            parseType: function(e, t) {
                                var i = Mi(e);
                                return 0 === i ? "pat" : i === t ? "pmt" : t ? "pes" : null
                            },
                            parsePat: function(e) {
                                var t = Ci(e),
                                    i = 4 + Ai(e);
                                return t && (i += e[i] + 1), (31 & e[i + 10]) << 8 | e[i + 11]
                            },
                            parsePmt: function(e) {
                                var t = {},
                                    i = Ci(e),
                                    n = 4 + Ai(e);
                                if (i && (n += e[n] + 1), 1 & e[n + 5]) {
                                    var r;
                                    r = 3 + ((15 & e[n + 1]) << 8 | e[n + 2]) - 4;
                                    for (var s = 12 + ((15 & e[n + 10]) << 8 | e[n + 11]); s < r;) {
                                        var a = n + s;
                                        t[(31 & e[a + 1]) << 8 | e[a + 2]] = e[a], s += 5 + ((15 & e[a + 3]) << 8 | e[a + 4])
                                    }
                                    return t
                                }
                            },
                            parsePayloadUnitStartIndicator: Ci,
                            parsePesType: function(e, t) {
                                switch (t[Mi(e)]) {
                                    case Ei.H264_STREAM_TYPE:
                                        return "video";
                                    case Ei.ADTS_STREAM_TYPE:
                                        return "audio";
                                    case Ei.METADATA_STREAM_TYPE:
                                        return "timed-metadata";
                                    default:
                                        return null
                                }
                            },
                            parsePesTime: function(e) {
                                if (!Ci(e)) return null;
                                var t = 4 + Ai(e);
                                if (t >= e.byteLength) return null;
                                var i, n = null;
                                return 192 & (i = e[t + 7]) && ((n = {}).pts = (14 & e[t + 9]) << 27 | (255 & e[t + 10]) << 20 | (254 & e[t + 11]) << 12 | (255 & e[t + 12]) << 5 | (254 & e[t + 13]) >>> 3, n.pts *= 4, n.pts += (6 & e[t + 13]) >>> 1, n.dts = n.pts, 64 & i && (n.dts = (14 & e[t + 14]) << 27 | (255 & e[t + 15]) << 20 | (254 & e[t + 16]) << 12 | (255 & e[t + 17]) << 5 | (254 & e[t + 18]) >>> 3, n.dts *= 4, n.dts += (6 & e[t + 18]) >>> 1)), n
                            },
                            videoPacketContainsKeyFrame: function(e) {
                                for (var t = 4 + Ai(e), i = e.subarray(t), n = 0, r = 0, s = !1; r < i.byteLength - 3; r++)
                                    if (1 === i[r + 2]) {
                                        n = r + 5;
                                        break
                                    }
                                for (; n < i.byteLength;) switch (i[n]) {
                                    case 0:
                                        if (0 !== i[n - 1]) {
                                            n += 2;
                                            break
                                        }
                                        if (0 !== i[n - 2]) {
                                            n++;
                                            break
                                        }
                                        r + 3 !== n - 2 && "slice_layer_without_partitioning_rbsp_idr" === Li(31 & i[r + 3]) && (s = !0);
                                        do {
                                            n++
                                        } while (1 !== i[n] && n < i.length);
                                        r = n - 2, n += 3;
                                        break;
                                    case 1:
                                        if (0 !== i[n - 1] || 0 !== i[n - 2]) {
                                            n += 3;
                                            break
                                        }
                                        "slice_layer_without_partitioning_rbsp_idr" === Li(31 & i[r + 3]) && (s = !0), r = n - 2, n += 3;
                                        break;
                                    default:
                                        n += 3
                                }
                                return i = i.subarray(r), n -= r, r = 0, i && i.byteLength > 3 && "slice_layer_without_partitioning_rbsp_idr" === Li(31 & i[r + 3]) && (s = !0), s
                            }
                        },
                        Pi = Le,
                        Ri = Oe.handleRollover,
                        ki = {};
                    ki.ts = Ii, ki.aac = _t;
                    var Di = le.ONE_SECOND_IN_TS,
                        Oi = 188,
                        Ni = 71,
                        Ui = function(e, t, i) {
                            for (var n, r, s, a, o = 0, l = Oi, h = !1; l <= e.byteLength;)
                                if (e[o] !== Ni || e[l] !== Ni && l !== e.byteLength) o++, l++;
                                else {
                                    if (n = e.subarray(o, l), "pes" === ki.ts.parseType(n, t.pid)) r = ki.ts.parsePesType(n, t.table), s = ki.ts.parsePayloadUnitStartIndicator(n), "audio" === r && s && (a = ki.ts.parsePesTime(n)) && (a.type = "audio", i.audio.push(a), h = !0);
                                    if (h) break;
                                    o += Oi, l += Oi
                                }
                            for (o = (l = e.byteLength) - Oi, h = !1; o >= 0;)
                                if (e[o] !== Ni || e[l] !== Ni && l !== e.byteLength) o--, l--;
                                else {
                                    if (n = e.subarray(o, l), "pes" === ki.ts.parseType(n, t.pid)) r = ki.ts.parsePesType(n, t.table), s = ki.ts.parsePayloadUnitStartIndicator(n), "audio" === r && s && (a = ki.ts.parsePesTime(n)) && (a.type = "audio", i.audio.push(a), h = !0);
                                    if (h) break;
                                    o -= Oi, l -= Oi
                                }
                        },
                        Bi = function(e, t, i) {
                            for (var n, r, s, a, o, l, h, c = 0, u = Oi, d = !1, p = {
                                    data: [],
                                    size: 0
                                }; u < e.byteLength;)
                                if (e[c] !== Ni || e[u] !== Ni) c++, u++;
                                else {
                                    if (n = e.subarray(c, u), "pes" === ki.ts.parseType(n, t.pid))
                                        if (r = ki.ts.parsePesType(n, t.table), s = ki.ts.parsePayloadUnitStartIndicator(n), "video" === r && (s && !d && (a = ki.ts.parsePesTime(n)) && (a.type = "video", i.video.push(a), d = !0), !i.firstKeyFrame)) {
                                            if (s && 0 !== p.size) {
                                                for (o = new Uint8Array(p.size), l = 0; p.data.length;) h = p.data.shift(), o.set(h, l), l += h.byteLength;
                                                if (ki.ts.videoPacketContainsKeyFrame(o)) {
                                                    var f = ki.ts.parsePesTime(o);
                                                    f ? (i.firstKeyFrame = f, i.firstKeyFrame.type = "video") : console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.")
                                                }
                                                p.size = 0
                                            }
                                            p.data.push(n), p.size += n.byteLength
                                        }
                                    if (d && i.firstKeyFrame) break;
                                    c += Oi, u += Oi
                                }
                            for (c = (u = e.byteLength) - Oi, d = !1; c >= 0;)
                                if (e[c] !== Ni || e[u] !== Ni) c--, u--;
                                else {
                                    if (n = e.subarray(c, u), "pes" === ki.ts.parseType(n, t.pid)) r = ki.ts.parsePesType(n, t.table), s = ki.ts.parsePayloadUnitStartIndicator(n), "video" === r && s && (a = ki.ts.parsePesTime(n)) && (a.type = "video", i.video.push(a), d = !0);
                                    if (d) break;
                                    c -= Oi, u -= Oi
                                }
                        },
                        Fi = function(e) {
                            var t = {
                                    pid: null,
                                    table: null
                                },
                                i = {};
                            for (var n in function(e, t) {
                                    for (var i, n = 0, r = Oi; r < e.byteLength;)
                                        if (e[n] !== Ni || e[r] !== Ni) n++, r++;
                                        else {
                                            switch (i = e.subarray(n, r), ki.ts.parseType(i, t.pid)) {
                                                case "pat":
                                                    t.pid = ki.ts.parsePat(i);
                                                    break;
                                                case "pmt":
                                                    var s = ki.ts.parsePmt(i);
                                                    t.table = t.table || {}, Object.keys(s).forEach((function(e) {
                                                        t.table[e] = s[e]
                                                    }))
                                            }
                                            n += Oi, r += Oi
                                        }
                                }(e, t), t.table) {
                                if (t.table.hasOwnProperty(n)) switch (t.table[n]) {
                                    case Pi.H264_STREAM_TYPE:
                                        i.video = [], Bi(e, t, i), 0 === i.video.length && delete i.video;
                                        break;
                                    case Pi.ADTS_STREAM_TYPE:
                                        i.audio = [], Ui(e, t, i), 0 === i.audio.length && delete i.audio
                                }
                            }
                            return i
                        },
                        Hi = function(e, t) {
                            var i;
                            return i = ki.aac.isLikelyAacData(e) ? function(e) {
                                for (var t, i = !1, n = 0, r = null, s = null, a = 0, o = 0; e.length - o >= 3;) {
                                    switch (ki.aac.parseType(e, o)) {
                                        case "timed-metadata":
                                            if (e.length - o < 10) {
                                                i = !0;
                                                break
                                            }
                                            if ((a = ki.aac.parseId3TagSize(e, o)) > e.length) {
                                                i = !0;
                                                break
                                            }
                                            null === s && (t = e.subarray(o, o + a), s = ki.aac.parseAacTimestamp(t)), o += a;
                                            break;
                                        case "audio":
                                            if (e.length - o < 7) {
                                                i = !0;
                                                break
                                            }
                                            if ((a = ki.aac.parseAdtsSize(e, o)) > e.length) {
                                                i = !0;
                                                break
                                            }
                                            null === r && (t = e.subarray(o, o + a), r = ki.aac.parseSampleRate(t)), n++, o += a;
                                            break;
                                        default:
                                            o++
                                    }
                                    if (i) return null
                                }
                                if (null === r || null === s) return null;
                                var l = Di / r;
                                return {
                                    audio: [{
                                        type: "audio",
                                        dts: s,
                                        pts: s
                                    }, {
                                        type: "audio",
                                        dts: s + 1024 * n * l,
                                        pts: s + 1024 * n * l
                                    }]
                                }
                            }(e) : Fi(e), i && (i.audio || i.video) ? (function(e, t) {
                                if (e.audio && e.audio.length) {
                                    var i = t;
                                    (void 0 === i || isNaN(i)) && (i = e.audio[0].dts), e.audio.forEach((function(e) {
                                        e.dts = Ri(e.dts, i), e.pts = Ri(e.pts, i), e.dtsTime = e.dts / Di, e.ptsTime = e.pts / Di
                                    }))
                                }
                                if (e.video && e.video.length) {
                                    var n = t;
                                    if ((void 0 === n || isNaN(n)) && (n = e.video[0].dts), e.video.forEach((function(e) {
                                            e.dts = Ri(e.dts, n), e.pts = Ri(e.pts, n), e.dtsTime = e.dts / Di, e.ptsTime = e.pts / Di
                                        })), e.firstKeyFrame) {
                                        var r = e.firstKeyFrame;
                                        r.dts = Ri(r.dts, n), r.pts = Ri(r.pts, n), r.dtsTime = r.dts / Di, r.ptsTime = r.pts / Di
                                    }
                                }
                            }(i, t), i) : null
                        };
                    class zi {
                        constructor(e, t) {
                            this.options = t || {}, this.self = e, this.init()
                        }
                        init() {
                            this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new qt.Transmuxer(this.options),
                                function(e, t) {
                                    t.on("data", (function(t) {
                                        const i = t.initSegment;
                                        t.initSegment = {
                                            data: i.buffer,
                                            byteOffset: i.byteOffset,
                                            byteLength: i.byteLength
                                        };
                                        const n = t.data;
                                        t.data = n.buffer, e.postMessage({
                                            action: "data",
                                            segment: t,
                                            byteOffset: n.byteOffset,
                                            byteLength: n.byteLength
                                        }, [t.data])
                                    })), t.on("done", (function(t) {
                                        e.postMessage({
                                            action: "done"
                                        })
                                    })), t.on("gopInfo", (function(t) {
                                        e.postMessage({
                                            action: "gopInfo",
                                            gopInfo: t
                                        })
                                    })), t.on("videoSegmentTimingInfo", (function(t) {
                                        const i = {
                                            start: {
                                                decode: le.videoTsToSeconds(t.start.dts),
                                                presentation: le.videoTsToSeconds(t.start.pts)
                                            },
                                            end: {
                                                decode: le.videoTsToSeconds(t.end.dts),
                                                presentation: le.videoTsToSeconds(t.end.pts)
                                            },
                                            baseMediaDecodeTime: le.videoTsToSeconds(t.baseMediaDecodeTime)
                                        };
                                        t.prependedContentDuration && (i.prependedContentDuration = le.videoTsToSeconds(t.prependedContentDuration)), e.postMessage({
                                            action: "videoSegmentTimingInfo",
                                            videoSegmentTimingInfo: i
                                        })
                                    })), t.on("audioSegmentTimingInfo", (function(t) {
                                        const i = {
                                            start: {
                                                decode: le.videoTsToSeconds(t.start.dts),
                                                presentation: le.videoTsToSeconds(t.start.pts)
                                            },
                                            end: {
                                                decode: le.videoTsToSeconds(t.end.dts),
                                                presentation: le.videoTsToSeconds(t.end.pts)
                                            },
                                            baseMediaDecodeTime: le.videoTsToSeconds(t.baseMediaDecodeTime)
                                        };
                                        t.prependedContentDuration && (i.prependedContentDuration = le.videoTsToSeconds(t.prependedContentDuration)), e.postMessage({
                                            action: "audioSegmentTimingInfo",
                                            audioSegmentTimingInfo: i
                                        })
                                    })), t.on("id3Frame", (function(t) {
                                        e.postMessage({
                                            action: "id3Frame",
                                            id3Frame: t
                                        })
                                    })), t.on("caption", (function(t) {
                                        e.postMessage({
                                            action: "caption",
                                            caption: t
                                        })
                                    })), t.on("trackinfo", (function(t) {
                                        e.postMessage({
                                            action: "trackinfo",
                                            trackInfo: t
                                        })
                                    })), t.on("audioTimingInfo", (function(t) {
                                        e.postMessage({
                                            action: "audioTimingInfo",
                                            audioTimingInfo: {
                                                start: le.videoTsToSeconds(t.start),
                                                end: le.videoTsToSeconds(t.end)
                                            }
                                        })
                                    })), t.on("videoTimingInfo", (function(t) {
                                        e.postMessage({
                                            action: "videoTimingInfo",
                                            videoTimingInfo: {
                                                start: le.videoTsToSeconds(t.start),
                                                end: le.videoTsToSeconds(t.end)
                                            }
                                        })
                                    })), t.on("log", (function(t) {
                                        e.postMessage({
                                            action: "log",
                                            log: t
                                        })
                                    }))
                                }(this.self, this.transmuxer)
                        }
                        pushMp4Captions(e) {
                            this.captionParser || (this.captionParser = new pi, this.captionParser.init());
                            const t = new Uint8Array(e.data, e.byteOffset, e.byteLength),
                                i = this.captionParser.parse(t, e.trackIds, e.timescales);
                            this.self.postMessage({
                                action: "mp4Captions",
                                captions: i && i.captions || [],
                                logs: i && i.logs || [],
                                data: t.buffer
                            }, [t.buffer])
                        }
                        probeMp4StartTime({
                            timescales: e,
                            data: t
                        }) {
                            const i = wi(e, t);
                            this.self.postMessage({
                                action: "probeMp4StartTime",
                                startTime: i,
                                data: t
                            }, [t.buffer])
                        }
                        probeMp4Tracks({
                            data: e
                        }) {
                            const t = Si(e);
                            this.self.postMessage({
                                action: "probeMp4Tracks",
                                tracks: t,
                                data: e
                            }, [e.buffer])
                        }
                        probeTs({
                            data: e,
                            baseStartTime: t
                        }) {
                            const i = "number" != typeof t || isNaN(t) ? void 0 : t * le.ONE_SECOND_IN_TS,
                                n = Hi(e, i);
                            let r = null;
                            n && (r = {
                                hasVideo: n.video && 2 === n.video.length || !1,
                                hasAudio: n.audio && 2 === n.audio.length || !1
                            }, r.hasVideo && (r.videoStart = n.video[0].ptsTime), r.hasAudio && (r.audioStart = n.audio[0].ptsTime)), this.self.postMessage({
                                action: "probeTs",
                                result: r,
                                data: e
                            }, [e.buffer])
                        }
                        clearAllMp4Captions() {
                            this.captionParser && this.captionParser.clearAllCaptions()
                        }
                        clearParsedMp4Captions() {
                            this.captionParser && this.captionParser.clearParsedCaptions()
                        }
                        push(e) {
                            const t = new Uint8Array(e.data, e.byteOffset, e.byteLength);
                            this.transmuxer.push(t)
                        }
                        reset() {
                            this.transmuxer.reset()
                        }
                        setTimestampOffset(e) {
                            const t = e.timestampOffset || 0;
                            this.transmuxer.setBaseMediaDecodeTime(Math.round(le.secondsToVideoTs(t)))
                        }
                        setAudioAppendStart(e) {
                            this.transmuxer.setAudioAppendStart(Math.ceil(le.secondsToVideoTs(e.appendStart)))
                        }
                        setRemux(e) {
                            this.transmuxer.setRemux(e.remux)
                        }
                        flush(e) {
                            this.transmuxer.flush(), self.postMessage({
                                action: "done",
                                type: "transmuxed"
                            })
                        }
                        endTimeline() {
                            this.transmuxer.endTimeline(), self.postMessage({
                                action: "endedtimeline",
                                type: "transmuxed"
                            })
                        }
                        alignGopsWith(e) {
                            this.transmuxer.alignGopsWith(e.gopsToAlignWith.slice())
                        }
                    }
                    self.onmessage = function(e) {
                        "init" === e.data.action && e.data.options ? this.messageHandlers = new zi(self, e.data.options) : (this.messageHandlers || (this.messageHandlers = new zi(self)), e.data && e.data.action && "init" !== e.data.action && this.messageHandlers[e.data.action] && this.messageHandlers[e.data.action](e.data))
                    }
                })));
            var Zo = Xo(Jo);
            const Qo = e => {
                    const {
                        transmuxer: t,
                        bytes: i,
                        audioAppendStart: n,
                        gopsToAlignWith: r,
                        remux: s,
                        onData: a,
                        onTrackInfo: o,
                        onAudioTimingInfo: l,
                        onVideoTimingInfo: h,
                        onVideoSegmentTimingInfo: c,
                        onAudioSegmentTimingInfo: u,
                        onId3: d,
                        onCaptions: p,
                        onDone: f,
                        onEndedTimeline: m,
                        onTransmuxerLog: g,
                        isEndOfTimeline: y
                    } = e, _ = {
                        buffer: []
                    };
                    let v = y;
                    if (t.onmessage = i => {
                            t.currentTransmux === e && ("data" === i.data.action && ((e, t, i) => {
                                const {
                                    type: n,
                                    initSegment: r,
                                    captions: s,
                                    captionStreams: a,
                                    metadata: o,
                                    videoFrameDtsTime: l,
                                    videoFramePtsTime: h
                                } = e.data.segment;
                                t.buffer.push({
                                    captions: s,
                                    captionStreams: a,
                                    metadata: o
                                });
                                const c = e.data.segment.boxes || {
                                        data: e.data.segment.data
                                    },
                                    u = {
                                        type: n,
                                        data: new Uint8Array(c.data, c.data.byteOffset, c.data.byteLength),
                                        initSegment: new Uint8Array(r.data, r.byteOffset, r.byteLength)
                                    };
                                void 0 !== l && (u.videoFrameDtsTime = l), void 0 !== h && (u.videoFramePtsTime = h), i(u)
                            })(i, _, a), "trackinfo" === i.data.action && o(i.data.trackInfo), "gopInfo" === i.data.action && ((e, t) => {
                                t.gopInfo = e.data.gopInfo
                            })(i, _), "audioTimingInfo" === i.data.action && l(i.data.audioTimingInfo), "videoTimingInfo" === i.data.action && h(i.data.videoTimingInfo), "videoSegmentTimingInfo" === i.data.action && c(i.data.videoSegmentTimingInfo), "audioSegmentTimingInfo" === i.data.action && u(i.data.audioSegmentTimingInfo), "id3Frame" === i.data.action && d([i.data.id3Frame], i.data.id3Frame.dispatchType), "caption" === i.data.action && p(i.data.caption), "endedtimeline" === i.data.action && (v = !1, m()), "log" === i.data.action && g(i.data.log), "transmuxed" === i.data.type && (v || (t.onmessage = null, (({
                                transmuxedData: e,
                                callback: t
                            }) => {
                                e.buffer = [], t(e)
                            })({
                                transmuxedData: _,
                                callback: f
                            }), el(t))))
                        }, n && t.postMessage({
                            action: "setAudioAppendStart",
                            appendStart: n
                        }), Array.isArray(r) && t.postMessage({
                            action: "alignGopsWith",
                            gopsToAlignWith: r
                        }), void 0 !== s && t.postMessage({
                            action: "setRemux",
                            remux: s
                        }), i.byteLength) {
                        const e = i instanceof ArrayBuffer ? i : i.buffer,
                            n = i instanceof ArrayBuffer ? 0 : i.byteOffset;
                        t.postMessage({
                            action: "push",
                            data: e,
                            byteOffset: n,
                            byteLength: i.byteLength
                        }, [e])
                    }
                    y && t.postMessage({
                        action: "endTimeline"
                    }), t.postMessage({
                        action: "flush"
                    })
                },
                el = e => {
                    e.currentTransmux = null, e.transmuxQueue.length && (e.currentTransmux = e.transmuxQueue.shift(), "function" == typeof e.currentTransmux ? e.currentTransmux() : Qo(e.currentTransmux))
                },
                tl = (e, t) => {
                    e.postMessage({
                        action: t
                    }), el(e)
                },
                il = (e, t) => {
                    if (!t.currentTransmux) return t.currentTransmux = e, void tl(t, e);
                    t.transmuxQueue.push(tl.bind(null, t, e))
                },
                nl = e => {
                    if (!e.transmuxer.currentTransmux) return e.transmuxer.currentTransmux = e, void Qo(e);
                    e.transmuxer.transmuxQueue.push(e)
                };
            var rl = e => {
                    il("reset", e)
                },
                sl = e => {
                    const t = new Zo;
                    t.currentTransmux = null, t.transmuxQueue = [];
                    const i = t.terminate;
                    return t.terminate = () => (t.currentTransmux = null, t.transmuxQueue.length = 0, i.call(t)), t.postMessage({
                        action: "init",
                        options: e
                    }), t
                };
            const al = function(e) {
                    const t = e.transmuxer,
                        i = e.endAction || e.action,
                        n = e.callback,
                        r = v({}, e, {
                            endAction: null,
                            transmuxer: null,
                            callback: null
                        }),
                        s = r => {
                            r.data.action === i && (t.removeEventListener("message", s), r.data.data && (r.data.data = new Uint8Array(r.data.data, e.byteOffset || 0, e.byteLength || r.data.data.byteLength), e.data && (e.data = r.data.data)), n(r.data))
                        };
                    if (t.addEventListener("message", s), e.data) {
                        const i = e.data instanceof ArrayBuffer;
                        r.byteOffset = i ? 0 : e.data.byteOffset, r.byteLength = e.data.byteLength;
                        const n = [i ? e.data : e.data.buffer];
                        t.postMessage(r, n)
                    } else t.postMessage(r)
                },
                ol = 2,
                ll = -101,
                hl = -102,
                cl = e => {
                    e.forEach((e => {
                        e.abort()
                    }))
                },
                ul = (e, t) => t.timedout ? {
                    status: t.status,
                    message: "HLS request timed-out at URL: " + t.uri,
                    code: ll,
                    xhr: t
                } : t.aborted ? {
                    status: t.status,
                    message: "HLS request aborted at URL: " + t.uri,
                    code: hl,
                    xhr: t
                } : e ? {
                    status: t.status,
                    message: "HLS request errored at URL: " + t.uri,
                    code: ol,
                    xhr: t
                } : "arraybuffer" === t.responseType && 0 === t.response.byteLength ? {
                    status: t.status,
                    message: "Empty HLS response at URL: " + t.uri,
                    code: ol,
                    xhr: t
                } : null,
                dl = (e, t, i) => (n, r) => {
                    const s = r.response,
                        a = ul(n, r);
                    if (a) return i(a, e);
                    if (16 !== s.byteLength) return i({
                        status: r.status,
                        message: "Invalid HLS key at URL: " + r.uri,
                        code: ol,
                        xhr: r
                    }, e);
                    const o = new DataView(s),
                        l = new Uint32Array([o.getUint32(0), o.getUint32(4), o.getUint32(8), o.getUint32(12)]);
                    for (let e = 0; e < t.length; e++) t[e].bytes = l;
                    return i(null, e)
                },
                pl = (e, t) => {
                    const i = Et(e.map.bytes);
                    if ("mp4" !== i) {
                        const n = e.map.resolvedUri || e.map.uri;
                        return t({
                            internal: !0,
                            message: `Found unsupported ${i||"unknown"} container for initialization segment at URL: ${n}`,
                            code: ol
                        })
                    }
                    al({
                        action: "probeMp4Tracks",
                        data: e.map.bytes,
                        transmuxer: e.transmuxer,
                        callback: ({
                            tracks: i,
                            data: n
                        }) => (e.map.bytes = n, i.forEach((function(t) {
                            e.map.tracks = e.map.tracks || {}, e.map.tracks[t.type] || (e.map.tracks[t.type] = t, "number" == typeof t.id && t.timescale && (e.map.timescales = e.map.timescales || {}, e.map.timescales[t.id] = t.timescale))
                        })), t(null))
                    })
                },
                fl = ({
                    segment: e,
                    finishProcessingFn: t,
                    responseType: i
                }) => (n, r) => {
                    const s = ul(n, r);
                    if (s) return t(s, e);
                    const a = "arraybuffer" !== i && r.responseText ? (e => {
                        const t = new Uint8Array(new ArrayBuffer(e.length));
                        for (let i = 0; i < e.length; i++) t[i] = e.charCodeAt(i);
                        return t.buffer
                    })(r.responseText.substring(e.lastReachedChar || 0)) : r.response;
                    return e.stats = (e => ({
                        bandwidth: e.bandwidth,
                        bytesReceived: e.bytesReceived || 0,
                        roundTripTime: e.roundTripTime || 0
                    }))(r), e.key ? e.encryptedBytes = new Uint8Array(a) : e.bytes = new Uint8Array(a), t(null, e)
                },
                ml = ({
                    segment: e,
                    bytes: t,
                    trackInfoFn: i,
                    timingInfoFn: n,
                    videoSegmentTimingInfoFn: r,
                    audioSegmentTimingInfoFn: s,
                    id3Fn: a,
                    captionsFn: o,
                    isEndOfTimeline: l,
                    endedTimelineFn: h,
                    dataFn: c,
                    doneFn: u,
                    onTransmuxerLog: d
                }) => {
                    const p = e.map && e.map.tracks || {},
                        f = Boolean(p.audio && p.video);
                    let m = n.bind(null, e, "audio", "start");
                    const g = n.bind(null, e, "audio", "end");
                    let y = n.bind(null, e, "video", "start");
                    const _ = n.bind(null, e, "video", "end");
                    al({
                        action: "probeTs",
                        transmuxer: e.transmuxer,
                        data: t,
                        baseStartTime: e.baseStartTime,
                        callback: n => {
                            e.bytes = t = n.data;
                            const p = n.result;
                            p && (i(e, {
                                hasAudio: p.hasAudio,
                                hasVideo: p.hasVideo,
                                isMuxed: f
                            }), i = null, p.hasAudio && !f && m(p.audioStart), p.hasVideo && y(p.videoStart), m = null, y = null), nl({
                                bytes: t,
                                transmuxer: e.transmuxer,
                                audioAppendStart: e.audioAppendStart,
                                gopsToAlignWith: e.gopsToAlignWith,
                                remux: f,
                                onData: t => {
                                    t.type = "combined" === t.type ? "video" : t.type, c(e, t)
                                },
                                onTrackInfo: t => {
                                    i && (f && (t.isMuxed = !0), i(e, t))
                                },
                                onAudioTimingInfo: e => {
                                    m && void 0 !== e.start && (m(e.start), m = null), g && void 0 !== e.end && g(e.end)
                                },
                                onVideoTimingInfo: e => {
                                    y && void 0 !== e.start && (y(e.start), y = null), _ && void 0 !== e.end && _(e.end)
                                },
                                onVideoSegmentTimingInfo: e => {
                                    r(e)
                                },
                                onAudioSegmentTimingInfo: e => {
                                    s(e)
                                },
                                onId3: (t, i) => {
                                    a(e, t, i)
                                },
                                onCaptions: t => {
                                    o(e, [t])
                                },
                                isEndOfTimeline: l,
                                onEndedTimeline: () => {
                                    h()
                                },
                                onTransmuxerLog: d,
                                onDone: t => {
                                    u && (t.type = "combined" === t.type ? "video" : t.type, u(null, e, t))
                                }
                            })
                        }
                    })
                },
                gl = ({
                    segment: e,
                    bytes: t,
                    trackInfoFn: i,
                    timingInfoFn: n,
                    videoSegmentTimingInfoFn: r,
                    audioSegmentTimingInfoFn: s,
                    id3Fn: a,
                    captionsFn: o,
                    isEndOfTimeline: l,
                    endedTimelineFn: h,
                    dataFn: c,
                    doneFn: u,
                    onTransmuxerLog: d
                }) => {
                    let p = new Uint8Array(t);
                    if (function(e) {
                            return ht(e, ["moof"]).length > 0
                        }(p)) {
                        e.isFmp4 = !0;
                        const {
                            tracks: r
                        } = e.map, s = {
                            isFmp4: !0,
                            hasVideo: !!r.video,
                            hasAudio: !!r.audio
                        };
                        r.audio && r.audio.codec && "enca" !== r.audio.codec && (s.audioCodec = r.audio.codec), r.video && r.video.codec && "encv" !== r.video.codec && (s.videoCodec = r.video.codec), r.video && r.audio && (s.isMuxed = !0), i(e, s);
                        const a = t => {
                            c(e, {
                                data: p,
                                type: s.hasAudio && !s.isMuxed ? "audio" : "video"
                            }), t && t.length && o(e, t), u(null, e, {})
                        };
                        al({
                            action: "probeMp4StartTime",
                            timescales: e.map.timescales,
                            data: p,
                            transmuxer: e.transmuxer,
                            callback: ({
                                data: i,
                                startTime: o
                            }) => {
                                t = i.buffer, e.bytes = p = i, s.hasAudio && !s.isMuxed && n(e, "audio", "start", o), s.hasVideo && n(e, "video", "start", o), r.video && i.byteLength && e.transmuxer ? al({
                                    action: "pushMp4Captions",
                                    endAction: "mp4Captions",
                                    transmuxer: e.transmuxer,
                                    data: p,
                                    timescales: e.map.timescales,
                                    trackIds: [r.video.id],
                                    callback: i => {
                                        t = i.data.buffer, e.bytes = p = i.data, i.logs.forEach((function(e) {
                                            d(Na(e, {
                                                stream: "mp4CaptionParser"
                                            }))
                                        })), a(i.captions)
                                    }
                                }) : a()
                            }
                        })
                    } else if (e.transmuxer) {
                        if (void 0 === e.container && (e.container = Et(p)), "ts" !== e.container && "aac" !== e.container) return i(e, {
                            hasAudio: !1,
                            hasVideo: !1
                        }), void u(null, e, {});
                        ml({
                            segment: e,
                            bytes: t,
                            trackInfoFn: i,
                            timingInfoFn: n,
                            videoSegmentTimingInfoFn: r,
                            audioSegmentTimingInfoFn: s,
                            id3Fn: a,
                            captionsFn: o,
                            isEndOfTimeline: l,
                            endedTimelineFn: h,
                            dataFn: c,
                            doneFn: u,
                            onTransmuxerLog: d
                        })
                    } else u(null, e, {})
                },
                yl = function({
                    id: e,
                    key: t,
                    encryptedBytes: i,
                    decryptionWorker: n
                }, r) {
                    const s = t => {
                        if (t.data.source === e) {
                            n.removeEventListener("message", s);
                            const e = t.data.decrypted;
                            r(new Uint8Array(e.bytes, e.byteOffset, e.byteLength))
                        }
                    };
                    let a;
                    n.addEventListener("message", s), a = t.bytes.slice ? t.bytes.slice() : new Uint32Array(Array.prototype.slice.call(t.bytes)), n.postMessage(Ro({
                        source: e,
                        encrypted: i,
                        key: a,
                        iv: t.iv
                    }), [i.buffer, a.buffer])
                },
                _l = ({
                    activeXhrs: e,
                    decryptionWorker: t,
                    trackInfoFn: i,
                    timingInfoFn: n,
                    videoSegmentTimingInfoFn: r,
                    audioSegmentTimingInfoFn: s,
                    id3Fn: a,
                    captionsFn: o,
                    isEndOfTimeline: l,
                    endedTimelineFn: h,
                    dataFn: c,
                    doneFn: u,
                    onTransmuxerLog: d
                }) => {
                    let p = 0,
                        f = !1;
                    return (m, g) => {
                        if (!f) {
                            if (m) return f = !0, cl(e), u(m, g);
                            if (p += 1, p === e.length) {
                                const p = function() {
                                    if (g.encryptedBytes) return (({
                                        decryptionWorker: e,
                                        segment: t,
                                        trackInfoFn: i,
                                        timingInfoFn: n,
                                        videoSegmentTimingInfoFn: r,
                                        audioSegmentTimingInfoFn: s,
                                        id3Fn: a,
                                        captionsFn: o,
                                        isEndOfTimeline: l,
                                        endedTimelineFn: h,
                                        dataFn: c,
                                        doneFn: u,
                                        onTransmuxerLog: d
                                    }) => {
                                        yl({
                                            id: t.requestId,
                                            key: t.key,
                                            encryptedBytes: t.encryptedBytes,
                                            decryptionWorker: e
                                        }, (e => {
                                            t.bytes = e, gl({
                                                segment: t,
                                                bytes: t.bytes,
                                                trackInfoFn: i,
                                                timingInfoFn: n,
                                                videoSegmentTimingInfoFn: r,
                                                audioSegmentTimingInfoFn: s,
                                                id3Fn: a,
                                                captionsFn: o,
                                                isEndOfTimeline: l,
                                                endedTimelineFn: h,
                                                dataFn: c,
                                                doneFn: u,
                                                onTransmuxerLog: d
                                            })
                                        }))
                                    })({
                                        decryptionWorker: t,
                                        segment: g,
                                        trackInfoFn: i,
                                        timingInfoFn: n,
                                        videoSegmentTimingInfoFn: r,
                                        audioSegmentTimingInfoFn: s,
                                        id3Fn: a,
                                        captionsFn: o,
                                        isEndOfTimeline: l,
                                        endedTimelineFn: h,
                                        dataFn: c,
                                        doneFn: u,
                                        onTransmuxerLog: d
                                    });
                                    gl({
                                        segment: g,
                                        bytes: g.bytes,
                                        trackInfoFn: i,
                                        timingInfoFn: n,
                                        videoSegmentTimingInfoFn: r,
                                        audioSegmentTimingInfoFn: s,
                                        id3Fn: a,
                                        captionsFn: o,
                                        isEndOfTimeline: l,
                                        endedTimelineFn: h,
                                        dataFn: c,
                                        doneFn: u,
                                        onTransmuxerLog: d
                                    })
                                };
                                if (g.endOfAllRequests = Date.now(), g.map && g.map.encryptedBytes && !g.map.bytes) return yl({
                                    decryptionWorker: t,
                                    id: g.requestId + "-init",
                                    encryptedBytes: g.map.encryptedBytes,
                                    key: g.map.key
                                }, (t => {
                                    g.map.bytes = t, pl(g, (t => {
                                        if (t) return cl(e), u(t, g);
                                        p()
                                    }))
                                }));
                                p()
                            }
                        }
                    }
                },
                vl = ({
                    segment: e,
                    progressFn: t,
                    trackInfoFn: i,
                    timingInfoFn: n,
                    videoSegmentTimingInfoFn: r,
                    audioSegmentTimingInfoFn: s,
                    id3Fn: a,
                    captionsFn: o,
                    isEndOfTimeline: l,
                    endedTimelineFn: h,
                    dataFn: c
                }) => i => {
                    if (!i.target.aborted) return e.stats = Na(e.stats, (e => {
                        const t = e.target,
                            i = {
                                bandwidth: 1 / 0,
                                bytesReceived: 0,
                                roundTripTime: Date.now() - t.requestTime || 0
                            };
                        return i.bytesReceived = e.loaded, i.bandwidth = Math.floor(i.bytesReceived / i.roundTripTime * 8 * 1e3), i
                    })(i)), !e.stats.firstBytesReceivedAt && e.stats.bytesReceived && (e.stats.firstBytesReceivedAt = Date.now()), t(i, e)
                },
                bl = ({
                    xhr: e,
                    xhrOptions: t,
                    decryptionWorker: i,
                    segment: n,
                    abortFn: r,
                    progressFn: s,
                    trackInfoFn: a,
                    timingInfoFn: o,
                    videoSegmentTimingInfoFn: l,
                    audioSegmentTimingInfoFn: h,
                    id3Fn: c,
                    captionsFn: u,
                    isEndOfTimeline: d,
                    endedTimelineFn: p,
                    dataFn: f,
                    doneFn: m,
                    onTransmuxerLog: g
                }) => {
                    const y = [],
                        _ = _l({
                            activeXhrs: y,
                            decryptionWorker: i,
                            trackInfoFn: a,
                            timingInfoFn: o,
                            videoSegmentTimingInfoFn: l,
                            audioSegmentTimingInfoFn: h,
                            id3Fn: c,
                            captionsFn: u,
                            isEndOfTimeline: d,
                            endedTimelineFn: p,
                            dataFn: f,
                            doneFn: m,
                            onTransmuxerLog: g
                        });
                    if (n.key && !n.key.bytes) {
                        const i = [n.key];
                        n.map && !n.map.bytes && n.map.key && n.map.key.resolvedUri === n.key.resolvedUri && i.push(n.map.key);
                        const r = e(Na(t, {
                            uri: n.key.resolvedUri,
                            responseType: "arraybuffer"
                        }), dl(n, i, _));
                        y.push(r)
                    }
                    if (n.map && !n.map.bytes) {
                        if (n.map.key && (!n.key || n.key.resolvedUri !== n.map.key.resolvedUri)) {
                            const i = e(Na(t, {
                                uri: n.map.key.resolvedUri,
                                responseType: "arraybuffer"
                            }), dl(n, [n.map.key], _));
                            y.push(i)
                        }
                        const i = Na(t, {
                                uri: n.map.resolvedUri,
                                responseType: "arraybuffer",
                                headers: Ao(n.map)
                            }),
                            r = (({
                                segment: e,
                                finishProcessingFn: t
                            }) => (i, n) => {
                                const r = ul(i, n);
                                if (r) return t(r, e);
                                const s = new Uint8Array(n.response);
                                if (e.map.key) return e.map.encryptedBytes = s, t(null, e);
                                e.map.bytes = s, pl(e, (function(i) {
                                    if (i) return i.xhr = n, i.status = n.status, t(i, e);
                                    t(null, e)
                                }))
                            })({
                                segment: n,
                                finishProcessingFn: _
                            }),
                            s = e(i, r);
                        y.push(s)
                    }
                    const v = Na(t, {
                            uri: n.part && n.part.resolvedUri || n.resolvedUri,
                            responseType: "arraybuffer",
                            headers: Ao(n)
                        }),
                        b = e(v, fl({
                            segment: n,
                            finishProcessingFn: _,
                            responseType: v.responseType
                        }));
                    b.addEventListener("progress", vl({
                        segment: n,
                        progressFn: s,
                        trackInfoFn: a,
                        timingInfoFn: o,
                        videoSegmentTimingInfoFn: l,
                        audioSegmentTimingInfoFn: h,
                        id3Fn: c,
                        captionsFn: u,
                        isEndOfTimeline: d,
                        endedTimelineFn: p,
                        dataFn: f
                    })), y.push(b);
                    const T = {};
                    return y.forEach((e => {
                        e.addEventListener("loadend", (({
                            loadendState: e,
                            abortFn: t
                        }) => i => {
                            i.target.aborted && t && !e.calledAbortFn && (t(), e.calledAbortFn = !0)
                        })({
                            loadendState: T,
                            abortFn: r
                        }))
                    })), () => cl(y)
                },
                Tl = Oa("CodecUtils"),
                xl = (e, t) => {
                    const i = t.attributes || {};
                    return e && e.mediaGroups && e.mediaGroups.AUDIO && i.AUDIO && e.mediaGroups.AUDIO[i.AUDIO]
                },
                wl = function(e) {
                    const t = {};
                    return e.forEach((({
                        mediaType: e,
                        type: i,
                        details: n
                    }) => {
                        t[e] = t[e] || [], t[e].push(U(`${i}${n}`))
                    })), Object.keys(t).forEach((function(e) {
                        if (t[e].length > 1) return Tl(`multiple ${e} codecs found as attributes: ${t[e].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`), void(t[e] = null);
                        t[e] = t[e][0]
                    })), t
                },
                Sl = function(e) {
                    let t = 0;
                    return e.audio && t++, e.video && t++, t
                },
                El = function(e, t) {
                    const i = t.attributes || {},
                        n = wl(function(e) {
                            const t = e.attributes || {};
                            if (t.CODECS) return B(t.CODECS)
                        }(t) || []);
                    if (xl(e, t) && !n.audio && !((e, t) => {
                            if (!xl(e, t)) return !0;
                            const i = t.attributes || {},
                                n = e.mediaGroups.AUDIO[i.AUDIO];
                            for (const e in n)
                                if (!n[e].uri && !n[e].playlists) return !0;
                            return !1
                        })(e, t)) {
                        const t = wl(function(e, t) {
                            if (!e.mediaGroups.AUDIO || !t) return null;
                            var i = e.mediaGroups.AUDIO[t];
                            if (!i) return null;
                            for (var n in i) {
                                var r = i[n];
                                if (r.default && r.playlists) return B(r.playlists[0].attributes.CODECS)
                            }
                            return null
                        }(e, i.AUDIO) || []);
                        t.audio && (n.audio = t.audio)
                    }
                    return n
                },
                Ml = Oa("PlaylistSelector"),
                Cl = function(e) {
                    if (!e || !e.playlist) return;
                    const t = e.playlist;
                    return JSON.stringify({
                        id: t.id,
                        bandwidth: e.bandwidth,
                        width: e.width,
                        height: e.height,
                        codecs: t.attributes && t.attributes.CODECS || ""
                    })
                },
                Al = function(e, t) {
                    if (!e) return "";
                    const i = r().getComputedStyle(e);
                    return i ? i[t] : ""
                },
                Ll = function(e, t) {
                    const i = e.slice();
                    e.sort((function(e, n) {
                        const r = t(e, n);
                        return 0 === r ? i.indexOf(e) - i.indexOf(n) : r
                    }))
                },
                Il = function(e, t) {
                    let i, n;
                    return e.attributes.BANDWIDTH && (i = e.attributes.BANDWIDTH), i = i || r().Number.MAX_VALUE, t.attributes.BANDWIDTH && (n = t.attributes.BANDWIDTH), n = n || r().Number.MAX_VALUE, i - n
                };
            let Pl = function(e, t, i, n, s, a) {
                if (!e) return;
                const o = {
                    bandwidth: t,
                    width: i,
                    height: n,
                    limitRenditionByPlayerDimensions: s
                };
                let l = e.playlists;
                co.isAudioOnly(e) && (l = a.getAudioTrackPlaylists_(), o.audioOnly = !0);
                let h = l.map((e => {
                    let t;
                    const i = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.width,
                        n = e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.height;
                    return t = e.attributes && e.attributes.BANDWIDTH, t = t || r().Number.MAX_VALUE, {
                        bandwidth: t,
                        width: i,
                        height: n,
                        playlist: e
                    }
                }));
                Ll(h, ((e, t) => e.bandwidth - t.bandwidth)), h = h.filter((e => !co.isIncompatible(e.playlist)));
                let c = h.filter((e => co.isEnabled(e.playlist)));
                c.length || (c = h.filter((e => !co.isDisabled(e.playlist))));
                const u = c.filter((e => e.bandwidth * qo.BANDWIDTH_VARIANCE < t));
                let d = u[u.length - 1];
                const p = u.filter((e => e.bandwidth === d.bandwidth))[0];
                if (!1 === s) {
                    const e = p || c[0] || h[0];
                    if (e && e.playlist) {
                        let t = "sortedPlaylistReps";
                        return p && (t = "bandwidthBestRep"), c[0] && (t = "enabledPlaylistReps"), Ml(`choosing ${Cl(e)} using ${t} with options`, o), e.playlist
                    }
                    return Ml("could not choose a playlist with options", o), null
                }
                const f = u.filter((e => e.width && e.height));
                Ll(f, ((e, t) => e.width - t.width));
                const m = f.filter((e => e.width === i && e.height === n));
                d = m[m.length - 1];
                const g = m.filter((e => e.bandwidth === d.bandwidth))[0];
                let y, _, v, b;
                if (g || (y = f.filter((e => e.width > i || e.height > n)), _ = y.filter((e => e.width === y[0].width && e.height === y[0].height)), d = _[_.length - 1], v = _.filter((e => e.bandwidth === d.bandwidth))[0]), a.leastPixelDiffSelector) {
                    const e = f.map((e => (e.pixelDiff = Math.abs(e.width - i) + Math.abs(e.height - n), e)));
                    Ll(e, ((e, t) => e.pixelDiff === t.pixelDiff ? t.bandwidth - e.bandwidth : e.pixelDiff - t.pixelDiff)), b = e[0]
                }
                const T = b || v || g || p || c[0] || h[0];
                if (T && T.playlist) {
                    let e = "sortedPlaylistReps";
                    return b ? e = "leastPixelDiffRep" : v ? e = "resolutionPlusOneRep" : g ? e = "resolutionBestRep" : p ? e = "bandwidthBestRep" : c[0] && (e = "enabledPlaylistReps"), Ml(`choosing ${Cl(T)} using ${e} with options`, o), T.playlist
                }
                return Ml("could not choose a playlist with options", o), null
            };
            const Rl = function() {
                    const e = this.useDevicePixelRatio && r().devicePixelRatio || 1;
                    return Pl(this.playlists.main, this.systemBandwidth, parseInt(Al(this.tech_.el(), "width"), 10) * e, parseInt(Al(this.tech_.el(), "height"), 10) * e, this.limitRenditionByPlayerDimensions, this.playlistController_)
                },
                kl = ({
                    inbandTextTracks: e,
                    metadataArray: t,
                    timestampOffset: i,
                    videoDuration: n
                }) => {
                    if (!t) return;
                    const s = r().WebKitDataCue || r().VTTCue,
                        a = e.metadataTrack_;
                    if (!a) return;
                    if (t.forEach((e => {
                            const t = e.cueTime + i;
                            !("number" != typeof t || r().isNaN(t) || t < 0) && t < 1 / 0 && e.frames.forEach((e => {
                                const i = new s(t, t, e.value || e.url || e.data || "");
                                i.frame = e, i.value = e,
                                    function(e) {
                                        Object.defineProperties(e.frame, {
                                            id: {
                                                get: () => (Ca.log.warn("cue.frame.id is deprecated. Use cue.value.key instead."), e.value.key)
                                            },
                                            value: {
                                                get: () => (Ca.log.warn("cue.frame.value is deprecated. Use cue.value.data instead."), e.value.data)
                                            },
                                            privateData: {
                                                get: () => (Ca.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead."), e.value.data)
                                            }
                                        })
                                    }(i), a.addCue(i)
                            }))
                        })), !a.cues || !a.cues.length) return;
                    const o = a.cues,
                        l = [];
                    for (let e = 0; e < o.length; e++) o[e] && l.push(o[e]);
                    const h = l.reduce(((e, t) => {
                            const i = e[t.startTime] || [];
                            return i.push(t), e[t.startTime] = i, e
                        }), {}),
                        c = Object.keys(h).sort(((e, t) => Number(e) - Number(t)));
                    c.forEach(((e, t) => {
                        const i = h[e],
                            r = Number(c[t + 1]) || n;
                        i.forEach((e => {
                            e.endTime = r
                        }))
                    }))
                },
                Dl = function(e, t, i) {
                    let n, r;
                    if (i && i.cues)
                        for (n = i.cues.length; n--;) r = i.cues[n], r.startTime >= e && r.endTime <= t && i.removeCue(r)
                },
                Ol = e => "number" == typeof e && isFinite(e),
                Nl = 1 / 60,
                Ul = e => {
                    const {
                        startOfSegment: t,
                        duration: i,
                        segment: n,
                        part: r,
                        playlist: {
                            mediaSequence: s,
                            id: a,
                            segments: o = []
                        },
                        mediaIndex: l,
                        partIndex: h,
                        timeline: c
                    } = e, u = o.length - 1;
                    let d = "mediaIndex/partIndex increment";
                    e.getMediaInfoForTime ? d = `getMediaInfoForTime (${e.getMediaInfoForTime})` : e.isSyncRequest && (d = "getSyncSegmentCandidate (isSyncRequest)"), e.independent && (d += ` with independent ${e.independent}`);
                    const p = "number" == typeof h,
                        f = e.segment.uri ? "segment" : "pre-segment",
                        m = p ? Ka({
                            preloadSegment: n
                        }) - 1 : 0;
                    return `${f} [${s+l}/${s+u}]` + (p ? ` part [${h}/${m}]` : "") + ` segment start/end [${n.start} => ${n.end}]` + (p ? ` part start/end [${r.start} => ${r.end}]` : "") + ` startOfSegment [${t}]` + ` duration [${i}]` + ` timeline [${c}]` + ` selected by [${d}]` + ` playlist [${a}]`
                },
                Bl = e => `${e}TimingInfo`,
                Fl = ({
                    timelineChangeController: e,
                    currentTimeline: t,
                    segmentTimeline: i,
                    loaderType: n,
                    audioDisabled: r
                }) => {
                    if (t === i) return !1;
                    if ("audio" === n) {
                        const t = e.lastTimelineChange({
                            type: "main"
                        });
                        return !t || t.to !== i
                    }
                    if ("main" === n && r) {
                        const t = e.pendingTimelineChange({
                            type: "audio"
                        });
                        return !t || t.to !== i
                    }
                    return !1
                },
                Hl = ({
                    segmentDuration: e,
                    maxDuration: t
                }) => !!e && Math.round(e) > t + Ba,
                zl = (e, t) => {
                    if ("hls" !== t) return null;
                    const i = (e => {
                        let t = 0;
                        return ["video", "audio"].forEach((function(i) {
                            const n = e[`${i}TimingInfo`];
                            if (!n) return;
                            const {
                                start: s,
                                end: a
                            } = n;
                            let o;
                            "bigint" == typeof s || "bigint" == typeof a ? o = r().BigInt(a) - r().BigInt(s) : "number" == typeof s && "number" == typeof a && (o = a - s), void 0 !== o && o > t && (t = o)
                        })), "bigint" == typeof t && t < Number.MAX_SAFE_INTEGER && (t = Number(t)), t
                    })({
                        audioTimingInfo: e.audioTimingInfo,
                        videoTimingInfo: e.videoTimingInfo
                    });
                    if (!i) return null;
                    const n = e.playlist.targetDuration,
                        s = Hl({
                            segmentDuration: i,
                            maxDuration: 2 * n
                        }),
                        a = Hl({
                            segmentDuration: i,
                            maxDuration: n
                        }),
                        o = `Segment with index ${e.mediaIndex} from playlist ${e.playlist.id} has a duration of ${i} when the reported duration is ${e.duration} and the target duration is ${n}. For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1`;
                    return s || a ? {
                        severity: s ? "warn" : "info",
                        message: o
                    } : null
                };
            class Vl extends Ca.EventTarget {
                constructor(e, t = {}) {
                    if (super(), !e) throw new TypeError("Initialization settings are required");
                    if ("function" != typeof e.currentTime) throw new TypeError("No currentTime getter specified");
                    if (!e.mediaSource) throw new TypeError("No MediaSource specified");
                    this.bandwidth = e.bandwidth, this.throughput = {
                        rate: 0,
                        count: 0
                    }, this.roundTrip = NaN, this.resetStats_(), this.mediaIndex = null, this.partIndex = null, this.hasPlayed_ = e.hasPlayed, this.currentTime_ = e.currentTime, this.seekable_ = e.seekable, this.seeking_ = e.seeking, this.duration_ = e.duration, this.mediaSource_ = e.mediaSource, this.vhs_ = e.vhs, this.loaderType_ = e.loaderType, this.currentMediaInfo_ = void 0, this.startingMediaInfo_ = void 0, this.segmentMetadataTrack_ = e.segmentMetadataTrack, this.goalBufferLength_ = e.goalBufferLength, this.sourceType_ = e.sourceType, this.sourceUpdater_ = e.sourceUpdater, this.inbandTextTracks_ = e.inbandTextTracks, this.state_ = "INIT", this.timelineChangeController_ = e.timelineChangeController, this.shouldSaveSegmentTimingInfo_ = !0, this.parse708captions_ = e.parse708captions, this.useDtsForTimestampOffset_ = e.useDtsForTimestampOffset, this.captionServices_ = e.captionServices, this.exactManifestTimings = e.exactManifestTimings, this.checkBufferTimeout_ = null, this.error_ = void 0, this.currentTimeline_ = -1, this.pendingSegment_ = null, this.xhrOptions_ = null, this.pendingSegments_ = [], this.audioDisabled_ = !1, this.isPendingTimestampOffset_ = !1, this.gopBuffer_ = [], this.timeMapping_ = 0, this.safeAppend_ = Ca.browser.IE_VERSION >= 11, this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    }, this.playlistOfLastInitSegment_ = {
                        audio: null,
                        video: null
                    }, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_ = {
                        id3: [],
                        caption: []
                    }, this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = null, this.activeInitSegmentId_ = null, this.initSegments_ = {}, this.cacheEncryptionKeys_ = e.cacheEncryptionKeys, this.keyCache_ = {}, this.decrypter_ = e.decrypter, this.syncController_ = e.syncController, this.syncPoint_ = {
                        segmentIndex: 0,
                        time: 0
                    }, this.transmuxer_ = this.createTransmuxer_(), this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate"), this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_), this.mediaSource_.addEventListener("sourceopen", (() => {
                        this.isEndOfStream_() || (this.ended_ = !1)
                    })), this.fetchAtBuffer_ = !1, this.logger_ = Oa(`SegmentLoader[${this.loaderType_}]`), Object.defineProperty(this, "state", {
                        get() {
                            return this.state_
                        },
                        set(e) {
                            e !== this.state_ && (this.logger_(`${this.state_} -> ${e}`), this.state_ = e, this.trigger("statechange"))
                        }
                    }), this.sourceUpdater_.on("ready", (() => {
                        this.hasEnoughInfoToAppend_() && this.processCallQueue_()
                    })), "main" === this.loaderType_ && this.timelineChangeController_.on("pendingtimelinechange", (() => {
                        this.hasEnoughInfoToAppend_() && this.processCallQueue_()
                    })), "audio" === this.loaderType_ && this.timelineChangeController_.on("timelinechange", (() => {
                        this.hasEnoughInfoToLoad_() && this.processLoadQueue_(), this.hasEnoughInfoToAppend_() && this.processCallQueue_()
                    }))
                }
                createTransmuxer_() {
                    return sl({
                        remux: !1,
                        alignGopsAtEnd: this.safeAppend_,
                        keepOriginalTimestamps: !0,
                        parse708captions: this.parse708captions_,
                        captionServices: this.captionServices_
                    })
                }
                resetStats_() {
                    this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0
                }
                dispose() {
                    this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && r().clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off()
                }
                setAudio(e) {
                    this.audioDisabled_ = !e, e ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_())
                }
                abort() {
                    "WAITING" === this.state ? (this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_()) : this.pendingSegment_ && (this.pendingSegment_ = null)
                }
                abort_() {
                    this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, r().clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null
                }
                checkForAbort_(e) {
                    return "APPENDING" !== this.state || this.pendingSegment_ ? !this.pendingSegment_ || this.pendingSegment_.requestId !== e : (this.state = "READY", !0)
                }
                error(e) {
                    return void 0 !== e && (this.logger_("error occurred:", e), this.error_ = e), this.pendingSegment_ = null, this.error_
                }
                endOfStream() {
                    this.ended_ = !0, this.transmuxer_ && rl(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended")
                }
                buffered_() {
                    const e = this.getMediaInfo_();
                    if (!this.sourceUpdater_ || !e) return Ua();
                    if ("main" === this.loaderType_) {
                        const {
                            hasAudio: t,
                            hasVideo: i,
                            isMuxed: n
                        } = e;
                        if (i && t && !this.audioDisabled_ && !n) return this.sourceUpdater_.buffered();
                        if (i) return this.sourceUpdater_.videoBuffered()
                    }
                    return this.sourceUpdater_.audioBuffered()
                }
                initSegmentForMap(e, t = !1) {
                    if (!e) return null;
                    const i = ko(e);
                    let n = this.initSegments_[i];
                    return t && !n && e.bytes && (this.initSegments_[i] = n = {
                        resolvedUri: e.resolvedUri,
                        byterange: e.byterange,
                        bytes: e.bytes,
                        tracks: e.tracks,
                        timescales: e.timescales
                    }), n || e
                }
                segmentKey(e, t = !1) {
                    if (!e) return null;
                    const i = Do(e);
                    let n = this.keyCache_[i];
                    this.cacheEncryptionKeys_ && t && !n && e.bytes && (this.keyCache_[i] = n = {
                        resolvedUri: e.resolvedUri,
                        bytes: e.bytes
                    });
                    const r = {
                        resolvedUri: (n || e).resolvedUri
                    };
                    return n && (r.bytes = n.bytes), r
                }
                couldBeginLoading_() {
                    return this.playlist_ && !this.paused()
                }
                load() {
                    if (this.monitorBuffer_(), this.playlist_) return "INIT" === this.state && this.couldBeginLoading_() ? this.init_() : void(!this.couldBeginLoading_() || "READY" !== this.state && "INIT" !== this.state || (this.state = "READY"))
                }
                init_() {
                    return this.state = "READY", this.resetEverything(), this.monitorBuffer_()
                }
                playlist(e, t = {}) {
                    if (!e) return;
                    const i = this.playlist_,
                        n = this.pendingSegment_;
                    this.playlist_ = e, this.xhrOptions_ = t, "INIT" === this.state && (e.syncInfo = {
                        mediaSequence: e.mediaSequence,
                        time: 0
                    }, "main" === this.loaderType_ && this.syncController_.setDateTimeMappingForStart(e));
                    let r = null;
                    if (i && (i.id ? r = i.id : i.uri && (r = i.uri)), this.logger_(`playlist update [${r} => ${e.id||e.uri}]`), this.trigger("syncinfoupdate"), "INIT" === this.state && this.couldBeginLoading_()) return this.init_();
                    if (!i || i.uri !== e.uri) return null !== this.mediaIndex && (e.endList ? this.resyncLoader() : this.resetLoader()), this.currentMediaInfo_ = void 0, void this.trigger("playlistupdate");
                    const s = e.mediaSequence - i.mediaSequence;
                    if (this.logger_(`live window shift [${s}]`), null !== this.mediaIndex)
                        if (this.mediaIndex -= s, this.mediaIndex < 0) this.mediaIndex = null, this.partIndex = null;
                        else {
                            const e = this.playlist_.segments[this.mediaIndex];
                            if (this.partIndex && (!e.parts || !e.parts.length || !e.parts[this.partIndex])) {
                                const e = this.mediaIndex;
                                this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`), this.resetLoader(), this.mediaIndex = e
                            }
                        }
                    n && (n.mediaIndex -= s, n.mediaIndex < 0 ? (n.mediaIndex = null, n.partIndex = null) : (n.mediaIndex >= 0 && (n.segment = e.segments[n.mediaIndex]), n.partIndex >= 0 && n.segment.parts && (n.part = n.segment.parts[n.partIndex]))), this.syncController_.saveExpiredSegmentInfo(i, e)
                }
                pause() {
                    this.checkBufferTimeout_ && (r().clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null)
                }
                paused() {
                    return null === this.checkBufferTimeout_
                }
                resetEverything(e) {
                    this.ended_ = !1, this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    }, this.resetLoader(), this.remove(0, 1 / 0, e), this.transmuxer_ && (this.transmuxer_.postMessage({
                        action: "clearAllMp4Captions"
                    }), this.transmuxer_.postMessage({
                        action: "reset"
                    }))
                }
                resetLoader() {
                    this.fetchAtBuffer_ = !1, this.resyncLoader()
                }
                resyncLoader() {
                    this.transmuxer_ && rl(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.abort(), this.transmuxer_ && this.transmuxer_.postMessage({
                        action: "clearParsedMp4Captions"
                    })
                }
                remove(e, t, i = (() => {}), n = !1) {
                    if (t === 1 / 0 && (t = this.duration_()), t <= e) return void this.logger_("skipping remove because end ${end} is <= start ${start}");
                    if (!this.sourceUpdater_ || !this.getMediaInfo_()) return void this.logger_("skipping remove because no source updater or starting media info");
                    let r = 1;
                    const s = () => {
                        r--, 0 === r && i()
                    };
                    !n && this.audioDisabled_ || (r++, this.sourceUpdater_.removeAudio(e, t, s)), (n || "main" === this.loaderType_) && (this.gopBuffer_ = ((e, t, i, n) => {
                        const r = Math.ceil((t - n) * Mt.ONE_SECOND_IN_TS),
                            s = Math.ceil((i - n) * Mt.ONE_SECOND_IN_TS),
                            a = e.slice();
                        let o = e.length;
                        for (; o-- && !(e[o].pts <= s););
                        if (-1 === o) return a;
                        let l = o + 1;
                        for (; l-- && !(e[l].pts <= r););
                        return l = Math.max(l, 0), a.splice(l, o - l + 1), a
                    })(this.gopBuffer_, e, t, this.timeMapping_), r++, this.sourceUpdater_.removeVideo(e, t, s));
                    for (const i in this.inbandTextTracks_) Dl(e, t, this.inbandTextTracks_[i]);
                    Dl(e, t, this.segmentMetadataTrack_), s()
                }
                monitorBuffer_() {
                    this.checkBufferTimeout_ && r().clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = r().setTimeout(this.monitorBufferTick_.bind(this), 1)
                }
                monitorBufferTick_() {
                    "READY" === this.state && this.fillBuffer_(), this.checkBufferTimeout_ && r().clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = r().setTimeout(this.monitorBufferTick_.bind(this), 500)
                }
                fillBuffer_() {
                    if (this.sourceUpdater_.updating()) return;
                    const e = this.chooseNextRequest_();
                    e && ("number" == typeof e.timestampOffset && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({
                        type: this.loaderType_,
                        from: this.currentTimeline_,
                        to: e.timeline
                    })), this.loadSegment_(e))
                }
                isEndOfStream_(e = this.mediaIndex, t = this.playlist_, i = this.partIndex) {
                    if (!t || !this.mediaSource_) return !1;
                    const n = "number" == typeof e && t.segments[e],
                        r = e + 1 === t.segments.length,
                        s = !n || !n.parts || i + 1 === n.parts.length;
                    return t.endList && "open" === this.mediaSource_.readyState && r && s
                }
                chooseNextRequest_() {
                    const e = this.buffered_(),
                        t = ja(e) || 0,
                        i = qa(e, this.currentTime_()),
                        n = !this.hasPlayed_() && i >= 1,
                        r = i >= this.goalBufferLength_(),
                        s = this.playlist_.segments;
                    if (!s.length || n || r) return null;
                    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());
                    const a = {
                        partIndex: null,
                        mediaIndex: null,
                        startOfSegment: null,
                        playlist: this.playlist_,
                        isSyncRequest: Boolean(!this.syncPoint_)
                    };
                    if (a.isSyncRequest) a.mediaIndex = function(e, t, i) {
                        t = t || [];
                        const n = [];
                        let r = 0;
                        for (let s = 0; s < t.length; s++) {
                            const a = t[s];
                            if (e === a.timeline && (n.push(s), r += a.duration, r > i)) return s
                        }
                        return 0 === n.length ? 0 : n[n.length - 1]
                    }(this.currentTimeline_, s, t);
                    else if (null !== this.mediaIndex) {
                        const e = s[this.mediaIndex],
                            i = "number" == typeof this.partIndex ? this.partIndex : -1;
                        a.startOfSegment = e.end ? e.end : t, e.parts && e.parts[i + 1] ? (a.mediaIndex = this.mediaIndex, a.partIndex = i + 1) : a.mediaIndex = this.mediaIndex + 1
                    } else {
                        const {
                            segmentIndex: e,
                            startTime: i,
                            partIndex: n
                        } = co.getMediaInfoForTime({
                            exactManifestTimings: this.exactManifestTimings,
                            playlist: this.playlist_,
                            currentTime: this.fetchAtBuffer_ ? t : this.currentTime_(),
                            startingPartIndex: this.syncPoint_.partIndex,
                            startingSegmentIndex: this.syncPoint_.segmentIndex,
                            startTime: this.syncPoint_.time
                        });
                        a.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${t}` : `currentTime ${this.currentTime_()}`, a.mediaIndex = e, a.startOfSegment = i, a.partIndex = n
                    }
                    const o = s[a.mediaIndex];
                    let l = o && "number" == typeof a.partIndex && o.parts && o.parts[a.partIndex];
                    if (!o || "number" == typeof a.partIndex && !l) return null;
                    if ("number" != typeof a.partIndex && o.parts && (a.partIndex = 0, l = o.parts[0]), !i && l && !l.independent)
                        if (0 === a.partIndex) {
                            const e = s[a.mediaIndex - 1],
                                t = e.parts && e.parts.length && e.parts[e.parts.length - 1];
                            t && t.independent && (a.mediaIndex -= 1, a.partIndex = e.parts.length - 1, a.independent = "previous segment")
                        } else o.parts[a.partIndex - 1].independent && (a.partIndex -= 1, a.independent = "previous part");
                    const h = this.mediaSource_ && "ended" === this.mediaSource_.readyState;
                    return a.mediaIndex >= s.length - 1 && h && !this.seeking_() ? null : this.generateSegmentInfo_(a)
                }
                generateSegmentInfo_(e) {
                    const {
                        independent: t,
                        playlist: i,
                        mediaIndex: n,
                        startOfSegment: r,
                        isSyncRequest: s,
                        partIndex: a,
                        forceTimestampOffset: o,
                        getMediaInfoForTime: l
                    } = e, h = i.segments[n], c = "number" == typeof a && h.parts[a], u = {
                        requestId: "segment-loader-" + Math.random(),
                        uri: c && c.resolvedUri || h.resolvedUri,
                        mediaIndex: n,
                        partIndex: c ? a : null,
                        isSyncRequest: s,
                        startOfSegment: r,
                        playlist: i,
                        bytes: null,
                        encryptedBytes: null,
                        timestampOffset: null,
                        timeline: h.timeline,
                        duration: c && c.duration || h.duration,
                        segment: h,
                        part: c,
                        byteLength: 0,
                        transmuxer: this.transmuxer_,
                        getMediaInfoForTime: l,
                        independent: t
                    }, d = void 0 !== o ? o : this.isPendingTimestampOffset_;
                    u.timestampOffset = this.timestampOffsetForSegment_({
                        segmentTimeline: h.timeline,
                        currentTimeline: this.currentTimeline_,
                        startOfSegment: r,
                        buffered: this.buffered_(),
                        overrideCheck: d
                    });
                    const p = ja(this.sourceUpdater_.audioBuffered());
                    return "number" == typeof p && (u.audioAppendStart = p - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (u.gopsToAlignWith = ((e, t, i) => {
                        if (null == t || !e.length) return [];
                        const n = Math.ceil((t - i + 3) * Mt.ONE_SECOND_IN_TS);
                        let r;
                        for (r = 0; r < e.length && !(e[r].pts > n); r++);
                        return e.slice(r)
                    })(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_)), u
                }
                timestampOffsetForSegment_(e) {
                    return (({
                        segmentTimeline: e,
                        currentTimeline: t,
                        startOfSegment: i,
                        buffered: n,
                        overrideCheck: r
                    }) => r || e !== t ? e < t ? i : n.length ? n.end(n.length - 1) : i : null)(e)
                }
                earlyAbortWhenNeeded_(e) {
                    if (this.vhs_.tech_.paused() || !this.xhrOptions_.timeout || !this.playlist_.attributes.BANDWIDTH) return;
                    if (Date.now() - (e.firstBytesReceivedAt || Date.now()) < 1e3) return;
                    const t = this.currentTime_(),
                        i = e.bandwidth,
                        n = this.pendingSegment_.duration,
                        r = co.estimateSegmentRequestTime(n, i, this.playlist_, e.bytesReceived),
                        s = function(e, t, i = 1) {
                            return ((e.length ? e.end(e.length - 1) : 0) - t) / i
                        }(this.buffered_(), t, this.vhs_.tech_.playbackRate()) - 1;
                    if (r <= s) return;
                    const a = function(e) {
                        const {
                            main: t,
                            currentTime: i,
                            bandwidth: n,
                            duration: r,
                            segmentDuration: s,
                            timeUntilRebuffer: a,
                            currentTimeline: o,
                            syncController: l
                        } = e, h = t.playlists.filter((e => !co.isIncompatible(e)));
                        let c = h.filter(co.isEnabled);
                        c.length || (c = h.filter((e => !co.isDisabled(e))));
                        const u = c.filter(co.hasAttribute.bind(null, "BANDWIDTH")).map((e => {
                                const t = l.getSyncPoint(e, r, o, i) ? 1 : 2;
                                return {
                                    playlist: e,
                                    rebufferingImpact: co.estimateSegmentRequestTime(s, n, e) * t - a
                                }
                            })),
                            d = u.filter((e => e.rebufferingImpact <= 0));
                        return Ll(d, ((e, t) => Il(t.playlist, e.playlist))), d.length ? d[0] : (Ll(u, ((e, t) => e.rebufferingImpact - t.rebufferingImpact)), u[0] || null)
                    }({
                        main: this.vhs_.playlists.main,
                        currentTime: t,
                        bandwidth: i,
                        duration: this.duration_(),
                        segmentDuration: n,
                        timeUntilRebuffer: s,
                        currentTimeline: this.currentTimeline_,
                        syncController: this.syncController_
                    });
                    if (!a) return;
                    const o = r - s - a.rebufferingImpact;
                    let l = .5;
                    s <= Ba && (l = 1), !a.playlist || a.playlist.uri === this.playlist_.uri || o < l || (this.bandwidth = a.playlist.attributes.BANDWIDTH * qo.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort"))
                }
                handleAbort_(e) {
                    this.logger_(`Aborting ${Ul(e)}`), this.mediaRequestsAborted += 1
                }
                handleProgress_(e, t) {
                    this.earlyAbortWhenNeeded_(t.stats), this.checkForAbort_(t.requestId) || this.trigger("progress")
                }
                handleTrackInfo_(e, t) {
                    this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId) || this.checkForIllegalMediaSwitch(t) || (t = t || {}, function(e, t) {
                        if (!e && !t || !e && t || e && !t) return !1;
                        if (e === t) return !0;
                        const i = Object.keys(e).sort(),
                            n = Object.keys(t).sort();
                        if (i.length !== n.length) return !1;
                        for (let r = 0; r < i.length; r++) {
                            const s = i[r];
                            if (s !== n[r]) return !1;
                            if (e[s] !== t[s]) return !1
                        }
                        return !0
                    }(this.currentMediaInfo_, t) || (this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    }, this.startingMediaInfo_ = t, this.currentMediaInfo_ = t, this.logger_("trackinfo update", t), this.trigger("trackinfo")), this.checkForAbort_(e.requestId) || (this.pendingSegment_.trackInfo = t, this.hasEnoughInfoToAppend_() && this.processCallQueue_()))
                }
                handleTimingInfo_(e, t, i, n) {
                    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return;
                    const r = this.pendingSegment_,
                        s = Bl(t);
                    r[s] = r[s] || {}, r[s][i] = n, this.logger_(`timinginfo: ${t} - ${i} - ${n}`), this.hasEnoughInfoToAppend_() && this.processCallQueue_()
                }
                handleCaptions_(e, t) {
                    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return;
                    if (0 === t.length) return void this.logger_("SegmentLoader received no captions from a caption event");
                    if (!this.pendingSegment_.hasAppendedData_) return void this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, e, t));
                    const i = null === this.sourceUpdater_.videoTimestampOffset() ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(),
                        n = {};
                    t.forEach((e => {
                        n[e.stream] = n[e.stream] || {
                            startTime: 1 / 0,
                            captions: [],
                            endTime: 0
                        };
                        const t = n[e.stream];
                        t.startTime = Math.min(t.startTime, e.startTime + i), t.endTime = Math.max(t.endTime, e.endTime + i), t.captions.push(e)
                    })), Object.keys(n).forEach((e => {
                        const {
                            startTime: t,
                            endTime: s,
                            captions: a
                        } = n[e], o = this.inbandTextTracks_;
                        this.logger_(`adding cues from ${t} -> ${s} for ${e}`),
                            function(e, t, i) {
                                if (!e[i]) {
                                    t.trigger({
                                        type: "usage",
                                        name: "vhs-608"
                                    });
                                    let n = i;
                                    /^cc708_/.test(i) && (n = "SERVICE" + i.split("_")[1]);
                                    const r = t.textTracks().getTrackById(n);
                                    if (r) e[i] = r;
                                    else {
                                        let r = i,
                                            s = i,
                                            a = !1;
                                        const o = (t.options_.vhs && t.options_.vhs.captionServices || {})[n];
                                        o && (r = o.label, s = o.language, a = o.default), e[i] = t.addRemoteTextTrack({
                                            kind: "captions",
                                            id: n,
                                            default: a,
                                            label: r,
                                            language: s
                                        }, !1).track
                                    }
                                }
                            }(o, this.vhs_.tech_, e), Dl(t, s, o[e]),
                            function({
                                inbandTextTracks: e,
                                captionArray: t,
                                timestampOffset: i
                            }) {
                                if (!t) return;
                                const n = r().WebKitDataCue || r().VTTCue;
                                t.forEach((t => {
                                    const r = t.stream;
                                    e[r].addCue(new n(t.startTime + i, t.endTime + i, t.text))
                                }))
                            }({
                                captionArray: a,
                                inbandTextTracks: o,
                                timestampOffset: i
                            })
                    })), this.transmuxer_ && this.transmuxer_.postMessage({
                        action: "clearParsedMp4Captions"
                    })
                }
                handleId3_(e, t, i) {
                    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return;
                    if (!this.pendingSegment_.hasAppendedData_) return void this.metadataQueue_.id3.push(this.handleId3_.bind(this, e, t, i));
                    const n = null === this.sourceUpdater_.videoTimestampOffset() ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
                    ((e, t, i) => {
                        e.metadataTrack_ || (e.metadataTrack_ = i.addRemoteTextTrack({
                            kind: "metadata",
                            label: "Timed Metadata"
                        }, !1).track, e.metadataTrack_.inBandMetadataTrackDispatchType = t)
                    })(this.inbandTextTracks_, i, this.vhs_.tech_), kl({
                        inbandTextTracks: this.inbandTextTracks_,
                        metadataArray: t,
                        timestampOffset: n,
                        videoDuration: this.duration_()
                    })
                }
                processMetadataQueue_() {
                    this.metadataQueue_.id3.forEach((e => e())), this.metadataQueue_.caption.forEach((e => e())), this.metadataQueue_.id3 = [], this.metadataQueue_.caption = []
                }
                processCallQueue_() {
                    const e = this.callQueue_;
                    this.callQueue_ = [], e.forEach((e => e()))
                }
                processLoadQueue_() {
                    const e = this.loadQueue_;
                    this.loadQueue_ = [], e.forEach((e => e()))
                }
                hasEnoughInfoToLoad_() {
                    if ("audio" !== this.loaderType_) return !0;
                    const e = this.pendingSegment_;
                    return !!e && (!this.getCurrentMediaInfo_() || !Fl({
                        timelineChangeController: this.timelineChangeController_,
                        currentTimeline: this.currentTimeline_,
                        segmentTimeline: e.timeline,
                        loaderType: this.loaderType_,
                        audioDisabled: this.audioDisabled_
                    }))
                }
                getCurrentMediaInfo_(e = this.pendingSegment_) {
                    return e && e.trackInfo || this.currentMediaInfo_
                }
                getMediaInfo_(e = this.pendingSegment_) {
                    return this.getCurrentMediaInfo_(e) || this.startingMediaInfo_
                }
                hasEnoughInfoToAppend_() {
                    if (!this.sourceUpdater_.ready()) return !1;
                    if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) return !1;
                    const e = this.pendingSegment_,
                        t = this.getCurrentMediaInfo_();
                    if (!e || !t) return !1;
                    const {
                        hasAudio: i,
                        hasVideo: n,
                        isMuxed: r
                    } = t;
                    return !(n && !e.videoTimingInfo) && (!(i && !this.audioDisabled_ && !r && !e.audioTimingInfo) && !Fl({
                        timelineChangeController: this.timelineChangeController_,
                        currentTimeline: this.currentTimeline_,
                        segmentTimeline: e.timeline,
                        loaderType: this.loaderType_,
                        audioDisabled: this.audioDisabled_
                    }))
                }
                handleData_(e, t) {
                    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId)) return;
                    if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) return void this.callQueue_.push(this.handleData_.bind(this, e, t));
                    const i = this.pendingSegment_;
                    if (this.setTimeMapping_(i.timeline), this.updateMediaSecondsLoaded_(i.part || i.segment), "closed" !== this.mediaSource_.readyState) {
                        if (e.map && (e.map = this.initSegmentForMap(e.map, !0), i.segment.map = e.map), e.key && this.segmentKey(e.key, !0), i.isFmp4 = e.isFmp4, i.timingInfo = i.timingInfo || {}, i.isFmp4) this.trigger("fmp4"), i.timingInfo.start = i[Bl(t.type)].start;
                        else {
                            const e = this.getCurrentMediaInfo_(),
                                t = "main" === this.loaderType_ && e && e.hasVideo;
                            let n;
                            t && (n = i.videoTimingInfo.start), i.timingInfo.start = this.trueSegmentStart_({
                                currentStart: i.timingInfo.start,
                                playlist: i.playlist,
                                mediaIndex: i.mediaIndex,
                                currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
                                useVideoTimingInfo: t,
                                firstVideoFrameTimeForData: n,
                                videoTimingInfo: i.videoTimingInfo,
                                audioTimingInfo: i.audioTimingInfo
                            })
                        }
                        if (this.updateAppendInitSegmentStatus(i, t.type), this.updateSourceBufferTimestampOffset_(i), i.isSyncRequest) {
                            this.updateTimingInfoEnd_(i), this.syncController_.saveSegmentTimingInfo({
                                segmentInfo: i,
                                shouldSaveTimelineMapping: "main" === this.loaderType_
                            });
                            const e = this.chooseNextRequest_();
                            if (e.mediaIndex !== i.mediaIndex || e.partIndex !== i.partIndex) return void this.logger_("sync segment was incorrect, not appending");
                            this.logger_("sync segment was correct, appending")
                        }
                        i.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(i, t)
                    }
                }
                updateAppendInitSegmentStatus(e, t) {
                    "main" !== this.loaderType_ || "number" != typeof e.timestampOffset || e.changedTimestampOffset || (this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    }), this.playlistOfLastInitSegment_[t] !== e.playlist && (this.appendInitSegment_[t] = !0)
                }
                getInitSegmentAndUpdateState_({
                    type: e,
                    initSegment: t,
                    map: i,
                    playlist: n
                }) {
                    if (i) {
                        const e = ko(i);
                        if (this.activeInitSegmentId_ === e) return null;
                        t = this.initSegmentForMap(i, !0).bytes, this.activeInitSegmentId_ = e
                    }
                    return t && this.appendInitSegment_[e] ? (this.playlistOfLastInitSegment_[e] = n, this.appendInitSegment_[e] = !1, this.activeInitSegmentId_ = null, t) : null
                }
                handleQuotaExceededError_({
                    segmentInfo: e,
                    type: t,
                    bytes: i
                }, n) {
                    const s = this.sourceUpdater_.audioBuffered(),
                        a = this.sourceUpdater_.videoBuffered();
                    s.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + Wa(s).join(", ")), a.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + Wa(a).join(", "));
                    const o = s.length ? s.start(0) : 0,
                        l = s.length ? s.end(s.length - 1) : 0,
                        h = a.length ? a.start(0) : 0,
                        c = a.length ? a.end(a.length - 1) : 0;
                    if (l - o <= 1 && c - h <= 1) return this.logger_(`On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: ${i.byteLength}, audio buffer: ${Wa(s).join(", ")}, video buffer: ${Wa(a).join(", ")}, `), this.error({
                        message: "Quota exceeded error with append of a single segment of content",
                        excludeUntil: 1 / 0
                    }), void this.trigger("error");
                    this.waitingOnRemove_ = !0, this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
                        segmentInfo: e,
                        type: t,
                        bytes: i
                    }));
                    const u = this.currentTime_() - 1;
                    this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${u}`), this.remove(0, u, (() => {
                        this.logger_("On QUOTA_EXCEEDED_ERR, retrying append in 1s"), this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = r().setTimeout((() => {
                            this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), this.quotaExceededErrorRetryTimeout_ = null, this.processCallQueue_()
                        }), 1e3)
                    }), !0)
                }
                handleAppendError_({
                    segmentInfo: e,
                    type: t,
                    bytes: i
                }, n) {
                    n && (22 !== n.code ? (this.logger_("Received non QUOTA_EXCEEDED_ERR on append", n), this.error(`${t} append of ${i.length}b failed for segment #${e.mediaIndex} in playlist ${e.playlist.id}`), this.trigger("appenderror")) : this.handleQuotaExceededError_({
                        segmentInfo: e,
                        type: t,
                        bytes: i
                    }))
                }
                appendToSourceBuffer_({
                    segmentInfo: e,
                    type: t,
                    initSegment: i,
                    data: n,
                    bytes: r
                }) {
                    if (!r) {
                        const e = [n];
                        let t = n.byteLength;
                        i && (e.unshift(i), t += i.byteLength), r = (e => {
                            let t, i = 0;
                            return e.bytes && (t = new Uint8Array(e.bytes), e.segments.forEach((e => {
                                t.set(e, i), i += e.byteLength
                            }))), t
                        })({
                            bytes: t,
                            segments: e
                        })
                    }
                    this.sourceUpdater_.appendBuffer({
                        segmentInfo: e,
                        type: t,
                        bytes: r
                    }, this.handleAppendError_.bind(this, {
                        segmentInfo: e,
                        type: t,
                        bytes: r
                    }))
                }
                handleSegmentTimingInfo_(e, t, i) {
                    if (!this.pendingSegment_ || t !== this.pendingSegment_.requestId) return;
                    const n = this.pendingSegment_.segment,
                        r = `${e}TimingInfo`;
                    n[r] || (n[r] = {}), n[r].transmuxerPrependedSeconds = i.prependedContentDuration || 0, n[r].transmuxedPresentationStart = i.start.presentation, n[r].transmuxedDecodeStart = i.start.decode, n[r].transmuxedPresentationEnd = i.end.presentation, n[r].transmuxedDecodeEnd = i.end.decode, n[r].baseMediaDecodeTime = i.baseMediaDecodeTime
                }
                appendData_(e, t) {
                    const {
                        type: i,
                        data: n
                    } = t;
                    if (!n || !n.byteLength) return;
                    if ("audio" === i && this.audioDisabled_) return;
                    const r = this.getInitSegmentAndUpdateState_({
                        type: i,
                        initSegment: t.initSegment,
                        playlist: e.playlist,
                        map: e.isFmp4 ? e.segment.map : null
                    });
                    this.appendToSourceBuffer_({
                        segmentInfo: e,
                        type: i,
                        initSegment: r,
                        data: n
                    })
                }
                loadSegment_(e) {
                    this.state = "WAITING", this.pendingSegment_ = e, this.trimBackBuffer_(e), "number" == typeof e.timestampOffset && this.transmuxer_ && this.transmuxer_.postMessage({
                        action: "clearAllMp4Captions"
                    }), this.hasEnoughInfoToLoad_() ? this.updateTransmuxerAndRequestSegment_(e) : this.loadQueue_.push((() => {
                        const t = v({}, e, {
                            forceTimestampOffset: !0
                        });
                        v(e, this.generateSegmentInfo_(t)), this.isPendingTimestampOffset_ = !1, this.updateTransmuxerAndRequestSegment_(e)
                    }))
                }
                updateTransmuxerAndRequestSegment_(e) {
                    this.shouldUpdateTransmuxerTimestampOffset_(e.timestampOffset) && (this.gopBuffer_.length = 0, e.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({
                        action: "reset"
                    }), this.transmuxer_.postMessage({
                        action: "setTimestampOffset",
                        timestampOffset: e.timestampOffset
                    }));
                    const t = this.createSimplifiedSegmentObj_(e),
                        i = this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex),
                        n = null !== this.mediaIndex,
                        r = e.timeline !== this.currentTimeline_ && e.timeline > 0,
                        s = i || n && r;
                    this.logger_(`Requesting ${Ul(e)}`), t.map && !t.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = {
                        video: !0,
                        audio: !0
                    }), e.abortRequests = bl({
                        xhr: this.vhs_.xhr,
                        xhrOptions: this.xhrOptions_,
                        decryptionWorker: this.decrypter_,
                        segment: t,
                        abortFn: this.handleAbort_.bind(this, e),
                        progressFn: this.handleProgress_.bind(this),
                        trackInfoFn: this.handleTrackInfo_.bind(this),
                        timingInfoFn: this.handleTimingInfo_.bind(this),
                        videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", e.requestId),
                        audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", e.requestId),
                        captionsFn: this.handleCaptions_.bind(this),
                        isEndOfTimeline: s,
                        endedTimelineFn: () => {
                            this.logger_("received endedtimeline callback")
                        },
                        id3Fn: this.handleId3_.bind(this),
                        dataFn: this.handleData_.bind(this),
                        doneFn: this.segmentRequestFinished_.bind(this),
                        onTransmuxerLog: ({
                            message: t,
                            level: i,
                            stream: n
                        }) => {
                            this.logger_(`${Ul(e)} logged from transmuxer stream ${n} as a ${i}: ${t}`)
                        }
                    })
                }
                trimBackBuffer_(e) {
                    const t = ((e, t, i) => {
                        let n = t - qo.BACK_BUFFER_LENGTH;
                        e.length && (n = Math.max(n, e.start(0)));
                        const r = t - i;
                        return Math.min(r, n)
                    })(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
                    t > 0 && this.remove(0, t)
                }
                createSimplifiedSegmentObj_(e) {
                    const t = e.segment,
                        i = e.part,
                        n = {
                            resolvedUri: i ? i.resolvedUri : t.resolvedUri,
                            byterange: i ? i.byterange : t.byterange,
                            requestId: e.requestId,
                            transmuxer: e.transmuxer,
                            audioAppendStart: e.audioAppendStart,
                            gopsToAlignWith: e.gopsToAlignWith,
                            part: e.part
                        },
                        r = e.playlist.segments[e.mediaIndex - 1];
                    if (r && r.timeline === t.timeline && (r.videoTimingInfo ? n.baseStartTime = r.videoTimingInfo.transmuxedDecodeEnd : r.audioTimingInfo && (n.baseStartTime = r.audioTimingInfo.transmuxedDecodeEnd)), t.key) {
                        const i = t.key.iv || new Uint32Array([0, 0, 0, e.mediaIndex + e.playlist.mediaSequence]);
                        n.key = this.segmentKey(t.key), n.key.iv = i
                    }
                    return t.map && (n.map = this.initSegmentForMap(t.map)), n
                }
                saveTransferStats_(e) {
                    this.mediaRequests += 1, e && (this.mediaBytesTransferred += e.bytesReceived, this.mediaTransferDuration += e.roundTripTime)
                }
                saveBandwidthRelatedStats_(e, t) {
                    this.pendingSegment_.byteLength = t.bytesReceived, e < Nl ? this.logger_(`Ignoring segment's bandwidth because its duration of ${e} is less than the min to record 0.016666666666666666`) : (this.bandwidth = t.bandwidth, this.roundTrip = t.roundTripTime)
                }
                handleTimeout_() {
                    this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate"), this.trigger("timeout")
                }
                segmentRequestFinished_(e, t, i) {
                    if (this.callQueue_.length) return void this.callQueue_.push(this.segmentRequestFinished_.bind(this, e, t, i));
                    if (this.saveTransferStats_(t.stats), !this.pendingSegment_) return;
                    if (t.requestId !== this.pendingSegment_.requestId) return;
                    if (e) {
                        if (this.pendingSegment_ = null, this.state = "READY", e.code === hl) return;
                        return this.pause(), e.code === ll ? void this.handleTimeout_() : (this.mediaRequestsErrored += 1, this.error(e), void this.trigger("error"))
                    }
                    const n = this.pendingSegment_;
                    this.saveBandwidthRelatedStats_(n.duration, t.stats), n.endOfAllRequests = t.endOfAllRequests, i.gopInfo && (this.gopBuffer_ = ((e, t, i) => {
                        if (!t.length) return e;
                        if (i) return t.slice();
                        const n = t[0].pts;
                        let r = 0;
                        for (; r < e.length && !(e[r].pts >= n); r++);
                        return e.slice(0, r).concat(t)
                    })(this.gopBuffer_, i.gopInfo, this.safeAppend_)), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(n)
                }
                setTimeMapping_(e) {
                    const t = this.syncController_.mappingForTimeline(e);
                    null !== t && (this.timeMapping_ = t)
                }
                updateMediaSecondsLoaded_(e) {
                    "number" == typeof e.start && "number" == typeof e.end ? this.mediaSecondsLoaded += e.end - e.start : this.mediaSecondsLoaded += e.duration
                }
                shouldUpdateTransmuxerTimestampOffset_(e) {
                    return null !== e && ("main" === this.loaderType_ && e !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && e !== this.sourceUpdater_.audioTimestampOffset())
                }
                trueSegmentStart_({
                    currentStart: e,
                    playlist: t,
                    mediaIndex: i,
                    firstVideoFrameTimeForData: n,
                    currentVideoTimestampOffset: r,
                    useVideoTimingInfo: s,
                    videoTimingInfo: a,
                    audioTimingInfo: o
                }) {
                    if (void 0 !== e) return e;
                    if (!s) return o.start;
                    const l = t.segments[i - 1];
                    return 0 !== i && l && void 0 !== l.start && l.end === n + r ? a.start : n
                }
                waitForAppendsToComplete_(e) {
                    const t = this.getCurrentMediaInfo_(e);
                    if (!t) return this.error({
                        message: "No starting media returned, likely due to an unsupported media format.",
                        playlistExclusionDuration: 1 / 0
                    }), void this.trigger("error");
                    const {
                        hasAudio: i,
                        hasVideo: n,
                        isMuxed: r
                    } = t, s = "main" === this.loaderType_ && n, a = !this.audioDisabled_ && i && !r;
                    if (e.waitingOnAppends = 0, !e.hasAppendedData_) return e.timingInfo || "number" != typeof e.timestampOffset || (this.isPendingTimestampOffset_ = !0), e.timingInfo = {
                        start: 0
                    }, e.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(e), this.processMetadataQueue_()), void this.checkAppendsDone_(e);
                    s && e.waitingOnAppends++, a && e.waitingOnAppends++, s && this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, e)), a && this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, e))
                }
                checkAppendsDone_(e) {
                    this.checkForAbort_(e.requestId) || (e.waitingOnAppends--, 0 === e.waitingOnAppends && this.handleAppendsDone_())
                }
                checkForIllegalMediaSwitch(e) {
                    const t = ((e, t, i) => "main" === e && t && i ? i.hasAudio || i.hasVideo ? t.hasVideo && !i.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !t.hasVideo && i.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null : "Neither audio nor video found in segment." : null)(this.loaderType_, this.getCurrentMediaInfo_(), e);
                    return !!t && (this.error({
                        message: t,
                        playlistExclusionDuration: 1 / 0
                    }), this.trigger("error"), !0)
                }
                updateSourceBufferTimestampOffset_(e) {
                    if (null === e.timestampOffset || "number" != typeof e.timingInfo.start || e.changedTimestampOffset || "main" !== this.loaderType_) return;
                    let t = !1;
                    e.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
                        videoTimingInfo: e.segment.videoTimingInfo,
                        audioTimingInfo: e.segment.audioTimingInfo,
                        timingInfo: e.timingInfo
                    }), e.changedTimestampOffset = !0, e.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(e.timestampOffset), t = !0), e.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(e.timestampOffset), t = !0), t && this.trigger("timestampoffset")
                }
                getSegmentStartTimeForTimestampOffsetCalculation_({
                    videoTimingInfo: e,
                    audioTimingInfo: t,
                    timingInfo: i
                }) {
                    return this.useDtsForTimestampOffset_ ? e && "number" == typeof e.transmuxedDecodeStart ? e.transmuxedDecodeStart : t && "number" == typeof t.transmuxedDecodeStart ? t.transmuxedDecodeStart : i.start : i.start
                }
                updateTimingInfoEnd_(e) {
                    e.timingInfo = e.timingInfo || {};
                    const t = this.getMediaInfo_(),
                        i = "main" === this.loaderType_ && t && t.hasVideo && e.videoTimingInfo ? e.videoTimingInfo : e.audioTimingInfo;
                    i && (e.timingInfo.end = "number" == typeof i.end ? i.end : i.start + e.duration)
                }
                handleAppendsDone_() {
                    if (this.pendingSegment_ && this.trigger("appendsdone"), !this.pendingSegment_) return this.state = "READY", void(this.paused() || this.monitorBuffer_());
                    const e = this.pendingSegment_;
                    this.updateTimingInfoEnd_(e), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({
                        segmentInfo: e,
                        shouldSaveTimelineMapping: "main" === this.loaderType_
                    });
                    const t = zl(e, this.sourceType_);
                    if (t && ("warn" === t.severity ? Ca.log.warn(t.message) : this.logger_(t.message)), this.recordThroughput_(e), this.pendingSegment_ = null, this.state = "READY", e.isSyncRequest && (this.trigger("syncinfoupdate"), !e.hasAppendedData_)) return void this.logger_(`Throwing away un-appended sync request ${Ul(e)}`);
                    this.logger_(`Appended ${Ul(e)}`), this.addSegmentMetadataCue_(e), this.fetchAtBuffer_ = !0, this.currentTimeline_ !== e.timeline && (this.timelineChangeController_.lastTimelineChange({
                        type: this.loaderType_,
                        from: this.currentTimeline_,
                        to: e.timeline
                    }), "main" !== this.loaderType_ || this.audioDisabled_ || this.timelineChangeController_.lastTimelineChange({
                        type: "audio",
                        from: this.currentTimeline_,
                        to: e.timeline
                    })), this.currentTimeline_ = e.timeline, this.trigger("syncinfoupdate");
                    const i = e.segment,
                        n = e.part,
                        r = i.end && this.currentTime_() - i.end > 3 * e.playlist.targetDuration,
                        s = n && n.end && this.currentTime_() - n.end > 3 * e.playlist.partTargetDuration;
                    if (r || s) return this.logger_(`bad ${r?"segment":"part"} ${Ul(e)}`), void this.resetEverything();
                    null !== this.mediaIndex && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = e.mediaIndex, this.partIndex = e.partIndex, this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex) && this.endOfStream(), this.trigger("appended"), e.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_()
                }
                recordThroughput_(e) {
                    if (e.duration < Nl) return void this.logger_(`Ignoring segment's throughput because its duration of ${e.duration} is less than the min to record 0.016666666666666666`);
                    const t = this.throughput.rate,
                        i = Date.now() - e.endOfAllRequests + 1,
                        n = Math.floor(e.byteLength / i * 8 * 1e3);
                    this.throughput.rate += (n - t) / ++this.throughput.count
                }
                addSegmentMetadataCue_(e) {
                    if (!this.segmentMetadataTrack_) return;
                    const t = e.segment,
                        i = t.start,
                        n = t.end;
                    if (!Ol(i) || !Ol(n)) return;
                    Dl(i, n, this.segmentMetadataTrack_);
                    const s = r().WebKitDataCue || r().VTTCue,
                        a = {
                            custom: t.custom,
                            dateTimeObject: t.dateTimeObject,
                            dateTimeString: t.dateTimeString,
                            bandwidth: e.playlist.attributes.BANDWIDTH,
                            resolution: e.playlist.attributes.RESOLUTION,
                            codecs: e.playlist.attributes.CODECS,
                            byteLength: e.byteLength,
                            uri: e.uri,
                            timeline: e.timeline,
                            playlist: e.playlist.id,
                            start: i,
                            end: n
                        },
                        o = new s(i, n, JSON.stringify(a));
                    o.value = a, this.segmentMetadataTrack_.addCue(o)
                }
            }

            function Gl() {}
            const Wl = function(e) {
                    return "string" != typeof e ? e : e.replace(/./, (e => e.toUpperCase()))
                },
                jl = ["video", "audio"],
                ql = (e, t) => {
                    const i = t[`${e}Buffer`];
                    return i && i.updating || t.queuePending[e]
                },
                $l = (e, t) => {
                    if (0 === t.queue.length) return;
                    let i = 0,
                        n = t.queue[i];
                    if ("mediaSource" !== n.type) {
                        if ("mediaSource" !== e && t.ready() && "closed" !== t.mediaSource.readyState && !ql(e, t)) {
                            if (n.type !== e) {
                                if (i = ((e, t) => {
                                        for (let i = 0; i < t.length; i++) {
                                            const n = t[i];
                                            if ("mediaSource" === n.type) return null;
                                            if (n.type === e) return i
                                        }
                                        return null
                                    })(e, t.queue), null === i) return;
                                n = t.queue[i]
                            }
                            return t.queue.splice(i, 1), t.queuePending[e] = n, n.action(e, t), n.doneFn ? void 0 : (t.queuePending[e] = null, void $l(e, t))
                        }
                    } else t.updating() || "closed" === t.mediaSource.readyState || (t.queue.shift(), n.action(t), n.doneFn && n.doneFn(), $l("audio", t), $l("video", t))
                },
                Xl = (e, t) => {
                    const i = t[`${e}Buffer`],
                        n = Wl(e);
                    i && (i.removeEventListener("updateend", t[`on${n}UpdateEnd_`]), i.removeEventListener("error", t[`on${n}Error_`]), t.codecs[e] = null, t[`${e}Buffer`] = null)
                },
                Yl = (e, t) => e && t && -1 !== Array.prototype.indexOf.call(e.sourceBuffers, t),
                Kl = (e, t, i) => (n, r) => {
                    const s = r[`${n}Buffer`];
                    if (Yl(r.mediaSource, s)) {
                        r.logger_(`Appending segment ${t.mediaIndex}'s ${e.length} bytes to ${n}Buffer`);
                        try {
                            s.appendBuffer(e)
                        } catch (e) {
                            r.logger_(`Error with code ${e.code} ` + (22 === e.code ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${t.mediaIndex} to ${n}Buffer`), r.queuePending[n] = null, i(e)
                        }
                    }
                },
                Jl = (e, t) => (i, n) => {
                    const r = n[`${i}Buffer`];
                    if (Yl(n.mediaSource, r)) {
                        n.logger_(`Removing ${e} to ${t} from ${i}Buffer`);
                        try {
                            r.remove(e, t)
                        } catch (r) {
                            n.logger_(`Remove ${e} to ${t} from ${i}Buffer failed`)
                        }
                    }
                },
                Zl = e => (t, i) => {
                    const n = i[`${t}Buffer`];
                    Yl(i.mediaSource, n) && (i.logger_(`Setting ${t}timestampOffset to ${e}`), n.timestampOffset = e)
                },
                Ql = e => (t, i) => {
                    e()
                },
                eh = e => t => {
                    if ("open" === t.mediaSource.readyState) {
                        t.logger_(`Calling mediaSource endOfStream(${e||""})`);
                        try {
                            t.mediaSource.endOfStream(e)
                        } catch (e) {
                            Ca.log.warn("Failed to call media source endOfStream", e)
                        }
                    }
                },
                th = e => t => {
                    t.logger_(`Setting mediaSource duration to ${e}`);
                    try {
                        t.mediaSource.duration = e
                    } catch (e) {
                        Ca.log.warn("Failed to set media source duration", e)
                    }
                },
                ih = () => (e, t) => {
                    if ("open" !== t.mediaSource.readyState) return;
                    const i = t[`${e}Buffer`];
                    if (Yl(t.mediaSource, i)) {
                        t.logger_(`calling abort on ${e}Buffer`);
                        try {
                            i.abort()
                        } catch (t) {
                            Ca.log.warn(`Failed to abort on ${e}Buffer`, t)
                        }
                    }
                },
                nh = (e, t) => i => {
                    const n = Wl(e),
                        r = H(t);
                    i.logger_(`Adding ${e}Buffer with codec ${t} to mediaSource`);
                    const s = i.mediaSource.addSourceBuffer(r);
                    s.addEventListener("updateend", i[`on${n}UpdateEnd_`]), s.addEventListener("error", i[`on${n}Error_`]), i.codecs[e] = t, i[`${e}Buffer`] = s
                },
                rh = e => t => {
                    const i = t[`${e}Buffer`];
                    if (Xl(e, t), Yl(t.mediaSource, i)) {
                        t.logger_(`Removing ${e}Buffer with codec ${t.codecs[e]} from mediaSource`);
                        try {
                            t.mediaSource.removeSourceBuffer(i)
                        } catch (t) {
                            Ca.log.warn(`Failed to removeSourceBuffer ${e}Buffer`, t)
                        }
                    }
                },
                sh = e => (t, i) => {
                    const n = i[`${t}Buffer`],
                        r = H(e);
                    Yl(i.mediaSource, n) && i.codecs[t] !== e && (i.logger_(`changing ${t}Buffer codec from ${i.codecs[t]} to ${e}`), n.changeType(r), i.codecs[t] = e)
                },
                ah = ({
                    type: e,
                    sourceUpdater: t,
                    action: i,
                    doneFn: n,
                    name: r
                }) => {
                    t.queue.push({
                        type: e,
                        action: i,
                        doneFn: n,
                        name: r
                    }), $l(e, t)
                },
                oh = (e, t) => i => {
                    if (t.queuePending[e]) {
                        const i = t.queuePending[e].doneFn;
                        t.queuePending[e] = null, i && i(t[`${e}Error_`])
                    }
                    $l(e, t)
                };
            class lh extends Ca.EventTarget {
                constructor(e) {
                    super(), this.mediaSource = e, this.sourceopenListener_ = () => $l("mediaSource", this), this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_), this.logger_ = Oa("SourceUpdater"), this.audioTimestampOffset_ = 0, this.videoTimestampOffset_ = 0, this.queue = [], this.queuePending = {
                        audio: null,
                        video: null
                    }, this.delayedAudioAppendQueue_ = [], this.videoAppendQueued_ = !1, this.codecs = {}, this.onVideoUpdateEnd_ = oh("video", this), this.onAudioUpdateEnd_ = oh("audio", this), this.onVideoError_ = e => {
                        this.videoError_ = e
                    }, this.onAudioError_ = e => {
                        this.audioError_ = e
                    }, this.createdSourceBuffers_ = !1, this.initializedEme_ = !1, this.triggeredReady_ = !1
                }
                initializedEme() {
                    this.initializedEme_ = !0, this.triggerReady()
                }
                hasCreatedSourceBuffers() {
                    return this.createdSourceBuffers_
                }
                hasInitializedAnyEme() {
                    return this.initializedEme_
                }
                ready() {
                    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme()
                }
                createSourceBuffers(e) {
                    this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(e), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady())
                }
                triggerReady() {
                    this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready"))
                }
                addSourceBuffer(e, t) {
                    ah({
                        type: "mediaSource",
                        sourceUpdater: this,
                        action: nh(e, t),
                        name: "addSourceBuffer"
                    })
                }
                abort(e) {
                    ah({
                        type: e,
                        sourceUpdater: this,
                        action: ih(e),
                        name: "abort"
                    })
                }
                removeSourceBuffer(e) {
                    this.canRemoveSourceBuffer() ? ah({
                        type: "mediaSource",
                        sourceUpdater: this,
                        action: rh(e),
                        name: "removeSourceBuffer"
                    }) : Ca.log.error("removeSourceBuffer is not supported!")
                }
                canRemoveSourceBuffer() {
                    return !Ca.browser.IE_VERSION && !Ca.browser.IS_FIREFOX && r().MediaSource && r().MediaSource.prototype && "function" == typeof r().MediaSource.prototype.removeSourceBuffer
                }
                static canChangeType() {
                    return r().SourceBuffer && r().SourceBuffer.prototype && "function" == typeof r().SourceBuffer.prototype.changeType
                }
                canChangeType() {
                    return this.constructor.canChangeType()
                }
                changeType(e, t) {
                    this.canChangeType() ? ah({
                        type: e,
                        sourceUpdater: this,
                        action: sh(t),
                        name: "changeType"
                    }) : Ca.log.error("changeType is not supported!")
                }
                addOrChangeSourceBuffers(e) {
                    if (!e || "object" != typeof e || 0 === Object.keys(e).length) throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
                    Object.keys(e).forEach((t => {
                        const i = e[t];
                        if (!this.hasCreatedSourceBuffers()) return this.addSourceBuffer(t, i);
                        this.canChangeType() && this.changeType(t, i)
                    }))
                }
                appendBuffer(e, t) {
                    const {
                        segmentInfo: i,
                        type: n,
                        bytes: r
                    } = e;
                    if (this.processedAppend_ = !0, "audio" === n && this.videoBuffer && !this.videoAppendQueued_) return this.delayedAudioAppendQueue_.push([e, t]), void this.logger_(`delayed audio append of ${r.length} until video append`);
                    if (ah({
                            type: n,
                            sourceUpdater: this,
                            action: Kl(r, i || {
                                mediaIndex: -1
                            }, t),
                            doneFn: t,
                            name: "appendBuffer"
                        }), "video" === n) {
                        if (this.videoAppendQueued_ = !0, !this.delayedAudioAppendQueue_.length) return;
                        const e = this.delayedAudioAppendQueue_.slice();
                        this.logger_(`queuing delayed audio ${e.length} appendBuffers`), this.delayedAudioAppendQueue_.length = 0, e.forEach((e => {
                            this.appendBuffer.apply(this, e)
                        }))
                    }
                }
                audioBuffered() {
                    return Yl(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : Ua()
                }
                videoBuffered() {
                    return Yl(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : Ua()
                }
                buffered() {
                    const e = Yl(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null,
                        t = Yl(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
                    return t && !e ? this.audioBuffered() : e && !t ? this.videoBuffered() : function(e, t) {
                        let i = null,
                            n = null,
                            r = 0;
                        const s = [],
                            a = [];
                        if (!(e && e.length && t && t.length)) return Ua();
                        let o = e.length;
                        for (; o--;) s.push({
                            time: e.start(o),
                            type: "start"
                        }), s.push({
                            time: e.end(o),
                            type: "end"
                        });
                        for (o = t.length; o--;) s.push({
                            time: t.start(o),
                            type: "start"
                        }), s.push({
                            time: t.end(o),
                            type: "end"
                        });
                        for (s.sort((function(e, t) {
                                return e.time - t.time
                            })), o = 0; o < s.length; o++) "start" === s[o].type ? (r++, 2 === r && (i = s[o].time)) : "end" === s[o].type && (r--, 1 === r && (n = s[o].time)), null !== i && null !== n && (a.push([i, n]), i = null, n = null);
                        return Ua(a)
                    }(this.audioBuffered(), this.videoBuffered())
                }
                setDuration(e, t = Gl) {
                    ah({
                        type: "mediaSource",
                        sourceUpdater: this,
                        action: th(e),
                        name: "duration",
                        doneFn: t
                    })
                }
                endOfStream(e = null, t = Gl) {
                    "string" != typeof e && (e = void 0), ah({
                        type: "mediaSource",
                        sourceUpdater: this,
                        action: eh(e),
                        name: "endOfStream",
                        doneFn: t
                    })
                }
                removeAudio(e, t, i = Gl) {
                    this.audioBuffered().length && 0 !== this.audioBuffered().end(0) ? ah({
                        type: "audio",
                        sourceUpdater: this,
                        action: Jl(e, t),
                        doneFn: i,
                        name: "remove"
                    }) : i()
                }
                removeVideo(e, t, i = Gl) {
                    this.videoBuffered().length && 0 !== this.videoBuffered().end(0) ? ah({
                        type: "video",
                        sourceUpdater: this,
                        action: Jl(e, t),
                        doneFn: i,
                        name: "remove"
                    }) : i()
                }
                updating() {
                    return !(!ql("audio", this) && !ql("video", this))
                }
                audioTimestampOffset(e) {
                    return void 0 !== e && this.audioBuffer && this.audioTimestampOffset_ !== e && (ah({
                        type: "audio",
                        sourceUpdater: this,
                        action: Zl(e),
                        name: "timestampOffset"
                    }), this.audioTimestampOffset_ = e), this.audioTimestampOffset_
                }
                videoTimestampOffset(e) {
                    return void 0 !== e && this.videoBuffer && this.videoTimestampOffset !== e && (ah({
                        type: "video",
                        sourceUpdater: this,
                        action: Zl(e),
                        name: "timestampOffset"
                    }), this.videoTimestampOffset_ = e), this.videoTimestampOffset_
                }
                audioQueueCallback(e) {
                    this.audioBuffer && ah({
                        type: "audio",
                        sourceUpdater: this,
                        action: Ql(e),
                        name: "callback"
                    })
                }
                videoQueueCallback(e) {
                    this.videoBuffer && ah({
                        type: "video",
                        sourceUpdater: this,
                        action: Ql(e),
                        name: "callback"
                    })
                }
                dispose() {
                    this.trigger("dispose"), jl.forEach((e => {
                        this.abort(e), this.canRemoveSourceBuffer() ? this.removeSourceBuffer(e) : this[`${e}QueueCallback`]((() => Xl(e, this)))
                    })), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_), this.off()
                }
            }
            const hh = e => decodeURIComponent(escape(String.fromCharCode.apply(null, e))),
                ch = new Uint8Array("\n\n".split("").map((e => e.charCodeAt(0))));
            class uh extends Vl {
                constructor(e, t = {}) {
                    super(e, t), this.mediaSource_ = null, this.subtitlesTrack_ = null, this.loaderType_ = "subtitle", this.featuresNativeTextTracks_ = e.featuresNativeTextTracks, this.shouldSaveSegmentTimingInfo_ = !1
                }
                createTransmuxer_() {
                    return null
                }
                buffered_() {
                    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) return Ua();
                    const e = this.subtitlesTrack_.cues;
                    return Ua([
                        [e[0].startTime, e[e.length - 1].startTime]
                    ])
                }
                initSegmentForMap(e, t = !1) {
                    if (!e) return null;
                    const i = ko(e);
                    let n = this.initSegments_[i];
                    if (t && !n && e.bytes) {
                        const t = ch.byteLength + e.bytes.byteLength,
                            r = new Uint8Array(t);
                        r.set(e.bytes), r.set(ch, e.bytes.byteLength), this.initSegments_[i] = n = {
                            resolvedUri: e.resolvedUri,
                            byterange: e.byterange,
                            bytes: r
                        }
                    }
                    return n || e
                }
                couldBeginLoading_() {
                    return this.playlist_ && this.subtitlesTrack_ && !this.paused()
                }
                init_() {
                    return this.state = "READY", this.resetEverything(), this.monitorBuffer_()
                }
                track(e) {
                    return void 0 === e || (this.subtitlesTrack_ = e, "INIT" === this.state && this.couldBeginLoading_() && this.init_()), this.subtitlesTrack_
                }
                remove(e, t) {
                    Dl(e, t, this.subtitlesTrack_)
                }
                fillBuffer_() {
                    const e = this.chooseNextRequest_();
                    if (e) {
                        if (null === this.syncController_.timestampOffsetForTimeline(e.timeline)) {
                            const e = () => {
                                this.state = "READY", this.paused() || this.monitorBuffer_()
                            };
                            return this.syncController_.one("timestampoffset", e), void(this.state = "WAITING_ON_TIMELINE")
                        }
                        this.loadSegment_(e)
                    }
                }
                timestampOffsetForSegment_() {
                    return null
                }
                chooseNextRequest_() {
                    return this.skipEmptySegments_(super.chooseNextRequest_())
                }
                skipEmptySegments_(e) {
                    for (; e && e.segment.empty;) {
                        if (e.mediaIndex + 1 >= e.playlist.segments.length) {
                            e = null;
                            break
                        }
                        e = this.generateSegmentInfo_({
                            playlist: e.playlist,
                            mediaIndex: e.mediaIndex + 1,
                            startOfSegment: e.startOfSegment + e.duration,
                            isSyncRequest: e.isSyncRequest
                        })
                    }
                    return e
                }
                stopForError(e) {
                    this.error(e), this.state = "READY", this.pause(), this.trigger("error")
                }
                segmentRequestFinished_(e, t, i) {
                    if (!this.subtitlesTrack_) return void(this.state = "READY");
                    if (this.saveTransferStats_(t.stats), !this.pendingSegment_) return this.state = "READY", void(this.mediaRequestsAborted += 1);
                    if (e) return e.code === ll && this.handleTimeout_(), e.code === hl ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1, void this.stopForError(e);
                    const n = this.pendingSegment_;
                    this.saveBandwidthRelatedStats_(n.duration, t.stats), t.key && this.segmentKey(t.key, !0), this.state = "APPENDING", this.trigger("appending");
                    const s = n.segment;
                    if (s.map && (s.map.bytes = t.map.bytes), n.bytes = t.bytes, "function" != typeof r().WebVTT && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {
                        let n;
                        const r = () => {
                            this.subtitlesTrack_.tech_.off("vttjsloaded", n), this.stopForError({
                                message: "Error loading vtt.js"
                            })
                        };
                        return n = () => {
                            this.subtitlesTrack_.tech_.off("vttjserror", r), this.segmentRequestFinished_(e, t, i)
                        }, this.state = "WAITING_ON_VTTJS", this.subtitlesTrack_.tech_.one("vttjsloaded", n), void this.subtitlesTrack_.tech_.one("vttjserror", r)
                    }
                    s.requested = !0;
                    try {
                        this.parseVTTCues_(n)
                    } catch (e) {
                        return void this.stopForError({
                            message: e.message
                        })
                    }
                    if (this.updateTimeMapping_(n, this.syncController_.timelines[n.timeline], this.playlist_), n.cues.length ? n.timingInfo = {
                            start: n.cues[0].startTime,
                            end: n.cues[n.cues.length - 1].endTime
                        } : n.timingInfo = {
                            start: n.startOfSegment,
                            end: n.startOfSegment + n.duration
                        }, n.isSyncRequest) return this.trigger("syncinfoupdate"), this.pendingSegment_ = null, void(this.state = "READY");
                    n.byteLength = n.bytes.byteLength, this.mediaSecondsLoaded += s.duration, n.cues.forEach((e => {
                            this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new(r().VTTCue)(e.startTime, e.endTime, e.text) : e)
                        })),
                        function(e) {
                            const t = e.cues;
                            if (t)
                                for (let i = 0; i < t.length; i++) {
                                    const n = [];
                                    let r = 0;
                                    for (let e = 0; e < t.length; e++) t[i].startTime === t[e].startTime && t[i].endTime === t[e].endTime && t[i].text === t[e].text && (r++, r > 1 && n.push(t[e]));
                                    n.length && n.forEach((t => e.removeCue(t)))
                                }
                        }(this.subtitlesTrack_), this.handleAppendsDone_()
                }
                handleData_() {}
                updateTimingInfoEnd_() {}
                parseVTTCues_(e) {
                    let t, i = !1;
                    "function" == typeof r().TextDecoder ? t = new(r().TextDecoder)("utf8") : (t = r().WebVTT.StringDecoder(), i = !0);
                    const n = new(r().WebVTT.Parser)(r(), r().vttjs, t);
                    if (e.cues = [], e.timestampmap = {
                            MPEGTS: 0,
                            LOCAL: 0
                        }, n.oncue = e.cues.push.bind(e.cues), n.ontimestampmap = t => {
                            e.timestampmap = t
                        }, n.onparsingerror = e => {
                            Ca.log.warn("Error encountered when parsing cues: " + e.message)
                        }, e.segment.map) {
                        let t = e.segment.map.bytes;
                        i && (t = hh(t)), n.parse(t)
                    }
                    let s = e.bytes;
                    i && (s = hh(s)), n.parse(s), n.flush()
                }
                updateTimeMapping_(e, t, i) {
                    const n = e.segment;
                    if (!t) return;
                    if (!e.cues.length) return void(n.empty = !0);
                    const r = e.timestampmap,
                        s = r.MPEGTS / Mt.ONE_SECOND_IN_TS - r.LOCAL + t.mapping;
                    if (e.cues.forEach((e => {
                            e.startTime += s, e.endTime += s
                        })), !i.syncInfo) {
                        const t = e.cues[0].startTime,
                            r = e.cues[e.cues.length - 1].startTime;
                        i.syncInfo = {
                            mediaSequence: i.mediaSequence + e.mediaIndex,
                            time: Math.min(t, r - n.duration)
                        }
                    }
                }
            }
            const dh = function(e, t) {
                    const i = e.cues;
                    for (let e = 0; e < i.length; e++) {
                        const n = i[e];
                        if (t >= n.adStartTime && t <= n.adEndTime) return n
                    }
                    return null
                },
                ph = [{
                    name: "VOD",
                    run: (e, t, i, n, r) => {
                        if (i !== 1 / 0) {
                            return {
                                time: 0,
                                segmentIndex: 0,
                                partIndex: null
                            }
                        }
                        return null
                    }
                }, {
                    name: "ProgramDateTime",
                    run: (e, t, i, n, r) => {
                        if (!Object.keys(e.timelineToDatetimeMappings).length) return null;
                        let s = null,
                            a = null;
                        const o = Xa(t);
                        r = r || 0;
                        for (let i = 0; i < o.length; i++) {
                            const n = o[t.endList || 0 === r ? i : o.length - (i + 1)],
                                l = n.segment,
                                h = e.timelineToDatetimeMappings[l.timeline];
                            if (!h || !l.dateTimeObject) continue;
                            let c = l.dateTimeObject.getTime() / 1e3 + h;
                            if (l.parts && "number" == typeof n.partIndex)
                                for (let e = 0; e < n.partIndex; e++) c += l.parts[e].duration;
                            const u = Math.abs(r - c);
                            if (null !== a && (0 === u || a < u)) break;
                            a = u, s = {
                                time: c,
                                segmentIndex: n.segmentIndex,
                                partIndex: n.partIndex
                            }
                        }
                        return s
                    }
                }, {
                    name: "Segment",
                    run: (e, t, i, n, r) => {
                        let s = null,
                            a = null;
                        r = r || 0;
                        const o = Xa(t);
                        for (let e = 0; e < o.length; e++) {
                            const i = o[t.endList || 0 === r ? e : o.length - (e + 1)],
                                l = i.segment,
                                h = i.part && i.part.start || l && l.start;
                            if (l.timeline === n && void 0 !== h) {
                                const e = Math.abs(r - h);
                                if (null !== a && a < e) break;
                                (!s || null === a || a >= e) && (a = e, s = {
                                    time: h,
                                    segmentIndex: i.segmentIndex,
                                    partIndex: i.partIndex
                                })
                            }
                        }
                        return s
                    }
                }, {
                    name: "Discontinuity",
                    run: (e, t, i, n, r) => {
                        let s = null;
                        if (r = r || 0, t.discontinuityStarts && t.discontinuityStarts.length) {
                            let i = null;
                            for (let n = 0; n < t.discontinuityStarts.length; n++) {
                                const a = t.discontinuityStarts[n],
                                    o = t.discontinuitySequence + n + 1,
                                    l = e.discontinuities[o];
                                if (l) {
                                    const e = Math.abs(r - l.time);
                                    if (null !== i && i < e) break;
                                    (!s || null === i || i >= e) && (i = e, s = {
                                        time: l.time,
                                        segmentIndex: a,
                                        partIndex: null
                                    })
                                }
                            }
                        }
                        return s
                    }
                }, {
                    name: "Playlist",
                    run: (e, t, i, n, r) => {
                        if (t.syncInfo) {
                            return {
                                time: t.syncInfo.time,
                                segmentIndex: t.syncInfo.mediaSequence - t.mediaSequence,
                                partIndex: null
                            }
                        }
                        return null
                    }
                }];
            class fh extends Ca.EventTarget {
                constructor(e = {}) {
                    super(), this.timelines = [], this.discontinuities = [], this.timelineToDatetimeMappings = {}, this.logger_ = Oa("SyncController")
                }
                getSyncPoint(e, t, i, n) {
                    const r = this.runStrategies_(e, t, i, n);
                    return r.length ? this.selectSyncPoint_(r, {
                        key: "time",
                        value: n
                    }) : null
                }
                getExpiredTime(e, t) {
                    if (!e || !e.segments) return null;
                    const i = this.runStrategies_(e, t, e.discontinuitySequence, 0);
                    if (!i.length) return null;
                    const n = this.selectSyncPoint_(i, {
                        key: "segmentIndex",
                        value: 0
                    });
                    return n.segmentIndex > 0 && (n.time *= -1), Math.abs(n.time + eo({
                        defaultDuration: e.targetDuration,
                        durationList: e.segments,
                        startIndex: n.segmentIndex,
                        endIndex: 0
                    }))
                }
                runStrategies_(e, t, i, n) {
                    const r = [];
                    for (let s = 0; s < ph.length; s++) {
                        const a = ph[s],
                            o = a.run(this, e, t, i, n);
                        o && (o.strategy = a.name, r.push({
                            strategy: a.name,
                            syncPoint: o
                        }))
                    }
                    return r
                }
                selectSyncPoint_(e, t) {
                    let i = e[0].syncPoint,
                        n = Math.abs(e[0].syncPoint[t.key] - t.value),
                        r = e[0].strategy;
                    for (let s = 1; s < e.length; s++) {
                        const a = Math.abs(e[s].syncPoint[t.key] - t.value);
                        a < n && (n = a, i = e[s].syncPoint, r = e[s].strategy)
                    }
                    return this.logger_(`syncPoint for [${t.key}: ${t.value}] chosen with strategy [${r}]: [time:${i.time}, segmentIndex:${i.segmentIndex}` + ("number" == typeof i.partIndex ? `,partIndex:${i.partIndex}` : "") + "]"), i
                }
                saveExpiredSegmentInfo(e, t) {
                    const i = t.mediaSequence - e.mediaSequence;
                    if (i > 86400) Ca.log.warn(`Not saving expired segment info. Media sequence gap ${i} is too large.`);
                    else
                        for (let n = i - 1; n >= 0; n--) {
                            const i = e.segments[n];
                            if (i && void 0 !== i.start) {
                                t.syncInfo = {
                                    mediaSequence: e.mediaSequence + n,
                                    time: i.start
                                }, this.logger_(`playlist refresh sync: [time:${t.syncInfo.time}, mediaSequence: ${t.syncInfo.mediaSequence}]`), this.trigger("syncinfoupdate");
                                break
                            }
                        }
                }
                setDateTimeMappingForStart(e) {
                    if (this.timelineToDatetimeMappings = {}, e.segments && e.segments.length && e.segments[0].dateTimeObject) {
                        const t = e.segments[0],
                            i = t.dateTimeObject.getTime() / 1e3;
                        this.timelineToDatetimeMappings[t.timeline] = -i
                    }
                }
                saveSegmentTimingInfo({
                    segmentInfo: e,
                    shouldSaveTimelineMapping: t
                }) {
                    const i = this.calculateSegmentTimeMapping_(e, e.timingInfo, t),
                        n = e.segment;
                    i && (this.saveDiscontinuitySyncInfo_(e), e.playlist.syncInfo || (e.playlist.syncInfo = {
                        mediaSequence: e.playlist.mediaSequence + e.mediaIndex,
                        time: n.start
                    }));
                    const r = n.dateTimeObject;
                    n.discontinuity && t && r && (this.timelineToDatetimeMappings[n.timeline] = -r.getTime() / 1e3)
                }
                timestampOffsetForTimeline(e) {
                    return void 0 === this.timelines[e] ? null : this.timelines[e].time
                }
                mappingForTimeline(e) {
                    return void 0 === this.timelines[e] ? null : this.timelines[e].mapping
                }
                calculateSegmentTimeMapping_(e, t, i) {
                    const n = e.segment,
                        r = e.part;
                    let s, a, o = this.timelines[e.timeline];
                    if ("number" == typeof e.timestampOffset) o = {
                        time: e.startOfSegment,
                        mapping: e.startOfSegment - t.start
                    }, i && (this.timelines[e.timeline] = o, this.trigger("timestampoffset"), this.logger_(`time mapping for timeline ${e.timeline}: [time: ${o.time}] [mapping: ${o.mapping}]`)), s = e.startOfSegment, a = t.end + o.mapping;
                    else {
                        if (!o) return !1;
                        s = t.start + o.mapping, a = t.end + o.mapping
                    }
                    return r && (r.start = s, r.end = a), (!n.start || s < n.start) && (n.start = s), n.end = a, !0
                }
                saveDiscontinuitySyncInfo_(e) {
                    const t = e.playlist,
                        i = e.segment;
                    if (i.discontinuity) this.discontinuities[i.timeline] = {
                        time: i.start,
                        accuracy: 0
                    };
                    else if (t.discontinuityStarts && t.discontinuityStarts.length)
                        for (let n = 0; n < t.discontinuityStarts.length; n++) {
                            const r = t.discontinuityStarts[n],
                                s = t.discontinuitySequence + n + 1,
                                a = r - e.mediaIndex,
                                o = Math.abs(a);
                            if (!this.discontinuities[s] || this.discontinuities[s].accuracy > o) {
                                let n;
                                n = a < 0 ? i.start - eo({
                                    defaultDuration: t.targetDuration,
                                    durationList: t.segments,
                                    startIndex: e.mediaIndex,
                                    endIndex: r
                                }) : i.end + eo({
                                    defaultDuration: t.targetDuration,
                                    durationList: t.segments,
                                    startIndex: e.mediaIndex + 1,
                                    endIndex: r
                                }), this.discontinuities[s] = {
                                    time: n,
                                    accuracy: o
                                }
                            }
                        }
                }
                dispose() {
                    this.trigger("dispose"), this.off()
                }
            }
            class mh extends Ca.EventTarget {
                constructor() {
                    super(), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}
                }
                clearPendingTimelineChange(e) {
                    this.pendingTimelineChanges_[e] = null, this.trigger("pendingtimelinechange")
                }
                pendingTimelineChange({
                    type: e,
                    from: t,
                    to: i
                }) {
                    return "number" == typeof t && "number" == typeof i && (this.pendingTimelineChanges_[e] = {
                        type: e,
                        from: t,
                        to: i
                    }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[e]
                }
                lastTimelineChange({
                    type: e,
                    from: t,
                    to: i
                }) {
                    return "number" == typeof t && "number" == typeof i && (this.lastTimelineChanges_[e] = {
                        type: e,
                        from: t,
                        to: i
                    }, delete this.pendingTimelineChanges_[e], this.trigger("timelinechange")), this.lastTimelineChanges_[e]
                }
                dispose() {
                    this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off()
                }
            }
            const gh = Yo(Ko((function() {
                var e = function() {
                    function e() {
                        this.listeners = {}
                    }
                    var t = e.prototype;
                    return t.on = function(e, t) {
                        this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t)
                    }, t.off = function(e, t) {
                        if (!this.listeners[e]) return !1;
                        var i = this.listeners[e].indexOf(t);
                        return this.listeners[e] = this.listeners[e].slice(0), this.listeners[e].splice(i, 1), i > -1
                    }, t.trigger = function(e) {
                        var t = this.listeners[e];
                        if (t)
                            if (2 === arguments.length)
                                for (var i = t.length, n = 0; n < i; ++n) t[n].call(this, arguments[1]);
                            else
                                for (var r = Array.prototype.slice.call(arguments, 1), s = t.length, a = 0; a < s; ++a) t[a].apply(this, r)
                    }, t.dispose = function() {
                        this.listeners = {}
                    }, t.pipe = function(e) {
                        this.on("data", (function(t) {
                            e.push(t)
                        }))
                    }, e
                }();
                let t = null;
                class n {
                    constructor(e) {
                        let i, n, r;
                        t || (t = function() {
                            const e = [
                                    [
                                        [],
                                        [],
                                        [],
                                        [],
                                        []
                                    ],
                                    [
                                        [],
                                        [],
                                        [],
                                        [],
                                        []
                                    ]
                                ],
                                t = e[0],
                                i = e[1],
                                n = t[4],
                                r = i[4];
                            let s, a, o;
                            const l = [],
                                h = [];
                            let c, u, d, p, f, m;
                            for (s = 0; s < 256; s++) h[(l[s] = s << 1 ^ 283 * (s >> 7)) ^ s] = s;
                            for (a = o = 0; !n[a]; a ^= c || 1, o = h[o] || 1)
                                for (p = o ^ o << 1 ^ o << 2 ^ o << 3 ^ o << 4, p = p >> 8 ^ 255 & p ^ 99, n[a] = p, r[p] = a, d = l[u = l[c = l[a]]], m = 16843009 * d ^ 65537 * u ^ 257 * c ^ 16843008 * a, f = 257 * l[p] ^ 16843008 * p, s = 0; s < 4; s++) t[s][a] = f = f << 24 ^ f >>> 8, i[s][p] = m = m << 24 ^ m >>> 8;
                            for (s = 0; s < 5; s++) t[s] = t[s].slice(0), i[s] = i[s].slice(0);
                            return e
                        }()), this._tables = [
                            [t[0][0].slice(), t[0][1].slice(), t[0][2].slice(), t[0][3].slice(), t[0][4].slice()],
                            [t[1][0].slice(), t[1][1].slice(), t[1][2].slice(), t[1][3].slice(), t[1][4].slice()]
                        ];
                        const s = this._tables[0][4],
                            a = this._tables[1],
                            o = e.length;
                        let l = 1;
                        if (4 !== o && 6 !== o && 8 !== o) throw new Error("Invalid aes key size");
                        const h = e.slice(0),
                            c = [];
                        for (this._key = [h, c], i = o; i < 4 * o + 28; i++) r = h[i - 1], (i % o == 0 || 8 === o && i % o == 4) && (r = s[r >>> 24] << 24 ^ s[r >> 16 & 255] << 16 ^ s[r >> 8 & 255] << 8 ^ s[255 & r], i % o == 0 && (r = r << 8 ^ r >>> 24 ^ l << 24, l = l << 1 ^ 283 * (l >> 7))), h[i] = h[i - o] ^ r;
                        for (n = 0; i; n++, i--) r = h[3 & n ? i : i - 4], c[n] = i <= 4 || n < 4 ? r : a[0][s[r >>> 24]] ^ a[1][s[r >> 16 & 255]] ^ a[2][s[r >> 8 & 255]] ^ a[3][s[255 & r]]
                    }
                    decrypt(e, t, i, n, r, s) {
                        const a = this._key[1];
                        let o, l, h, c = e ^ a[0],
                            u = n ^ a[1],
                            d = i ^ a[2],
                            p = t ^ a[3];
                        const f = a.length / 4 - 2;
                        let m, g = 4;
                        const y = this._tables[1],
                            _ = y[0],
                            v = y[1],
                            b = y[2],
                            T = y[3],
                            x = y[4];
                        for (m = 0; m < f; m++) o = _[c >>> 24] ^ v[u >> 16 & 255] ^ b[d >> 8 & 255] ^ T[255 & p] ^ a[g], l = _[u >>> 24] ^ v[d >> 16 & 255] ^ b[p >> 8 & 255] ^ T[255 & c] ^ a[g + 1], h = _[d >>> 24] ^ v[p >> 16 & 255] ^ b[c >> 8 & 255] ^ T[255 & u] ^ a[g + 2], p = _[p >>> 24] ^ v[c >> 16 & 255] ^ b[u >> 8 & 255] ^ T[255 & d] ^ a[g + 3], g += 4, c = o, u = l, d = h;
                        for (m = 0; m < 4; m++) r[(3 & -m) + s] = x[c >>> 24] << 24 ^ x[u >> 16 & 255] << 16 ^ x[d >> 8 & 255] << 8 ^ x[255 & p] ^ a[g++], o = c, c = u, u = d, d = p, p = o
                    }
                }
                class r extends e {
                    constructor() {
                        super(e), this.jobs = [], this.delay = 1, this.timeout_ = null
                    }
                    processJob_() {
                        this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null
                    }
                    push(e) {
                        this.jobs.push(e), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay))
                    }
                }
                const s = function(e) {
                    return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
                };
                class a {
                    constructor(e, t, i, n) {
                        const o = a.STEP,
                            l = new Int32Array(e.buffer),
                            h = new Uint8Array(e.byteLength);
                        let c = 0;
                        for (this.asyncStream_ = new r, this.asyncStream_.push(this.decryptChunk_(l.subarray(c, c + o), t, i, h)), c = o; c < l.length; c += o) i = new Uint32Array([s(l[c - 4]), s(l[c - 3]), s(l[c - 2]), s(l[c - 1])]), this.asyncStream_.push(this.decryptChunk_(l.subarray(c, c + o), t, i, h));
                        this.asyncStream_.push((function() {
                            var e;
                            n(null, (e = h).subarray(0, e.byteLength - e[e.byteLength - 1]))
                        }))
                    }
                    static get STEP() {
                        return 32e3
                    }
                    decryptChunk_(e, t, i, r) {
                        return function() {
                            const a = function(e, t, i) {
                                const r = new Int32Array(e.buffer, e.byteOffset, e.byteLength >> 2),
                                    a = new n(Array.prototype.slice.call(t)),
                                    o = new Uint8Array(e.byteLength),
                                    l = new Int32Array(o.buffer);
                                let h, c, u, d, p, f, m, g, y;
                                for (h = i[0], c = i[1], u = i[2], d = i[3], y = 0; y < r.length; y += 4) p = s(r[y]), f = s(r[y + 1]), m = s(r[y + 2]), g = s(r[y + 3]), a.decrypt(p, f, m, g, l, y), l[y] = s(l[y] ^ h), l[y + 1] = s(l[y + 1] ^ c), l[y + 2] = s(l[y + 2] ^ u), l[y + 3] = s(l[y + 3] ^ d), h = p, c = f, u = m, d = g;
                                return o
                            }(e, t, i);
                            r.set(a, e.byteOffset)
                        }
                    }
                }
                var o, l = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self ? self : {};
                o = "undefined" != typeof window ? window : void 0 !== l ? l : "undefined" != typeof self ? self : {};
                var h = o.BigInt || Number;
                h("0x1"), h("0x100"), h("0x10000"), h("0x1000000"), h("0x100000000"), h("0x10000000000"), h("0x1000000000000"), h("0x100000000000000"), h("0x10000000000000000"),
                    function() {
                        var e = new Uint16Array([65484]),
                            t = new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
                        255 === t[0] || t[0]
                    }();
                const c = function(e) {
                    const t = {};
                    return Object.keys(e).forEach((i => {
                        const n = e[i];
                        var r;
                        r = n, ("function" === ArrayBuffer.isView ? ArrayBuffer.isView(r) : r && r.buffer instanceof ArrayBuffer) ? t[i] = {
                            bytes: n.buffer,
                            byteOffset: n.byteOffset,
                            byteLength: n.byteLength
                        } : t[i] = n
                    })), t
                };
                self.onmessage = function(e) {
                    const t = e.data,
                        i = new Uint8Array(t.encrypted.bytes, t.encrypted.byteOffset, t.encrypted.byteLength),
                        n = new Uint32Array(t.key.bytes, t.key.byteOffset, t.key.byteLength / 4),
                        r = new Uint32Array(t.iv.bytes, t.iv.byteOffset, t.iv.byteLength / 4);
                    new a(i, n, r, (function(e, i) {
                        self.postMessage(c({
                            source: t.source,
                            decrypted: i
                        }), [i.buffer])
                    }))
                }
            })));
            var yh = Xo(gh);
            const _h = e => {
                    let t = e.default ? "main" : "alternative";
                    return e.characteristics && e.characteristics.indexOf("public.accessibility.describes-video") >= 0 && (t = "main-desc"), t
                },
                vh = (e, t) => {
                    e.abort(), e.pause(), t && t.activePlaylistLoader && (t.activePlaylistLoader.pause(), t.activePlaylistLoader = null)
                },
                bh = (e, t) => {
                    t.activePlaylistLoader = e, e.load()
                },
                Th = {
                    AUDIO: (e, t) => () => {
                        const {
                            segmentLoaders: {
                                [e]: i
                            },
                            mediaTypes: {
                                [e]: n
                            },
                            excludePlaylist: r
                        } = t;
                        vh(i, n);
                        const s = n.activeTrack(),
                            a = n.activeGroup(),
                            o = (a.filter((e => e.default))[0] || a[0]).id,
                            l = n.tracks[o];
                        if (s !== l) {
                            Ca.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
                            for (const e in n.tracks) n.tracks[e].enabled = n.tracks[e] === l;
                            n.onTrackChanged()
                        } else r({
                            error: {
                                message: "Problem encountered loading the default audio track."
                            }
                        })
                    },
                    SUBTITLES: (e, t) => () => {
                        const {
                            segmentLoaders: {
                                [e]: i
                            },
                            mediaTypes: {
                                [e]: n
                            }
                        } = t;
                        Ca.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track."), vh(i, n);
                        const r = n.activeTrack();
                        r && (r.mode = "disabled"), n.onTrackChanged()
                    }
                },
                xh = {
                    AUDIO: (e, t, i) => {
                        if (!t) return;
                        const {
                            tech: n,
                            requestOptions: r,
                            segmentLoaders: {
                                [e]: s
                            }
                        } = i;
                        t.on("loadedmetadata", (() => {
                            const e = t.media();
                            s.playlist(e, r), (!n.paused() || e.endList && "none" !== n.preload()) && s.load()
                        })), t.on("loadedplaylist", (() => {
                            s.playlist(t.media(), r), n.paused() || s.load()
                        })), t.on("error", Th[e](e, i))
                    },
                    SUBTITLES: (e, t, i) => {
                        const {
                            tech: n,
                            requestOptions: r,
                            segmentLoaders: {
                                [e]: s
                            },
                            mediaTypes: {
                                [e]: a
                            }
                        } = i;
                        t.on("loadedmetadata", (() => {
                            const e = t.media();
                            s.playlist(e, r), s.track(a.activeTrack()), (!n.paused() || e.endList && "none" !== n.preload()) && s.load()
                        })), t.on("loadedplaylist", (() => {
                            s.playlist(t.media(), r), n.paused() || s.load()
                        })), t.on("error", Th[e](e, i))
                    }
                },
                wh = {
                    AUDIO: (e, t) => {
                        const {
                            vhs: i,
                            sourceType: n,
                            segmentLoaders: {
                                [e]: r
                            },
                            requestOptions: s,
                            main: {
                                mediaGroups: a
                            },
                            mediaTypes: {
                                [e]: {
                                    groups: o,
                                    tracks: l,
                                    logger_: h
                                }
                            },
                            mainPlaylistLoader: c
                        } = t, u = ho(c.main);
                        a[e] && 0 !== Object.keys(a[e]).length || (a[e] = {
                            main: {
                                default: {
                                    default: !0
                                }
                            }
                        }, u && (a[e].main.default.playlists = c.main.playlists));
                        for (const r in a[e]) {
                            o[r] || (o[r] = []);
                            for (const d in a[e][r]) {
                                let p, f = a[e][r][d];
                                if (u ? (h(`AUDIO group '${r}' label '${d}' is a main playlist`), f.isMainPlaylist = !0, p = null) : p = "vhs-json" === n && f.playlists ? new So(f.playlists[0], i, s) : f.resolvedUri ? new So(f.resolvedUri, i, s) : f.playlists && "dash" === n ? new jo(f.playlists[0], i, s, c) : null, f = Na({
                                        id: d,
                                        playlistLoader: p
                                    }, f), xh[e](e, f.playlistLoader, t), o[r].push(f), void 0 === l[d]) {
                                    const e = new Ca.AudioTrack({
                                        id: d,
                                        kind: _h(f),
                                        enabled: !1,
                                        language: f.language,
                                        default: f.default,
                                        label: d
                                    });
                                    l[d] = e
                                }
                            }
                        }
                        r.on("error", Th[e](e, t))
                    },
                    SUBTITLES: (e, t) => {
                        const {
                            tech: i,
                            vhs: n,
                            sourceType: r,
                            segmentLoaders: {
                                [e]: s
                            },
                            requestOptions: a,
                            main: {
                                mediaGroups: o
                            },
                            mediaTypes: {
                                [e]: {
                                    groups: l,
                                    tracks: h
                                }
                            },
                            mainPlaylistLoader: c
                        } = t;
                        for (const s in o[e]) {
                            l[s] || (l[s] = []);
                            for (const u in o[e][s]) {
                                if (o[e][s][u].forced) continue;
                                let d, p = o[e][s][u];
                                if ("hls" === r) d = new So(p.resolvedUri, n, a);
                                else if ("dash" === r) {
                                    if (!p.playlists.filter((e => e.excludeUntil !== 1 / 0)).length) return;
                                    d = new jo(p.playlists[0], n, a, c)
                                } else "vhs-json" === r && (d = new So(p.playlists ? p.playlists[0] : p.resolvedUri, n, a));
                                if (p = Na({
                                        id: u,
                                        playlistLoader: d
                                    }, p), xh[e](e, p.playlistLoader, t), l[s].push(p), void 0 === h[u]) {
                                    const e = i.addRemoteTextTrack({
                                        id: u,
                                        kind: "subtitles",
                                        default: p.default && p.autoselect,
                                        language: p.language,
                                        label: u
                                    }, !1).track;
                                    h[u] = e
                                }
                            }
                        }
                        s.on("error", Th[e](e, t))
                    },
                    "CLOSED-CAPTIONS": (e, t) => {
                        const {
                            tech: i,
                            main: {
                                mediaGroups: n
                            },
                            mediaTypes: {
                                [e]: {
                                    groups: r,
                                    tracks: s
                                }
                            }
                        } = t;
                        for (const t in n[e]) {
                            r[t] || (r[t] = []);
                            for (const a in n[e][t]) {
                                const o = n[e][t][a];
                                if (!/^(?:CC|SERVICE)/.test(o.instreamId)) continue;
                                const l = i.options_.vhs && i.options_.vhs.captionServices || {};
                                let h = {
                                    label: a,
                                    language: o.language,
                                    instreamId: o.instreamId,
                                    default: o.default && o.autoselect
                                };
                                if (l[h.instreamId] && (h = Na(h, l[h.instreamId])), void 0 === h.default && delete h.default, r[t].push(Na({
                                        id: a
                                    }, o)), void 0 === s[a]) {
                                    const e = i.addRemoteTextTrack({
                                        id: h.instreamId,
                                        kind: "captions",
                                        default: h.default,
                                        language: h.language,
                                        label: h.label
                                    }, !1).track;
                                    s[a] = e
                                }
                            }
                        }
                    }
                },
                Sh = (e, t) => {
                    for (let i = 0; i < e.length; i++) {
                        if (oo(t, e[i])) return !0;
                        if (e[i].playlists && Sh(e[i].playlists, t)) return !0
                    }
                    return !1
                },
                Eh = {
                    AUDIO: (e, t) => () => {
                        const {
                            mediaTypes: {
                                [e]: {
                                    tracks: i
                                }
                            }
                        } = t;
                        for (const e in i)
                            if (i[e].enabled) return i[e];
                        return null
                    },
                    SUBTITLES: (e, t) => () => {
                        const {
                            mediaTypes: {
                                [e]: {
                                    tracks: i
                                }
                            }
                        } = t;
                        for (const e in i)
                            if ("showing" === i[e].mode || "hidden" === i[e].mode) return i[e];
                        return null
                    }
                },
                Mh = e => {
                    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((t => {
                        wh[t](t, e)
                    }));
                    const {
                        mediaTypes: t,
                        mainPlaylistLoader: i,
                        tech: n,
                        vhs: r,
                        segmentLoaders: {
                            AUDIO: s,
                            main: a
                        }
                    } = e;
                    ["AUDIO", "SUBTITLES"].forEach((i => {
                        t[i].activeGroup = ((e, t) => i => {
                            const {
                                mainPlaylistLoader: n,
                                mediaTypes: {
                                    [e]: {
                                        groups: r
                                    }
                                }
                            } = t, s = n.media();
                            if (!s) return null;
                            let a = null;
                            s.attributes[e] && (a = r[s.attributes[e]]);
                            const o = Object.keys(r);
                            if (!a)
                                if ("AUDIO" === e && o.length > 1 && ho(t.main))
                                    for (let e = 0; e < o.length; e++) {
                                        const t = r[o[e]];
                                        if (Sh(t, s)) {
                                            a = t;
                                            break
                                        }
                                    } else r.main ? a = r.main : 1 === o.length && (a = r[o[0]]);
                            return void 0 === i ? a : null !== i && a && a.filter((e => e.id === i.id))[0] || null
                        })(i, e), t[i].activeTrack = Eh[i](i, e), t[i].onGroupChanged = ((e, t) => () => {
                            const {
                                segmentLoaders: {
                                    [e]: i,
                                    main: n
                                },
                                mediaTypes: {
                                    [e]: r
                                }
                            } = t, s = r.activeTrack(), a = r.getActiveGroup(), o = r.activePlaylistLoader, l = r.lastGroup_;
                            a && l && a.id === l.id || (r.lastGroup_ = a, r.lastTrack_ = s, vh(i, r), a && !a.isMainPlaylist && (a.playlistLoader ? (i.resyncLoader(), bh(a.playlistLoader, r)) : o && n.resetEverything()))
                        })(i, e), t[i].onGroupChanging = ((e, t) => () => {
                            const {
                                segmentLoaders: {
                                    [e]: i
                                },
                                mediaTypes: {
                                    [e]: n
                                }
                            } = t;
                            n.lastGroup_ = null, i.abort(), i.pause()
                        })(i, e), t[i].onTrackChanged = ((e, t) => () => {
                            const {
                                mainPlaylistLoader: i,
                                segmentLoaders: {
                                    [e]: n,
                                    main: r
                                },
                                mediaTypes: {
                                    [e]: s
                                }
                            } = t, a = s.activeTrack(), o = s.getActiveGroup(), l = s.activePlaylistLoader, h = s.lastTrack_;
                            if ((!h || !a || h.id !== a.id) && (s.lastGroup_ = o, s.lastTrack_ = a, vh(n, s), o)) {
                                if (o.isMainPlaylist) {
                                    if (!a || !h || a.id === h.id) return;
                                    const e = t.vhs.playlistController_,
                                        n = e.selectPlaylist();
                                    if (e.media() === n) return;
                                    return s.logger_(`track change. Switching main audio from ${h.id} to ${a.id}`), i.pause(), r.resetEverything(), void e.fastQualityChange_(n)
                                }
                                if ("AUDIO" === e) {
                                    if (!o.playlistLoader) return r.setAudio(!0), void r.resetEverything();
                                    n.setAudio(!0), r.setAudio(!1)
                                }
                                l !== o.playlistLoader ? (n.track && n.track(a), n.resetEverything(), bh(o.playlistLoader, s)) : bh(o.playlistLoader, s)
                            }
                        })(i, e), t[i].getActiveGroup = ((e, {
                            mediaTypes: t
                        }) => () => {
                            const i = t[e].activeTrack();
                            return i ? t[e].activeGroup(i) : null
                        })(i, e)
                    }));
                    const o = t.AUDIO.activeGroup();
                    if (o) {
                        const e = (o.filter((e => e.default))[0] || o[0]).id;
                        t.AUDIO.tracks[e].enabled = !0, t.AUDIO.onGroupChanged(), t.AUDIO.onTrackChanged();
                        t.AUDIO.getActiveGroup().playlistLoader ? (a.setAudio(!1), s.setAudio(!0)) : a.setAudio(!0)
                    }
                    i.on("mediachange", (() => {
                        ["AUDIO", "SUBTITLES"].forEach((e => t[e].onGroupChanged()))
                    })), i.on("mediachanging", (() => {
                        ["AUDIO", "SUBTITLES"].forEach((e => t[e].onGroupChanging()))
                    }));
                    const l = () => {
                        t.AUDIO.onTrackChanged(), n.trigger({
                            type: "usage",
                            name: "vhs-audio-change"
                        })
                    };
                    n.audioTracks().addEventListener("change", l), n.remoteTextTracks().addEventListener("change", t.SUBTITLES.onTrackChanged), r.on("dispose", (() => {
                        n.audioTracks().removeEventListener("change", l), n.remoteTextTracks().removeEventListener("change", t.SUBTITLES.onTrackChanged)
                    })), n.clearTracks("audio");
                    for (const e in t.AUDIO.tracks) n.audioTracks().addTrack(t.AUDIO.tracks[e])
                };
            let Ch;
            const Ah = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"],
                Lh = function(e) {
                    return this.audioSegmentLoader_[e] + this.mainSegmentLoader_[e]
                };
            class Ih extends Ca.EventTarget {
                constructor(e) {
                    super();
                    const {
                        src: t,
                        withCredentials: i,
                        tech: n,
                        bandwidth: s,
                        externVhs: a,
                        useCueTags: o,
                        playlistExclusionDuration: l,
                        enableLowInitialPlaylist: h,
                        sourceType: c,
                        cacheEncryptionKeys: u,
                        bufferBasedABR: d,
                        leastPixelDiffSelector: p,
                        captionServices: f
                    } = e;
                    if (!t) throw new Error("A non-empty playlist URL or JSON manifest string is required");
                    let {
                        maxPlaylistRetries: m
                    } = e;
                    null == m && (m = 1 / 0), Ch = a, this.bufferBasedABR = Boolean(d), this.leastPixelDiffSelector = Boolean(p), this.withCredentials = i, this.tech_ = n, this.vhs_ = n.vhs, this.sourceType_ = c, this.useCueTags_ = o, this.playlistExclusionDuration = l, this.maxPlaylistRetries = m, this.enableLowInitialPlaylist = h, this.useCueTags_ && (this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues"), this.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), this.requestOptions_ = {
                        withCredentials: i,
                        maxPlaylistRetries: m,
                        timeout: null
                    }, this.on("error", this.pauseLoading), this.mediaTypes_ = (() => {
                        const e = {};
                        return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((t => {
                            e[t] = {
                                groups: {},
                                tracks: {},
                                activePlaylistLoader: null,
                                activeGroup: Gl,
                                activeTrack: Gl,
                                getActiveGroup: Gl,
                                onGroupChanged: Gl,
                                onTrackChanged: Gl,
                                lastTrack_: null,
                                logger_: Oa(`MediaGroups[${t}]`)
                            }
                        })), e
                    })(), this.mediaSource = new(r().MediaSource), this.handleDurationChange_ = this.handleDurationChange_.bind(this), this.handleSourceOpen_ = this.handleSourceOpen_.bind(this), this.handleSourceEnded_ = this.handleSourceEnded_.bind(this), this.mediaSource.addEventListener("durationchange", this.handleDurationChange_), this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_), this.seekable_ = Ua(), this.hasPlayed_ = !1, this.syncController_ = new fh(e), this.segmentMetadataTrack_ = n.addRemoteTextTrack({
                        kind: "metadata",
                        label: "segment-metadata"
                    }, !1).track, this.decrypter_ = new yh, this.sourceUpdater_ = new lh(this.mediaSource), this.inbandTextTracks_ = {}, this.timelineChangeController_ = new mh;
                    const g = {
                        vhs: this.vhs_,
                        parse708captions: e.parse708captions,
                        useDtsForTimestampOffset: e.useDtsForTimestampOffset,
                        captionServices: f,
                        mediaSource: this.mediaSource,
                        currentTime: this.tech_.currentTime.bind(this.tech_),
                        seekable: () => this.seekable(),
                        seeking: () => this.tech_.seeking(),
                        duration: () => this.duration(),
                        hasPlayed: () => this.hasPlayed_,
                        goalBufferLength: () => this.goalBufferLength(),
                        bandwidth: s,
                        syncController: this.syncController_,
                        decrypter: this.decrypter_,
                        sourceType: this.sourceType_,
                        inbandTextTracks: this.inbandTextTracks_,
                        cacheEncryptionKeys: u,
                        sourceUpdater: this.sourceUpdater_,
                        timelineChangeController: this.timelineChangeController_,
                        exactManifestTimings: e.exactManifestTimings
                    };
                    this.mainPlaylistLoader_ = "dash" === this.sourceType_ ? new jo(t, this.vhs_, this.requestOptions_) : new So(t, this.vhs_, this.requestOptions_), this.setupMainPlaylistLoaderListeners_(), this.mainSegmentLoader_ = new Vl(Na(g, {
                        segmentMetadataTrack: this.segmentMetadataTrack_,
                        loaderType: "main"
                    }), e), this.audioSegmentLoader_ = new Vl(Na(g, {
                        loaderType: "audio"
                    }), e), this.subtitleSegmentLoader_ = new uh(Na(g, {
                        loaderType: "vtt",
                        featuresNativeTextTracks: this.tech_.featuresNativeTextTracks
                    }), e), this.setupSegmentLoaderListeners_(), this.bufferBasedABR && (this.mainPlaylistLoader_.one("loadedplaylist", (() => this.startABRTimer_())), this.tech_.on("pause", (() => this.stopABRTimer_())), this.tech_.on("play", (() => this.startABRTimer_()))), Ah.forEach((e => {
                        this[e + "_"] = Lh.bind(this, e)
                    })), this.logger_ = Oa("pc"), this.triggeredFmp4Usage = !1, "none" === this.tech_.preload() ? (this.loadOnPlay_ = () => {
                        this.loadOnPlay_ = null, this.mainPlaylistLoader_.load()
                    }, this.tech_.one("play", this.loadOnPlay_)) : this.mainPlaylistLoader_.load(), this.timeToLoadedData__ = -1, this.mainAppendsToLoadedData__ = -1, this.audioAppendsToLoadedData__ = -1;
                    const y = "none" === this.tech_.preload() ? "play" : "loadstart";
                    this.tech_.one(y, (() => {
                        const e = Date.now();
                        this.tech_.one("loadeddata", (() => {
                            this.timeToLoadedData__ = Date.now() - e, this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends, this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends
                        }))
                    }))
                }
                mainAppendsToLoadedData_() {
                    return this.mainAppendsToLoadedData__
                }
                audioAppendsToLoadedData_() {
                    return this.audioAppendsToLoadedData__
                }
                appendsToLoadedData_() {
                    const e = this.mainAppendsToLoadedData_(),
                        t = this.audioAppendsToLoadedData_();
                    return -1 === e || -1 === t ? -1 : e + t
                }
                timeToLoadedData_() {
                    return this.timeToLoadedData__
                }
                checkABR_(e = "abr") {
                    const t = this.selectPlaylist();
                    t && this.shouldSwitchToMedia_(t) && this.switchMedia_(t, e)
                }
                switchMedia_(e, t, i) {
                    const n = this.media(),
                        r = n && (n.id || n.uri),
                        s = e.id || e.uri;
                    r && r !== s && (this.logger_(`switch media ${r} -> ${s} from ${t}`), this.tech_.trigger({
                        type: "usage",
                        name: `vhs-rendition-change-${t}`
                    })), this.mainPlaylistLoader_.media(e, i)
                }
                startABRTimer_() {
                    this.stopABRTimer_(), this.abrTimer_ = r().setInterval((() => this.checkABR_()), 250)
                }
                stopABRTimer_() {
                    this.tech_.scrubbing && this.tech_.scrubbing() || (r().clearInterval(this.abrTimer_), this.abrTimer_ = null)
                }
                getAudioTrackPlaylists_() {
                    const e = this.main(),
                        t = e && e.playlists || [];
                    if (!e || !e.mediaGroups || !e.mediaGroups.AUDIO) return t;
                    const i = e.mediaGroups.AUDIO,
                        n = Object.keys(i);
                    let r;
                    if (Object.keys(this.mediaTypes_.AUDIO.groups).length) r = this.mediaTypes_.AUDIO.activeTrack();
                    else {
                        const e = i.main || n.length && i[n[0]];
                        for (const t in e)
                            if (e[t].default) {
                                r = {
                                    label: t
                                };
                                break
                            }
                    }
                    if (!r) return t;
                    const s = [];
                    for (const t in i)
                        if (i[t][r.label]) {
                            const n = i[t][r.label];
                            if (n.playlists && n.playlists.length) s.push.apply(s, n.playlists);
                            else if (n.uri) s.push(n);
                            else if (e.playlists.length)
                                for (let i = 0; i < e.playlists.length; i++) {
                                    const n = e.playlists[i];
                                    n.attributes && n.attributes.AUDIO && n.attributes.AUDIO === t && s.push(n)
                                }
                        }
                    return s.length ? s : t
                }
                setupMainPlaylistLoaderListeners_() {
                    this.mainPlaylistLoader_.on("loadedmetadata", (() => {
                        const e = this.mainPlaylistLoader_.media(),
                            t = 1.5 * e.targetDuration * 1e3;
                        ao(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = t, e.endList && "none" !== this.tech_.preload() && (this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.mainSegmentLoader_.load()), Mh({
                            sourceType: this.sourceType_,
                            segmentLoaders: {
                                AUDIO: this.audioSegmentLoader_,
                                SUBTITLES: this.subtitleSegmentLoader_,
                                main: this.mainSegmentLoader_
                            },
                            tech: this.tech_,
                            requestOptions: this.requestOptions_,
                            mainPlaylistLoader: this.mainPlaylistLoader_,
                            vhs: this.vhs_,
                            main: this.main(),
                            mediaTypes: this.mediaTypes_,
                            excludePlaylist: this.excludePlaylist.bind(this)
                        }), this.triggerPresenceUsage_(this.main(), e), this.setupFirstPlay(), !this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media() ? this.trigger("selectedinitialmedia") : this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", (() => {
                            this.trigger("selectedinitialmedia")
                        }))
                    })), this.mainPlaylistLoader_.on("loadedplaylist", (() => {
                        this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_);
                        let e = this.mainPlaylistLoader_.media();
                        if (!e) {
                            let t;
                            if (this.excludeUnsupportedVariants_(), this.enableLowInitialPlaylist && (t = this.selectInitialPlaylist()), t || (t = this.selectPlaylist()), !t || !this.shouldSwitchToMedia_(t)) return;
                            this.initialMedia_ = t, this.switchMedia_(this.initialMedia_, "initial");
                            if (!("vhs-json" === this.sourceType_ && this.initialMedia_.segments)) return;
                            e = this.initialMedia_
                        }
                        this.handleUpdatedMediaPlaylist(e)
                    })), this.mainPlaylistLoader_.on("error", (() => {
                        const e = this.mainPlaylistLoader_.error;
                        this.excludePlaylist({
                            playlistToExclude: e.playlist,
                            error: e
                        })
                    })), this.mainPlaylistLoader_.on("mediachanging", (() => {
                        this.mainSegmentLoader_.abort(), this.mainSegmentLoader_.pause()
                    })), this.mainPlaylistLoader_.on("mediachange", (() => {
                        const e = this.mainPlaylistLoader_.media(),
                            t = 1.5 * e.targetDuration * 1e3;
                        ao(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = t, this.mainPlaylistLoader_.load(), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.mainSegmentLoader_.load(), this.tech_.trigger({
                            type: "mediachange",
                            bubbles: !0
                        })
                    })), this.mainPlaylistLoader_.on("playlistunchanged", (() => {
                        const e = this.mainPlaylistLoader_.media();
                        if ("playlist-unchanged" === e.lastExcludeReason_) return;
                        this.stuckAtPlaylistEnd_(e) && (this.excludePlaylist({
                            error: {
                                message: "Playlist no longer updating.",
                                reason: "playlist-unchanged"
                            }
                        }), this.tech_.trigger("playliststuck"))
                    })), this.mainPlaylistLoader_.on("renditiondisabled", (() => {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-rendition-disabled"
                        })
                    })), this.mainPlaylistLoader_.on("renditionenabled", (() => {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-rendition-enabled"
                        })
                    }))
                }
                handleUpdatedMediaPlaylist(e) {
                    this.useCueTags_ && this.updateAdCues_(e), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.updateDuration(!e.endList), this.tech_.paused() || (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load())
                }
                triggerPresenceUsage_(e, t) {
                    const i = e.mediaGroups || {};
                    let n = !0;
                    const r = Object.keys(i.AUDIO);
                    for (const e in i.AUDIO)
                        for (const t in i.AUDIO[e]) {
                            i.AUDIO[e][t].uri || (n = !1)
                        }
                    n && this.tech_.trigger({
                        type: "usage",
                        name: "vhs-demuxed"
                    }), Object.keys(i.SUBTITLES).length && this.tech_.trigger({
                        type: "usage",
                        name: "vhs-webvtt"
                    }), Ch.Playlist.isAes(t) && this.tech_.trigger({
                        type: "usage",
                        name: "vhs-aes"
                    }), r.length && Object.keys(i.AUDIO[r[0]]).length > 1 && this.tech_.trigger({
                        type: "usage",
                        name: "vhs-alternate-audio"
                    }), this.useCueTags_ && this.tech_.trigger({
                        type: "usage",
                        name: "vhs-playlist-cue-tags"
                    })
                }
                shouldSwitchToMedia_(e) {
                    const t = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_,
                        i = this.tech_.currentTime(),
                        n = this.bufferLowWaterLine(),
                        r = this.bufferHighWaterLine();
                    return function({
                        currentPlaylist: e,
                        buffered: t,
                        currentTime: i,
                        nextPlaylist: n,
                        bufferLowWaterLine: r,
                        bufferHighWaterLine: s,
                        duration: a,
                        bufferBasedABR: o,
                        log: l
                    }) {
                        if (!n) return Ca.log.warn("We received no playlist to switch to. Please check your stream."), !1;
                        const h = `allowing switch ${e&&e.id||"null"} -> ${n.id}`;
                        if (!e) return l(`${h} as current playlist is not set`), !0;
                        if (n.id === e.id) return !1;
                        const c = Boolean(za(t, i).length);
                        if (!e.endList) return c || "number" != typeof e.partTargetDuration ? (l(`${h} as current playlist is live`), !0) : (l(`not ${h} as current playlist is live llhls, but currentTime isn't in buffered.`), !1);
                        const u = qa(t, i),
                            d = o ? qo.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : qo.MAX_BUFFER_LOW_WATER_LINE;
                        if (a < d) return l(`${h} as duration < max low water line (${a} < ${d})`), !0;
                        const p = n.attributes.BANDWIDTH,
                            f = e.attributes.BANDWIDTH;
                        if (p < f && (!o || u < s)) {
                            let e = `${h} as next bandwidth < current bandwidth (${p} < ${f})`;
                            return o && (e += ` and forwardBuffer < bufferHighWaterLine (${u} < ${s})`), l(e), !0
                        }
                        if ((!o || p > f) && u >= r) {
                            let e = `${h} as forwardBuffer >= bufferLowWaterLine (${u} >= ${r})`;
                            return o && (e += ` and next bandwidth > current bandwidth (${p} > ${f})`), l(e), !0
                        }
                        return l(`not ${h} as no switching criteria met`), !1
                    }({
                        buffered: this.tech_.buffered(),
                        currentTime: i,
                        currentPlaylist: t,
                        nextPlaylist: e,
                        bufferLowWaterLine: n,
                        bufferHighWaterLine: r,
                        duration: this.duration(),
                        bufferBasedABR: this.bufferBasedABR,
                        log: this.logger_
                    })
                }
                setupSegmentLoaderListeners_() {
                    this.mainSegmentLoader_.on("bandwidthupdate", (() => {
                        this.checkABR_("bandwidthupdate"), this.tech_.trigger("bandwidthupdate")
                    })), this.mainSegmentLoader_.on("timeout", (() => {
                        this.bufferBasedABR && this.mainSegmentLoader_.load()
                    })), this.bufferBasedABR || this.mainSegmentLoader_.on("progress", (() => {
                        this.trigger("progress")
                    })), this.mainSegmentLoader_.on("error", (() => {
                        const e = this.mainSegmentLoader_.error();
                        this.excludePlaylist({
                            playlistToExclude: e.playlist,
                            error: e
                        })
                    })), this.mainSegmentLoader_.on("appenderror", (() => {
                        this.error = this.mainSegmentLoader_.error_, this.trigger("error")
                    })), this.mainSegmentLoader_.on("syncinfoupdate", (() => {
                        this.onSyncInfoUpdate_()
                    })), this.mainSegmentLoader_.on("timestampoffset", (() => {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-timestamp-offset"
                        })
                    })), this.audioSegmentLoader_.on("syncinfoupdate", (() => {
                        this.onSyncInfoUpdate_()
                    })), this.audioSegmentLoader_.on("appenderror", (() => {
                        this.error = this.audioSegmentLoader_.error_, this.trigger("error")
                    })), this.mainSegmentLoader_.on("ended", (() => {
                        this.logger_("main segment loader ended"), this.onEndOfStream()
                    })), this.mainSegmentLoader_.on("earlyabort", (e => {
                        this.bufferBasedABR || (this.delegateLoaders_("all", ["abort"]), this.excludePlaylist({
                            error: {
                                message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
                            },
                            playlistExclusionDuration: 120
                        }))
                    }));
                    const e = () => {
                        if (!this.sourceUpdater_.hasCreatedSourceBuffers()) return this.tryToCreateSourceBuffers_();
                        const e = this.getCodecsOrExclude_();
                        e && this.sourceUpdater_.addOrChangeSourceBuffers(e)
                    };
                    this.mainSegmentLoader_.on("trackinfo", e), this.audioSegmentLoader_.on("trackinfo", e), this.mainSegmentLoader_.on("fmp4", (() => {
                        this.triggeredFmp4Usage || (this.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        }), this.triggeredFmp4Usage = !0)
                    })), this.audioSegmentLoader_.on("fmp4", (() => {
                        this.triggeredFmp4Usage || (this.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        }), this.triggeredFmp4Usage = !0)
                    })), this.audioSegmentLoader_.on("ended", (() => {
                        this.logger_("audioSegmentLoader ended"), this.onEndOfStream()
                    }))
                }
                mediaSecondsLoaded_() {
                    return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded)
                }
                load() {
                    this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load()
                }
                fastQualityChange_(e = this.selectPlaylist()) {
                    e !== this.mainPlaylistLoader_.media() ? (this.switchMedia_(e, "fast-quality"), this.mainSegmentLoader_.resetEverything((() => {
                        Ca.browser.IE_VERSION || Ca.browser.IS_EDGE ? this.tech_.setCurrentTime(this.tech_.currentTime() + .04) : this.tech_.setCurrentTime(this.tech_.currentTime())
                    }))) : this.logger_("skipping fastQualityChange because new media is same as old")
                }
                play() {
                    if (this.setupFirstPlay()) return;
                    this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load();
                    const e = this.tech_.seekable();
                    return this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < e.start(0) ? this.tech_.setCurrentTime(e.end(e.length - 1)) : void 0
                }
                setupFirstPlay() {
                    const e = this.mainPlaylistLoader_.media();
                    if (!e || this.tech_.paused() || this.hasPlayed_) return !1;
                    if (!e.endList) {
                        const e = this.seekable();
                        if (!e.length) return !1;
                        if (Ca.browser.IE_VERSION && 0 === this.tech_.readyState()) return this.tech_.one("loadedmetadata", (() => {
                            this.trigger("firstplay"), this.tech_.setCurrentTime(e.end(0)), this.hasPlayed_ = !0
                        })), !1;
                        this.trigger("firstplay"), this.tech_.setCurrentTime(e.end(0))
                    }
                    return this.hasPlayed_ = !0, this.load(), !0
                }
                handleSourceOpen_() {
                    if (this.tryToCreateSourceBuffers_(), this.tech_.autoplay()) {
                        const e = this.tech_.play();
                        void 0 !== e && "function" == typeof e.then && e.then(null, (e => {}))
                    }
                    this.trigger("sourceopen")
                }
                handleSourceEnded_() {
                    if (!this.inbandTextTracks_.metadataTrack_) return;
                    const e = this.inbandTextTracks_.metadataTrack_.cues;
                    if (!e || !e.length) return;
                    const t = this.duration();
                    e[e.length - 1].endTime = isNaN(t) || Math.abs(t) === 1 / 0 ? Number.MAX_VALUE : t
                }
                handleDurationChange_() {
                    this.tech_.trigger("durationchange")
                }
                onEndOfStream() {
                    let e = this.mainSegmentLoader_.ended_;
                    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                        const t = this.mainSegmentLoader_.getCurrentMediaInfo_();
                        e = !t || t.hasVideo ? e && this.audioSegmentLoader_.ended_ : this.audioSegmentLoader_.ended_
                    }
                    e && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream())
                }
                stuckAtPlaylistEnd_(e) {
                    if (!this.seekable().length) return !1;
                    const t = this.syncController_.getExpiredTime(e, this.duration());
                    if (null === t) return !1;
                    const i = Ch.Playlist.playlistEnd(e, t),
                        n = this.tech_.currentTime(),
                        r = this.tech_.buffered();
                    if (!r.length) return i - n <= Fa;
                    const s = r.end(r.length - 1);
                    return s - n <= Fa && i - s <= Fa
                }
                excludePlaylist({
                    playlistToExclude: e = this.mainPlaylistLoader_.media(),
                    error: t = {},
                    playlistExclusionDuration: i
                }) {
                    if (e = e || this.mainPlaylistLoader_.media(), i = i || t.playlistExclusionDuration || this.playlistExclusionDuration, !e) return this.error = t, void("open" !== this.mediaSource.readyState ? this.trigger("error") : this.sourceUpdater_.endOfStream("network"));
                    e.playlistErrors_++;
                    const n = this.mainPlaylistLoader_.main.playlists,
                        r = n.filter(ro),
                        s = 1 === r.length && r[0] === e;
                    if (1 === n.length && i !== 1 / 0) return Ca.log.warn(`Problem encountered with playlist ${e.id}. Trying again since it is the only playlist.`), this.tech_.trigger("retryplaylist"), this.mainPlaylistLoader_.load(s);
                    if (s) {
                        let t = !1;
                        n.forEach((i => {
                            if (i === e) return;
                            const n = i.excludeUntil;
                            void 0 !== n && n !== 1 / 0 && (t = !0, delete i.excludeUntil)
                        })), t && (Ca.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded."), this.tech_.trigger("retryplaylist"))
                    }
                    let a;
                    a = e.playlistErrors_ > this.maxPlaylistRetries ? 1 / 0 : Date.now() + 1e3 * i, e.excludeUntil = a, t.reason && (e.lastExcludeReason_ = t.reason), this.tech_.trigger("excludeplaylist"), this.tech_.trigger({
                        type: "usage",
                        name: "vhs-rendition-excluded"
                    });
                    const o = this.selectPlaylist();
                    if (!o) return this.error = "Playback cannot continue. No available working or supported playlists.", void this.trigger("error");
                    const l = t.internal ? this.logger_ : Ca.log.warn,
                        h = t.message ? " " + t.message : "";
                    l(`${t.internal?"Internal problem":"Problem"} encountered with playlist ${e.id}.${h} Switching to playlist ${o.id}.`), o.attributes.AUDIO !== e.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]), o.attributes.SUBTITLES !== e.attributes.SUBTITLES && this.delegateLoaders_("subtitle", ["abort", "pause"]), this.delegateLoaders_("main", ["abort", "pause"]);
                    const c = o.targetDuration / 2 * 1e3 || 5e3,
                        u = "number" == typeof o.lastRequest && Date.now() - o.lastRequest <= c;
                    return this.switchMedia_(o, "exclude", s || u)
                }
                pauseLoading() {
                    this.delegateLoaders_("all", ["abort", "pause"]), this.stopABRTimer_()
                }
                delegateLoaders_(e, t) {
                    const i = [],
                        n = "all" === e;
                    (n || "main" === e) && i.push(this.mainPlaylistLoader_);
                    const r = [];
                    (n || "audio" === e) && r.push("AUDIO"), (n || "subtitle" === e) && (r.push("CLOSED-CAPTIONS"), r.push("SUBTITLES")), r.forEach((e => {
                        const t = this.mediaTypes_[e] && this.mediaTypes_[e].activePlaylistLoader;
                        t && i.push(t)
                    })), ["main", "audio", "subtitle"].forEach((t => {
                        const n = this[`${t}SegmentLoader_`];
                        !n || e !== t && "all" !== e || i.push(n)
                    })), i.forEach((e => t.forEach((t => {
                        "function" == typeof e[t] && e[t]()
                    }))))
                }
                setCurrentTime(e) {
                    const t = za(this.tech_.buffered(), e);
                    return this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media() && this.mainPlaylistLoader_.media().segments ? t && t.length ? e : (this.mainSegmentLoader_.resetEverything(), this.mainSegmentLoader_.abort(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.resetEverything(), this.audioSegmentLoader_.abort()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.resetEverything(), this.subtitleSegmentLoader_.abort()), void this.load()) : 0
                }
                duration() {
                    if (!this.mainPlaylistLoader_) return 0;
                    const e = this.mainPlaylistLoader_.media();
                    return e ? e.endList ? this.mediaSource ? this.mediaSource.duration : Ch.Playlist.duration(e) : 1 / 0 : 0
                }
                seekable() {
                    return this.seekable_
                }
                onSyncInfoUpdate_() {
                    let e;
                    if (!this.mainPlaylistLoader_) return;
                    let t = this.mainPlaylistLoader_.media();
                    if (!t) return;
                    let i = this.syncController_.getExpiredTime(t, this.duration());
                    if (null === i) return;
                    const n = this.mainPlaylistLoader_.main,
                        r = Ch.Playlist.seekable(t, i, Ch.Playlist.liveEdgeDelay(n, t));
                    if (0 === r.length) return;
                    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                        if (t = this.mediaTypes_.AUDIO.activePlaylistLoader.media(), i = this.syncController_.getExpiredTime(t, this.duration()), null === i) return;
                        if (e = Ch.Playlist.seekable(t, i, Ch.Playlist.liveEdgeDelay(n, t)), 0 === e.length) return
                    }
                    let s, a;
                    this.seekable_ && this.seekable_.length && (s = this.seekable_.end(0), a = this.seekable_.start(0)), e ? e.start(0) > r.end(0) || r.start(0) > e.end(0) ? this.seekable_ = r : this.seekable_ = Ua([
                        [e.start(0) > r.start(0) ? e.start(0) : r.start(0), e.end(0) < r.end(0) ? e.end(0) : r.end(0)]
                    ]) : this.seekable_ = r, this.seekable_ && this.seekable_.length && this.seekable_.end(0) === s && this.seekable_.start(0) === a || (this.logger_(`seekable updated [${Ga(this.seekable_)}]`), this.tech_.trigger("seekablechanged"))
                }
                updateDuration(e) {
                    if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), "open" !== this.mediaSource.readyState) return this.updateDuration_ = this.updateDuration.bind(this, e), void this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
                    if (e) {
                        const e = this.seekable();
                        if (!e.length) return;
                        return void((isNaN(this.mediaSource.duration) || this.mediaSource.duration < e.end(e.length - 1)) && this.sourceUpdater_.setDuration(e.end(e.length - 1)))
                    }
                    const t = this.tech_.buffered();
                    let i = Ch.Playlist.duration(this.mainPlaylistLoader_.media());
                    t.length > 0 && (i = Math.max(i, t.end(t.length - 1))), this.mediaSource.duration !== i && this.sourceUpdater_.setDuration(i)
                }
                dispose() {
                    this.trigger("dispose"), this.decrypter_.terminate(), this.mainPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), ["AUDIO", "SUBTITLES"].forEach((e => {
                        const t = this.mediaTypes_[e].groups;
                        for (const e in t) t[e].forEach((e => {
                            e.playlistLoader && e.playlistLoader.dispose()
                        }))
                    })), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_), this.off()
                }
                main() {
                    return this.mainPlaylistLoader_.main
                }
                media() {
                    return this.mainPlaylistLoader_.media() || this.initialMedia_
                }
                areMediaTypesKnown_() {
                    const e = !!this.mediaTypes_.AUDIO.activePlaylistLoader,
                        t = !!this.mainSegmentLoader_.getCurrentMediaInfo_(),
                        i = !e || !!this.audioSegmentLoader_.getCurrentMediaInfo_();
                    return !(!t || !i)
                }
                getCodecsOrExclude_() {
                    const e = {
                        main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
                        audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
                    };
                    e.video = e.main;
                    const t = El(this.main(), this.media()),
                        i = {},
                        n = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
                    if (e.main.hasVideo && (i.video = t.video || e.main.videoCodec || "avc1.4d400d"), e.main.isMuxed && (i.video += `,${t.audio||e.main.audioCodec||G}`), (e.main.hasAudio && !e.main.isMuxed || e.audio.hasAudio || n) && (i.audio = t.audio || e.main.audioCodec || e.audio.audioCodec || G, e.audio.isFmp4 = e.main.hasAudio && !e.main.isMuxed ? e.main.isFmp4 : e.audio.isFmp4), !i.audio && !i.video) return void this.excludePlaylist({
                        playlistToExclude: this.media(),
                        error: {
                            message: "Could not determine codecs for playlist."
                        },
                        playlistExclusionDuration: 1 / 0
                    });
                    const r = {};
                    let s;
                    if (["video", "audio"].forEach((function(t) {
                            if (i.hasOwnProperty(t) && (n = e[t].isFmp4, a = i[t], !(n ? z(a) : V(a)))) {
                                const n = e[t].isFmp4 ? "browser" : "muxer";
                                r[n] = r[n] || [], r[n].push(i[t]), "audio" === t && (s = n)
                            }
                            var n, a
                        })), n && s && this.media().attributes.AUDIO) {
                        const e = this.media().attributes.AUDIO;
                        this.main().playlists.forEach((t => {
                            (t.attributes && t.attributes.AUDIO) === e && t !== this.media() && (t.excludeUntil = 1 / 0)
                        })), this.logger_(`excluding audio group ${e} as ${s} does not support codec(s): "${i.audio}"`)
                    }
                    if (!Object.keys(r).length) {
                        if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
                            const e = [];
                            if (["video", "audio"].forEach((t => {
                                    const n = (B(this.sourceUpdater_.codecs[t] || "")[0] || {}).type,
                                        r = (B(i[t] || "")[0] || {}).type;
                                    n && r && n.toLowerCase() !== r.toLowerCase() && e.push(`"${this.sourceUpdater_.codecs[t]}" -> "${i[t]}"`)
                                })), e.length) return void this.excludePlaylist({
                                playlistToExclude: this.media(),
                                error: {
                                    message: `Codec switching not supported: ${e.join(", ")}.`,
                                    internal: !0
                                },
                                playlistExclusionDuration: 1 / 0
                            })
                        }
                        return i
                    } {
                        const e = Object.keys(r).reduce(((e, t) => (e && (e += ", "), e += `${t} does not support codec(s): "${r[t].join(",")}"`)), "") + ".";
                        this.excludePlaylist({
                            playlistToExclude: this.media(),
                            error: {
                                internal: !0,
                                message: e
                            },
                            playlistExclusionDuration: 1 / 0
                        })
                    }
                }
                tryToCreateSourceBuffers_() {
                    if ("open" !== this.mediaSource.readyState || this.sourceUpdater_.hasCreatedSourceBuffers()) return;
                    if (!this.areMediaTypesKnown_()) return;
                    const e = this.getCodecsOrExclude_();
                    if (!e) return;
                    this.sourceUpdater_.createSourceBuffers(e);
                    const t = [e.video, e.audio].filter(Boolean).join(",");
                    this.excludeIncompatibleVariants_(t)
                }
                excludeUnsupportedVariants_() {
                    const e = this.main().playlists,
                        t = [];
                    Object.keys(e).forEach((i => {
                        const n = e[i];
                        if (-1 !== t.indexOf(n.id)) return;
                        t.push(n.id);
                        const r = El(this.main, n),
                            s = [];
                        !r.audio || V(r.audio) || z(r.audio) || s.push(`audio codec ${r.audio}`), !r.video || V(r.video) || z(r.video) || s.push(`video codec ${r.video}`), r.text && "stpp.ttml.im1t" === r.text && s.push(`text codec ${r.text}`), s.length && (n.excludeUntil = 1 / 0, this.logger_(`excluding ${n.id} for unsupported: ${s.join(", ")}`))
                    }))
                }
                excludeIncompatibleVariants_(e) {
                    const t = [],
                        i = this.main().playlists,
                        n = wl(B(e)),
                        r = Sl(n),
                        s = n.video && B(n.video)[0] || null,
                        a = n.audio && B(n.audio)[0] || null;
                    Object.keys(i).forEach((e => {
                        const n = i[e];
                        if (-1 !== t.indexOf(n.id) || n.excludeUntil === 1 / 0) return;
                        t.push(n.id);
                        const o = [],
                            l = El(this.mainPlaylistLoader_.main, n),
                            h = Sl(l);
                        if (l.audio || l.video) {
                            if (h !== r && o.push(`codec count "${h}" !== "${r}"`), !this.sourceUpdater_.canChangeType()) {
                                const e = l.video && B(l.video)[0] || null,
                                    t = l.audio && B(l.audio)[0] || null;
                                e && s && e.type.toLowerCase() !== s.type.toLowerCase() && o.push(`video codec "${e.type}" !== "${s.type}"`), t && a && t.type.toLowerCase() !== a.type.toLowerCase() && o.push(`audio codec "${t.type}" !== "${a.type}"`)
                            }
                            o.length && (n.excludeUntil = 1 / 0, this.logger_(`excluding ${n.id}: ${o.join(" && ")}`))
                        }
                    }))
                }
                updateAdCues_(e) {
                    let t = 0;
                    const i = this.seekable();
                    i.length && (t = i.start(0)),
                        function(e, t, i = 0) {
                            if (!e.segments) return;
                            let n, s = i;
                            for (let i = 0; i < e.segments.length; i++) {
                                const a = e.segments[i];
                                if (n || (n = dh(t, s + a.duration / 2)), n) {
                                    if ("cueIn" in a) {
                                        n.endTime = s, n.adEndTime = s, s += a.duration, n = null;
                                        continue
                                    }
                                    if (s < n.endTime) {
                                        s += a.duration;
                                        continue
                                    }
                                    n.endTime += a.duration
                                } else if ("cueOut" in a && (n = new(r().VTTCue)(s, s + a.duration, a.cueOut), n.adStartTime = s, n.adEndTime = s + parseFloat(a.cueOut), t.addCue(n)), "cueOutCont" in a) {
                                    const [e, i] = a.cueOutCont.split("/").map(parseFloat);
                                    n = new(r().VTTCue)(s, s + a.duration, ""), n.adStartTime = s - e, n.adEndTime = n.adStartTime + i, t.addCue(n)
                                }
                                s += a.duration
                            }
                        }(e, this.cueTagsTrack_, t)
                }
                goalBufferLength() {
                    const e = this.tech_.currentTime(),
                        t = qo.GOAL_BUFFER_LENGTH,
                        i = qo.GOAL_BUFFER_LENGTH_RATE,
                        n = Math.max(t, qo.MAX_GOAL_BUFFER_LENGTH);
                    return Math.min(t + e * i, n)
                }
                bufferLowWaterLine() {
                    const e = this.tech_.currentTime(),
                        t = qo.BUFFER_LOW_WATER_LINE,
                        i = qo.BUFFER_LOW_WATER_LINE_RATE,
                        n = Math.max(t, qo.MAX_BUFFER_LOW_WATER_LINE),
                        r = Math.max(t, qo.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
                    return Math.min(t + e * i, this.bufferBasedABR ? r : n)
                }
                bufferHighWaterLine() {
                    return qo.BUFFER_HIGH_WATER_LINE
                }
            }
            class Ph {
                constructor(e, t, i) {
                    const {
                        playlistController_: n
                    } = e, r = n.fastQualityChange_.bind(n);
                    if (t.attributes) {
                        const e = t.attributes.RESOLUTION;
                        this.width = e && e.width, this.height = e && e.height, this.bandwidth = t.attributes.BANDWIDTH, this.frameRate = t.attributes["FRAME-RATE"]
                    }
                    var s, a, o;
                    this.codecs = El(n.main(), t), this.playlist = t, this.id = i, this.enabled = (s = e.playlists, a = t.id, o = r, e => {
                        const t = s.main.playlists[a],
                            i = no(t),
                            n = ro(t);
                        return void 0 === e ? n : (e ? delete t.disabled : t.disabled = !0, e === n || i || (o(), e ? s.trigger("renditionenabled") : s.trigger("renditiondisabled")), e)
                    })
                }
            }
            const Rh = ["seeking", "seeked", "pause", "playing", "error"];
            class kh {
                constructor(e) {
                    this.playlistController_ = e.playlistController, this.tech_ = e.tech, this.seekable = e.seekable, this.allowSeeksWithinUnsafeLiveWindow = e.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = e.liveRangeSafeTimeDelta, this.media = e.media, this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = Oa("PlaybackWatcher"), this.logger_("initialize");
                    const t = () => this.monitorCurrentTime_(),
                        i = () => this.monitorCurrentTime_(),
                        n = () => this.techWaiting_(),
                        s = () => this.resetTimeUpdate_(),
                        a = this.playlistController_,
                        o = ["main", "subtitle", "audio"],
                        l = {};
                    o.forEach((e => {
                        l[e] = {
                            reset: () => this.resetSegmentDownloads_(e),
                            updateend: () => this.checkSegmentDownloads_(e)
                        }, a[`${e}SegmentLoader_`].on("appendsdone", l[e].updateend), a[`${e}SegmentLoader_`].on("playlistupdate", l[e].reset), this.tech_.on(["seeked", "seeking"], l[e].reset)
                    }));
                    const h = e => {
                        ["main", "audio"].forEach((t => {
                            a[`${t}SegmentLoader_`][e]("appended", this.seekingAppendCheck_)
                        }))
                    };
                    this.seekingAppendCheck_ = () => {
                        this.fixesBadSeeks_() && (this.consecutiveUpdates = 0, this.lastRecordedTime = this.tech_.currentTime(), h("off"))
                    }, this.clearSeekingAppendCheck_ = () => h("off"), this.watchForBadSeeking_ = () => {
                        this.clearSeekingAppendCheck_(), h("on")
                    }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", n), this.tech_.on(Rh, s), this.tech_.on("canplay", i), this.tech_.one("play", t), this.dispose = () => {
                        this.clearSeekingAppendCheck_(), this.logger_("dispose"), this.tech_.off("waiting", n), this.tech_.off(Rh, s), this.tech_.off("canplay", i), this.tech_.off("play", t), this.tech_.off("seeking", this.watchForBadSeeking_), this.tech_.off("seeked", this.clearSeekingAppendCheck_), o.forEach((e => {
                            a[`${e}SegmentLoader_`].off("appendsdone", l[e].updateend), a[`${e}SegmentLoader_`].off("playlistupdate", l[e].reset), this.tech_.off(["seeked", "seeking"], l[e].reset)
                        })), this.checkCurrentTimeTimeout_ && r().clearTimeout(this.checkCurrentTimeTimeout_), this.resetTimeUpdate_()
                    }
                }
                monitorCurrentTime_() {
                    this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && r().clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = r().setTimeout(this.monitorCurrentTime_.bind(this), 250)
                }
                resetSegmentDownloads_(e) {
                    const t = this.playlistController_[`${e}SegmentLoader_`];
                    this[`${e}StalledDownloads_`] > 0 && this.logger_(`resetting possible stalled download count for ${e} loader`), this[`${e}StalledDownloads_`] = 0, this[`${e}Buffered_`] = t.buffered_()
                }
                checkSegmentDownloads_(e) {
                    const t = this.playlistController_,
                        i = t[`${e}SegmentLoader_`],
                        n = i.buffered_(),
                        r = function(e, t) {
                            if (e === t) return !1;
                            if (!e && t || !t && e) return !0;
                            if (e.length !== t.length) return !0;
                            for (let i = 0; i < e.length; i++)
                                if (e.start(i) !== t.start(i) || e.end(i) !== t.end(i)) return !0;
                            return !1
                        }(this[`${e}Buffered_`], n);
                    this[`${e}Buffered_`] = n, r ? this.resetSegmentDownloads_(e) : (this[`${e}StalledDownloads_`]++, this.logger_(`found #${this[`${e}StalledDownloads_`]} ${e} appends that did not increase buffer (possible stalled download)`, {
                        playlistId: i.playlist_ && i.playlist_.id,
                        buffered: Wa(n)
                    }), this[`${e}StalledDownloads_`] < 10 || (this.logger_(`${e} loader stalled download exclusion`), this.resetSegmentDownloads_(e), this.tech_.trigger({
                        type: "usage",
                        name: `vhs-${e}-download-exclusion`
                    }), "subtitle" !== e && t.excludePlaylist({
                        error: {
                            message: `Excessive ${e} segment downloading detected.`
                        },
                        playlistExclusionDuration: 1 / 0
                    })))
                }
                checkCurrentTime_() {
                    if (this.tech_.paused() || this.tech_.seeking()) return;
                    const e = this.tech_.currentTime(),
                        t = this.tech_.buffered();
                    if (this.lastRecordedTime === e && (!t.length || e + Fa >= t.end(t.length - 1))) return this.techWaiting_();
                    this.consecutiveUpdates >= 5 && e === this.lastRecordedTime ? (this.consecutiveUpdates++, this.waiting_()) : e === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0, this.lastRecordedTime = e)
                }
                resetTimeUpdate_() {
                    this.consecutiveUpdates = 0
                }
                fixesBadSeeks_() {
                    if (!this.tech_.seeking()) return !1;
                    const e = this.seekable(),
                        t = this.tech_.currentTime();
                    let i;
                    if (this.afterSeekableWindow_(e, t, this.media(), this.allowSeeksWithinUnsafeLiveWindow)) {
                        i = e.end(e.length - 1)
                    }
                    if (this.beforeSeekableWindow_(e, t)) {
                        const t = e.start(0);
                        i = t + (t === e.end(0) ? 0 : Fa)
                    }
                    if (void 0 !== i) return this.logger_(`Trying to seek outside of seekable at time ${t} with seekable range ${Ga(e)}. Seeking to ${i}.`), this.tech_.setCurrentTime(i), !0;
                    const n = this.playlistController_.sourceUpdater_,
                        r = this.tech_.buffered(),
                        s = n.audioBuffer ? n.audioBuffered() : null,
                        a = n.videoBuffer ? n.videoBuffered() : null,
                        o = this.media(),
                        l = o.partTargetDuration ? o.partTargetDuration : 2 * (o.targetDuration - Ba),
                        h = [s, a];
                    for (let e = 0; e < h.length; e++) {
                        if (!h[e]) continue;
                        if (qa(h[e], t) < l) return !1
                    }
                    const c = Va(r, t);
                    return 0 !== c.length && (i = c.start(0) + Fa, this.logger_(`Buffered region starts (${c.start(0)})  just beyond seek point (${t}). Seeking to ${i}.`), this.tech_.setCurrentTime(i), !0)
                }
                waiting_() {
                    if (this.techWaiting_()) return;
                    const e = this.tech_.currentTime(),
                        t = this.tech_.buffered(),
                        i = za(t, e);
                    return i.length && e + 3 <= i.end(0) ? (this.resetTimeUpdate_(), this.tech_.setCurrentTime(e), this.logger_(`Stopped at ${e} while inside a buffered region [${i.start(0)} -> ${i.end(0)}]. Attempting to resume playback by seeking to the current time.`), void this.tech_.trigger({
                        type: "usage",
                        name: "vhs-unknown-waiting"
                    })) : void 0
                }
                techWaiting_() {
                    const e = this.seekable(),
                        t = this.tech_.currentTime();
                    if (this.tech_.seeking()) return !0;
                    if (this.beforeSeekableWindow_(e, t)) {
                        const i = e.end(e.length - 1);
                        return this.logger_(`Fell out of live window at time ${t}. Seeking to live point (seekable end) ${i}`), this.resetTimeUpdate_(), this.tech_.setCurrentTime(i), this.tech_.trigger({
                            type: "usage",
                            name: "vhs-live-resync"
                        }), !0
                    }
                    const i = this.tech_.vhs.playlistController_.sourceUpdater_,
                        n = this.tech_.buffered();
                    if (this.videoUnderflow_({
                            audioBuffered: i.audioBuffered(),
                            videoBuffered: i.videoBuffered(),
                            currentTime: t
                        })) return this.resetTimeUpdate_(), this.tech_.setCurrentTime(t), this.tech_.trigger({
                        type: "usage",
                        name: "vhs-video-underflow"
                    }), !0;
                    const r = Va(n, t);
                    return r.length > 0 && (this.logger_(`Stopped at ${t} and seeking to ${r.start(0)}`), this.resetTimeUpdate_(), this.skipTheGap_(t), !0)
                }
                afterSeekableWindow_(e, t, i, n = !1) {
                    if (!e.length) return !1;
                    let r = e.end(e.length - 1) + Fa;
                    return !i.endList && n && (r = e.end(e.length - 1) + 3 * i.targetDuration), t > r
                }
                beforeSeekableWindow_(e, t) {
                    return !!(e.length && e.start(0) > 0 && t < e.start(0) - this.liveRangeSafeTimeDelta)
                }
                videoUnderflow_({
                    videoBuffered: e,
                    audioBuffered: t,
                    currentTime: i
                }) {
                    if (!e) return;
                    let n;
                    if (e.length && t.length) {
                        const r = za(e, i - 3),
                            s = za(e, i),
                            a = za(t, i);
                        a.length && !s.length && r.length && (n = {
                            start: r.end(0),
                            end: a.end(0)
                        })
                    } else {
                        Va(e, i).length || (n = this.gapFromVideoUnderflow_(e, i))
                    }
                    return !!n && (this.logger_(`Encountered a gap in video from ${n.start} to ${n.end}. Seeking to current time ${i}`), !0)
                }
                skipTheGap_(e) {
                    const t = this.tech_.buffered(),
                        i = this.tech_.currentTime(),
                        n = Va(t, i);
                    this.resetTimeUpdate_(), 0 !== n.length && i === e && (this.logger_("skipTheGap_:", "currentTime:", i, "scheduled currentTime:", e, "nextRange start:", n.start(0)), this.tech_.setCurrentTime(n.start(0) + Ba), this.tech_.trigger({
                        type: "usage",
                        name: "vhs-gap-skip"
                    }))
                }
                gapFromVideoUnderflow_(e, t) {
                    const i = function(e) {
                        if (e.length < 2) return Ua();
                        const t = [];
                        for (let i = 1; i < e.length; i++) {
                            const n = e.end(i - 1),
                                r = e.start(i);
                            t.push([n, r])
                        }
                        return Ua(t)
                    }(e);
                    for (let e = 0; e < i.length; e++) {
                        const n = i.start(e),
                            r = i.end(e);
                        if (t - n < 4 && t - n > 2) return {
                            start: n,
                            end: r
                        }
                    }
                    return null
                }
            }
            const Dh = {
                    errorInterval: 30,
                    getSource(e) {
                        return e(this.tech({
                            IWillNotUseThisInPlugins: !0
                        }).currentSource_ || this.currentSource())
                    }
                },
                Oh = function(e, t) {
                    let i = 0,
                        n = 0;
                    const r = Na(Dh, t);
                    e.ready((() => {
                        e.trigger({
                            type: "usage",
                            name: "vhs-error-reload-initialized"
                        })
                    }));
                    const s = function() {
                            n && e.currentTime(n)
                        },
                        a = function(t) {
                            null != t && (n = e.duration() !== 1 / 0 && e.currentTime() || 0, e.one("loadedmetadata", s), e.src(t), e.trigger({
                                type: "usage",
                                name: "vhs-error-reload"
                            }), e.play())
                        },
                        o = function() {
                            if (Date.now() - i < 1e3 * r.errorInterval) e.trigger({
                                type: "usage",
                                name: "vhs-error-reload-canceled"
                            });
                            else {
                                if (r.getSource && "function" == typeof r.getSource) return i = Date.now(), r.getSource.call(e, a);
                                Ca.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!")
                            }
                        },
                        l = function() {
                            e.off("loadedmetadata", s), e.off("error", o), e.off("dispose", l)
                        };
                    e.on("error", o), e.on("dispose", l), e.reloadSourceOnError = function(t) {
                        l(), Oh(e, t)
                    }
                },
                Nh = function(e) {
                    Oh(this, e)
                };
            var Uh = "3.0.0";
            const Bh = {
                PlaylistLoader: So,
                Playlist: co,
                utils: No,
                STANDARD_PLAYLIST_SELECTOR: Rl,
                INITIAL_PLAYLIST_SELECTOR: function() {
                    const e = this.playlists.main.playlists.filter(co.isEnabled);
                    Ll(e, ((e, t) => Il(e, t)));
                    return e.filter((e => !!El(this.playlists.main, e).video))[0] || null
                },
                lastBandwidthSelector: Rl,
                movingAverageBandwidthSelector: function(e) {
                    let t = -1,
                        i = -1;
                    if (e < 0 || e > 1) throw new Error("Moving average bandwidth decay must be between 0 and 1.");
                    return function() {
                        const n = this.useDevicePixelRatio && r().devicePixelRatio || 1;
                        return t < 0 && (t = this.systemBandwidth, i = this.systemBandwidth), this.systemBandwidth > 0 && this.systemBandwidth !== i && (t = e * this.systemBandwidth + (1 - e) * t, i = this.systemBandwidth), Pl(this.playlists.main, t, parseInt(Al(this.tech_.el(), "width"), 10) * n, parseInt(Al(this.tech_.el(), "height"), 10) * n, this.limitRenditionByPlayerDimensions, this.playlistController_)
                    }
                },
                comparePlaylistBandwidth: Il,
                comparePlaylistResolution: function(e, t) {
                    let i, n;
                    return e.attributes.RESOLUTION && e.attributes.RESOLUTION.width && (i = e.attributes.RESOLUTION.width), i = i || r().Number.MAX_VALUE, t.attributes.RESOLUTION && t.attributes.RESOLUTION.width && (n = t.attributes.RESOLUTION.width), n = n || r().Number.MAX_VALUE, i === n && e.attributes.BANDWIDTH && t.attributes.BANDWIDTH ? e.attributes.BANDWIDTH - t.attributes.BANDWIDTH : i - n
                },
                xhr: Co()
            };
            Object.keys(qo).forEach((e => {
                Object.defineProperty(Bh, e, {
                    get: () => (Ca.log.warn(`using Vhs.${e} is UNSAFE be sure you know what you are doing`), qo[e]),
                    set(t) {
                        Ca.log.warn(`using Vhs.${e} is UNSAFE be sure you know what you are doing`), "number" != typeof t || t < 0 ? Ca.log.warn(`value of Vhs.${e} must be greater than or equal to 0`) : qo[e] = t
                    }
                })
            }));
            const Fh = "videojs-vhs",
                Hh = function(e, t) {
                    const i = t.media();
                    let n = -1;
                    for (let t = 0; t < e.length; t++)
                        if (e[t].id === i.id) {
                            n = t;
                            break
                        }
                    e.selectedIndex_ = n, e.trigger({
                        selectedIndex: n,
                        type: "change"
                    })
                };
            Bh.canPlaySource = function() {
                return Ca.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.")
            };
            const zh = ({
                    player: e,
                    sourceKeySystems: t,
                    audioMedia: i,
                    mainPlaylists: n
                }) => {
                    if (!e.eme.initializeMediaKeys) return Promise.resolve();
                    const r = ((e, t) => e.reduce(((e, i) => {
                            if (!i.contentProtection) return e;
                            const n = t.reduce(((e, t) => {
                                const n = i.contentProtection[t];
                                return n && n.pssh && (e[t] = {
                                    pssh: n.pssh
                                }), e
                            }), {});
                            return Object.keys(n).length && e.push(n), e
                        }), []))(i ? n.concat([i]) : n, Object.keys(t)),
                        s = [],
                        a = [];
                    return r.forEach((t => {
                        a.push(new Promise(((t, i) => {
                            e.tech_.one("keysessioncreated", t)
                        }))), s.push(new Promise(((i, n) => {
                            e.eme.initializeMediaKeys({
                                keySystems: t
                            }, (e => {
                                e ? n(e) : i()
                            }))
                        })))
                    })), Promise.race([Promise.all(s), Promise.race(a)])
                },
                Vh = ({
                    player: e,
                    sourceKeySystems: t,
                    media: i,
                    audioMedia: n
                }) => {
                    const r = ((e, t, i) => {
                        if (!e) return e;
                        let n = {};
                        t && t.attributes && t.attributes.CODECS && (n = wl(B(t.attributes.CODECS))), i && i.attributes && i.attributes.CODECS && (n.audio = i.attributes.CODECS);
                        const r = H(n.video),
                            s = H(n.audio),
                            a = {};
                        for (const i in e) a[i] = {}, s && (a[i].audioContentType = s), r && (a[i].videoContentType = r), t.contentProtection && t.contentProtection[i] && t.contentProtection[i].pssh && (a[i].pssh = t.contentProtection[i].pssh), "string" == typeof e[i] && (a[i].url = e[i]);
                        return Na(e, a)
                    })(t, i, n);
                    return !!r && (e.currentSource().keySystems = r, !(r && !e.eme) || (Ca.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin"), !1))
                },
                Gh = () => {
                    if (!r().localStorage) return null;
                    const e = r().localStorage.getItem(Fh);
                    if (!e) return null;
                    try {
                        return JSON.parse(e)
                    } catch (e) {
                        return null
                    }
                };
            Bh.supportsNativeHls = function() {
                if (!a() || !a().createElement) return !1;
                const e = a().createElement("video");
                if (!Ca.getTech("Html5").isSupported()) return !1;
                return ["application/vnd.apple.mpegurl", "audio/mpegurl", "audio/x-mpegurl", "application/x-mpegurl", "video/x-mpegurl", "video/mpegurl", "application/mpegurl"].some((function(t) {
                    return /maybe|probably/i.test(e.canPlayType(t))
                }))
            }(), Bh.supportsNativeDash = !!(a() && a().createElement && Ca.getTech("Html5").isSupported()) && /maybe|probably/i.test(a().createElement("video").canPlayType("application/dash+xml")), Bh.supportsTypeNatively = e => "hls" === e ? Bh.supportsNativeHls : "dash" === e && Bh.supportsNativeDash, Bh.isSupported = function() {
                return Ca.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.")
            };
            const Wh = Ca.getComponent("Component");
            class jh extends Wh {
                constructor(e, t, i) {
                    if (super(t, i.vhs), "number" == typeof i.initialBandwidth && (this.options_.bandwidth = i.initialBandwidth), this.logger_ = Oa("VhsHandler"), t.options_ && t.options_.playerId) {
                        const e = Ca.getPlayer(t.options_.playerId);
                        this.player_ = e
                    }
                    if (this.tech_ = t, this.source_ = e, this.stats = {}, this.ignoreNextSeekingEvent_ = !1, this.setOptions_(), this.options_.overrideNative && t.overrideNativeAudioTracks && t.overrideNativeVideoTracks) t.overrideNativeAudioTracks(!0), t.overrideNativeVideoTracks(!0);
                    else if (this.options_.overrideNative && (t.featuresNativeVideoTracks || t.featuresNativeAudioTracks)) throw new Error("Overriding native VHS requires emulated tracks. See https://git.io/vMpjB");
                    this.on(a(), ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], (e => {
                        const t = a().fullscreenElement || a().webkitFullscreenElement || a().mozFullScreenElement || a().msFullscreenElement;
                        t && t.contains(this.tech_.el()) ? this.playlistController_.fastQualityChange_() : this.playlistController_.checkABR_()
                    })), this.on(this.tech_, "seeking", (function() {
                        this.ignoreNextSeekingEvent_ ? this.ignoreNextSeekingEvent_ = !1 : this.setCurrentTime(this.tech_.currentTime())
                    })), this.on(this.tech_, "error", (function() {
                        this.tech_.error() && this.playlistController_ && this.playlistController_.pauseLoading()
                    })), this.on(this.tech_, "play", this.play)
                }
                setOptions_() {
                    if (this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.limitRenditionByPlayerDimensions = !1 !== this.options_.limitRenditionByPlayerDimensions, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.useBandwidthFromLocalStorage = void 0 !== this.source_.useBandwidthFromLocalStorage ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || !1, this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, this.options_.llhls = !1 !== this.options_.llhls, this.options_.bufferBasedABR = this.options_.bufferBasedABR || !1, "number" != typeof this.options_.playlistExclusionDuration && (this.options_.playlistExclusionDuration = 300), "number" != typeof this.options_.bandwidth && this.options_.useBandwidthFromLocalStorage) {
                        const e = Gh();
                        e && e.bandwidth && (this.options_.bandwidth = e.bandwidth, this.tech_.trigger({
                            type: "usage",
                            name: "vhs-bandwidth-from-local-storage"
                        })), e && e.throughput && (this.options_.throughput = e.throughput, this.tech_.trigger({
                            type: "usage",
                            name: "vhs-throughput-from-local-storage"
                        }))
                    }
                    "number" != typeof this.options_.bandwidth && (this.options_.bandwidth = qo.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === qo.INITIAL_BANDWIDTH, ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector"].forEach((e => {
                        void 0 !== this.source_[e] && (this.options_[e] = this.source_[e])
                    })), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio
                }
                src(e, t) {
                    if (!e) return;
                    var i;
                    this.setOptions_(), this.options_.src = 0 === (i = this.source_.src).toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") ? JSON.parse(i.substring(i.indexOf(",") + 1)) : i, this.options_.tech = this.tech_, this.options_.externVhs = Bh, this.options_.sourceType = q(t), this.options_.seekTo = e => {
                        this.tech_.setCurrentTime(e)
                    }, this.playlistController_ = new Ih(this.options_);
                    const n = Na({
                        liveRangeSafeTimeDelta: Fa
                    }, this.options_, {
                        seekable: () => this.seekable(),
                        media: () => this.playlistController_.media(),
                        playlistController: this.playlistController_
                    });
                    this.playbackWatcher_ = new kh(n), this.playlistController_.on("error", (() => {
                        const e = Ca.players[this.tech_.options_.playerId];
                        let t = this.playlistController_.error;
                        "object" != typeof t || t.code ? "string" == typeof t && (t = {
                            message: t,
                            code: 3
                        }) : t.code = 3, e.error(t)
                    }));
                    const s = this.options_.bufferBasedABR ? Bh.movingAverageBandwidthSelector(.55) : Bh.STANDARD_PLAYLIST_SELECTOR;
                    this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : s.bind(this), this.playlistController_.selectInitialPlaylist = Bh.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.playlistController_.mainPlaylistLoader_, this.mediaSource = this.playlistController_.mediaSource, Object.defineProperties(this, {
                        selectPlaylist: {
                            get() {
                                return this.playlistController_.selectPlaylist
                            },
                            set(e) {
                                this.playlistController_.selectPlaylist = e.bind(this)
                            }
                        },
                        throughput: {
                            get() {
                                return this.playlistController_.mainSegmentLoader_.throughput.rate
                            },
                            set(e) {
                                this.playlistController_.mainSegmentLoader_.throughput.rate = e, this.playlistController_.mainSegmentLoader_.throughput.count = 1
                            }
                        },
                        bandwidth: {
                            get() {
                                let e = this.playlistController_.mainSegmentLoader_.bandwidth;
                                const t = r().navigator.connection || r().navigator.mozConnection || r().navigator.webkitConnection,
                                    i = 1e7;
                                if (this.options_.useNetworkInformationApi && t) {
                                    const n = 1e3 * t.downlink * 1e3;
                                    e = n >= i && e >= i ? Math.max(e, n) : n
                                }
                                return e
                            },
                            set(e) {
                                this.playlistController_.mainSegmentLoader_.bandwidth = e, this.playlistController_.mainSegmentLoader_.throughput = {
                                    rate: 0,
                                    count: 0
                                }
                            }
                        },
                        systemBandwidth: {
                            get() {
                                const e = 1 / (this.bandwidth || 1);
                                let t;
                                t = this.throughput > 0 ? 1 / this.throughput : 0;
                                return Math.floor(1 / (e + t))
                            },
                            set() {
                                Ca.log.error('The "systemBandwidth" property is read-only')
                            }
                        }
                    }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, {
                        bandwidth: {
                            get: () => this.bandwidth || 0,
                            enumerable: !0
                        },
                        mediaRequests: {
                            get: () => this.playlistController_.mediaRequests_() || 0,
                            enumerable: !0
                        },
                        mediaRequestsAborted: {
                            get: () => this.playlistController_.mediaRequestsAborted_() || 0,
                            enumerable: !0
                        },
                        mediaRequestsTimedout: {
                            get: () => this.playlistController_.mediaRequestsTimedout_() || 0,
                            enumerable: !0
                        },
                        mediaRequestsErrored: {
                            get: () => this.playlistController_.mediaRequestsErrored_() || 0,
                            enumerable: !0
                        },
                        mediaTransferDuration: {
                            get: () => this.playlistController_.mediaTransferDuration_() || 0,
                            enumerable: !0
                        },
                        mediaBytesTransferred: {
                            get: () => this.playlistController_.mediaBytesTransferred_() || 0,
                            enumerable: !0
                        },
                        mediaSecondsLoaded: {
                            get: () => this.playlistController_.mediaSecondsLoaded_() || 0,
                            enumerable: !0
                        },
                        mediaAppends: {
                            get: () => this.playlistController_.mediaAppends_() || 0,
                            enumerable: !0
                        },
                        mainAppendsToLoadedData: {
                            get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,
                            enumerable: !0
                        },
                        audioAppendsToLoadedData: {
                            get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,
                            enumerable: !0
                        },
                        appendsToLoadedData: {
                            get: () => this.playlistController_.appendsToLoadedData_() || 0,
                            enumerable: !0
                        },
                        timeToLoadedData: {
                            get: () => this.playlistController_.timeToLoadedData_() || 0,
                            enumerable: !0
                        },
                        buffered: {
                            get: () => Wa(this.tech_.buffered()),
                            enumerable: !0
                        },
                        currentTime: {
                            get: () => this.tech_.currentTime(),
                            enumerable: !0
                        },
                        currentSource: {
                            get: () => this.tech_.currentSource_,
                            enumerable: !0
                        },
                        currentTech: {
                            get: () => this.tech_.name_,
                            enumerable: !0
                        },
                        duration: {
                            get: () => this.tech_.duration(),
                            enumerable: !0
                        },
                        main: {
                            get: () => this.playlists.main,
                            enumerable: !0
                        },
                        playerDimensions: {
                            get: () => this.tech_.currentDimensions(),
                            enumerable: !0
                        },
                        seekable: {
                            get: () => Wa(this.tech_.seekable()),
                            enumerable: !0
                        },
                        timestamp: {
                            get: () => Date.now(),
                            enumerable: !0
                        },
                        videoPlaybackQuality: {
                            get: () => this.tech_.getVideoPlaybackQuality(),
                            enumerable: !0
                        }
                    }), this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_)), this.tech_.on("bandwidthupdate", (() => {
                        this.options_.useBandwidthFromLocalStorage && (e => {
                            if (!r().localStorage) return !1;
                            let t = Gh();
                            t = t ? Na(t, e) : e;
                            try {
                                r().localStorage.setItem(Fh, JSON.stringify(t))
                            } catch (e) {
                                return !1
                            }
                        })({
                            bandwidth: this.bandwidth,
                            throughput: Math.round(this.throughput)
                        })
                    })), this.playlistController_.on("selectedinitialmedia", (() => {
                        var e;
                        (e = this).representations = () => {
                            const t = e.playlistController_.main(),
                                i = ho(t) ? e.playlistController_.getAudioTrackPlaylists_() : t.playlists;
                            return i ? i.filter((e => !no(e))).map(((t, i) => new Ph(e, t, t.id))) : []
                        }
                    })), this.playlistController_.sourceUpdater_.on("createdsourcebuffers", (() => {
                        this.setupEme_()
                    })), this.on(this.playlistController_, "progress", (function() {
                        this.tech_.trigger("progress")
                    })), this.on(this.playlistController_, "firstplay", (function() {
                        this.ignoreNextSeekingEvent_ = !0
                    })), this.setupQualityLevels_(), this.tech_.el() && (this.mediaSourceUrl_ = r().URL.createObjectURL(this.playlistController_.mediaSource), this.tech_.src(this.mediaSourceUrl_))
                }
                createKeySessions_() {
                    const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
                    this.logger_("waiting for EME key session creation"), zh({
                        player: this.player_,
                        sourceKeySystems: this.source_.keySystems,
                        audioMedia: e && e.media(),
                        mainPlaylists: this.playlists.main.playlists
                    }).then((() => {
                        this.logger_("created EME key session"), this.playlistController_.sourceUpdater_.initializedEme()
                    })).catch((e => {
                        this.logger_("error while creating EME key session", e), this.player_.error({
                            message: "Failed to initialize media keys for EME",
                            code: 3
                        })
                    }))
                }
                handleWaitingForKey_() {
                    this.logger_("waitingforkey fired, attempting to create any new key sessions"), this.createKeySessions_()
                }
                setupEme_() {
                    const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader,
                        t = Vh({
                            player: this.player_,
                            sourceKeySystems: this.source_.keySystems,
                            media: this.playlists.media(),
                            audioMedia: e && e.media()
                        });
                    this.player_.tech_.on("keystatuschange", (e => {
                        if ("output-restricted" !== e.status) return;
                        const t = this.playlistController_.main();
                        if (!t || !t.playlists) return;
                        const i = [];
                        t.playlists.forEach((e => {
                            e && e.attributes && e.attributes.RESOLUTION && e.attributes.RESOLUTION.height >= 720 && (!e.excludeUntil || e.excludeUntil < 1 / 0) && (e.excludeUntil = 1 / 0, i.push(e))
                        })), i.length && (Ca.log.warn('DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.', ...i), this.playlistController_.fastQualityChange_())
                    })), this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this), this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_), 11 !== Ca.browser.IE_VERSION && t ? this.createKeySessions_() : this.playlistController_.sourceUpdater_.initializedEme()
                }
                setupQualityLevels_() {
                    const e = Ca.players[this.tech_.options_.playerId];
                    e && e.qualityLevels && !this.qualityLevels_ && (this.qualityLevels_ = e.qualityLevels(), this.playlistController_.on("selectedinitialmedia", (() => {
                        ! function(e, t) {
                            t.representations().forEach((t => {
                                e.addQualityLevel(t)
                            })), Hh(e, t.playlists)
                        }(this.qualityLevels_, this)
                    })), this.playlists.on("mediachange", (() => {
                        Hh(this.qualityLevels_, this.playlists)
                    })))
                }
                static version() {
                    return {
                        "@videojs/http-streaming": Uh,
                        "mux.js": "6.2.0",
                        "mpd-parser": "1.0.1",
                        "m3u8-parser": "6.0.0",
                        "aes-decrypter": "4.0.1"
                    }
                }
                version() {
                    return this.constructor.version()
                }
                canChangeType() {
                    return lh.canChangeType()
                }
                play() {
                    this.playlistController_.play()
                }
                setCurrentTime(e) {
                    this.playlistController_.setCurrentTime(e)
                }
                duration() {
                    return this.playlistController_.duration()
                }
                seekable() {
                    return this.playlistController_.seekable()
                }
                dispose() {
                    this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.playlistController_ && this.playlistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.mediaSourceUrl_ && r().URL.revokeObjectURL && (r().URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_), super.dispose()
                }
                convertToProgramTime(e, t) {
                    return Uo({
                        playlist: this.playlistController_.media(),
                        time: e,
                        callback: t
                    })
                }
                seekToProgramTime(e, t, i = !0, n = 2) {
                    return Bo({
                        programTime: e,
                        playlist: this.playlistController_.media(),
                        retryCount: n,
                        pauseAfterSeek: i,
                        seekTo: this.options_.seekTo,
                        tech: this.options_.tech,
                        callback: t
                    })
                }
            }
            const qh = {
                name: "videojs-http-streaming",
                VERSION: Uh,
                canHandleSource(e, t = {}) {
                    const i = Na(Ca.options, t);
                    return qh.canPlayType(e.type, i)
                },
                handleSource(e, t, i = {}) {
                    const n = Na(Ca.options, i);
                    return t.vhs = new jh(e, t, n), t.vhs.xhr = Co(), t.vhs.src(e.src, e.type), t.vhs
                },
                canPlayType(e, t = {}) {
                    const {
                        vhs: {
                            overrideNative: i = !Ca.browser.IS_ANY_SAFARI
                        } = {}
                    } = Na(Ca.options, t), n = q(e);
                    return n && (!Bh.supportsTypeNatively(n) || i) ? "maybe" : ""
                }
            };
            z("avc1.4d400d,mp4a.40.2") && Ca.getTech("Html5").registerSourceHandler(qh, 0), Ca.VhsHandler = jh, Ca.VhsSourceHandler = qh, Ca.Vhs = Bh, Ca.use || Ca.registerComponent("Vhs", Bh), Ca.options.vhs = Ca.options.vhs || {}, Ca.getPlugin && Ca.getPlugin("reloadSourceOnError") || Ca.registerPlugin("reloadSourceOnError", Nh)
        },
        545: (e, t, i) => {
            var n = i(1192),
                r = e.exports = {
                    WebVTT: i(285),
                    VTTCue: i(9038),
                    VTTRegion: i(1058)
                };
            n.vttjs = r, n.WebVTT = r.WebVTT;
            var s = r.VTTCue,
                a = r.VTTRegion,
                o = n.VTTCue,
                l = n.VTTRegion;
            r.shim = function() {
                n.VTTCue = s, n.VTTRegion = a
            }, r.restore = function() {
                n.VTTCue = o, n.VTTRegion = l
            }, n.VTTCue || r.shim()
        },
        285: (e, t, i) => {
            var n = i(930),
                r = Object.create || function() {
                    function e() {}
                    return function(t) {
                        if (1 !== arguments.length) throw new Error("Object.create shim only accepts one parameter.");
                        return e.prototype = t, new e
                    }
                }();

            function s(e, t) {
                this.name = "ParsingError", this.code = e.code, this.message = t || e.message
            }

            function a(e) {
                function t(e, t, i, n) {
                    return 3600 * (0 | e) + 60 * (0 | t) + (0 | i) + (0 | n) / 1e3
                }
                var i = e.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
                return i ? i[3] ? t(i[1], i[2], i[3].replace(":", ""), i[4]) : i[1] > 59 ? t(i[1], i[2], 0, i[4]) : t(0, i[1], i[2], i[4]) : null
            }

            function o() {
                this.values = r(null)
            }

            function l(e, t, i, n) {
                var r = n ? e.split(n) : [e];
                for (var s in r)
                    if ("string" == typeof r[s]) {
                        var a = r[s].split(i);
                        if (2 === a.length) t(a[0].trim(), a[1].trim())
                    }
            }

            function h(e, t, i) {
                var n = e;

                function r() {
                    var t = a(e);
                    if (null === t) throw new s(s.Errors.BadTimeStamp, "Malformed timestamp: " + n);
                    return e = e.replace(/^[^\sa-zA-Z-]+/, ""), t
                }

                function h() {
                    e = e.replace(/^\s+/, "")
                }
                if (h(), t.startTime = r(), h(), "--\x3e" !== e.substr(0, 3)) throw new s(s.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '--\x3e'): " + n);
                e = e.substr(3), h(), t.endTime = r(), h(),
                    function(e, t) {
                        var n = new o;
                        l(e, (function(e, t) {
                            switch (e) {
                                case "region":
                                    for (var r = i.length - 1; r >= 0; r--)
                                        if (i[r].id === t) {
                                            n.set(e, i[r].region);
                                            break
                                        }
                                    break;
                                case "vertical":
                                    n.alt(e, t, ["rl", "lr"]);
                                    break;
                                case "line":
                                    var s = t.split(","),
                                        a = s[0];
                                    n.integer(e, a), n.percent(e, a) && n.set("snapToLines", !1), n.alt(e, a, ["auto"]), 2 === s.length && n.alt("lineAlign", s[1], ["start", "center", "end"]);
                                    break;
                                case "position":
                                    s = t.split(","), n.percent(e, s[0]), 2 === s.length && n.alt("positionAlign", s[1], ["start", "center", "end"]);
                                    break;
                                case "size":
                                    n.percent(e, t);
                                    break;
                                case "align":
                                    n.alt(e, t, ["start", "center", "end", "left", "right"])
                            }
                        }), /:/, /\s/), t.region = n.get("region", null), t.vertical = n.get("vertical", "");
                        try {
                            t.line = n.get("line", "auto")
                        } catch (e) {}
                        t.lineAlign = n.get("lineAlign", "start"), t.snapToLines = n.get("snapToLines", !0), t.size = n.get("size", 100);
                        try {
                            t.align = n.get("align", "center")
                        } catch (e) {
                            t.align = n.get("align", "middle")
                        }
                        try {
                            t.position = n.get("position", "auto")
                        } catch (e) {
                            t.position = n.get("position", {
                                start: 0,
                                left: 0,
                                center: 50,
                                middle: 50,
                                end: 100,
                                right: 100
                            }, t.align)
                        }
                        t.positionAlign = n.get("positionAlign", {
                            start: "start",
                            left: "start",
                            center: "center",
                            middle: "center",
                            end: "end",
                            right: "end"
                        }, t.align)
                    }(e, t)
            }
            s.prototype = r(Error.prototype), s.prototype.constructor = s, s.Errors = {
                BadSignature: {
                    code: 0,
                    message: "Malformed WebVTT signature."
                },
                BadTimeStamp: {
                    code: 1,
                    message: "Malformed time stamp."
                }
            }, o.prototype = {
                set: function(e, t) {
                    this.get(e) || "" === t || (this.values[e] = t)
                },
                get: function(e, t, i) {
                    return i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t
                },
                has: function(e) {
                    return e in this.values
                },
                alt: function(e, t, i) {
                    for (var n = 0; n < i.length; ++n)
                        if (t === i[n]) {
                            this.set(e, t);
                            break
                        }
                },
                integer: function(e, t) {
                    /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
                },
                percent: function(e, t) {
                    return !!(t.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (t = parseFloat(t)) >= 0 && t <= 100) && (this.set(e, t), !0)
                }
            };
            var c = n.createElement && n.createElement("textarea"),
                u = {
                    c: "span",
                    i: "i",
                    b: "b",
                    u: "u",
                    ruby: "ruby",
                    rt: "rt",
                    v: "span",
                    lang: "span"
                },
                d = {
                    white: "rgba(255,255,255,1)",
                    lime: "rgba(0,255,0,1)",
                    cyan: "rgba(0,255,255,1)",
                    red: "rgba(255,0,0,1)",
                    yellow: "rgba(255,255,0,1)",
                    magenta: "rgba(255,0,255,1)",
                    blue: "rgba(0,0,255,1)",
                    black: "rgba(0,0,0,1)"
                },
                p = {
                    v: "title",
                    lang: "lang"
                },
                f = {
                    rt: "ruby"
                };

            function m(e, t) {
                function i() {
                    if (!t) return null;
                    var e, i = t.match(/^([^<]*)(<[^>]*>?)?/);
                    return e = i[1] ? i[1] : i[2], t = t.substr(e.length), e
                }

                function n(e, t) {
                    return !f[t.localName] || f[t.localName] === e.localName
                }

                function r(t, i) {
                    var n = u[t];
                    if (!n) return null;
                    var r = e.document.createElement(n),
                        s = p[t];
                    return s && i && (r[s] = i.trim()), r
                }
                for (var s, o, l = e.document.createElement("div"), h = l, m = []; null !== (s = i());)
                    if ("<" !== s[0]) h.appendChild(e.document.createTextNode((o = s, c.innerHTML = o, o = c.textContent, c.textContent = "", o)));
                    else {
                        if ("/" === s[1]) {
                            m.length && m[m.length - 1] === s.substr(2).replace(">", "") && (m.pop(), h = h.parentNode);
                            continue
                        }
                        var g, y = a(s.substr(1, s.length - 2));
                        if (y) {
                            g = e.document.createProcessingInstruction("timestamp", y), h.appendChild(g);
                            continue
                        }
                        var _ = s.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
                        if (!_) continue;
                        if (!(g = r(_[1], _[3]))) continue;
                        if (!n(h, g)) continue;
                        if (_[2]) {
                            var v = _[2].split(".");
                            v.forEach((function(e) {
                                var t = /^bg_/.test(e),
                                    i = t ? e.slice(3) : e;
                                if (d.hasOwnProperty(i)) {
                                    var n = t ? "background-color" : "color",
                                        r = d[i];
                                    g.style[n] = r
                                }
                            })), g.className = v.join(" ")
                        }
                        m.push(_[1]), h.appendChild(g), h = g
                    }
                return l
            }
            var g = [
                [1470, 1470],
                [1472, 1472],
                [1475, 1475],
                [1478, 1478],
                [1488, 1514],
                [1520, 1524],
                [1544, 1544],
                [1547, 1547],
                [1549, 1549],
                [1563, 1563],
                [1566, 1610],
                [1645, 1647],
                [1649, 1749],
                [1765, 1766],
                [1774, 1775],
                [1786, 1805],
                [1807, 1808],
                [1810, 1839],
                [1869, 1957],
                [1969, 1969],
                [1984, 2026],
                [2036, 2037],
                [2042, 2042],
                [2048, 2069],
                [2074, 2074],
                [2084, 2084],
                [2088, 2088],
                [2096, 2110],
                [2112, 2136],
                [2142, 2142],
                [2208, 2208],
                [2210, 2220],
                [8207, 8207],
                [64285, 64285],
                [64287, 64296],
                [64298, 64310],
                [64312, 64316],
                [64318, 64318],
                [64320, 64321],
                [64323, 64324],
                [64326, 64449],
                [64467, 64829],
                [64848, 64911],
                [64914, 64967],
                [65008, 65020],
                [65136, 65140],
                [65142, 65276],
                [67584, 67589],
                [67592, 67592],
                [67594, 67637],
                [67639, 67640],
                [67644, 67644],
                [67647, 67669],
                [67671, 67679],
                [67840, 67867],
                [67872, 67897],
                [67903, 67903],
                [67968, 68023],
                [68030, 68031],
                [68096, 68096],
                [68112, 68115],
                [68117, 68119],
                [68121, 68147],
                [68160, 68167],
                [68176, 68184],
                [68192, 68223],
                [68352, 68405],
                [68416, 68437],
                [68440, 68466],
                [68472, 68479],
                [68608, 68680],
                [126464, 126467],
                [126469, 126495],
                [126497, 126498],
                [126500, 126500],
                [126503, 126503],
                [126505, 126514],
                [126516, 126519],
                [126521, 126521],
                [126523, 126523],
                [126530, 126530],
                [126535, 126535],
                [126537, 126537],
                [126539, 126539],
                [126541, 126543],
                [126545, 126546],
                [126548, 126548],
                [126551, 126551],
                [126553, 126553],
                [126555, 126555],
                [126557, 126557],
                [126559, 126559],
                [126561, 126562],
                [126564, 126564],
                [126567, 126570],
                [126572, 126578],
                [126580, 126583],
                [126585, 126588],
                [126590, 126590],
                [126592, 126601],
                [126603, 126619],
                [126625, 126627],
                [126629, 126633],
                [126635, 126651],
                [1114109, 1114109]
            ];

            function y(e) {
                for (var t = 0; t < g.length; t++) {
                    var i = g[t];
                    if (e >= i[0] && e <= i[1]) return !0
                }
                return !1
            }

            function _(e) {
                var t = [],
                    i = "";
                if (!e || !e.childNodes) return "ltr";

                function n(e, t) {
                    for (var i = t.childNodes.length - 1; i >= 0; i--) e.push(t.childNodes[i])
                }

                function r(e) {
                    if (!e || !e.length) return null;
                    var t = e.pop(),
                        i = t.textContent || t.innerText;
                    if (i) {
                        var s = i.match(/^.*(\n|\r)/);
                        return s ? (e.length = 0, s[0]) : i
                    }
                    return "ruby" === t.tagName ? r(e) : t.childNodes ? (n(e, t), r(e)) : void 0
                }
                for (n(t, e); i = r(t);)
                    for (var s = 0; s < i.length; s++)
                        if (y(i.charCodeAt(s))) return "rtl";
                return "ltr"
            }

            function v() {}

            function b(e, t, i) {
                v.call(this), this.cue = t, this.cueDiv = m(e, t.text);
                var n = {
                    color: "rgba(255, 255, 255, 1)",
                    backgroundColor: "rgba(0, 0, 0, 0.8)",
                    position: "relative",
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    display: "inline",
                    writingMode: "" === t.vertical ? "horizontal-tb" : "lr" === t.vertical ? "vertical-lr" : "vertical-rl",
                    unicodeBidi: "plaintext"
                };
                this.applyStyles(n, this.cueDiv), this.div = e.document.createElement("div"), n = {
                    direction: _(this.cueDiv),
                    writingMode: "" === t.vertical ? "horizontal-tb" : "lr" === t.vertical ? "vertical-lr" : "vertical-rl",
                    unicodeBidi: "plaintext",
                    textAlign: "middle" === t.align ? "center" : t.align,
                    font: i.font,
                    whiteSpace: "pre-line",
                    position: "absolute"
                }, this.applyStyles(n), this.div.appendChild(this.cueDiv);
                var r = 0;
                switch (t.positionAlign) {
                    case "start":
                        r = t.position;
                        break;
                    case "center":
                        r = t.position - t.size / 2;
                        break;
                    case "end":
                        r = t.position - t.size
                }
                "" === t.vertical ? this.applyStyles({
                    left: this.formatStyle(r, "%"),
                    width: this.formatStyle(t.size, "%")
                }) : this.applyStyles({
                    top: this.formatStyle(r, "%"),
                    height: this.formatStyle(t.size, "%")
                }), this.move = function(e) {
                    this.applyStyles({
                        top: this.formatStyle(e.top, "px"),
                        bottom: this.formatStyle(e.bottom, "px"),
                        left: this.formatStyle(e.left, "px"),
                        right: this.formatStyle(e.right, "px"),
                        height: this.formatStyle(e.height, "px"),
                        width: this.formatStyle(e.width, "px")
                    })
                }
            }

            function T(e) {
                var t, i, n, r;
                if (e.div) {
                    i = e.div.offsetHeight, n = e.div.offsetWidth, r = e.div.offsetTop;
                    var s = (s = e.div.childNodes) && (s = s[0]) && s.getClientRects && s.getClientRects();
                    e = e.div.getBoundingClientRect(), t = s ? Math.max(s[0] && s[0].height || 0, e.height / s.length) : 0
                }
                this.left = e.left, this.right = e.right, this.top = e.top || r, this.height = e.height || i, this.bottom = e.bottom || r + (e.height || i), this.width = e.width || n, this.lineHeight = void 0 !== t ? t : e.lineHeight
            }

            function x(e, t, i, n) {
                var r = new T(t),
                    s = t.cue,
                    a = function(e) {
                        if ("number" == typeof e.line && (e.snapToLines || e.line >= 0 && e.line <= 100)) return e.line;
                        if (!e.track || !e.track.textTrackList || !e.track.textTrackList.mediaElement) return -1;
                        for (var t = e.track, i = t.textTrackList, n = 0, r = 0; r < i.length && i[r] !== t; r++) "showing" === i[r].mode && n++;
                        return -1 * ++n
                    }(s),
                    o = [];
                if (s.snapToLines) {
                    var l;
                    switch (s.vertical) {
                        case "":
                            o = ["+y", "-y"], l = "height";
                            break;
                        case "rl":
                            o = ["+x", "-x"], l = "width";
                            break;
                        case "lr":
                            o = ["-x", "+x"], l = "width"
                    }
                    var h = r.lineHeight,
                        c = h * Math.round(a),
                        u = i[l] + h,
                        d = o[0];
                    Math.abs(c) > u && (c = c < 0 ? -1 : 1, c *= Math.ceil(u / h) * h), a < 0 && (c += "" === s.vertical ? i.height : i.width, o = o.reverse()), r.move(d, c)
                } else {
                    var p = r.lineHeight / i.height * 100;
                    switch (s.lineAlign) {
                        case "center":
                            a -= p / 2;
                            break;
                        case "end":
                            a -= p
                    }
                    switch (s.vertical) {
                        case "":
                            t.applyStyles({
                                top: t.formatStyle(a, "%")
                            });
                            break;
                        case "rl":
                            t.applyStyles({
                                left: t.formatStyle(a, "%")
                            });
                            break;
                        case "lr":
                            t.applyStyles({
                                right: t.formatStyle(a, "%")
                            })
                    }
                    o = ["+y", "-x", "+x", "-y"], r = new T(t)
                }
                var f = function(e, t) {
                    for (var r, s = new T(e), a = 1, o = 0; o < t.length; o++) {
                        for (; e.overlapsOppositeAxis(i, t[o]) || e.within(i) && e.overlapsAny(n);) e.move(t[o]);
                        if (e.within(i)) return e;
                        var l = e.intersectPercentage(i);
                        a > l && (r = new T(e), a = l), e = new T(s)
                    }
                    return r || s
                }(r, o);
                t.move(f.toCSSCompatValues(i))
            }

            function w() {}
            v.prototype.applyStyles = function(e, t) {
                for (var i in t = t || this.div, e) e.hasOwnProperty(i) && (t.style[i] = e[i])
            }, v.prototype.formatStyle = function(e, t) {
                return 0 === e ? 0 : e + t
            }, b.prototype = r(v.prototype), b.prototype.constructor = b, T.prototype.move = function(e, t) {
                switch (t = void 0 !== t ? t : this.lineHeight, e) {
                    case "+x":
                        this.left += t, this.right += t;
                        break;
                    case "-x":
                        this.left -= t, this.right -= t;
                        break;
                    case "+y":
                        this.top += t, this.bottom += t;
                        break;
                    case "-y":
                        this.top -= t, this.bottom -= t
                }
            }, T.prototype.overlaps = function(e) {
                return this.left < e.right && this.right > e.left && this.top < e.bottom && this.bottom > e.top
            }, T.prototype.overlapsAny = function(e) {
                for (var t = 0; t < e.length; t++)
                    if (this.overlaps(e[t])) return !0;
                return !1
            }, T.prototype.within = function(e) {
                return this.top >= e.top && this.bottom <= e.bottom && this.left >= e.left && this.right <= e.right
            }, T.prototype.overlapsOppositeAxis = function(e, t) {
                switch (t) {
                    case "+x":
                        return this.left < e.left;
                    case "-x":
                        return this.right > e.right;
                    case "+y":
                        return this.top < e.top;
                    case "-y":
                        return this.bottom > e.bottom
                }
            }, T.prototype.intersectPercentage = function(e) {
                return Math.max(0, Math.min(this.right, e.right) - Math.max(this.left, e.left)) * Math.max(0, Math.min(this.bottom, e.bottom) - Math.max(this.top, e.top)) / (this.height * this.width)
            }, T.prototype.toCSSCompatValues = function(e) {
                return {
                    top: this.top - e.top,
                    bottom: e.bottom - this.bottom,
                    left: this.left - e.left,
                    right: e.right - this.right,
                    height: this.height,
                    width: this.width
                }
            }, T.getSimpleBoxPosition = function(e) {
                var t = e.div ? e.div.offsetHeight : e.tagName ? e.offsetHeight : 0,
                    i = e.div ? e.div.offsetWidth : e.tagName ? e.offsetWidth : 0,
                    n = e.div ? e.div.offsetTop : e.tagName ? e.offsetTop : 0;
                return {
                    left: (e = e.div ? e.div.getBoundingClientRect() : e.tagName ? e.getBoundingClientRect() : e).left,
                    right: e.right,
                    top: e.top || n,
                    height: e.height || t,
                    bottom: e.bottom || n + (e.height || t),
                    width: e.width || i
                }
            }, w.StringDecoder = function() {
                return {
                    decode: function(e) {
                        if (!e) return "";
                        if ("string" != typeof e) throw new Error("Error - expected string data.");
                        return decodeURIComponent(encodeURIComponent(e))
                    }
                }
            }, w.convertCueToDOMTree = function(e, t) {
                return e && t ? m(e, t) : null
            };
            w.processCues = function(e, t, i) {
                if (!e || !t || !i) return null;
                for (; i.firstChild;) i.removeChild(i.firstChild);
                var n = e.document.createElement("div");
                if (n.style.position = "absolute", n.style.left = "0", n.style.right = "0", n.style.top = "0", n.style.bottom = "0", n.style.margin = "1.5%", i.appendChild(n), function(e) {
                        for (var t = 0; t < e.length; t++)
                            if (e[t].hasBeenReset || !e[t].displayState) return !0;
                        return !1
                    }(t)) {
                    var r = [],
                        s = T.getSimpleBoxPosition(n),
                        a = {
                            font: Math.round(.05 * s.height * 100) / 100 + "px sans-serif"
                        };
                    ! function() {
                        for (var i, o, l = 0; l < t.length; l++) o = t[l], i = new b(e, o, a), n.appendChild(i.div), x(0, i, s, r), o.displayState = i.div, r.push(T.getSimpleBoxPosition(i))
                    }()
                } else
                    for (var o = 0; o < t.length; o++) n.appendChild(t[o].displayState)
            }, w.Parser = function(e, t, i) {
                i || (i = t, t = {}), t || (t = {}), this.window = e, this.vttjs = t, this.state = "INITIAL", this.buffer = "", this.decoder = i || new TextDecoder("utf8"), this.regionList = []
            }, w.Parser.prototype = {
                reportOrThrowError: function(e) {
                    if (!(e instanceof s)) throw e;
                    this.onparsingerror && this.onparsingerror(e)
                },
                parse: function(e) {
                    var t = this;

                    function i() {
                        for (var e = t.buffer, i = 0; i < e.length && "\r" !== e[i] && "\n" !== e[i];) ++i;
                        var n = e.substr(0, i);
                        return "\r" === e[i] && ++i, "\n" === e[i] && ++i, t.buffer = e.substr(i), n
                    }

                    function n(e) {
                        e.match(/X-TIMESTAMP-MAP/) ? l(e, (function(e, i) {
                            if ("X-TIMESTAMP-MAP" === e) ! function(e) {
                                var i = new o;
                                l(e, (function(e, t) {
                                    switch (e) {
                                        case "MPEGT":
                                            i.integer(e + "S", t);
                                            break;
                                        case "LOCA":
                                            i.set(e + "L", a(t))
                                    }
                                }), /[^\d]:/, /,/), t.ontimestampmap && t.ontimestampmap({
                                    MPEGTS: i.get("MPEGTS"),
                                    LOCAL: i.get("LOCAL")
                                })
                            }(i)
                        }), /=/) : l(e, (function(e, i) {
                            if ("Region" === e) ! function(e) {
                                var i = new o;
                                if (l(e, (function(e, t) {
                                        switch (e) {
                                            case "id":
                                                i.set(e, t);
                                                break;
                                            case "width":
                                                i.percent(e, t);
                                                break;
                                            case "lines":
                                                i.integer(e, t);
                                                break;
                                            case "regionanchor":
                                            case "viewportanchor":
                                                var n = t.split(",");
                                                if (2 !== n.length) break;
                                                var r = new o;
                                                if (r.percent("x", n[0]), r.percent("y", n[1]), !r.has("x") || !r.has("y")) break;
                                                i.set(e + "X", r.get("x")), i.set(e + "Y", r.get("y"));
                                                break;
                                            case "scroll":
                                                i.alt(e, t, ["up"])
                                        }
                                    }), /=/, /\s/), i.has("id")) {
                                    var n = new(t.vttjs.VTTRegion || t.window.VTTRegion);
                                    n.width = i.get("width", 100), n.lines = i.get("lines", 3), n.regionAnchorX = i.get("regionanchorX", 0), n.regionAnchorY = i.get("regionanchorY", 100), n.viewportAnchorX = i.get("viewportanchorX", 0), n.viewportAnchorY = i.get("viewportanchorY", 100), n.scroll = i.get("scroll", ""), t.onregion && t.onregion(n), t.regionList.push({
                                        id: i.get("id"),
                                        region: n
                                    })
                                }
                            }(i)
                        }), /:/)
                    }
                    e && (t.buffer += t.decoder.decode(e, {
                        stream: !0
                    }));
                    try {
                        var r;
                        if ("INITIAL" === t.state) {
                            if (!/\r\n|\n/.test(t.buffer)) return this;
                            var c = (r = i()).match(/^WEBVTT([ \t].*)?$/);
                            if (!c || !c[0]) throw new s(s.Errors.BadSignature);
                            t.state = "HEADER"
                        }
                        for (var u = !1; t.buffer;) {
                            if (!/\r\n|\n/.test(t.buffer)) return this;
                            switch (u ? u = !1 : r = i(), t.state) {
                                case "HEADER":
                                    /:/.test(r) ? n(r) : r || (t.state = "ID");
                                    continue;
                                case "NOTE":
                                    r || (t.state = "ID");
                                    continue;
                                case "ID":
                                    if (/^NOTE($|[ \t])/.test(r)) {
                                        t.state = "NOTE";
                                        break
                                    }
                                    if (!r) continue;
                                    t.cue = new(t.vttjs.VTTCue || t.window.VTTCue)(0, 0, "");
                                    try {
                                        t.cue.align = "center"
                                    } catch (e) {
                                        t.cue.align = "middle"
                                    }
                                    if (t.state = "CUE", -1 === r.indexOf("--\x3e")) {
                                        t.cue.id = r;
                                        continue
                                    }
                                case "CUE":
                                    try {
                                        h(r, t.cue, t.regionList)
                                    } catch (e) {
                                        t.reportOrThrowError(e), t.cue = null, t.state = "BADCUE";
                                        continue
                                    }
                                    t.state = "CUETEXT";
                                    continue;
                                case "CUETEXT":
                                    var d = -1 !== r.indexOf("--\x3e");
                                    if (!r || d && (u = !0)) {
                                        t.oncue && t.oncue(t.cue), t.cue = null, t.state = "ID";
                                        continue
                                    }
                                    t.cue.text && (t.cue.text += "\n"), t.cue.text += r.replace(/\u2028/g, "\n").replace(/u2029/g, "\n");
                                    continue;
                                case "BADCUE":
                                    r || (t.state = "ID");
                                    continue
                            }
                        }
                    } catch (e) {
                        t.reportOrThrowError(e), "CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE"
                    }
                    return this
                },
                flush: function() {
                    var e = this;
                    try {
                        if (e.buffer += e.decoder.decode(), (e.cue || "HEADER" === e.state) && (e.buffer += "\n\n", e.parse()), "INITIAL" === e.state) throw new s(s.Errors.BadSignature)
                    } catch (t) {
                        e.reportOrThrowError(t)
                    }
                    return e.onflush && e.onflush(), this
                }
            }, e.exports = w
        },
        9038: e => {
            var t = "auto",
                i = {
                    "": 1,
                    lr: 1,
                    rl: 1
                },
                n = {
                    start: 1,
                    center: 1,
                    end: 1,
                    left: 1,
                    right: 1,
                    auto: 1,
                    "line-left": 1,
                    "line-right": 1
                };

            function r(e) {
                return "string" == typeof e && (!!n[e.toLowerCase()] && e.toLowerCase())
            }

            function s(e, n, s) {
                this.hasBeenReset = !1;
                var a = "",
                    o = !1,
                    l = e,
                    h = n,
                    c = s,
                    u = null,
                    d = "",
                    p = !0,
                    f = "auto",
                    m = "start",
                    g = "auto",
                    y = "auto",
                    _ = 100,
                    v = "center";
                Object.defineProperties(this, {
                    id: {
                        enumerable: !0,
                        get: function() {
                            return a
                        },
                        set: function(e) {
                            a = "" + e
                        }
                    },
                    pauseOnExit: {
                        enumerable: !0,
                        get: function() {
                            return o
                        },
                        set: function(e) {
                            o = !!e
                        }
                    },
                    startTime: {
                        enumerable: !0,
                        get: function() {
                            return l
                        },
                        set: function(e) {
                            if ("number" != typeof e) throw new TypeError("Start time must be set to a number.");
                            l = e, this.hasBeenReset = !0
                        }
                    },
                    endTime: {
                        enumerable: !0,
                        get: function() {
                            return h
                        },
                        set: function(e) {
                            if ("number" != typeof e) throw new TypeError("End time must be set to a number.");
                            h = e, this.hasBeenReset = !0
                        }
                    },
                    text: {
                        enumerable: !0,
                        get: function() {
                            return c
                        },
                        set: function(e) {
                            c = "" + e, this.hasBeenReset = !0
                        }
                    },
                    region: {
                        enumerable: !0,
                        get: function() {
                            return u
                        },
                        set: function(e) {
                            u = e, this.hasBeenReset = !0
                        }
                    },
                    vertical: {
                        enumerable: !0,
                        get: function() {
                            return d
                        },
                        set: function(e) {
                            var t = function(e) {
                                return "string" == typeof e && !!i[e.toLowerCase()] && e.toLowerCase()
                            }(e);
                            if (!1 === t) throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
                            d = t, this.hasBeenReset = !0
                        }
                    },
                    snapToLines: {
                        enumerable: !0,
                        get: function() {
                            return p
                        },
                        set: function(e) {
                            p = !!e, this.hasBeenReset = !0
                        }
                    },
                    line: {
                        enumerable: !0,
                        get: function() {
                            return f
                        },
                        set: function(e) {
                            if ("number" != typeof e && e !== t) throw new SyntaxError("Line: an invalid number or illegal string was specified.");
                            f = e, this.hasBeenReset = !0
                        }
                    },
                    lineAlign: {
                        enumerable: !0,
                        get: function() {
                            return m
                        },
                        set: function(e) {
                            var t = r(e);
                            t ? (m = t, this.hasBeenReset = !0) : console.warn("lineAlign: an invalid or illegal string was specified.")
                        }
                    },
                    position: {
                        enumerable: !0,
                        get: function() {
                            return g
                        },
                        set: function(e) {
                            if (e < 0 || e > 100) throw new Error("Position must be between 0 and 100.");
                            g = e, this.hasBeenReset = !0
                        }
                    },
                    positionAlign: {
                        enumerable: !0,
                        get: function() {
                            return y
                        },
                        set: function(e) {
                            var t = r(e);
                            t ? (y = t, this.hasBeenReset = !0) : console.warn("positionAlign: an invalid or illegal string was specified.")
                        }
                    },
                    size: {
                        enumerable: !0,
                        get: function() {
                            return _
                        },
                        set: function(e) {
                            if (e < 0 || e > 100) throw new Error("Size must be between 0 and 100.");
                            _ = e, this.hasBeenReset = !0
                        }
                    },
                    align: {
                        enumerable: !0,
                        get: function() {
                            return v
                        },
                        set: function(e) {
                            var t = r(e);
                            if (!t) throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
                            v = t, this.hasBeenReset = !0
                        }
                    }
                }), this.displayState = void 0
            }
            s.prototype.getCueAsHTML = function() {
                return WebVTT.convertCueToDOMTree(window, this.text)
            }, e.exports = s
        },
        1058: e => {
            var t = {
                "": !0,
                up: !0
            };

            function i(e) {
                return "number" == typeof e && e >= 0 && e <= 100
            }
            e.exports = function() {
                var e = 100,
                    n = 3,
                    r = 0,
                    s = 100,
                    a = 0,
                    o = 100,
                    l = "";
                Object.defineProperties(this, {
                    width: {
                        enumerable: !0,
                        get: function() {
                            return e
                        },
                        set: function(t) {
                            if (!i(t)) throw new Error("Width must be between 0 and 100.");
                            e = t
                        }
                    },
                    lines: {
                        enumerable: !0,
                        get: function() {
                            return n
                        },
                        set: function(e) {
                            if ("number" != typeof e) throw new TypeError("Lines must be set to a number.");
                            n = e
                        }
                    },
                    regionAnchorY: {
                        enumerable: !0,
                        get: function() {
                            return s
                        },
                        set: function(e) {
                            if (!i(e)) throw new Error("RegionAnchorX must be between 0 and 100.");
                            s = e
                        }
                    },
                    regionAnchorX: {
                        enumerable: !0,
                        get: function() {
                            return r
                        },
                        set: function(e) {
                            if (!i(e)) throw new Error("RegionAnchorY must be between 0 and 100.");
                            r = e
                        }
                    },
                    viewportAnchorY: {
                        enumerable: !0,
                        get: function() {
                            return o
                        },
                        set: function(e) {
                            if (!i(e)) throw new Error("ViewportAnchorY must be between 0 and 100.");
                            o = e
                        }
                    },
                    viewportAnchorX: {
                        enumerable: !0,
                        get: function() {
                            return a
                        },
                        set: function(e) {
                            if (!i(e)) throw new Error("ViewportAnchorX must be between 0 and 100.");
                            a = e
                        }
                    },
                    scroll: {
                        enumerable: !0,
                        get: function() {
                            return l
                        },
                        set: function(e) {
                            var i = function(e) {
                                return "string" == typeof e && !!t[e.toLowerCase()] && e.toLowerCase()
                            }(e);
                            !1 === i ? console.warn("Scroll: an invalid or illegal string was specified.") : l = i
                        }
                    }
                })
            }
        },
        8746: function(e) {
            e.exports = function() {
                var e = 0;

                function t(t) {
                    return "__private_" + e++ + "_" + t
                }

                function i(e, t) {
                    if (!Object.prototype.hasOwnProperty.call(e, t)) throw new TypeError("attempted to use private field on non-instance");
                    return e
                }

                function n() {}
                n.prototype = {
                    on: function(e, t, i) {
                        var n = this.e || (this.e = {});
                        return (n[e] || (n[e] = [])).push({
                            fn: t,
                            ctx: i
                        }), this
                    },
                    once: function(e, t, i) {
                        var n = this;

                        function r() {
                            n.off(e, r), t.apply(i, arguments)
                        }
                        return r._ = t, this.on(e, r, i)
                    },
                    emit: function(e) {
                        for (var t = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[e] || []).slice(), n = 0, r = i.length; n < r; n++) i[n].fn.apply(i[n].ctx, t);
                        return this
                    },
                    off: function(e, t) {
                        var i = this.e || (this.e = {}),
                            n = i[e],
                            r = [];
                        if (n && t)
                            for (var s = 0, a = n.length; s < a; s++) n[s].fn !== t && n[s].fn._ !== t && r.push(n[s]);
                        return r.length ? i[e] = r : delete i[e], this
                    }
                };
                var r = n;
                r.TinyEmitter = n;
                var s, a = "virtualscroll",
                    o = t("options"),
                    l = t("el"),
                    h = t("emitter"),
                    c = t("event"),
                    u = t("touchStart"),
                    d = t("bodyTouchAction");
                return function() {
                    function e(e) {
                        var t = this;
                        Object.defineProperty(this, o, {
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, l, {
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, h, {
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, c, {
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, u, {
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, d, {
                            writable: !0,
                            value: void 0
                        }), this._onWheel = function(e) {
                            var n = i(t, o)[o],
                                r = i(t, c)[c];
                            r.deltaX = e.wheelDeltaX || -1 * e.deltaX, r.deltaY = e.wheelDeltaY || -1 * e.deltaY, s.isFirefox && 1 === e.deltaMode && (r.deltaX *= n.firefoxMultiplier, r.deltaY *= n.firefoxMultiplier), r.deltaX *= n.mouseMultiplier, r.deltaY *= n.mouseMultiplier, t._notify(e)
                        }, this._onMouseWheel = function(e) {
                            var n = i(t, c)[c];
                            n.deltaX = e.wheelDeltaX ? e.wheelDeltaX : 0, n.deltaY = e.wheelDeltaY ? e.wheelDeltaY : e.wheelDelta, t._notify(e)
                        }, this._onTouchStart = function(e) {
                            var n = e.targetTouches ? e.targetTouches[0] : e;
                            i(t, u)[u].x = n.pageX, i(t, u)[u].y = n.pageY
                        }, this._onTouchMove = function(e) {
                            var n = i(t, o)[o];
                            n.preventTouch && !e.target.classList.contains(n.unpreventTouchClass) && e.preventDefault();
                            var r = i(t, c)[c],
                                s = e.targetTouches ? e.targetTouches[0] : e;
                            r.deltaX = (s.pageX - i(t, u)[u].x) * n.touchMultiplier, r.deltaY = (s.pageY - i(t, u)[u].y) * n.touchMultiplier, i(t, u)[u].x = s.pageX, i(t, u)[u].y = s.pageY, t._notify(e)
                        }, this._onKeyDown = function(e) {
                            var n = i(t, c)[c];
                            n.deltaX = n.deltaY = 0;
                            var r = window.innerHeight - 40;
                            switch (e.keyCode) {
                                case 37:
                                case 38:
                                    n.deltaY = i(t, o)[o].keyStep;
                                    break;
                                case 39:
                                case 40:
                                    n.deltaY = -i(t, o)[o].keyStep;
                                    break;
                                case 32:
                                    n.deltaY = r * (e.shiftKey ? 1 : -1);
                                    break;
                                default:
                                    return
                            }
                            t._notify(e)
                        }, i(this, l)[l] = window, e && e.el && (i(this, l)[l] = e.el, delete e.el), s || (s = {
                            hasWheelEvent: "onwheel" in document,
                            hasMouseWheelEvent: "onmousewheel" in document,
                            hasTouch: "ontouchstart" in document,
                            hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
                            hasPointer: !!window.navigator.msPointerEnabled,
                            hasKeyDown: "onkeydown" in document,
                            isFirefox: navigator.userAgent.indexOf("Firefox") > -1
                        }), i(this, o)[o] = Object.assign({
                            mouseMultiplier: 1,
                            touchMultiplier: 2,
                            firefoxMultiplier: 15,
                            keyStep: 120,
                            preventTouch: !1,
                            unpreventTouchClass: "vs-touchmove-allowed",
                            useKeyboard: !0,
                            useTouch: !0
                        }, e), i(this, h)[h] = new r, i(this, c)[c] = {
                            y: 0,
                            x: 0,
                            deltaX: 0,
                            deltaY: 0
                        }, i(this, u)[u] = {
                            x: null,
                            y: null
                        }, i(this, d)[d] = null, void 0 !== i(this, o)[o].passive && (this.listenerOptions = {
                            passive: i(this, o)[o].passive
                        })
                    }
                    var t = e.prototype;
                    return t._notify = function(e) {
                        var t = i(this, c)[c];
                        t.x += t.deltaX, t.y += t.deltaY, i(this, h)[h].emit(a, {
                            x: t.x,
                            y: t.y,
                            deltaX: t.deltaX,
                            deltaY: t.deltaY,
                            originalEvent: e
                        })
                    }, t._bind = function() {
                        s.hasWheelEvent && i(this, l)[l].addEventListener("wheel", this._onWheel, this.listenerOptions), s.hasMouseWheelEvent && i(this, l)[l].addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions), s.hasTouch && i(this, o)[o].useTouch && (i(this, l)[l].addEventListener("touchstart", this._onTouchStart, this.listenerOptions), i(this, l)[l].addEventListener("touchmove", this._onTouchMove, this.listenerOptions)), s.hasPointer && s.hasTouchWin && (i(this, d)[d] = document.body.style.msTouchAction, document.body.style.msTouchAction = "none", i(this, l)[l].addEventListener("MSPointerDown", this._onTouchStart, !0), i(this, l)[l].addEventListener("MSPointerMove", this._onTouchMove, !0)), s.hasKeyDown && i(this, o)[o].useKeyboard && document.addEventListener("keydown", this._onKeyDown)
                    }, t._unbind = function() {
                        s.hasWheelEvent && i(this, l)[l].removeEventListener("wheel", this._onWheel), s.hasMouseWheelEvent && i(this, l)[l].removeEventListener("mousewheel", this._onMouseWheel), s.hasTouch && (i(this, l)[l].removeEventListener("touchstart", this._onTouchStart), i(this, l)[l].removeEventListener("touchmove", this._onTouchMove)), s.hasPointer && s.hasTouchWin && (document.body.style.msTouchAction = i(this, d)[d], i(this, l)[l].removeEventListener("MSPointerDown", this._onTouchStart, !0), i(this, l)[l].removeEventListener("MSPointerMove", this._onTouchMove, !0)), s.hasKeyDown && i(this, o)[o].useKeyboard && document.removeEventListener("keydown", this._onKeyDown)
                    }, t.on = function(e, t) {
                        i(this, h)[h].on(a, e, t);
                        var n = i(this, h)[h].e;
                        n && n[a] && 1 === n[a].length && this._bind()
                    }, t.off = function(e, t) {
                        i(this, h)[h].off(a, e, t);
                        var n = i(this, h)[h].e;
                        (!n[a] || n[a].length <= 0) && this._unbind()
                    }, t.destroy = function() {
                        i(this, h)[h].off(), this._unbind()
                    }, e
                }()
            }()
        },
        9894: e => {
            function t() {
                return e.exports = t = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var i = arguments[t];
                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
                    }
                    return e
                }, e.exports.__esModule = !0, e.exports.default = e.exports, t.apply(this, arguments)
            }
            e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
        },
        9961: (e, t, i) => {
            "use strict";
            i.d(t, {
                Z: () => h
            });
            var n = i(438),
                r = i(8746);

            function s() {
                return s = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var i = arguments[t];
                        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
                    }
                    return e
                }, s.apply(this, arguments)
            }

            function a(e, t) {
                let i = e % t;
                return (t > 0 && i < 0 || t < 0 && i > 0) && (i += t), i
            }
            const o = ["duration", "easing"];
            class l {
                to(e, t = {}) {
                    let {
                        duration: i = 1,
                        easing: n = (e => e)
                    } = t, r = function(e, t) {
                        if (null == e) return {};
                        var i, n, r = {},
                            s = Object.keys(e);
                        for (n = 0; n < s.length; n++) t.indexOf(i = s[n]) >= 0 || (r[i] = e[i]);
                        return r
                    }(t, o);
                    this.target = e, this.fromKeys = s({}, r), this.toKeys = s({}, r), this.keys = Object.keys(s({}, r)), this.keys.forEach((t => {
                        this.fromKeys[t] = e[t]
                    })), this.duration = i, this.easing = n, this.currentTime = 0, this.isRunning = !0
                }
                stop() {
                    this.isRunning = !1
                }
                raf(e) {
                    if (!this.isRunning) return;
                    this.currentTime = Math.min(this.currentTime + e, this.duration);
                    const t = this.progress >= 1 ? 1 : this.easing(this.progress);
                    this.keys.forEach((e => {
                        const i = this.fromKeys[e];
                        this.target[e] = i + (this.toKeys[e] - i) * t
                    })), 1 === t && this.stop()
                }
                get progress() {
                    return this.currentTime / this.duration
                }
            }
            class h extends n.TinyEmitter {
                constructor({
                    duration: e = 1.2,
                    easing: t = (e => Math.min(1, 1.001 - Math.pow(2, -10 * e))),
                    smooth: i = !0,
                    mouseMultiplier: n = 1,
                    smoothTouch: s = !1,
                    touchMultiplier: a = 2,
                    direction: o = "vertical",
                    gestureDirection: h = "vertical",
                    infinite: c = !1,
                    wrapper: u = window,
                    content: d = document.body
                } = {}) {
                    var p, f, m;
                    super(), this.onWindowResize = () => {
                        this.wrapperWidth = window.innerWidth, this.wrapperHeight = window.innerHeight
                    }, this.onWrapperResize = ([e]) => {
                        if (e) {
                            const t = e.contentRect;
                            this.wrapperWidth = t.width, this.wrapperHeight = t.height
                        }
                    }, this.onContentResize = ([e]) => {
                        if (e) {
                            const t = e.contentRect;
                            this.contentWidth = t.width, this.contentHeight = t.height
                        }
                    }, this.onVirtualScroll = ({
                        deltaY: e,
                        deltaX: t,
                        originalEvent: i
                    }) => {
                        if ("vertical" === this.gestureDirection && 0 === e || "horizontal" === this.gestureDirection && 0 === t) return;
                        const n = !!i.composedPath().find((e => e.hasAttribute && e.hasAttribute("data-lenis-prevent")));
                        if (i.ctrlKey || n) return;
                        if (this.smooth = i.changedTouches ? this.smoothTouch : this.options.smooth, this.stopped) return void i.preventDefault();
                        if (!this.smooth) return;
                        if (4 === i.buttons) return;
                        this.smooth && i.preventDefault();
                        let r = 0;
                        r = "both" === this.gestureDirection ? t + e : "horizontal" === this.gestureDirection ? t : e, this.targetScroll -= r, this.scrollTo(this.targetScroll)
                    }, this.onScroll = e => {
                        this.isScrolling && this.smooth || (this.targetScroll = this.scroll = this.lastScroll = this.wrapperNode[this.scrollProperty], this.notify())
                    }, window.lenisVersion = "0.2.28", this.options = {
                        duration: e,
                        easing: t,
                        smooth: i,
                        mouseMultiplier: n,
                        smoothTouch: s,
                        touchMultiplier: a,
                        direction: o,
                        gestureDirection: h,
                        infinite: c,
                        wrapper: u,
                        content: d
                    }, this.duration = e, this.easing = t, this.smooth = i, this.mouseMultiplier = n, this.smoothTouch = s, this.touchMultiplier = a, this.direction = o, this.gestureDirection = h, this.infinite = c, this.wrapperNode = u, this.contentNode = d, this.wrapperNode.addEventListener("scroll", this.onScroll), this.wrapperNode === window ? (this.wrapperNode.addEventListener("resize", this.onWindowResize), this.onWindowResize()) : (this.wrapperHeight = this.wrapperNode.offsetHeight, this.wrapperWidth = this.wrapperNode.offsetWidth, this.wrapperObserver = new ResizeObserver(this.onWrapperResize), this.wrapperObserver.observe(this.wrapperNode)), this.contentHeight = this.contentNode.offsetHeight, this.contentWidth = this.contentNode.offsetWidth, this.contentObserver = new ResizeObserver(this.onContentResize), this.contentObserver.observe(this.contentNode), this.targetScroll = this.scroll = this.lastScroll = this.wrapperNode[this.scrollProperty], this.animate = new l;
                    const g = (null == (p = navigator) || null == (f = p.userAgentData) ? void 0 : f.platform) || (null == (m = navigator) ? void 0 : m.platform) || "unknown";
                    this.virtualScroll = new r({
                        el: this.wrapperNode,
                        firefoxMultiplier: 50,
                        mouseMultiplier: this.mouseMultiplier * (g.includes("Win") || g.includes("Linux") ? .84 : .4),
                        touchMultiplier: this.touchMultiplier,
                        passive: !1,
                        useKeyboard: !1,
                        useTouch: !0
                    }), this.virtualScroll.on(this.onVirtualScroll)
                }
                get scrollProperty() {
                    let e;
                    return e = this.wrapperNode === window ? "horizontal" === this.direction ? "scrollX" : "scrollY" : "horizontal" === this.direction ? "scrollLeft" : "scrollTop", e
                }
                start() {
                    let e = this.wrapperNode;
                    this.wrapperNode === window && (e = document.documentElement), e.classList.remove("lenis-stopped"), this.stopped = !1
                }
                stop() {
                    let e = this.wrapperNode;
                    this.wrapperNode === window && (e = document.documentElement), e.classList.add("lenis-stopped"), this.stopped = !0, this.animate.stop()
                }
                destroy() {
                    var e;
                    this.wrapperNode === window && this.wrapperNode.removeEventListener("resize", this.onWindowResize), this.wrapperNode.removeEventListener("scroll", this.onScroll), this.virtualScroll.destroy(), null == (e = this.wrapperObserver) || e.disconnect(), this.contentObserver.disconnect()
                }
                get limit() {
                    return "horizontal" === this.direction ? this.contentWidth - this.wrapperWidth : this.contentHeight - this.wrapperHeight
                }
                raf(e) {
                    const t = e - (this.now || 0);
                    this.now = e, !this.stopped && this.smooth && (this.lastScroll = this.scroll, this.animate.raf(.001 * t), this.scroll === this.targetScroll && (this.lastScroll = this.scroll), this.isScrolling && (this.setScroll(this.scroll), this.notify()), this.isScrolling = this.scroll !== this.targetScroll)
                }
                get velocity() {
                    return this.scroll - this.lastScroll
                }
                setScroll(e) {
                    let t = this.infinite ? a(e, this.limit) : e;
                    "horizontal" === this.direction ? this.wrapperNode.scrollTo(t, 0) : this.wrapperNode.scrollTo(0, t)
                }
                notify() {
                    let e = this.infinite ? a(this.scroll, this.limit) : this.scroll;
                    this.emit("scroll", {
                        scroll: e,
                        limit: this.limit,
                        velocity: this.velocity,
                        direction: 0 === this.velocity ? 0 : this.velocity > 0 ? 1 : -1,
                        progress: e / this.limit
                    })
                }
                scrollTo(e, {
                    offset: t = 0,
                    immediate: i = !1,
                    duration: n = this.duration,
                    easing: r = this.easing
                } = {}) {
                    if (null == e || this.stopped) return;
                    let s;
                    if ("number" == typeof e) s = e;
                    else if ("top" === e || "#top" === e) s = 0;
                    else if ("bottom" === e) s = this.limit;
                    else {
                        let t;
                        if ("string" == typeof e) t = document.querySelector(e);
                        else {
                            if (null == e || !e.nodeType) return;
                            t = e
                        }
                        if (!t) return;
                        let i = 0;
                        if (this.wrapperNode !== window) {
                            const e = this.wrapperNode.getBoundingClientRect();
                            i = "horizontal" === this.direction ? e.left : e.top
                        }
                        const n = t.getBoundingClientRect();
                        s = ("horizontal" === this.direction ? n.left : n.top) + this.scroll - i
                    }
                    s += t, this.targetScroll = this.infinite ? s : Math.max(0, Math.min(s, this.limit)), !this.smooth || i ? (this.animate.stop(), this.scroll = this.lastScroll = this.targetScroll, this.setScroll(this.targetScroll)) : this.animate.to(this, {
                        duration: n,
                        easing: r,
                        scroll: this.targetScroll
                    })
                }
            }
        },
        4599: (e, t, i) => {
            "use strict";
            i.d(t, {
                CP7: () => fo,
                D1R: () => de,
                DvJ: () => nr,
                EJi: () => bh,
                EoG: () => $,
                F5T: () => xn,
                FM8: () => Ht,
                IOt: () => bt,
                Ilk: () => Kt,
                Kj0: () => tr,
                LY2: () => K,
                M8C: () => Ft,
                Mig: () => dc,
                N$j: () => Go,
                NMF: () => ht,
                OdW: () => $o,
                OoA: () => ae,
                Ox3: () => uc,
                PMe: () => rc,
                Pa4: () => ai,
                QRU: () => _c,
                SUY: () => xc,
                Syv: () => lt,
                TUv: () => Vo,
                TlE: () => Mn,
                Tme: () => hn,
                TyD: () => oe,
                USm: () => $i,
                UY4: () => ul,
                UlW: () => mt,
                Wid: () => vh,
                Wl3: () => c,
                YLQ: () => le,
                ZAu: () => oo,
                Zp0: () => gc,
                ZzF: () => hi,
                _C8: () => Ah,
                _Li: () => u,
                _fP: () => si,
                aH4: () => he,
                aLr: () => Ai,
                aNw: () => jh,
                anP: () => Kr,
                blk: () => cl,
                cPb: () => hr,
                cek: () => hc,
                dUE: () => Oh,
                dpR: () => Kh,
                ehD: () => d,
                ejS: () => hl,
                hH6: () => $h,
                iKG: () => kr,
                iLg: () => Uh,
                iUV: () => Nc,
                kB5: () => bo,
                knz: () => _t,
                m7l: () => Hh,
                nls: () => el,
                qyh: () => ue,
                rpg: () => re,
                u9r: () => Un,
                uWy: () => se,
                vBJ: () => wn,
                vmT: () => Zh,
                vpT: () => _o,
                wem: () => ce,
                woe: () => gl,
                x12: () => al,
                xEZ: () => ei,
                xsS: () => yo,
                yC1: () => Fh,
                yGw: () => Ui,
                ybr: () => go,
                z$h: () => gt
            });
            const n = "137",
                r = 0,
                s = 1,
                a = 2,
                o = 1,
                l = 2,
                h = 3,
                c = 0,
                u = 1,
                d = 2,
                p = 0,
                f = 1,
                m = 2,
                g = 3,
                y = 4,
                _ = 5,
                v = 100,
                b = 101,
                T = 102,
                x = 103,
                w = 104,
                S = 200,
                E = 201,
                M = 202,
                C = 203,
                A = 204,
                L = 205,
                I = 206,
                P = 207,
                R = 208,
                k = 209,
                D = 210,
                O = 0,
                N = 1,
                U = 2,
                B = 3,
                F = 4,
                H = 5,
                z = 6,
                V = 7,
                G = 0,
                W = 1,
                j = 2,
                q = 0,
                $ = 1,
                X = 2,
                Y = 3,
                K = 4,
                J = 5,
                Z = 301,
                Q = 302,
                ee = 303,
                te = 304,
                ie = 306,
                ne = 307,
                re = 1e3,
                se = 1001,
                ae = 1002,
                oe = 1003,
                le = 1004,
                he = 1005,
                ce = 1006,
                ue = 1007,
                de = 1008,
                pe = 1009,
                fe = 1010,
                me = 1011,
                ge = 1012,
                ye = 1013,
                _e = 1014,
                ve = 1015,
                be = 1016,
                Te = 1017,
                xe = 1018,
                we = 1020,
                Se = 1021,
                Ee = 1022,
                Me = 1023,
                Ce = 1024,
                Ae = 1025,
                Le = 1026,
                Ie = 1027,
                Pe = 1028,
                Re = 1029,
                ke = 1030,
                De = 1031,
                Oe = 1033,
                Ne = 33776,
                Ue = 33777,
                Be = 33778,
                Fe = 33779,
                He = 35840,
                ze = 35841,
                Ve = 35842,
                Ge = 35843,
                We = 36196,
                je = 37492,
                qe = 37496,
                $e = 37808,
                Xe = 37809,
                Ye = 37810,
                Ke = 37811,
                Je = 37812,
                Ze = 37813,
                Qe = 37814,
                et = 37815,
                tt = 37816,
                it = 37817,
                nt = 37818,
                rt = 37819,
                st = 37820,
                at = 37821,
                ot = 36492,
                lt = 2300,
                ht = 2301,
                ct = 2302,
                ut = 2400,
                dt = 2401,
                pt = 2402,
                ft = 2500,
                mt = 1,
                gt = 2,
                yt = 3e3,
                _t = 3001,
                vt = 3201,
                bt = 0,
                Tt = 1,
                xt = 7680,
                wt = 35044,
                St = 35048,
                Et = "300 es",
                Mt = 1035;
            class Ct {
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    const i = this._listeners;
                    void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
                }
                hasEventListener(e, t) {
                    if (void 0 === this._listeners) return !1;
                    const i = this._listeners;
                    return void 0 !== i[e] && -1 !== i[e].indexOf(t)
                }
                removeEventListener(e, t) {
                    if (void 0 === this._listeners) return;
                    const i = this._listeners[e];
                    if (void 0 !== i) {
                        const e = i.indexOf(t); - 1 !== e && i.splice(e, 1)
                    }
                }
                dispatchEvent(e) {
                    if (void 0 === this._listeners) return;
                    const t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        const i = t.slice(0);
                        for (let t = 0, n = i.length; t < n; t++) i[t].call(this, e);
                        e.target = null
                    }
                }
            }
            const At = [];
            for (let e = 0; e < 256; e++) At[e] = (e < 16 ? "0" : "") + e.toString(16);
            let Lt = 1234567;
            const It = Math.PI / 180,
                Pt = 180 / Math.PI;

            function Rt() {
                const e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0;
                return (At[255 & e] + At[e >> 8 & 255] + At[e >> 16 & 255] + At[e >> 24 & 255] + "-" + At[255 & t] + At[t >> 8 & 255] + "-" + At[t >> 16 & 15 | 64] + At[t >> 24 & 255] + "-" + At[63 & i | 128] + At[i >> 8 & 255] + "-" + At[i >> 16 & 255] + At[i >> 24 & 255] + At[255 & n] + At[n >> 8 & 255] + At[n >> 16 & 255] + At[n >> 24 & 255]).toUpperCase()
            }

            function kt(e, t, i) {
                return Math.max(t, Math.min(i, e))
            }

            function Dt(e, t) {
                return (e % t + t) % t
            }

            function Ot(e, t, i) {
                return (1 - i) * e + i * t
            }

            function Nt(e) {
                return 0 == (e & e - 1) && 0 !== e
            }

            function Ut(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }

            function Bt(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }
            var Ft = Object.freeze({
                __proto__: null,
                DEG2RAD: It,
                RAD2DEG: Pt,
                generateUUID: Rt,
                clamp: kt,
                euclideanModulo: Dt,
                mapLinear: function(e, t, i, n, r) {
                    return n + (e - t) * (r - n) / (i - t)
                },
                inverseLerp: function(e, t, i) {
                    return e !== t ? (i - e) / (t - e) : 0
                },
                lerp: Ot,
                damp: function(e, t, i, n) {
                    return Ot(e, t, 1 - Math.exp(-i * n))
                },
                pingpong: function(e, t = 1) {
                    return t - Math.abs(Dt(e, 2 * t) - t)
                },
                smoothstep: function(e, t, i) {
                    return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
                },
                smootherstep: function(e, t, i) {
                    return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                seededRandom: function(e) {
                    return void 0 !== e && (Lt = e % 2147483647), Lt = 16807 * Lt % 2147483647, (Lt - 1) / 2147483646
                },
                degToRad: function(e) {
                    return e * It
                },
                radToDeg: function(e) {
                    return e * Pt
                },
                isPowerOfTwo: Nt,
                ceilPowerOfTwo: Ut,
                floorPowerOfTwo: Bt,
                setQuaternionFromProperEuler: function(e, t, i, n, r) {
                    const s = Math.cos,
                        a = Math.sin,
                        o = s(i / 2),
                        l = a(i / 2),
                        h = s((t + n) / 2),
                        c = a((t + n) / 2),
                        u = s((t - n) / 2),
                        d = a((t - n) / 2),
                        p = s((n - t) / 2),
                        f = a((n - t) / 2);
                    switch (r) {
                        case "XYX":
                            e.set(o * c, l * u, l * d, o * h);
                            break;
                        case "YZY":
                            e.set(l * d, o * c, l * u, o * h);
                            break;
                        case "ZXZ":
                            e.set(l * u, l * d, o * c, o * h);
                            break;
                        case "XZX":
                            e.set(o * c, l * f, l * p, o * h);
                            break;
                        case "YXY":
                            e.set(l * p, o * c, l * f, o * h);
                            break;
                        case "ZYZ":
                            e.set(l * f, l * p, o * c, o * h);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                    }
                }
            });
            class Ht {
                constructor(e = 0, t = 0) {
                    this.x = e, this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e, this.y = t, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this
                }
                add(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                }
                sub(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    const t = this.x,
                        i = this.y,
                        n = e.elements;
                    return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                }
                clampLength(e, t) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        i = this.y - e.y;
                    return t * t + i * i
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                }
                lerpVectors(e, t, i) {
                    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e
                }
                fromBufferAttribute(e, t, i) {
                    return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
                }
                rotateAround(e, t) {
                    const i = Math.cos(t),
                        n = Math.sin(t),
                        r = this.x - e.x,
                        s = this.y - e.y;
                    return this.x = r * i - s * n + e.x, this.y = r * n + s * i + e.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            Ht.prototype.isVector2 = !0;
            class zt {
                constructor() {
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                set(e, t, i, n, r, s, a, o, l) {
                    const h = this.elements;
                    return h[0] = e, h[1] = n, h[2] = a, h[3] = t, h[4] = r, h[5] = o, h[6] = i, h[7] = s, h[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(e) {
                    const t = this.elements,
                        i = e.elements;
                    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this
                }
                extractBasis(e, t, i) {
                    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(e) {
                    const t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const i = e.elements,
                        n = t.elements,
                        r = this.elements,
                        s = i[0],
                        a = i[3],
                        o = i[6],
                        l = i[1],
                        h = i[4],
                        c = i[7],
                        u = i[2],
                        d = i[5],
                        p = i[8],
                        f = n[0],
                        m = n[3],
                        g = n[6],
                        y = n[1],
                        _ = n[4],
                        v = n[7],
                        b = n[2],
                        T = n[5],
                        x = n[8];
                    return r[0] = s * f + a * y + o * b, r[3] = s * m + a * _ + o * T, r[6] = s * g + a * v + o * x, r[1] = l * f + h * y + c * b, r[4] = l * m + h * _ + c * T, r[7] = l * g + h * v + c * x, r[2] = u * f + d * y + p * b, r[5] = u * m + d * _ + p * T, r[8] = u * g + d * v + p * x, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        i = e[1],
                        n = e[2],
                        r = e[3],
                        s = e[4],
                        a = e[5],
                        o = e[6],
                        l = e[7],
                        h = e[8];
                    return t * s * h - t * a * l - i * r * h + i * a * o + n * r * l - n * s * o
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        i = e[1],
                        n = e[2],
                        r = e[3],
                        s = e[4],
                        a = e[5],
                        o = e[6],
                        l = e[7],
                        h = e[8],
                        c = h * s - a * l,
                        u = a * o - h * r,
                        d = l * r - s * o,
                        p = t * c + i * u + n * d;
                    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const f = 1 / p;
                    return e[0] = c * f, e[1] = (n * l - h * i) * f, e[2] = (a * i - n * s) * f, e[3] = u * f, e[4] = (h * t - n * o) * f, e[5] = (n * r - a * t) * f, e[6] = d * f, e[7] = (i * o - l * t) * f, e[8] = (s * t - i * r) * f, this
                }
                transpose() {
                    let e;
                    const t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).invert().transpose()
                }
                transposeIntoArray(e) {
                    const t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                }
                setUvTransform(e, t, i, n, r, s, a) {
                    const o = Math.cos(r),
                        l = Math.sin(r);
                    return this.set(i * o, i * l, -i * (o * s + l * a) + s + e, -n * l, n * o, -n * (-l * s + o * a) + a + t, 0, 0, 1), this
                }
                scale(e, t) {
                    const i = this.elements;
                    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this
                }
                rotate(e) {
                    const t = Math.cos(e),
                        i = Math.sin(e),
                        n = this.elements,
                        r = n[0],
                        s = n[3],
                        a = n[6],
                        o = n[1],
                        l = n[4],
                        h = n[7];
                    return n[0] = t * r + i * o, n[3] = t * s + i * l, n[6] = t * a + i * h, n[1] = -i * r + t * o, n[4] = -i * s + t * l, n[7] = -i * a + t * h, this
                }
                translate(e, t) {
                    const i = this.elements;
                    return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this
                }
                equals(e) {
                    const t = this.elements,
                        i = e.elements;
                    for (let e = 0; e < 9; e++)
                        if (t[e] !== i[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const i = this.elements;
                    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }

            function Vt(e) {
                for (let t = e.length - 1; t >= 0; --t)
                    if (e[t] > 65535) return !0;
                return !1
            }
            zt.prototype.isMatrix3 = !0;
            Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

            function Gt(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }
            const Wt = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                jt = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                qt = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function $t(e, t, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
            }

            function Xt(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function Yt(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            class Kt {
                constructor(e, t, i) {
                    return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
                }
                set(e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                }
                setScalar(e) {
                    return this.r = e, this.g = e, this.b = e, this
                }
                setHex(e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                }
                setRGB(e, t, i) {
                    return this.r = e, this.g = t, this.b = i, this
                }
                setHSL(e, t, i) {
                    if (e = Dt(e, 1), t = kt(t, 0, 1), i = kt(i, 0, 1), 0 === t) this.r = this.g = this.b = i;
                    else {
                        const n = i <= .5 ? i * (1 + t) : i + t - i * t,
                            r = 2 * i - n;
                        this.r = $t(r, n, e + 1 / 3), this.g = $t(r, n, e), this.b = $t(r, n, e - 1 / 3)
                    }
                    return this
                }
                setStyle(e) {
                    function t(t) {
                        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    let i;
                    if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                        let e;
                        const n = i[1],
                            r = i[2];
                        switch (n) {
                            case "rgb":
                            case "rgba":
                                if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this;
                                if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                                    const i = parseFloat(e[1]) / 360,
                                        n = parseInt(e[2], 10) / 100,
                                        r = parseInt(e[3], 10) / 100;
                                    return t(e[4]), this.setHSL(i, n, r)
                                }
                        }
                    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        const e = i[1],
                            t = e.length;
                        if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this;
                        if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this
                    }
                    return e && e.length > 0 ? this.setColorName(e) : this
                }
                setColorName(e) {
                    const t = Wt[e.toLowerCase()];
                    return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                }
                copySRGBToLinear(e) {
                    return this.r = Xt(e.r), this.g = Xt(e.g), this.b = Xt(e.b), this
                }
                copyLinearToSRGB(e) {
                    return this.r = Yt(e.r), this.g = Yt(e.g), this.b = Yt(e.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                }
                getHexString() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                }
                getHSL(e) {
                    const t = this.r,
                        i = this.g,
                        n = this.b,
                        r = Math.max(t, i, n),
                        s = Math.min(t, i, n);
                    let a, o;
                    const l = (s + r) / 2;
                    if (s === r) a = 0, o = 0;
                    else {
                        const e = r - s;
                        switch (o = l <= .5 ? e / (r + s) : e / (2 - r - s), r) {
                            case t:
                                a = (i - n) / e + (i < n ? 6 : 0);
                                break;
                            case i:
                                a = (n - t) / e + 2;
                                break;
                            case n:
                                a = (t - i) / e + 4
                        }
                        a /= 6
                    }
                    return e.h = a, e.s = o, e.l = l, e
                }
                getStyle() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                }
                offsetHSL(e, t, i) {
                    return this.getHSL(jt), jt.h += e, jt.s += t, jt.l += i, this.setHSL(jt.h, jt.s, jt.l), this
                }
                add(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                }
                addScalar(e) {
                    return this.r += e, this.g += e, this.b += e, this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                }
                multiply(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                }
                multiplyScalar(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                }
                lerpColors(e, t, i) {
                    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this
                }
                lerpHSL(e, t) {
                    this.getHSL(jt), e.getHSL(qt);
                    const i = Ot(jt.h, qt.h, t),
                        n = Ot(jt.s, qt.s, t),
                        r = Ot(jt.l, qt.l, t);
                    return this.setHSL(i, n, r), this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t = 0) {
                    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }
            }
            let Jt;
            Kt.NAMES = Wt, Kt.prototype.isColor = !0, Kt.prototype.r = 1, Kt.prototype.g = 1, Kt.prototype.b = 1;
            class Zt {
                static getDataURL(e) {
                    if (/^data:/i.test(e.src)) return e.src;
                    if ("undefined" == typeof HTMLCanvasElement) return e.src;
                    let t;
                    if (e instanceof HTMLCanvasElement) t = e;
                    else {
                        void 0 === Jt && (Jt = Gt("canvas")), Jt.width = e.width, Jt.height = e.height;
                        const i = Jt.getContext("2d");
                        e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Jt
                    }
                    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
                }
                static sRGBToLinear(e) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        const t = Gt("canvas");
                        t.width = e.width, t.height = e.height;
                        const i = t.getContext("2d");
                        i.drawImage(e, 0, 0, e.width, e.height);
                        const n = i.getImageData(0, 0, e.width, e.height),
                            r = n.data;
                        for (let e = 0; e < r.length; e++) r[e] = 255 * Xt(r[e] / 255);
                        return i.putImageData(n, 0, 0), t
                    }
                    if (e.data) {
                        const t = e.data.slice(0);
                        for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Xt(t[e] / 255)) : t[e] = Xt(t[e]);
                        return {
                            data: t,
                            width: e.width,
                            height: e.height
                        }
                    }
                    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
                }
            }
            let Qt = 0;
            class ei extends Ct {
                constructor(e = ei.DEFAULT_IMAGE, t = ei.DEFAULT_MAPPING, i = se, n = se, r = ce, s = de, a = Me, o = pe, l = 1, h = yt) {
                    super(), Object.defineProperty(this, "id", {
                        value: Qt++
                    }), this.uuid = Rt(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new Ht(0, 0), this.repeat = new Ht(1, 1), this.center = new Ht(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new zt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    const i = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        const n = this.image;
                        if (void 0 === n.uuid && (n.uuid = Rt()), !t && void 0 === e.images[n.uuid]) {
                            let t;
                            if (Array.isArray(n)) {
                                t = [];
                                for (let e = 0, i = n.length; e < i; e++) n[e].isDataTexture ? t.push(ti(n[e].image)) : t.push(ti(n[e]))
                            } else t = ti(n);
                            e.images[n.uuid] = {
                                uuid: n.uuid,
                                url: t
                            }
                        }
                        i.image = n.uuid
                    }
                    return "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(e) {
                    if (300 !== this.mapping) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case re:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case se:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case ae:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case re:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case se:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case ae:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
            }

            function ti(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Zt.getDataURL(e) : e.data ? {
                    data: Array.prototype.slice.call(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            ei.DEFAULT_IMAGE = void 0, ei.DEFAULT_MAPPING = 300, ei.prototype.isTexture = !0;
            class ii {
                constructor(e = 0, t = 0, i = 0, n = 1) {
                    this.x = e, this.y = t, this.z = i, this.w = n
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, i, n) {
                    return this.x = e, this.y = t, this.z = i, this.w = n, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setW(e) {
                    return this.w = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                }
                add(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                }
                sub(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                }
                applyMatrix4(e) {
                    const t = this.x,
                        i = this.y,
                        n = this.z,
                        r = this.w,
                        s = e.elements;
                    return this.x = s[0] * t + s[4] * i + s[8] * n + s[12] * r, this.y = s[1] * t + s[5] * i + s[9] * n + s[13] * r, this.z = s[2] * t + s[6] * i + s[10] * n + s[14] * r, this.w = s[3] * t + s[7] * i + s[11] * n + s[15] * r, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    const t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, i, n, r;
                    const s = .01,
                        a = .1,
                        o = e.elements,
                        l = o[0],
                        h = o[4],
                        c = o[8],
                        u = o[1],
                        d = o[5],
                        p = o[9],
                        f = o[2],
                        m = o[6],
                        g = o[10];
                    if (Math.abs(h - u) < s && Math.abs(c - f) < s && Math.abs(p - m) < s) {
                        if (Math.abs(h + u) < a && Math.abs(c + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        const e = (l + 1) / 2,
                            o = (d + 1) / 2,
                            y = (g + 1) / 2,
                            _ = (h + u) / 4,
                            v = (c + f) / 4,
                            b = (p + m) / 4;
                        return e > o && e > y ? e < s ? (i = 0, n = .707106781, r = .707106781) : (i = Math.sqrt(e), n = _ / i, r = v / i) : o > y ? o < s ? (i = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(o), i = _ / n, r = b / n) : y < s ? (i = .707106781, n = .707106781, r = 0) : (r = Math.sqrt(y), i = v / r, n = b / r), this.set(i, n, r, t), this
                    }
                    let y = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (u - h) * (u - h));
                    return Math.abs(y) < .001 && (y = 1), this.x = (m - p) / y, this.y = (c - f) / y, this.z = (u - h) / y, this.w = Math.acos((l + d + g - 1) / 2), this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                }
                clampLength(e, t) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                }
                lerpVectors(e, t, i) {
                    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                }
                fromBufferAttribute(e, t, i) {
                    return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            ii.prototype.isVector4 = !0;
            class ni extends Ct {
                constructor(e, t, i = {}) {
                    super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new ii(0, 0, e, t), this.scissorTest = !1, this.viewport = new ii(0, 0, e, t), this.texture = new ei(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                        width: e,
                        height: t,
                        depth: 1
                    }, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.internalFormat = void 0 !== i.internalFormat ? i.internalFormat : null, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : ce, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
                }
                setTexture(e) {
                    e.image = {
                        width: this.width,
                        height: this.height,
                        depth: this.depth
                    }, this.texture = e
                }
                setSize(e, t, i = 1) {
                    this.width === e && this.height === t && this.depth === i || (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = Object.assign({}, e.texture.image), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            ni.prototype.isWebGLRenderTarget = !0;
            (class extends ni {
                constructor(e, t, i) {
                    super(e, t);
                    const n = this.texture;
                    this.texture = [];
                    for (let e = 0; e < i; e++) this.texture[e] = n.clone()
                }
                setSize(e, t, i = 1) {
                    if (this.width !== e || this.height !== t || this.depth !== i) {
                        this.width = e, this.height = t, this.depth = i;
                        for (let n = 0, r = this.texture.length; n < r; n++) this.texture[n].image.width = e, this.texture[n].image.height = t, this.texture[n].image.depth = i;
                        this.dispose()
                    }
                    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
                }
                copy(e) {
                    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0;
                    for (let t = 0, i = e.texture.length; t < i; t++) this.texture[t] = e.texture[t].clone();
                    return this
                }
            }).prototype.isWebGLMultipleRenderTargets = !0;
            class ri extends ni {
                constructor(e, t, i = {}) {
                    super(e, t, i), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === i.ignoreDepth || i.ignoreDepth, this.useRenderToTexture = void 0 !== i.useRenderToTexture && i.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
                }
                copy(e) {
                    return super.copy.call(this, e), this.samples = e.samples, this.useRenderToTexture = e.useRenderToTexture, this.useRenderbuffer = e.useRenderbuffer, this
                }
            }
            ri.prototype.isWebGLMultisampleRenderTarget = !0;
            class si {
                constructor(e = 0, t = 0, i = 0, n = 1) {
                    this._x = e, this._y = t, this._z = i, this._w = n
                }
                static slerp(e, t, i, n) {
                    return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i.slerpQuaternions(e, t, n)
                }
                static slerpFlat(e, t, i, n, r, s, a) {
                    let o = i[n + 0],
                        l = i[n + 1],
                        h = i[n + 2],
                        c = i[n + 3];
                    const u = r[s + 0],
                        d = r[s + 1],
                        p = r[s + 2],
                        f = r[s + 3];
                    if (0 === a) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = h, void(e[t + 3] = c);
                    if (1 === a) return e[t + 0] = u, e[t + 1] = d, e[t + 2] = p, void(e[t + 3] = f);
                    if (c !== f || o !== u || l !== d || h !== p) {
                        let e = 1 - a;
                        const t = o * u + l * d + h * p + c * f,
                            i = t >= 0 ? 1 : -1,
                            n = 1 - t * t;
                        if (n > Number.EPSILON) {
                            const r = Math.sqrt(n),
                                s = Math.atan2(r, t * i);
                            e = Math.sin(e * s) / r, a = Math.sin(a * s) / r
                        }
                        const r = a * i;
                        if (o = o * e + u * r, l = l * e + d * r, h = h * e + p * r, c = c * e + f * r, e === 1 - a) {
                            const e = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
                            o *= e, l *= e, h *= e, c *= e
                        }
                    }
                    e[t] = o, e[t + 1] = l, e[t + 2] = h, e[t + 3] = c
                }
                static multiplyQuaternionsFlat(e, t, i, n, r, s) {
                    const a = i[n],
                        o = i[n + 1],
                        l = i[n + 2],
                        h = i[n + 3],
                        c = r[s],
                        u = r[s + 1],
                        d = r[s + 2],
                        p = r[s + 3];
                    return e[t] = a * p + h * c + o * d - l * u, e[t + 1] = o * p + h * u + l * c - a * d, e[t + 2] = l * p + h * d + a * u - o * c, e[t + 3] = h * p - a * c - o * u - l * d, e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e, this._onChangeCallback()
                }
                set(e, t, i, n) {
                    return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                }
                setFromEuler(e, t) {
                    if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const i = e._x,
                        n = e._y,
                        r = e._z,
                        s = e._order,
                        a = Math.cos,
                        o = Math.sin,
                        l = a(i / 2),
                        h = a(n / 2),
                        c = a(r / 2),
                        u = o(i / 2),
                        d = o(n / 2),
                        p = o(r / 2);
                    switch (s) {
                        case "XYZ":
                            this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                            break;
                        case "YXZ":
                            this._x = u * h * c + l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                            break;
                        case "ZXY":
                            this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c - u * d * p;
                            break;
                        case "ZYX":
                            this._x = u * h * c - l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c + u * d * p;
                            break;
                        case "YZX":
                            this._x = u * h * c + l * d * p, this._y = l * d * c + u * h * p, this._z = l * h * p - u * d * c, this._w = l * h * c - u * d * p;
                            break;
                        case "XZY":
                            this._x = u * h * c - l * d * p, this._y = l * d * c - u * h * p, this._z = l * h * p + u * d * c, this._w = l * h * c + u * d * p;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                    }
                    return !1 !== t && this._onChangeCallback(), this
                }
                setFromAxisAngle(e, t) {
                    const i = t / 2,
                        n = Math.sin(i);
                    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this
                }
                setFromRotationMatrix(e) {
                    const t = e.elements,
                        i = t[0],
                        n = t[4],
                        r = t[8],
                        s = t[1],
                        a = t[5],
                        o = t[9],
                        l = t[2],
                        h = t[6],
                        c = t[10],
                        u = i + a + c;
                    if (u > 0) {
                        const e = .5 / Math.sqrt(u + 1);
                        this._w = .25 / e, this._x = (h - o) * e, this._y = (r - l) * e, this._z = (s - n) * e
                    } else if (i > a && i > c) {
                        const e = 2 * Math.sqrt(1 + i - a - c);
                        this._w = (h - o) / e, this._x = .25 * e, this._y = (n + s) / e, this._z = (r + l) / e
                    } else if (a > c) {
                        const e = 2 * Math.sqrt(1 + a - i - c);
                        this._w = (r - l) / e, this._x = (n + s) / e, this._y = .25 * e, this._z = (o + h) / e
                    } else {
                        const e = 2 * Math.sqrt(1 + c - i - a);
                        this._w = (s - n) / e, this._x = (r + l) / e, this._y = (o + h) / e, this._z = .25 * e
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(e, t) {
                    let i = e.dot(t) + 1;
                    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(kt(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    const i = this.angleTo(e);
                    if (0 === i) return this;
                    const n = Math.min(1, t / i);
                    return this.slerp(e, n), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                }
                multiply(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    const i = e._x,
                        n = e._y,
                        r = e._z,
                        s = e._w,
                        a = t._x,
                        o = t._y,
                        l = t._z,
                        h = t._w;
                    return this._x = i * h + s * a + n * l - r * o, this._y = n * h + s * o + r * a - i * l, this._z = r * h + s * l + i * o - n * a, this._w = s * h - i * a - n * o - r * l, this._onChangeCallback(), this
                }
                slerp(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    const i = this._x,
                        n = this._y,
                        r = this._z,
                        s = this._w;
                    let a = s * e._w + i * e._x + n * e._y + r * e._z;
                    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = i, this._y = n, this._z = r, this;
                    const o = 1 - a * a;
                    if (o <= Number.EPSILON) {
                        const e = 1 - t;
                        return this._w = e * s + t * this._w, this._x = e * i + t * this._x, this._y = e * n + t * this._y, this._z = e * r + t * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const l = Math.sqrt(o),
                        h = Math.atan2(l, a),
                        c = Math.sin((1 - t) * h) / l,
                        u = Math.sin(t * h) / l;
                    return this._w = s * c + this._w * u, this._x = i * c + this._x * u, this._y = n * c + this._y * u, this._z = r * c + this._z * u, this._onChangeCallback(), this
                }
                slerpQuaternions(e, t, i) {
                    return this.copy(e).slerp(t, i)
                }
                random() {
                    const e = Math.random(),
                        t = Math.sqrt(1 - e),
                        i = Math.sqrt(e),
                        n = 2 * Math.PI * Math.random(),
                        r = 2 * Math.PI * Math.random();
                    return this.set(t * Math.cos(n), i * Math.sin(r), i * Math.cos(r), t * Math.sin(n))
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t = 0) {
                    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}
            }
            si.prototype.isQuaternion = !0;
            class ai {
                constructor(e = 0, t = 0, i = 0) {
                    this.x = e, this.y = t, this.z = i
                }
                set(e, t, i) {
                    return void 0 === i && (i = this.z), this.x = e, this.y = t, this.z = i, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
                add(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                }
                sub(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                }
                multiply(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                }
                applyEuler(e) {
                    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(li.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(li.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    const t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    const t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.elements,
                        s = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
                    return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * s, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * s, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * s, this
                }
                applyQuaternion(e) {
                    const t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.x,
                        s = e.y,
                        a = e.z,
                        o = e.w,
                        l = o * t + s * n - a * i,
                        h = o * i + a * t - r * n,
                        c = o * n + r * i - s * t,
                        u = -r * t - s * i - a * n;
                    return this.x = l * o + u * -r + h * -a - c * -s, this.y = h * o + u * -s + c * -r - l * -a, this.z = c * o + u * -a + l * -s - h * -r, this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    const t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize()
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                }
                clampLength(e, t) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                }
                lerpVectors(e, t, i) {
                    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this
                }
                cross(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    const i = e.x,
                        n = e.y,
                        r = e.z,
                        s = t.x,
                        a = t.y,
                        o = t.z;
                    return this.x = n * o - r * a, this.y = r * s - i * o, this.z = i * a - n * s, this
                }
                projectOnVector(e) {
                    const t = e.lengthSq();
                    if (0 === t) return this.set(0, 0, 0);
                    const i = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(i)
                }
                projectOnPlane(e) {
                    return oi.copy(this).projectOnVector(e), this.sub(oi)
                }
                reflect(e) {
                    return this.sub(oi.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t) return Math.PI / 2;
                    const i = this.dot(e) / t;
                    return Math.acos(kt(i, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        i = this.y - e.y,
                        n = this.z - e.z;
                    return t * t + i * i + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, i) {
                    const n = Math.sin(t) * e;
                    return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, i) {
                    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
                }
                setFromMatrixPosition(e) {
                    const t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                }
                setFromMatrixScale(e) {
                    const t = this.setFromMatrixColumn(e, 0).length(),
                        i = this.setFromMatrixColumn(e, 1).length(),
                        n = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = i, this.z = n, this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                }
                fromBufferAttribute(e, t, i) {
                    return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    const e = 2 * (Math.random() - .5),
                        t = Math.random() * Math.PI * 2,
                        i = Math.sqrt(1 - e ** 2);
                    return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            ai.prototype.isVector3 = !0;
            const oi = new ai,
                li = new si;
            class hi {
                constructor(e = new ai(1 / 0, 1 / 0, 1 / 0), t = new ai(-1 / 0, -1 / 0, -1 / 0)) {
                    this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromArray(e) {
                    let t = 1 / 0,
                        i = 1 / 0,
                        n = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = e.length; o < l; o += 3) {
                        const l = e[o],
                            h = e[o + 1],
                            c = e[o + 2];
                        l < t && (t = l), h < i && (i = h), c < n && (n = c), l > r && (r = l), h > s && (s = h), c > a && (a = c)
                    }
                    return this.min.set(t, i, n), this.max.set(r, s, a), this
                }
                setFromBufferAttribute(e) {
                    let t = 1 / 0,
                        i = 1 / 0,
                        n = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = e.count; o < l; o++) {
                        const l = e.getX(o),
                            h = e.getY(o),
                            c = e.getZ(o);
                        l < t && (t = l), h < i && (i = h), c < n && (n = c), l > r && (r = l), h > s && (s = h), c > a && (a = c)
                    }
                    return this.min.set(t, i, n), this.max.set(r, s, a), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const i = ui.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
                }
                setFromObject(e, t = !1) {
                    return this.makeEmpty(), this.expandByObject(e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                expandByObject(e, t = !1) {
                    e.updateWorldMatrix(!1, !1);
                    const i = e.geometry;
                    if (void 0 !== i)
                        if (t && null != i.attributes && void 0 !== i.attributes.position) {
                            const t = i.attributes.position;
                            for (let i = 0, n = t.count; i < n; i++) ui.fromBufferAttribute(t, i).applyMatrix4(e.matrixWorld), this.expandByPoint(ui)
                        } else null === i.boundingBox && i.computeBoundingBox(), di.copy(i.boundingBox), di.applyMatrix4(e.matrixWorld), this.union(di);
                    const n = e.children;
                    for (let e = 0, i = n.length; e < i; e++) this.expandByObject(n[e], t);
                    return this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, ui), ui.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, i;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(vi), bi.subVectors(this.max, vi), pi.subVectors(e.a, vi), fi.subVectors(e.b, vi), mi.subVectors(e.c, vi), gi.subVectors(fi, pi), yi.subVectors(mi, fi), _i.subVectors(pi, mi);
                    let t = [0, -gi.z, gi.y, 0, -yi.z, yi.y, 0, -_i.z, _i.y, gi.z, 0, -gi.x, yi.z, 0, -yi.x, _i.z, 0, -_i.x, -gi.y, gi.x, 0, -yi.y, yi.x, 0, -_i.y, _i.x, 0];
                    return !!wi(t, pi, fi, mi, bi) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!wi(t, pi, fi, mi, bi) && (Ti.crossVectors(gi, yi), t = [Ti.x, Ti.y, Ti.z], wi(t, pi, fi, mi, bi)))
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return ui.copy(e).clamp(this.min, this.max).sub(e).length()
                }
                getBoundingSphere(e) {
                    return this.getCenter(e.center), e.radius = .5 * this.getSize(ui).length(), e
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (ci[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), ci[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), ci[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), ci[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), ci[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), ci[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), ci[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), ci[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(ci)), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            hi.prototype.isBox3 = !0;
            const ci = [new ai, new ai, new ai, new ai, new ai, new ai, new ai, new ai],
                ui = new ai,
                di = new hi,
                pi = new ai,
                fi = new ai,
                mi = new ai,
                gi = new ai,
                yi = new ai,
                _i = new ai,
                vi = new ai,
                bi = new ai,
                Ti = new ai,
                xi = new ai;

            function wi(e, t, i, n, r) {
                for (let s = 0, a = e.length - 3; s <= a; s += 3) {
                    xi.fromArray(e, s);
                    const a = r.x * Math.abs(xi.x) + r.y * Math.abs(xi.y) + r.z * Math.abs(xi.z),
                        o = t.dot(xi),
                        l = i.dot(xi),
                        h = n.dot(xi);
                    if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1
                }
                return !0
            }
            const Si = new hi,
                Ei = new ai,
                Mi = new ai,
                Ci = new ai;
            class Ai {
                constructor(e = new ai, t = -1) {
                    this.center = e, this.radius = t
                }
                set(e, t) {
                    return this.center.copy(e), this.radius = t, this
                }
                setFromPoints(e, t) {
                    const i = this.center;
                    void 0 !== t ? i.copy(t) : Si.setFromPoints(e).getCenter(i);
                    let n = 0;
                    for (let t = 0, r = e.length; t < r; t++) n = Math.max(n, i.distanceToSquared(e[t]));
                    return this.radius = Math.sqrt(n), this
                }
                copy(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    const t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    const i = this.center.distanceToSquared(e);
                    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                }
                getBoundingBox(e) {
                    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                }
                translate(e) {
                    return this.center.add(e), this
                }
                expandByPoint(e) {
                    Ci.subVectors(e, this.center);
                    const t = Ci.lengthSq();
                    if (t > this.radius * this.radius) {
                        const e = Math.sqrt(t),
                            i = .5 * (e - this.radius);
                        this.center.add(Ci.multiplyScalar(i / e)), this.radius += i
                    }
                    return this
                }
                union(e) {
                    return !0 === this.center.equals(e.center) ? Mi.set(0, 0, 1).multiplyScalar(e.radius) : Mi.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Ei.copy(e.center).add(Mi)), this.expandByPoint(Ei.copy(e.center).sub(Mi)), this
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Li = new ai,
                Ii = new ai,
                Pi = new ai,
                Ri = new ai,
                ki = new ai,
                Di = new ai,
                Oi = new ai;
            class Ni {
                constructor(e = new ai, t = new ai(0, 0, -1)) {
                    this.origin = e, this.direction = t
                }
                set(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                }
                copy(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                }
                at(e, t) {
                    return t.copy(this.direction).multiplyScalar(e).add(this.origin)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, Li)), this
                }
                closestPointToPoint(e, t) {
                    t.subVectors(e, this.origin);
                    const i = t.dot(this.direction);
                    return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    const t = Li.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (Li.copy(this.direction).multiplyScalar(t).add(this.origin), Li.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, i, n) {
                    Ii.copy(e).add(t).multiplyScalar(.5), Pi.copy(t).sub(e).normalize(), Ri.copy(this.origin).sub(Ii);
                    const r = .5 * e.distanceTo(t),
                        s = -this.direction.dot(Pi),
                        a = Ri.dot(this.direction),
                        o = -Ri.dot(Pi),
                        l = Ri.lengthSq(),
                        h = Math.abs(1 - s * s);
                    let c, u, d, p;
                    if (h > 0)
                        if (c = s * o - a, u = s * a - o, p = r * h, c >= 0)
                            if (u >= -p)
                                if (u <= p) {
                                    const e = 1 / h;
                                    c *= e, u *= e, d = c * (c + s * u + 2 * a) + u * (s * c + u + 2 * o) + l
                                } else u = r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                    else u = -r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                    else u <= -p ? (c = Math.max(0, -(-s * r + a)), u = c > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l) : u <= p ? (c = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (c = Math.max(0, -(s * r + a)), u = c > 0 ? r : Math.min(Math.max(-r, -o), r), d = -c * c + u * (u + 2 * o) + l);
                    else u = s > 0 ? -r : r, c = Math.max(0, -(s * u + a)), d = -c * c + u * (u + 2 * o) + l;
                    return i && i.copy(this.direction).multiplyScalar(c).add(this.origin), n && n.copy(Pi).multiplyScalar(u).add(Ii), d
                }
                intersectSphere(e, t) {
                    Li.subVectors(e.center, this.origin);
                    const i = Li.dot(this.direction),
                        n = Li.dot(Li) - i * i,
                        r = e.radius * e.radius;
                    if (n > r) return null;
                    const s = Math.sqrt(r - n),
                        a = i - s,
                        o = i + s;
                    return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
                }
                intersectsSphere(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    const t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    const i = -(this.origin.dot(e.normal) + e.constant) / t;
                    return i >= 0 ? i : null
                }
                intersectPlane(e, t) {
                    const i = this.distanceToPlane(e);
                    return null === i ? null : this.at(i, t)
                }
                intersectsPlane(e) {
                    const t = e.distanceToPoint(this.origin);
                    if (0 === t) return !0;
                    return e.normal.dot(this.direction) * t < 0
                }
                intersectBox(e, t) {
                    let i, n, r, s, a, o;
                    const l = 1 / this.direction.x,
                        h = 1 / this.direction.y,
                        c = 1 / this.direction.z,
                        u = this.origin;
                    return l >= 0 ? (i = (e.min.x - u.x) * l, n = (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l, n = (e.min.x - u.x) * l), h >= 0 ? (r = (e.min.y - u.y) * h, s = (e.max.y - u.y) * h) : (r = (e.max.y - u.y) * h, s = (e.min.y - u.y) * h), i > s || r > n ? null : ((r > i || i != i) && (i = r), (s < n || n != n) && (n = s), c >= 0 ? (a = (e.min.z - u.z) * c, o = (e.max.z - u.z) * c) : (a = (e.max.z - u.z) * c, o = (e.min.z - u.z) * c), i > o || a > n ? null : ((a > i || i != i) && (i = a), (o < n || n != n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, t)))
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, Li)
                }
                intersectTriangle(e, t, i, n, r) {
                    ki.subVectors(t, e), Di.subVectors(i, e), Oi.crossVectors(ki, Di);
                    let s, a = this.direction.dot(Oi);
                    if (a > 0) {
                        if (n) return null;
                        s = 1
                    } else {
                        if (!(a < 0)) return null;
                        s = -1, a = -a
                    }
                    Ri.subVectors(this.origin, e);
                    const o = s * this.direction.dot(Di.crossVectors(Ri, Di));
                    if (o < 0) return null;
                    const l = s * this.direction.dot(ki.cross(Ri));
                    if (l < 0) return null;
                    if (o + l > a) return null;
                    const h = -s * Ri.dot(Oi);
                    return h < 0 ? null : this.at(h / a, r)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class Ui {
                constructor() {
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
                set(e, t, i, n, r, s, a, o, l, h, c, u, d, p, f, m) {
                    const g = this.elements;
                    return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = h, g[10] = c, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new Ui).fromArray(this.elements)
                }
                copy(e) {
                    const t = this.elements,
                        i = e.elements;
                    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this
                }
                copyPosition(e) {
                    const t = this.elements,
                        i = e.elements;
                    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this
                }
                setFromMatrix3(e) {
                    const t = e.elements;
                    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(e, t, i) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                }
                makeBasis(e, t, i) {
                    return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(e) {
                    const t = this.elements,
                        i = e.elements,
                        n = 1 / Bi.setFromMatrixColumn(e, 0).length(),
                        r = 1 / Bi.setFromMatrixColumn(e, 1).length(),
                        s = 1 / Bi.setFromMatrixColumn(e, 2).length();
                    return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * s, t[9] = i[9] * s, t[10] = i[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromEuler(e) {
                    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    const t = this.elements,
                        i = e.x,
                        n = e.y,
                        r = e.z,
                        s = Math.cos(i),
                        a = Math.sin(i),
                        o = Math.cos(n),
                        l = Math.sin(n),
                        h = Math.cos(r),
                        c = Math.sin(r);
                    if ("XYZ" === e.order) {
                        const e = s * h,
                            i = s * c,
                            n = a * h,
                            r = a * c;
                        t[0] = o * h, t[4] = -o * c, t[8] = l, t[1] = i + n * l, t[5] = e - r * l, t[9] = -a * o, t[2] = r - e * l, t[6] = n + i * l, t[10] = s * o
                    } else if ("YXZ" === e.order) {
                        const e = o * h,
                            i = o * c,
                            n = l * h,
                            r = l * c;
                        t[0] = e + r * a, t[4] = n * a - i, t[8] = s * l, t[1] = s * c, t[5] = s * h, t[9] = -a, t[2] = i * a - n, t[6] = r + e * a, t[10] = s * o
                    } else if ("ZXY" === e.order) {
                        const e = o * h,
                            i = o * c,
                            n = l * h,
                            r = l * c;
                        t[0] = e - r * a, t[4] = -s * c, t[8] = n + i * a, t[1] = i + n * a, t[5] = s * h, t[9] = r - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o
                    } else if ("ZYX" === e.order) {
                        const e = s * h,
                            i = s * c,
                            n = a * h,
                            r = a * c;
                        t[0] = o * h, t[4] = n * l - i, t[8] = e * l + r, t[1] = o * c, t[5] = r * l + e, t[9] = i * l - n, t[2] = -l, t[6] = a * o, t[10] = s * o
                    } else if ("YZX" === e.order) {
                        const e = s * o,
                            i = s * l,
                            n = a * o,
                            r = a * l;
                        t[0] = o * h, t[4] = r - e * c, t[8] = n * c + i, t[1] = c, t[5] = s * h, t[9] = -a * h, t[2] = -l * h, t[6] = i * c + n, t[10] = e - r * c
                    } else if ("XZY" === e.order) {
                        const e = s * o,
                            i = s * l,
                            n = a * o,
                            r = a * l;
                        t[0] = o * h, t[4] = -c, t[8] = l * h, t[1] = e * c + r, t[5] = s * h, t[9] = i * c - n, t[2] = n * c - i, t[6] = a * h, t[10] = r * c + e
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(Hi, e, zi)
                }
                lookAt(e, t, i) {
                    const n = this.elements;
                    return Wi.subVectors(e, t), 0 === Wi.lengthSq() && (Wi.z = 1), Wi.normalize(), Vi.crossVectors(i, Wi), 0 === Vi.lengthSq() && (1 === Math.abs(i.z) ? Wi.x += 1e-4 : Wi.z += 1e-4, Wi.normalize(), Vi.crossVectors(i, Wi)), Vi.normalize(), Gi.crossVectors(Wi, Vi), n[0] = Vi.x, n[4] = Gi.x, n[8] = Wi.x, n[1] = Vi.y, n[5] = Gi.y, n[9] = Wi.y, n[2] = Vi.z, n[6] = Gi.z, n[10] = Wi.z, this
                }
                multiply(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const i = e.elements,
                        n = t.elements,
                        r = this.elements,
                        s = i[0],
                        a = i[4],
                        o = i[8],
                        l = i[12],
                        h = i[1],
                        c = i[5],
                        u = i[9],
                        d = i[13],
                        p = i[2],
                        f = i[6],
                        m = i[10],
                        g = i[14],
                        y = i[3],
                        _ = i[7],
                        v = i[11],
                        b = i[15],
                        T = n[0],
                        x = n[4],
                        w = n[8],
                        S = n[12],
                        E = n[1],
                        M = n[5],
                        C = n[9],
                        A = n[13],
                        L = n[2],
                        I = n[6],
                        P = n[10],
                        R = n[14],
                        k = n[3],
                        D = n[7],
                        O = n[11],
                        N = n[15];
                    return r[0] = s * T + a * E + o * L + l * k, r[4] = s * x + a * M + o * I + l * D, r[8] = s * w + a * C + o * P + l * O, r[12] = s * S + a * A + o * R + l * N, r[1] = h * T + c * E + u * L + d * k, r[5] = h * x + c * M + u * I + d * D, r[9] = h * w + c * C + u * P + d * O, r[13] = h * S + c * A + u * R + d * N, r[2] = p * T + f * E + m * L + g * k, r[6] = p * x + f * M + m * I + g * D, r[10] = p * w + f * C + m * P + g * O, r[14] = p * S + f * A + m * R + g * N, r[3] = y * T + _ * E + v * L + b * k, r[7] = y * x + _ * M + v * I + b * D, r[11] = y * w + _ * C + v * P + b * O, r[15] = y * S + _ * A + v * R + b * N, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        i = e[4],
                        n = e[8],
                        r = e[12],
                        s = e[1],
                        a = e[5],
                        o = e[9],
                        l = e[13],
                        h = e[2],
                        c = e[6],
                        u = e[10],
                        d = e[14];
                    return e[3] * (+r * o * c - n * l * c - r * a * u + i * l * u + n * a * d - i * o * d) + e[7] * (+t * o * d - t * l * u + r * s * u - n * s * d + n * l * h - r * o * h) + e[11] * (+t * l * c - t * a * d - r * s * c + i * s * d + r * a * h - i * l * h) + e[15] * (-n * a * h - t * o * c + t * a * u + n * s * c - i * s * u + i * o * h)
                }
                transpose() {
                    const e = this.elements;
                    let t;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                }
                setPosition(e, t, i) {
                    const n = this.elements;
                    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        i = e[1],
                        n = e[2],
                        r = e[3],
                        s = e[4],
                        a = e[5],
                        o = e[6],
                        l = e[7],
                        h = e[8],
                        c = e[9],
                        u = e[10],
                        d = e[11],
                        p = e[12],
                        f = e[13],
                        m = e[14],
                        g = e[15],
                        y = c * m * l - f * u * l + f * o * d - a * m * d - c * o * g + a * u * g,
                        _ = p * u * l - h * m * l - p * o * d + s * m * d + h * o * g - s * u * g,
                        v = h * f * l - p * c * l + p * a * d - s * f * d - h * a * g + s * c * g,
                        b = p * c * o - h * f * o - p * a * u + s * f * u + h * a * m - s * c * m,
                        T = t * y + i * _ + n * v + r * b;
                    if (0 === T) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const x = 1 / T;
                    return e[0] = y * x, e[1] = (f * u * r - c * m * r - f * n * d + i * m * d + c * n * g - i * u * g) * x, e[2] = (a * m * r - f * o * r + f * n * l - i * m * l - a * n * g + i * o * g) * x, e[3] = (c * o * r - a * u * r - c * n * l + i * u * l + a * n * d - i * o * d) * x, e[4] = _ * x, e[5] = (h * m * r - p * u * r + p * n * d - t * m * d - h * n * g + t * u * g) * x, e[6] = (p * o * r - s * m * r - p * n * l + t * m * l + s * n * g - t * o * g) * x, e[7] = (s * u * r - h * o * r + h * n * l - t * u * l - s * n * d + t * o * d) * x, e[8] = v * x, e[9] = (p * c * r - h * f * r - p * i * d + t * f * d + h * i * g - t * c * g) * x, e[10] = (s * f * r - p * a * r + p * i * l - t * f * l - s * i * g + t * a * g) * x, e[11] = (h * a * r - s * c * r - h * i * l + t * c * l + s * i * d - t * a * d) * x, e[12] = b * x, e[13] = (h * f * n - p * c * n + p * i * u - t * f * u - h * i * m + t * c * m) * x, e[14] = (p * a * n - s * f * n - p * i * o + t * f * o + s * i * m - t * a * m) * x, e[15] = (s * c * n - h * a * n + h * i * o - t * c * o - s * i * u + t * a * u) * x, this
                }
                scale(e) {
                    const t = this.elements,
                        i = e.x,
                        n = e.y,
                        r = e.z;
                    return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    const e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, i, n))
                }
                makeTranslation(e, t, i) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
                }
                makeRotationX(e) {
                    const t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
                }
                makeRotationY(e) {
                    const t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(e) {
                    const t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(e, t) {
                    const i = Math.cos(t),
                        n = Math.sin(t),
                        r = 1 - i,
                        s = e.x,
                        a = e.y,
                        o = e.z,
                        l = r * s,
                        h = r * a;
                    return this.set(l * s + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, h * a + i, h * o - n * s, 0, l * o - n * a, h * o + n * s, r * o * o + i, 0, 0, 0, 0, 1), this
                }
                makeScale(e, t, i) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                }
                makeShear(e, t, i, n, r, s) {
                    return this.set(1, i, r, 0, e, 1, s, 0, t, n, 1, 0, 0, 0, 0, 1), this
                }
                compose(e, t, i) {
                    const n = this.elements,
                        r = t._x,
                        s = t._y,
                        a = t._z,
                        o = t._w,
                        l = r + r,
                        h = s + s,
                        c = a + a,
                        u = r * l,
                        d = r * h,
                        p = r * c,
                        f = s * h,
                        m = s * c,
                        g = a * c,
                        y = o * l,
                        _ = o * h,
                        v = o * c,
                        b = i.x,
                        T = i.y,
                        x = i.z;
                    return n[0] = (1 - (f + g)) * b, n[1] = (d + v) * b, n[2] = (p - _) * b, n[3] = 0, n[4] = (d - v) * T, n[5] = (1 - (u + g)) * T, n[6] = (m + y) * T, n[7] = 0, n[8] = (p + _) * x, n[9] = (m - y) * x, n[10] = (1 - (u + f)) * x, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this
                }
                decompose(e, t, i) {
                    const n = this.elements;
                    let r = Bi.set(n[0], n[1], n[2]).length();
                    const s = Bi.set(n[4], n[5], n[6]).length(),
                        a = Bi.set(n[8], n[9], n[10]).length();
                    this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], Fi.copy(this);
                    const o = 1 / r,
                        l = 1 / s,
                        h = 1 / a;
                    return Fi.elements[0] *= o, Fi.elements[1] *= o, Fi.elements[2] *= o, Fi.elements[4] *= l, Fi.elements[5] *= l, Fi.elements[6] *= l, Fi.elements[8] *= h, Fi.elements[9] *= h, Fi.elements[10] *= h, t.setFromRotationMatrix(Fi), i.x = r, i.y = s, i.z = a, this
                }
                makePerspective(e, t, i, n, r, s) {
                    void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    const a = this.elements,
                        o = 2 * r / (t - e),
                        l = 2 * r / (i - n),
                        h = (t + e) / (t - e),
                        c = (i + n) / (i - n),
                        u = -(s + r) / (s - r),
                        d = -2 * s * r / (s - r);
                    return a[0] = o, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = l, a[9] = c, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                }
                makeOrthographic(e, t, i, n, r, s) {
                    const a = this.elements,
                        o = 1 / (t - e),
                        l = 1 / (i - n),
                        h = 1 / (s - r),
                        c = (t + e) * o,
                        u = (i + n) * l,
                        d = (s + r) * h;
                    return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -c, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                }
                equals(e) {
                    const t = this.elements,
                        i = e.elements;
                    for (let e = 0; e < 16; e++)
                        if (t[e] !== i[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const i = this.elements;
                    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
                }
            }
            Ui.prototype.isMatrix4 = !0;
            const Bi = new ai,
                Fi = new Ui,
                Hi = new ai(0, 0, 0),
                zi = new ai(1, 1, 1),
                Vi = new ai,
                Gi = new ai,
                Wi = new ai,
                ji = new Ui,
                qi = new si;
            class $i {
                constructor(e = 0, t = 0, i = 0, n = $i.DefaultOrder) {
                    this._x = e, this._y = t, this._z = i, this._order = n
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e, this._onChangeCallback()
                }
                set(e, t, i, n = this._order) {
                    return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(e, t = this._order, i = !0) {
                    const n = e.elements,
                        r = n[0],
                        s = n[4],
                        a = n[8],
                        o = n[1],
                        l = n[5],
                        h = n[9],
                        c = n[2],
                        u = n[6],
                        d = n[10];
                    switch (t) {
                        case "XYZ":
                            this._y = Math.asin(kt(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-kt(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-c, r), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(kt(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-kt(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(kt(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                            break;
                        case "XZY":
                            this._z = Math.asin(-kt(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, d), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                    }
                    return this._order = t, !0 === i && this._onChangeCallback(), this
                }
                setFromQuaternion(e, t, i) {
                    return ji.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ji, t, i)
                }
                setFromVector3(e, t = this._order) {
                    return this.set(e.x, e.y, e.z, t)
                }
                reorder(e) {
                    return qi.setFromEuler(this), this.setFromQuaternion(qi, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                }
                toVector3(e) {
                    return e ? e.set(this._x, this._y, this._z) : new ai(this._x, this._y, this._z)
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}
            }
            $i.prototype.isEuler = !0, $i.DefaultOrder = "XYZ", $i.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            class Xi {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = (1 << e | 0) >>> 0
                }
                enable(e) {
                    this.mask |= 1 << e | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e | 0
                }
                disable(e) {
                    this.mask &= ~(1 << e | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return 0 != (this.mask & e.mask)
                }
                isEnabled(e) {
                    return 0 != (this.mask & (1 << e | 0))
                }
            }
            let Yi = 0;
            const Ki = new ai,
                Ji = new si,
                Zi = new Ui,
                Qi = new ai,
                en = new ai,
                tn = new ai,
                nn = new si,
                rn = new ai(1, 0, 0),
                sn = new ai(0, 1, 0),
                an = new ai(0, 0, 1),
                on = {
                    type: "added"
                },
                ln = {
                    type: "removed"
                };
            class hn extends Ct {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: Yi++
                    }), this.uuid = Rt(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = hn.DefaultUp.clone();
                    const e = new ai,
                        t = new $i,
                        i = new si,
                        n = new ai(1, 1, 1);
                    t._onChange((function() {
                        i.setFromEuler(t, !1)
                    })), i._onChange((function() {
                        t.setFromQuaternion(i, void 0, !1)
                    })), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: i
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        modelViewMatrix: {
                            value: new Ui
                        },
                        normalMatrix: {
                            value: new zt
                        }
                    }), this.matrix = new Ui, this.matrixWorld = new Ui, this.matrixAutoUpdate = hn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Xi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(e) {
                    return this.quaternion.premultiply(e), this
                }
                setRotationFromAxisAngle(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                }
                setRotationFromEuler(e) {
                    this.quaternion.setFromEuler(e, !0)
                }
                setRotationFromMatrix(e) {
                    this.quaternion.setFromRotationMatrix(e)
                }
                setRotationFromQuaternion(e) {
                    this.quaternion.copy(e)
                }
                rotateOnAxis(e, t) {
                    return Ji.setFromAxisAngle(e, t), this.quaternion.multiply(Ji), this
                }
                rotateOnWorldAxis(e, t) {
                    return Ji.setFromAxisAngle(e, t), this.quaternion.premultiply(Ji), this
                }
                rotateX(e) {
                    return this.rotateOnAxis(rn, e)
                }
                rotateY(e) {
                    return this.rotateOnAxis(sn, e)
                }
                rotateZ(e) {
                    return this.rotateOnAxis(an, e)
                }
                translateOnAxis(e, t) {
                    return Ki.copy(e).applyQuaternion(this.quaternion), this.position.add(Ki.multiplyScalar(t)), this
                }
                translateX(e) {
                    return this.translateOnAxis(rn, e)
                }
                translateY(e) {
                    return this.translateOnAxis(sn, e)
                }
                translateZ(e) {
                    return this.translateOnAxis(an, e)
                }
                localToWorld(e) {
                    return e.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(e) {
                    return e.applyMatrix4(Zi.copy(this.matrixWorld).invert())
                }
                lookAt(e, t, i) {
                    e.isVector3 ? Qi.copy(e) : Qi.set(e, t, i);
                    const n = this.parent;
                    this.updateWorldMatrix(!0, !1), en.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Zi.lookAt(en, Qi, this.up) : Zi.lookAt(Qi, en, this.up), this.quaternion.setFromRotationMatrix(Zi), n && (Zi.extractRotation(n.matrixWorld), Ji.setFromRotationMatrix(Zi), this.quaternion.premultiply(Ji.invert()))
                }
                add(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(on)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                }
                remove(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    const t = this.children.indexOf(e);
                    return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(ln)), this
                }
                removeFromParent() {
                    const e = this.parent;
                    return null !== e && e.remove(this), this
                }
                clear() {
                    for (let e = 0; e < this.children.length; e++) {
                        const t = this.children[e];
                        t.parent = null, t.dispatchEvent(ln)
                    }
                    return this.children.length = 0, this
                }
                attach(e) {
                    return this.updateWorldMatrix(!0, !1), Zi.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Zi.multiply(e.parent.matrixWorld)), e.applyMatrix4(Zi), this.add(e), e.updateWorldMatrix(!1, !0), this
                }
                getObjectById(e) {
                    return this.getObjectByProperty("id", e)
                }
                getObjectByName(e) {
                    return this.getObjectByProperty("name", e)
                }
                getObjectByProperty(e, t) {
                    if (this[e] === t) return this;
                    for (let i = 0, n = this.children.length; i < n; i++) {
                        const n = this.children[i].getObjectByProperty(e, t);
                        if (void 0 !== n) return n
                    }
                }
                getWorldPosition(e) {
                    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(en, e, tn), e
                }
                getWorldScale(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(en, nn, e), e
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    const t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                }
                raycast() {}
                traverse(e) {
                    e(this);
                    const t = this.children;
                    for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e)
                }
                traverseVisible(e) {
                    if (!1 === this.visible) return;
                    e(this);
                    const t = this.children;
                    for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e)
                }
                traverseAncestors(e) {
                    const t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                    const t = this.children;
                    for (let i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e)
                }
                updateWorldMatrix(e, t) {
                    const i = this.parent;
                    if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                        const e = this.children;
                        for (let t = 0, i = e.length; t < i; t++) e[t].updateWorldMatrix(!1, !0)
                    }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e,
                        i = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {}
                    }, i.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const n = {};

                    function r(t, i) {
                        return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(e).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        n.geometry = r(e.geometries, this.geometry);
                        const t = this.geometry.parameters;
                        if (void 0 !== t && void 0 !== t.shapes) {
                            const i = t.shapes;
                            if (Array.isArray(i))
                                for (let t = 0, n = i.length; t < n; t++) {
                                    const n = i[t];
                                    r(e.shapes, n)
                                } else r(e.shapes, i)
                        }
                    }
                    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const t = [];
                            for (let i = 0, n = this.material.length; i < n; i++) t.push(r(e.materials, this.material[i]));
                            n.material = t
                        } else n.material = r(e.materials, this.material);
                    if (this.children.length > 0) {
                        n.children = [];
                        for (let t = 0; t < this.children.length; t++) n.children.push(this.children[t].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        n.animations = [];
                        for (let t = 0; t < this.animations.length; t++) {
                            const i = this.animations[t];
                            n.animations.push(r(e.animations, i))
                        }
                    }
                    if (t) {
                        const t = s(e.geometries),
                            n = s(e.materials),
                            r = s(e.textures),
                            a = s(e.images),
                            o = s(e.shapes),
                            l = s(e.skeletons),
                            h = s(e.animations);
                        t.length > 0 && (i.geometries = t), n.length > 0 && (i.materials = n), r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a), o.length > 0 && (i.shapes = o), l.length > 0 && (i.skeletons = l), h.length > 0 && (i.animations = h)
                    }
                    return i.object = n, i;

                    function s(e) {
                        const t = [];
                        for (const i in e) {
                            const n = e[i];
                            delete n.metadata, t.push(n)
                        }
                        return t
                    }
                }
                clone(e) {
                    return (new this.constructor).copy(this, e)
                }
                copy(e, t = !0) {
                    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (let t = 0; t < e.children.length; t++) {
                            const i = e.children[t];
                            this.add(i.clone())
                        }
                    return this
                }
            }
            hn.DefaultUp = new ai(0, 1, 0), hn.DefaultMatrixAutoUpdate = !0, hn.prototype.isObject3D = !0;
            const cn = new ai,
                un = new ai,
                dn = new ai,
                pn = new ai,
                fn = new ai,
                mn = new ai,
                gn = new ai,
                yn = new ai,
                _n = new ai,
                vn = new ai;
            class bn {
                constructor(e = new ai, t = new ai, i = new ai) {
                    this.a = e, this.b = t, this.c = i
                }
                static getNormal(e, t, i, n) {
                    n.subVectors(i, t), cn.subVectors(e, t), n.cross(cn);
                    const r = n.lengthSq();
                    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
                }
                static getBarycoord(e, t, i, n, r) {
                    cn.subVectors(n, t), un.subVectors(i, t), dn.subVectors(e, t);
                    const s = cn.dot(cn),
                        a = cn.dot(un),
                        o = cn.dot(dn),
                        l = un.dot(un),
                        h = un.dot(dn),
                        c = s * l - a * a;
                    if (0 === c) return r.set(-2, -1, -1);
                    const u = 1 / c,
                        d = (l * o - a * h) * u,
                        p = (s * h - a * o) * u;
                    return r.set(1 - d - p, p, d)
                }
                static containsPoint(e, t, i, n) {
                    return this.getBarycoord(e, t, i, n, pn), pn.x >= 0 && pn.y >= 0 && pn.x + pn.y <= 1
                }
                static getUV(e, t, i, n, r, s, a, o) {
                    return this.getBarycoord(e, t, i, n, pn), o.set(0, 0), o.addScaledVector(r, pn.x), o.addScaledVector(s, pn.y), o.addScaledVector(a, pn.z), o
                }
                static isFrontFacing(e, t, i, n) {
                    return cn.subVectors(i, t), un.subVectors(e, t), cn.cross(un).dot(n) < 0
                }
                set(e, t, i) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
                }
                setFromPointsAndIndices(e, t, i, n) {
                    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this
                }
                setFromAttributeAndIndices(e, t, i, n) {
                    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                }
                getArea() {
                    return cn.subVectors(this.c, this.b), un.subVectors(this.a, this.b), .5 * cn.cross(un).length()
                }
                getMidpoint(e) {
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return bn.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return bn.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getUV(e, t, i, n, r) {
                    return bn.getUV(e, this.a, this.b, this.c, t, i, n, r)
                }
                containsPoint(e) {
                    return bn.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return bn.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    const i = this.a,
                        n = this.b,
                        r = this.c;
                    let s, a;
                    fn.subVectors(n, i), mn.subVectors(r, i), yn.subVectors(e, i);
                    const o = fn.dot(yn),
                        l = mn.dot(yn);
                    if (o <= 0 && l <= 0) return t.copy(i);
                    _n.subVectors(e, n);
                    const h = fn.dot(_n),
                        c = mn.dot(_n);
                    if (h >= 0 && c <= h) return t.copy(n);
                    const u = o * c - h * l;
                    if (u <= 0 && o >= 0 && h <= 0) return s = o / (o - h), t.copy(i).addScaledVector(fn, s);
                    vn.subVectors(e, r);
                    const d = fn.dot(vn),
                        p = mn.dot(vn);
                    if (p >= 0 && d <= p) return t.copy(r);
                    const f = d * l - o * p;
                    if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), t.copy(i).addScaledVector(mn, a);
                    const m = h * p - d * c;
                    if (m <= 0 && c - h >= 0 && d - p >= 0) return gn.subVectors(r, n), a = (c - h) / (c - h + (d - p)), t.copy(n).addScaledVector(gn, a);
                    const g = 1 / (m + f + u);
                    return s = f * g, a = u * g, t.copy(i).addScaledVector(fn, s).addScaledVector(mn, a)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            let Tn = 0;
            class xn extends Ct {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: Tn++
                    }), this.uuid = Rt(), this.name = "", this.type = "Material", this.fog = !0, this.blending = f, this.side = c, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = A, this.blendDst = L, this.blendEquation = v, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = B, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = xt, this.stencilZFail = xt, this.stencilZPass = xt, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(e) {
                    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                }
                onBuild() {}
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(e) {
                    if (void 0 !== e)
                        for (const t in e) {
                            const i = e[t];
                            if (void 0 === i) {
                                console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                                continue
                            }
                            if ("shading" === t) {
                                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                                continue
                            }
                            const n = this[t];
                            void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                        }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    const i = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function n(e) {
                        const t = [];
                        for (const i in e) {
                            const n = e[i];
                            delete n.metadata, t.push(n)
                        }
                        return t
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== f && (i.blending = this.blending), this.side !== c && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = this.flatShading), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), t) {
                        const t = n(e.textures),
                            r = n(e.images);
                        t.length > 0 && (i.textures = t), r.length > 0 && (i.images = r)
                    }
                    return i
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                    const t = e.clippingPlanes;
                    let i = null;
                    if (null !== t) {
                        const e = t.length;
                        i = new Array(e);
                        for (let n = 0; n !== e; ++n) i[n] = t[n].clone()
                    }
                    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
            }
            xn.prototype.isMaterial = !0;
            class wn extends xn {
                constructor(e) {
                    super(), this.type = "MeshBasicMaterial", this.color = new Kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = G, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
                }
            }
            wn.prototype.isMeshBasicMaterial = !0;
            const Sn = new ai,
                En = new Ht;
            class Mn {
                constructor(e, t, i) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.usage = wt, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
                }
                copyAt(e, t, i) {
                    e *= this.itemSize, i *= t.itemSize;
                    for (let n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
                    return this
                }
                copyArray(e) {
                    return this.array.set(e), this
                }
                copyColorsArray(e) {
                    const t = this.array;
                    let i = 0;
                    for (let n = 0, r = e.length; n < r; n++) {
                        let r = e[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), r = new Kt), t[i++] = r.r, t[i++] = r.g, t[i++] = r.b
                    }
                    return this
                }
                copyVector2sArray(e) {
                    const t = this.array;
                    let i = 0;
                    for (let n = 0, r = e.length; n < r; n++) {
                        let r = e[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), r = new Ht), t[i++] = r.x, t[i++] = r.y
                    }
                    return this
                }
                copyVector3sArray(e) {
                    const t = this.array;
                    let i = 0;
                    for (let n = 0, r = e.length; n < r; n++) {
                        let r = e[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), r = new ai), t[i++] = r.x, t[i++] = r.y, t[i++] = r.z
                    }
                    return this
                }
                copyVector4sArray(e) {
                    const t = this.array;
                    let i = 0;
                    for (let n = 0, r = e.length; n < r; n++) {
                        let r = e[n];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), r = new ii), t[i++] = r.x, t[i++] = r.y, t[i++] = r.z, t[i++] = r.w
                    }
                    return this
                }
                applyMatrix3(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, i = this.count; t < i; t++) En.fromBufferAttribute(this, t), En.applyMatrix3(e), this.setXY(t, En.x, En.y);
                    else if (3 === this.itemSize)
                        for (let t = 0, i = this.count; t < i; t++) Sn.fromBufferAttribute(this, t), Sn.applyMatrix3(e), this.setXYZ(t, Sn.x, Sn.y, Sn.z);
                    return this
                }
                applyMatrix4(e) {
                    for (let t = 0, i = this.count; t < i; t++) Sn.x = this.getX(t), Sn.y = this.getY(t), Sn.z = this.getZ(t), Sn.applyMatrix4(e), this.setXYZ(t, Sn.x, Sn.y, Sn.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, i = this.count; t < i; t++) Sn.x = this.getX(t), Sn.y = this.getY(t), Sn.z = this.getZ(t), Sn.applyNormalMatrix(e), this.setXYZ(t, Sn.x, Sn.y, Sn.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, i = this.count; t < i; t++) Sn.x = this.getX(t), Sn.y = this.getY(t), Sn.z = this.getZ(t), Sn.transformDirection(e), this.setXYZ(t, Sn.x, Sn.y, Sn.z);
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                getX(e) {
                    return this.array[e * this.itemSize]
                }
                setX(e, t) {
                    return this.array[e * this.itemSize] = t, this
                }
                getY(e) {
                    return this.array[e * this.itemSize + 1]
                }
                setY(e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                }
                getZ(e) {
                    return this.array[e * this.itemSize + 2]
                }
                setZ(e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                }
                getW(e) {
                    return this.array[e * this.itemSize + 3]
                }
                setW(e, t) {
                    return this.array[e * this.itemSize + 3] = t, this
                }
                setXY(e, t, i) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this
                }
                setXYZ(e, t, i, n) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this
                }
                setXYZW(e, t, i, n, r) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    const e = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (e.name = this.name), this.usage !== wt && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
                }
            }
            Mn.prototype.isBufferAttribute = !0;
            class Cn extends Mn {
                constructor(e, t, i) {
                    super(new Uint16Array(e), t, i)
                }
            }
            class An extends Mn {
                constructor(e, t, i) {
                    super(new Uint32Array(e), t, i)
                }
            }(class extends Mn {
                constructor(e, t, i) {
                    super(new Uint16Array(e), t, i)
                }
            }).prototype.isFloat16BufferAttribute = !0;
            class Ln extends Mn {
                constructor(e, t, i) {
                    super(new Float32Array(e), t, i)
                }
            }
            let In = 0;
            const Pn = new Ui,
                Rn = new hn,
                kn = new ai,
                Dn = new hi,
                On = new hi,
                Nn = new ai;
            class Un extends Ct {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: In++
                    }), this.uuid = Rt(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(e) {
                    return Array.isArray(e) ? this.index = new(Vt(e) ? An : Cn)(e, 1) : this.index = e, this
                }
                getAttribute(e) {
                    return this.attributes[e]
                }
                setAttribute(e, t) {
                    return this.attributes[e] = t, this
                }
                deleteAttribute(e) {
                    return delete this.attributes[e], this
                }
                hasAttribute(e) {
                    return void 0 !== this.attributes[e]
                }
                addGroup(e, t, i = 0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: i
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                }
                applyMatrix4(e) {
                    const t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                    const i = this.attributes.normal;
                    if (void 0 !== i) {
                        const t = (new zt).getNormalMatrix(e);
                        i.applyNormalMatrix(t), i.needsUpdate = !0
                    }
                    const n = this.attributes.tangent;
                    return void 0 !== n && (n.transformDirection(e), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(e) {
                    return Pn.makeRotationFromQuaternion(e), this.applyMatrix4(Pn), this
                }
                rotateX(e) {
                    return Pn.makeRotationX(e), this.applyMatrix4(Pn), this
                }
                rotateY(e) {
                    return Pn.makeRotationY(e), this.applyMatrix4(Pn), this
                }
                rotateZ(e) {
                    return Pn.makeRotationZ(e), this.applyMatrix4(Pn), this
                }
                translate(e, t, i) {
                    return Pn.makeTranslation(e, t, i), this.applyMatrix4(Pn), this
                }
                scale(e, t, i) {
                    return Pn.makeScale(e, t, i), this.applyMatrix4(Pn), this
                }
                lookAt(e) {
                    return Rn.lookAt(e), Rn.updateMatrix(), this.applyMatrix4(Rn.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(kn).negate(), this.translate(kn.x, kn.y, kn.z), this
                }
                setFromPoints(e) {
                    const t = [];
                    for (let i = 0, n = e.length; i < n; i++) {
                        const n = e[i];
                        t.push(n.x, n.y, n.z || 0)
                    }
                    return this.setAttribute("position", new Ln(t, 3)), this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new hi);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new ai(-1 / 0, -1 / 0, -1 / 0), new ai(1 / 0, 1 / 0, 1 / 0));
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e), t)
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e];
                                Dn.setFromBufferAttribute(i), this.morphTargetsRelative ? (Nn.addVectors(this.boundingBox.min, Dn.min), this.boundingBox.expandByPoint(Nn), Nn.addVectors(this.boundingBox.max, Dn.max), this.boundingBox.expandByPoint(Nn)) : (this.boundingBox.expandByPoint(Dn.min), this.boundingBox.expandByPoint(Dn.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new Ai);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new ai, 1 / 0);
                    if (e) {
                        const i = this.boundingSphere.center;
                        if (Dn.setFromBufferAttribute(e), t)
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e];
                                On.setFromBufferAttribute(i), this.morphTargetsRelative ? (Nn.addVectors(Dn.min, On.min), Dn.expandByPoint(Nn), Nn.addVectors(Dn.max, On.max), Dn.expandByPoint(Nn)) : (Dn.expandByPoint(On.min), Dn.expandByPoint(On.max))
                            }
                        Dn.getCenter(i);
                        let n = 0;
                        for (let t = 0, r = e.count; t < r; t++) Nn.fromBufferAttribute(e, t), n = Math.max(n, i.distanceToSquared(Nn));
                        if (t)
                            for (let r = 0, s = t.length; r < s; r++) {
                                const s = t[r],
                                    a = this.morphTargetsRelative;
                                for (let t = 0, r = s.count; t < r; t++) Nn.fromBufferAttribute(s, t), a && (kn.fromBufferAttribute(e, t), Nn.add(kn)), n = Math.max(n, i.distanceToSquared(Nn))
                            }
                        this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    const e = this.index,
                        t = this.attributes;
                    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    const i = e.array,
                        n = t.position.array,
                        r = t.normal.array,
                        s = t.uv.array,
                        a = n.length / 3;
                    void 0 === t.tangent && this.setAttribute("tangent", new Mn(new Float32Array(4 * a), 4));
                    const o = t.tangent.array,
                        l = [],
                        h = [];
                    for (let e = 0; e < a; e++) l[e] = new ai, h[e] = new ai;
                    const c = new ai,
                        u = new ai,
                        d = new ai,
                        p = new Ht,
                        f = new Ht,
                        m = new Ht,
                        g = new ai,
                        y = new ai;

                    function _(e, t, i) {
                        c.fromArray(n, 3 * e), u.fromArray(n, 3 * t), d.fromArray(n, 3 * i), p.fromArray(s, 2 * e), f.fromArray(s, 2 * t), m.fromArray(s, 2 * i), u.sub(c), d.sub(c), f.sub(p), m.sub(p);
                        const r = 1 / (f.x * m.y - m.x * f.y);
                        isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), y.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r), l[e].add(g), l[t].add(g), l[i].add(g), h[e].add(y), h[t].add(y), h[i].add(y))
                    }
                    let v = this.groups;
                    0 === v.length && (v = [{
                        start: 0,
                        count: i.length
                    }]);
                    for (let e = 0, t = v.length; e < t; ++e) {
                        const t = v[e],
                            n = t.start;
                        for (let e = n, r = n + t.count; e < r; e += 3) _(i[e + 0], i[e + 1], i[e + 2])
                    }
                    const b = new ai,
                        T = new ai,
                        x = new ai,
                        w = new ai;

                    function S(e) {
                        x.fromArray(r, 3 * e), w.copy(x);
                        const t = l[e];
                        b.copy(t), b.sub(x.multiplyScalar(x.dot(t))).normalize(), T.crossVectors(w, t);
                        const i = T.dot(h[e]) < 0 ? -1 : 1;
                        o[4 * e] = b.x, o[4 * e + 1] = b.y, o[4 * e + 2] = b.z, o[4 * e + 3] = i
                    }
                    for (let e = 0, t = v.length; e < t; ++e) {
                        const t = v[e],
                            n = t.start;
                        for (let e = n, r = n + t.count; e < r; e += 3) S(i[e + 0]), S(i[e + 1]), S(i[e + 2])
                    }
                }
                computeVertexNormals() {
                    const e = this.index,
                        t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let i = this.getAttribute("normal");
                        if (void 0 === i) i = new Mn(new Float32Array(3 * t.count), 3), this.setAttribute("normal", i);
                        else
                            for (let e = 0, t = i.count; e < t; e++) i.setXYZ(e, 0, 0, 0);
                        const n = new ai,
                            r = new ai,
                            s = new ai,
                            a = new ai,
                            o = new ai,
                            l = new ai,
                            h = new ai,
                            c = new ai;
                        if (e)
                            for (let u = 0, d = e.count; u < d; u += 3) {
                                const d = e.getX(u + 0),
                                    p = e.getX(u + 1),
                                    f = e.getX(u + 2);
                                n.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), s.fromBufferAttribute(t, f), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), a.fromBufferAttribute(i, d), o.fromBufferAttribute(i, p), l.fromBufferAttribute(i, f), a.add(h), o.add(h), l.add(h), i.setXYZ(d, a.x, a.y, a.z), i.setXYZ(p, o.x, o.y, o.z), i.setXYZ(f, l.x, l.y, l.z)
                            } else
                                for (let e = 0, a = t.count; e < a; e += 3) n.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), h.subVectors(s, r), c.subVectors(n, r), h.cross(c), i.setXYZ(e + 0, h.x, h.y, h.z), i.setXYZ(e + 1, h.x, h.y, h.z), i.setXYZ(e + 2, h.x, h.y, h.z);
                        this.normalizeNormals(), i.needsUpdate = !0
                    }
                }
                merge(e, t) {
                    if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                    void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    const i = this.attributes;
                    for (const n in i) {
                        if (void 0 === e.attributes[n]) continue;
                        const r = i[n].array,
                            s = e.attributes[n],
                            a = s.array,
                            o = s.itemSize * t,
                            l = Math.min(a.length, r.length - o);
                        for (let e = 0, t = o; e < l; e++, t++) r[t] = a[e]
                    }
                    return this
                }
                normalizeNormals() {
                    const e = this.attributes.normal;
                    for (let t = 0, i = e.count; t < i; t++) Nn.fromBufferAttribute(e, t), Nn.normalize(), e.setXYZ(t, Nn.x, Nn.y, Nn.z)
                }
                toNonIndexed() {
                    function e(e, t) {
                        const i = e.array,
                            n = e.itemSize,
                            r = e.normalized,
                            s = new i.constructor(t.length * n);
                        let a = 0,
                            o = 0;
                        for (let r = 0, l = t.length; r < l; r++) {
                            a = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * n;
                            for (let e = 0; e < n; e++) s[o++] = i[a++]
                        }
                        return new Mn(s, n, r)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    const t = new Un,
                        i = this.index.array,
                        n = this.attributes;
                    for (const r in n) {
                        const s = e(n[r], i);
                        t.setAttribute(r, s)
                    }
                    const r = this.morphAttributes;
                    for (const n in r) {
                        const s = [],
                            a = r[n];
                        for (let t = 0, n = a.length; t < n; t++) {
                            const n = e(a[t], i);
                            s.push(n)
                        }
                        t.morphAttributes[n] = s
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    const s = this.groups;
                    for (let e = 0, i = s.length; e < i; e++) {
                        const i = s[e];
                        t.addGroup(i.start, i.count, i.materialIndex)
                    }
                    return t
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        const t = this.parameters;
                        for (const i in t) void 0 !== t[i] && (e[i] = t[i]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    const t = this.index;
                    null !== t && (e.data.index = {
                        type: t.array.constructor.name,
                        array: Array.prototype.slice.call(t.array)
                    });
                    const i = this.attributes;
                    for (const t in i) {
                        const n = i[t];
                        e.data.attributes[t] = n.toJSON(e.data)
                    }
                    const n = {};
                    let r = !1;
                    for (const t in this.morphAttributes) {
                        const i = this.morphAttributes[t],
                            s = [];
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            s.push(n.toJSON(e.data))
                        }
                        s.length > 0 && (n[t] = s, r = !0)
                    }
                    r && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
                    const s = this.groups;
                    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                    const a = this.boundingSphere;
                    return null !== a && (e.data.boundingSphere = {
                        center: a.center.toArray(),
                        radius: a.radius
                    }), e
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const t = {};
                    this.name = e.name;
                    const i = e.index;
                    null !== i && this.setIndex(i.clone(t));
                    const n = e.attributes;
                    for (const e in n) {
                        const i = n[e];
                        this.setAttribute(e, i.clone(t))
                    }
                    const r = e.morphAttributes;
                    for (const e in r) {
                        const i = [],
                            n = r[e];
                        for (let e = 0, r = n.length; e < r; e++) i.push(n[e].clone(t));
                        this.morphAttributes[e] = i
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    const s = e.groups;
                    for (let e = 0, t = s.length; e < t; e++) {
                        const t = s[e];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const a = e.boundingBox;
                    null !== a && (this.boundingBox = a.clone());
                    const o = e.boundingSphere;
                    return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            Un.prototype.isBufferGeometry = !0;
            const Bn = new Ui,
                Fn = new Ni,
                Hn = new Ai,
                zn = new ai,
                Vn = new ai,
                Gn = new ai,
                Wn = new ai,
                jn = new ai,
                qn = new ai,
                $n = new ai,
                Xn = new ai,
                Yn = new ai,
                Kn = new Ht,
                Jn = new Ht,
                Zn = new Ht,
                Qn = new ai,
                er = new ai;
            class tr extends hn {
                constructor(e = new Un, t = new wn) {
                    super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e) {
                    return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
                }
                updateMorphTargets() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        const t = e.morphAttributes,
                            i = Object.keys(t);
                        if (i.length > 0) {
                            const e = t[i[0]];
                            if (void 0 !== e) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, i = e.length; t < i; t++) {
                                    const i = e[t].name || String(t);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                                }
                            }
                        }
                    } else {
                        const t = e.morphTargets;
                        void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
                raycast(e, t) {
                    const i = this.geometry,
                        n = this.material,
                        r = this.matrixWorld;
                    if (void 0 === n) return;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), Hn.copy(i.boundingSphere), Hn.applyMatrix4(r), !1 === e.ray.intersectsSphere(Hn)) return;
                    if (Bn.copy(r).invert(), Fn.copy(e.ray).applyMatrix4(Bn), null !== i.boundingBox && !1 === Fn.intersectsBox(i.boundingBox)) return;
                    let s;
                    if (i.isBufferGeometry) {
                        const r = i.index,
                            a = i.attributes.position,
                            o = i.morphAttributes.position,
                            l = i.morphTargetsRelative,
                            h = i.attributes.uv,
                            c = i.attributes.uv2,
                            u = i.groups,
                            d = i.drawRange;
                        if (null !== r)
                            if (Array.isArray(n))
                                for (let i = 0, p = u.length; i < p; i++) {
                                    const p = u[i],
                                        f = n[p.materialIndex];
                                    for (let i = Math.max(p.start, d.start), n = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); i < n; i += 3) {
                                        const n = r.getX(i),
                                            u = r.getX(i + 1),
                                            d = r.getX(i + 2);
                                        s = ir(this, f, e, Fn, a, o, l, h, c, n, u, d), s && (s.faceIndex = Math.floor(i / 3), s.face.materialIndex = p.materialIndex, t.push(s))
                                    }
                                } else {
                                    for (let i = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); i < u; i += 3) {
                                        const u = r.getX(i),
                                            d = r.getX(i + 1),
                                            p = r.getX(i + 2);
                                        s = ir(this, n, e, Fn, a, o, l, h, c, u, d, p), s && (s.faceIndex = Math.floor(i / 3), t.push(s))
                                    }
                                } else if (void 0 !== a)
                                    if (Array.isArray(n))
                                        for (let i = 0, r = u.length; i < r; i++) {
                                            const r = u[i],
                                                p = n[r.materialIndex];
                                            for (let i = Math.max(r.start, d.start), n = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); i < n; i += 3) {
                                                s = ir(this, p, e, Fn, a, o, l, h, c, i, i + 1, i + 2), s && (s.faceIndex = Math.floor(i / 3), s.face.materialIndex = r.materialIndex, t.push(s))
                                            }
                                        } else {
                                            for (let i = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); i < r; i += 3) {
                                                s = ir(this, n, e, Fn, a, o, l, h, c, i, i + 1, i + 2), s && (s.faceIndex = Math.floor(i / 3), t.push(s))
                                            }
                                        }
                    } else i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }

            function ir(e, t, i, n, r, s, a, o, l, h, c, p) {
                zn.fromBufferAttribute(r, h), Vn.fromBufferAttribute(r, c), Gn.fromBufferAttribute(r, p);
                const f = e.morphTargetInfluences;
                if (s && f) {
                    $n.set(0, 0, 0), Xn.set(0, 0, 0), Yn.set(0, 0, 0);
                    for (let e = 0, t = s.length; e < t; e++) {
                        const t = f[e],
                            i = s[e];
                        0 !== t && (Wn.fromBufferAttribute(i, h), jn.fromBufferAttribute(i, c), qn.fromBufferAttribute(i, p), a ? ($n.addScaledVector(Wn, t), Xn.addScaledVector(jn, t), Yn.addScaledVector(qn, t)) : ($n.addScaledVector(Wn.sub(zn), t), Xn.addScaledVector(jn.sub(Vn), t), Yn.addScaledVector(qn.sub(Gn), t)))
                    }
                    zn.add($n), Vn.add(Xn), Gn.add(Yn)
                }
                e.isSkinnedMesh && (e.boneTransform(h, zn), e.boneTransform(c, Vn), e.boneTransform(p, Gn));
                const m = function(e, t, i, n, r, s, a, o) {
                    let l;
                    if (l = t.side === u ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, t.side !== d, o), null === l) return null;
                    er.copy(o), er.applyMatrix4(e.matrixWorld);
                    const h = i.ray.origin.distanceTo(er);
                    return h < i.near || h > i.far ? null : {
                        distance: h,
                        point: er.clone(),
                        object: e
                    }
                }(e, t, i, n, zn, Vn, Gn, Qn);
                if (m) {
                    o && (Kn.fromBufferAttribute(o, h), Jn.fromBufferAttribute(o, c), Zn.fromBufferAttribute(o, p), m.uv = bn.getUV(Qn, zn, Vn, Gn, Kn, Jn, Zn, new Ht)), l && (Kn.fromBufferAttribute(l, h), Jn.fromBufferAttribute(l, c), Zn.fromBufferAttribute(l, p), m.uv2 = bn.getUV(Qn, zn, Vn, Gn, Kn, Jn, Zn, new Ht));
                    const e = {
                        a: h,
                        b: c,
                        c: p,
                        normal: new ai,
                        materialIndex: 0
                    };
                    bn.getNormal(zn, Vn, Gn, e.normal), m.face = e
                }
                return m
            }
            tr.prototype.isMesh = !0;
            class nr extends Un {
                constructor(e = 1, t = 1, i = 1, n = 1, r = 1, s = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: i,
                        widthSegments: n,
                        heightSegments: r,
                        depthSegments: s
                    };
                    const a = this;
                    n = Math.floor(n), r = Math.floor(r), s = Math.floor(s);
                    const o = [],
                        l = [],
                        h = [],
                        c = [];
                    let u = 0,
                        d = 0;

                    function p(e, t, i, n, r, s, p, f, m, g, y) {
                        const _ = s / m,
                            v = p / g,
                            b = s / 2,
                            T = p / 2,
                            x = f / 2,
                            w = m + 1,
                            S = g + 1;
                        let E = 0,
                            M = 0;
                        const C = new ai;
                        for (let s = 0; s < S; s++) {
                            const a = s * v - T;
                            for (let o = 0; o < w; o++) {
                                const u = o * _ - b;
                                C[e] = u * n, C[t] = a * r, C[i] = x, l.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[i] = f > 0 ? 1 : -1, h.push(C.x, C.y, C.z), c.push(o / m), c.push(1 - s / g), E += 1
                            }
                        }
                        for (let e = 0; e < g; e++)
                            for (let t = 0; t < m; t++) {
                                const i = u + t + w * e,
                                    n = u + t + w * (e + 1),
                                    r = u + (t + 1) + w * (e + 1),
                                    s = u + (t + 1) + w * e;
                                o.push(i, n, s), o.push(n, r, s), M += 6
                            }
                        a.addGroup(d, M, y), d += M, u += E
                    }
                    p("z", "y", "x", -1, -1, i, t, e, s, r, 0), p("z", "y", "x", 1, -1, i, t, -e, s, r, 1), p("x", "z", "y", 1, 1, e, i, t, n, s, 2), p("x", "z", "y", 1, -1, e, i, -t, n, s, 3), p("x", "y", "z", 1, -1, e, t, i, n, r, 4), p("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(o), this.setAttribute("position", new Ln(l, 3)), this.setAttribute("normal", new Ln(h, 3)), this.setAttribute("uv", new Ln(c, 2))
                }
                static fromJSON(e) {
                    return new nr(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                }
            }

            function rr(e) {
                const t = {};
                for (const i in e) {
                    t[i] = {};
                    for (const n in e[i]) {
                        const r = e[i][n];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r
                    }
                }
                return t
            }

            function sr(e) {
                const t = {};
                for (let i = 0; i < e.length; i++) {
                    const n = rr(e[i]);
                    for (const e in n) t[e] = n[e]
                }
                return t
            }
            const ar = {
                clone: rr,
                merge: sr
            };
            class or extends xn {
                constructor(e) {
                    super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
                }
                copy(e) {
                    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = rr(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    t.glslVersion = this.glslVersion, t.uniforms = {};
                    for (const i in this.uniforms) {
                        const n = this.uniforms[i].value;
                        n && n.isTexture ? t.uniforms[i] = {
                            type: "t",
                            value: n.toJSON(e).uuid
                        } : n && n.isColor ? t.uniforms[i] = {
                            type: "c",
                            value: n.getHex()
                        } : n && n.isVector2 ? t.uniforms[i] = {
                            type: "v2",
                            value: n.toArray()
                        } : n && n.isVector3 ? t.uniforms[i] = {
                            type: "v3",
                            value: n.toArray()
                        } : n && n.isVector4 ? t.uniforms[i] = {
                            type: "v4",
                            value: n.toArray()
                        } : n && n.isMatrix3 ? t.uniforms[i] = {
                            type: "m3",
                            value: n.toArray()
                        } : n && n.isMatrix4 ? t.uniforms[i] = {
                            type: "m4",
                            value: n.toArray()
                        } : t.uniforms[i] = {
                            value: n
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                    const i = {};
                    for (const e in this.extensions) !0 === this.extensions[e] && (i[e] = !0);
                    return Object.keys(i).length > 0 && (t.extensions = i), t
                }
            }
            or.prototype.isShaderMaterial = !0;
            class lr extends hn {
                constructor() {
                    super(), this.type = "Camera", this.matrixWorldInverse = new Ui, this.projectionMatrix = new Ui, this.projectionMatrixInverse = new Ui
                }
                copy(e, t) {
                    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    const t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize()
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(e, t) {
                    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            lr.prototype.isCamera = !0;
            class hr extends lr {
                constructor(e = 50, t = 1, i = .1, n = 2e3) {
                    super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                }
                setFocalLength(e) {
                    const t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * Pt * Math.atan(t), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    const e = Math.tan(.5 * It * this.fov);
                    return .5 * this.getFilmHeight() / e
                }
                getEffectiveFOV() {
                    return 2 * Pt * Math.atan(Math.tan(.5 * It * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                setViewOffset(e, t, i, n, r, s) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = this.near;
                    let t = e * Math.tan(.5 * It * this.fov) / this.zoom,
                        i = 2 * t,
                        n = this.aspect * i,
                        r = -.5 * n;
                    const s = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const e = s.fullWidth,
                            a = s.fullHeight;
                        r += s.offsetX * n / e, t -= s.offsetY * i / a, n *= s.width / e, i *= s.height / a
                    }
                    const a = this.filmOffset;
                    0 !== a && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }
            hr.prototype.isPerspectiveCamera = !0;
            const cr = 90;
            class ur extends hn {
                constructor(e, t, i) {
                    if (super(), this.type = "CubeCamera", !0 !== i.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                    this.renderTarget = i;
                    const n = new hr(cr, 1, e, t);
                    n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new ai(1, 0, 0)), this.add(n);
                    const r = new hr(cr, 1, e, t);
                    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new ai(-1, 0, 0)), this.add(r);
                    const s = new hr(cr, 1, e, t);
                    s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new ai(0, 1, 0)), this.add(s);
                    const a = new hr(cr, 1, e, t);
                    a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new ai(0, -1, 0)), this.add(a);
                    const o = new hr(cr, 1, e, t);
                    o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new ai(0, 0, 1)), this.add(o);
                    const l = new hr(cr, 1, e, t);
                    l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new ai(0, 0, -1)), this.add(l)
                }
                update(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    const i = this.renderTarget,
                        [n, r, s, a, o, l] = this.children,
                        h = e.xr.enabled,
                        c = e.getRenderTarget();
                    e.xr.enabled = !1;
                    const u = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, n), e.setRenderTarget(i, 1), e.render(t, r), e.setRenderTarget(i, 2), e.render(t, s), e.setRenderTarget(i, 3), e.render(t, a), e.setRenderTarget(i, 4), e.render(t, o), i.texture.generateMipmaps = u, e.setRenderTarget(i, 5), e.render(t, l), e.setRenderTarget(c), e.xr.enabled = h, i.texture.needsPMREMUpdate = !0
                }
            }
            class dr extends ei {
                constructor(e, t, i, n, r, s, a, o, l, h) {
                    super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : Z, i, n, r, s, a, o, l, h), this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            dr.prototype.isCubeTexture = !0;
            class pr extends ni {
                constructor(e, t, i) {
                    Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = i), super(e, e, t), t = t || {}, this.texture = new dr(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : ce
                }
                fromEquirectangularTexture(e, t) {
                    this.texture.type = t.type, this.texture.format = Me, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                    const i = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                        },
                        n = new nr(5, 5, 5),
                        r = new or({
                            name: "CubemapFromEquirect",
                            uniforms: rr(i.uniforms),
                            vertexShader: i.vertexShader,
                            fragmentShader: i.fragmentShader,
                            side: u,
                            blending: p
                        });
                    r.uniforms.tEquirect.value = t;
                    const s = new tr(n, r),
                        a = t.minFilter;
                    t.minFilter === de && (t.minFilter = ce);
                    return new ur(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
                }
                clear(e, t, i, n) {
                    const r = e.getRenderTarget();
                    for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, i, n);
                    e.setRenderTarget(r)
                }
            }
            pr.prototype.isWebGLCubeRenderTarget = !0;
            const fr = new ai,
                mr = new ai,
                gr = new zt;
            class yr {
                constructor(e = new ai(1, 0, 0), t = 0) {
                    this.normal = e, this.constant = t
                }
                set(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                }
                setComponents(e, t, i, n) {
                    return this.normal.set(e, t, i), this.constant = n, this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                }
                setFromCoplanarPoints(e, t, i) {
                    const n = fr.subVectors(i, t).cross(mr.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(n, e), this
                }
                copy(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                }
                normalize() {
                    const e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                }
                intersectLine(e, t) {
                    const i = e.delta(fr),
                        n = this.normal.dot(i);
                    if (0 === n) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                    const r = -(e.start.dot(this.normal) + this.constant) / n;
                    return r < 0 || r > 1 ? null : t.copy(i).multiplyScalar(r).add(e.start)
                }
                intersectsLine(e) {
                    const t = this.distanceToPoint(e.start),
                        i = this.distanceToPoint(e.end);
                    return t < 0 && i > 0 || i < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    const i = t || gr.getNormalMatrix(e),
                        n = this.coplanarPoint(fr).applyMatrix4(e),
                        r = this.normal.applyMatrix3(i).normalize();
                    return this.constant = -n.dot(r), this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal), this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            yr.prototype.isPlane = !0;
            const _r = new Ai,
                vr = new ai;
            class br {
                constructor(e = new yr, t = new yr, i = new yr, n = new yr, r = new yr, s = new yr) {
                    this.planes = [e, t, i, n, r, s]
                }
                set(e, t, i, n, r, s) {
                    const a = this.planes;
                    return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(s), this
                }
                copy(e) {
                    const t = this.planes;
                    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
                    return this
                }
                setFromProjectionMatrix(e) {
                    const t = this.planes,
                        i = e.elements,
                        n = i[0],
                        r = i[1],
                        s = i[2],
                        a = i[3],
                        o = i[4],
                        l = i[5],
                        h = i[6],
                        c = i[7],
                        u = i[8],
                        d = i[9],
                        p = i[10],
                        f = i[11],
                        m = i[12],
                        g = i[13],
                        y = i[14],
                        _ = i[15];
                    return t[0].setComponents(a - n, c - o, f - u, _ - m).normalize(), t[1].setComponents(a + n, c + o, f + u, _ + m).normalize(), t[2].setComponents(a + r, c + l, f + d, _ + g).normalize(), t[3].setComponents(a - r, c - l, f - d, _ - g).normalize(), t[4].setComponents(a - s, c - h, f - p, _ - y).normalize(), t[5].setComponents(a + s, c + h, f + p, _ + y).normalize(), this
                }
                intersectsObject(e) {
                    const t = e.geometry;
                    return null === t.boundingSphere && t.computeBoundingSphere(), _r.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(_r)
                }
                intersectsSprite(e) {
                    return _r.center.set(0, 0, 0), _r.radius = .7071067811865476, _r.applyMatrix4(e.matrixWorld), this.intersectsSphere(_r)
                }
                intersectsSphere(e) {
                    const t = this.planes,
                        i = e.center,
                        n = -e.radius;
                    for (let e = 0; e < 6; e++) {
                        if (t[e].distanceToPoint(i) < n) return !1
                    }
                    return !0
                }
                intersectsBox(e) {
                    const t = this.planes;
                    for (let i = 0; i < 6; i++) {
                        const n = t[i];
                        if (vr.x = n.normal.x > 0 ? e.max.x : e.min.x, vr.y = n.normal.y > 0 ? e.max.y : e.min.y, vr.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(vr) < 0) return !1
                    }
                    return !0
                }
                containsPoint(e) {
                    const t = this.planes;
                    for (let i = 0; i < 6; i++)
                        if (t[i].distanceToPoint(e) < 0) return !1;
                    return !0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }

            function Tr() {
                let e = null,
                    t = !1,
                    i = null,
                    n = null;

                function r(t, s) {
                    i(t, s), n = e.requestAnimationFrame(r)
                }
                return {
                    start: function() {
                        !0 !== t && null !== i && (n = e.requestAnimationFrame(r), t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(n), t = !1
                    },
                    setAnimationLoop: function(e) {
                        i = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }

            function xr(e, t) {
                const i = t.isWebGL2,
                    n = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), n.get(e)
                    },
                    remove: function(t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const i = n.get(t);
                        i && (e.deleteBuffer(i.buffer), n.delete(t))
                    },
                    update: function(t, r) {
                        if (t.isGLBufferAttribute) {
                            const e = n.get(t);
                            return void((!e || e.version < t.version) && n.set(t, {
                                buffer: t.buffer,
                                type: t.type,
                                bytesPerElement: t.elementSize,
                                version: t.version
                            }))
                        }
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const s = n.get(t);
                        void 0 === s ? n.set(t, function(t, n) {
                            const r = t.array,
                                s = t.usage,
                                a = e.createBuffer();
                            e.bindBuffer(n, a), e.bufferData(n, r, s), t.onUploadCallback();
                            let o = 5126;
                            return r instanceof Float32Array ? o = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? t.isFloat16BufferAttribute ? i ? o = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = 5123 : r instanceof Int16Array ? o = 5122 : r instanceof Uint32Array ? o = 5125 : r instanceof Int32Array ? o = 5124 : r instanceof Int8Array ? o = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (o = 5121), {
                                buffer: a,
                                type: o,
                                bytesPerElement: r.BYTES_PER_ELEMENT,
                                version: t.version
                            }
                        }(t, r)) : s.version < t.version && (! function(t, n, r) {
                            const s = n.array,
                                a = n.updateRange;
                            e.bindBuffer(r, t), -1 === a.count ? e.bufferSubData(r, 0, s) : (i ? e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
                        }(s.buffer, t, r), s.version = t.version)
                    }
                }
            }
            class wr extends Un {
                constructor(e = 1, t = 1, i = 1, n = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: i,
                        heightSegments: n
                    };
                    const r = e / 2,
                        s = t / 2,
                        a = Math.floor(i),
                        o = Math.floor(n),
                        l = a + 1,
                        h = o + 1,
                        c = e / a,
                        u = t / o,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let e = 0; e < h; e++) {
                        const t = e * u - s;
                        for (let i = 0; i < l; i++) {
                            const n = i * c - r;
                            p.push(n, -t, 0), f.push(0, 0, 1), m.push(i / a), m.push(1 - e / o)
                        }
                    }
                    for (let e = 0; e < o; e++)
                        for (let t = 0; t < a; t++) {
                            const i = t + l * e,
                                n = t + l * (e + 1),
                                r = t + 1 + l * (e + 1),
                                s = t + 1 + l * e;
                            d.push(i, n, s), d.push(n, r, s)
                        }
                    this.setIndex(d), this.setAttribute("position", new Ln(p, 3)), this.setAttribute("normal", new Ln(f, 3)), this.setAttribute("uv", new Ln(m, 2))
                }
                static fromJSON(e) {
                    return new wr(e.width, e.height, e.widthSegments, e.heightSegments)
                }
            }
            const Sr = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
                },
                Er = {
                    common: {
                        diffuse: {
                            value: new Kt(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new zt
                        },
                        uv2Transform: {
                            value: new zt
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Ht(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new Kt(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Kt(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new zt
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new Kt(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Ht(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new zt
                        }
                    }
                },
                Mr = {
                    basic: {
                        uniforms: sr([Er.common, Er.specularmap, Er.envmap, Er.aomap, Er.lightmap, Er.fog]),
                        vertexShader: Sr.meshbasic_vert,
                        fragmentShader: Sr.meshbasic_frag
                    },
                    lambert: {
                        uniforms: sr([Er.common, Er.specularmap, Er.envmap, Er.aomap, Er.lightmap, Er.emissivemap, Er.fog, Er.lights, {
                            emissive: {
                                value: new Kt(0)
                            }
                        }]),
                        vertexShader: Sr.meshlambert_vert,
                        fragmentShader: Sr.meshlambert_frag
                    },
                    phong: {
                        uniforms: sr([Er.common, Er.specularmap, Er.envmap, Er.aomap, Er.lightmap, Er.emissivemap, Er.bumpmap, Er.normalmap, Er.displacementmap, Er.fog, Er.lights, {
                            emissive: {
                                value: new Kt(0)
                            },
                            specular: {
                                value: new Kt(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Sr.meshphong_vert,
                        fragmentShader: Sr.meshphong_frag
                    },
                    standard: {
                        uniforms: sr([Er.common, Er.envmap, Er.aomap, Er.lightmap, Er.emissivemap, Er.bumpmap, Er.normalmap, Er.displacementmap, Er.roughnessmap, Er.metalnessmap, Er.fog, Er.lights, {
                            emissive: {
                                value: new Kt(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Sr.meshphysical_vert,
                        fragmentShader: Sr.meshphysical_frag
                    },
                    toon: {
                        uniforms: sr([Er.common, Er.aomap, Er.lightmap, Er.emissivemap, Er.bumpmap, Er.normalmap, Er.displacementmap, Er.gradientmap, Er.fog, Er.lights, {
                            emissive: {
                                value: new Kt(0)
                            }
                        }]),
                        vertexShader: Sr.meshtoon_vert,
                        fragmentShader: Sr.meshtoon_frag
                    },
                    matcap: {
                        uniforms: sr([Er.common, Er.bumpmap, Er.normalmap, Er.displacementmap, Er.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: Sr.meshmatcap_vert,
                        fragmentShader: Sr.meshmatcap_frag
                    },
                    points: {
                        uniforms: sr([Er.points, Er.fog]),
                        vertexShader: Sr.points_vert,
                        fragmentShader: Sr.points_frag
                    },
                    dashed: {
                        uniforms: sr([Er.common, Er.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Sr.linedashed_vert,
                        fragmentShader: Sr.linedashed_frag
                    },
                    depth: {
                        uniforms: sr([Er.common, Er.displacementmap]),
                        vertexShader: Sr.depth_vert,
                        fragmentShader: Sr.depth_frag
                    },
                    normal: {
                        uniforms: sr([Er.common, Er.bumpmap, Er.normalmap, Er.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Sr.meshnormal_vert,
                        fragmentShader: Sr.meshnormal_frag
                    },
                    sprite: {
                        uniforms: sr([Er.sprite, Er.fog]),
                        vertexShader: Sr.sprite_vert,
                        fragmentShader: Sr.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new zt
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: Sr.background_vert,
                        fragmentShader: Sr.background_frag
                    },
                    cube: {
                        uniforms: sr([Er.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Sr.cube_vert,
                        fragmentShader: Sr.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Sr.equirect_vert,
                        fragmentShader: Sr.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: sr([Er.common, Er.displacementmap, {
                            referencePosition: {
                                value: new ai
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Sr.distanceRGBA_vert,
                        fragmentShader: Sr.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: sr([Er.lights, Er.fog, {
                            color: {
                                value: new Kt(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Sr.shadow_vert,
                        fragmentShader: Sr.shadow_frag
                    }
                };

            function Cr(e, t, i, n, r, s) {
                const a = new Kt(0);
                let o, l, h = !0 === r ? 0 : 1,
                    d = null,
                    p = 0,
                    f = null;

                function m(e, t) {
                    i.buffers.color.setClear(e.r, e.g, e.b, t, s)
                }
                return {
                    getClearColor: function() {
                        return a
                    },
                    setClearColor: function(e, t = 1) {
                        a.set(e), h = t, m(a, h)
                    },
                    getClearAlpha: function() {
                        return h
                    },
                    setClearAlpha: function(e) {
                        h = e, m(a, h)
                    },
                    render: function(i, r) {
                        let s = !1,
                            g = !0 === r.isScene ? r.background : null;
                        g && g.isTexture && (g = t.get(g));
                        const y = e.xr,
                            _ = y.getSession && y.getSession();
                        _ && "additive" === _.environmentBlendMode && (g = null), null === g ? m(a, h) : g && g.isColor && (m(g, 1), s = !0), (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), g && (g.isCubeTexture || g.mapping === ie) ? (void 0 === l && (l = new tr(new nr(1, 1, 1), new or({
                            name: "BackgroundCubeMaterial",
                            uniforms: rr(Mr.cube.uniforms),
                            vertexShader: Mr.cube.vertexShader,
                            fragmentShader: Mr.cube.fragmentShader,
                            side: u,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(e, t, i) {
                            this.matrixWorld.copyPosition(i.matrixWorld)
                        }, Object.defineProperty(l.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), n.update(l)), l.material.uniforms.envMap.value = g, l.material.uniforms.flipEnvMap.value = g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1, d === g && p === g.version && f === e.toneMapping || (l.material.needsUpdate = !0, d = g, p = g.version, f = e.toneMapping), i.unshift(l, l.geometry, l.material, 0, 0, null)) : g && g.isTexture && (void 0 === o && (o = new tr(new wr(2, 2), new or({
                            name: "BackgroundMaterial",
                            uniforms: rr(Mr.background.uniforms),
                            vertexShader: Mr.background.vertexShader,
                            fragmentShader: Mr.background.fragmentShader,
                            side: c,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), n.update(o)), o.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), o.material.uniforms.uvTransform.value.copy(g.matrix), d === g && p === g.version && f === e.toneMapping || (o.material.needsUpdate = !0, d = g, p = g.version, f = e.toneMapping), i.unshift(o, o.geometry, o.material, 0, 0, null))
                    }
                }
            }

            function Ar(e, t, i, n) {
                const r = e.getParameter(34921),
                    s = n.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                    a = n.isWebGL2 || null !== s,
                    o = {},
                    l = d(null);
                let h = l;

                function c(t) {
                    return n.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t)
                }

                function u(t) {
                    return n.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t)
                }

                function d(e) {
                    const t = [],
                        i = [],
                        n = [];
                    for (let e = 0; e < r; e++) t[e] = 0, i[e] = 0, n[e] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: i,
                        attributeDivisors: n,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }

                function p() {
                    const e = h.newAttributes;
                    for (let t = 0, i = e.length; t < i; t++) e[t] = 0
                }

                function f(e) {
                    m(e, 0)
                }

                function m(i, r) {
                    const s = h.newAttributes,
                        a = h.enabledAttributes,
                        o = h.attributeDivisors;
                    if (s[i] = 1, 0 === a[i] && (e.enableVertexAttribArray(i), a[i] = 1), o[i] !== r) {
                        (n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), o[i] = r
                    }
                }

                function g() {
                    const t = h.newAttributes,
                        i = h.enabledAttributes;
                    for (let n = 0, r = i.length; n < r; n++) i[n] !== t[n] && (e.disableVertexAttribArray(n), i[n] = 0)
                }

                function y(t, i, r, s, a, o) {
                    !0 !== n.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, i, r, s, a, o) : e.vertexAttribIPointer(t, i, r, a, o)
                }

                function _() {
                    v(), h !== l && (h = l, c(h.object))
                }

                function v() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                return {
                    setup: function(r, l, u, _, v) {
                        let b = !1;
                        if (a) {
                            const t = function(t, i, r) {
                                const a = !0 === r.wireframe;
                                let l = o[t.id];
                                void 0 === l && (l = {}, o[t.id] = l);
                                let h = l[i.id];
                                void 0 === h && (h = {}, l[i.id] = h);
                                let c = h[a];
                                void 0 === c && (c = d(n.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), h[a] = c);
                                return c
                            }(_, u, l);
                            h !== t && (h = t, c(h.object)), b = function(e, t) {
                                const i = h.attributes,
                                    n = e.attributes;
                                let r = 0;
                                for (const e in n) {
                                    const t = i[e],
                                        s = n[e];
                                    if (void 0 === t) return !0;
                                    if (t.attribute !== s) return !0;
                                    if (t.data !== s.data) return !0;
                                    r++
                                }
                                return h.attributesNum !== r || h.index !== t
                            }(_, v), b && function(e, t) {
                                const i = {},
                                    n = e.attributes;
                                let r = 0;
                                for (const e in n) {
                                    const t = n[e],
                                        s = {};
                                    s.attribute = t, t.data && (s.data = t.data), i[e] = s, r++
                                }
                                h.attributes = i, h.attributesNum = r, h.index = t
                            }(_, v)
                        } else {
                            const e = !0 === l.wireframe;
                            h.geometry === _.id && h.program === u.id && h.wireframe === e || (h.geometry = _.id, h.program = u.id, h.wireframe = e, b = !0)
                        }!0 === r.isInstancedMesh && (b = !0), null !== v && i.update(v, 34963), b && (! function(r, s, a, o) {
                            if (!1 === n.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                            p();
                            const l = o.attributes,
                                h = a.getAttributes(),
                                c = s.defaultAttributeValues;
                            for (const t in h) {
                                const n = h[t];
                                if (n.location >= 0) {
                                    let s = l[t];
                                    if (void 0 === s && ("instanceMatrix" === t && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === t && r.instanceColor && (s = r.instanceColor)), void 0 !== s) {
                                        const t = s.normalized,
                                            a = s.itemSize,
                                            l = i.get(s);
                                        if (void 0 === l) continue;
                                        const h = l.buffer,
                                            c = l.type,
                                            u = l.bytesPerElement;
                                        if (s.isInterleavedBufferAttribute) {
                                            const i = s.data,
                                                l = i.stride,
                                                d = s.offset;
                                            if (i && i.isInstancedInterleavedBuffer) {
                                                for (let e = 0; e < n.locationSize; e++) m(n.location + e, i.meshPerAttribute);
                                                !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = i.meshPerAttribute * i.count)
                                            } else
                                                for (let e = 0; e < n.locationSize; e++) f(n.location + e);
                                            e.bindBuffer(34962, h);
                                            for (let e = 0; e < n.locationSize; e++) y(n.location + e, a / n.locationSize, c, t, l * u, (d + a / n.locationSize * e) * u)
                                        } else {
                                            if (s.isInstancedBufferAttribute) {
                                                for (let e = 0; e < n.locationSize; e++) m(n.location + e, s.meshPerAttribute);
                                                !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                                            } else
                                                for (let e = 0; e < n.locationSize; e++) f(n.location + e);
                                            e.bindBuffer(34962, h);
                                            for (let e = 0; e < n.locationSize; e++) y(n.location + e, a / n.locationSize, c, t, a * u, a / n.locationSize * e * u)
                                        }
                                    } else if (void 0 !== c) {
                                        const i = c[t];
                                        if (void 0 !== i) switch (i.length) {
                                            case 2:
                                                e.vertexAttrib2fv(n.location, i);
                                                break;
                                            case 3:
                                                e.vertexAttrib3fv(n.location, i);
                                                break;
                                            case 4:
                                                e.vertexAttrib4fv(n.location, i);
                                                break;
                                            default:
                                                e.vertexAttrib1fv(n.location, i)
                                        }
                                    }
                                }
                            }
                            g()
                        }(r, l, u, _), null !== v && e.bindBuffer(34963, i.get(v).buffer))
                    },
                    reset: _,
                    resetDefaultState: v,
                    dispose: function() {
                        _();
                        for (const e in o) {
                            const t = o[e];
                            for (const e in t) {
                                const i = t[e];
                                for (const e in i) u(i[e].object), delete i[e];
                                delete t[e]
                            }
                            delete o[e]
                        }
                    },
                    releaseStatesOfGeometry: function(e) {
                        if (void 0 === o[e.id]) return;
                        const t = o[e.id];
                        for (const e in t) {
                            const i = t[e];
                            for (const e in i) u(i[e].object), delete i[e];
                            delete t[e]
                        }
                        delete o[e.id]
                    },
                    releaseStatesOfProgram: function(e) {
                        for (const t in o) {
                            const i = o[t];
                            if (void 0 === i[e.id]) continue;
                            const n = i[e.id];
                            for (const e in n) u(n[e].object), delete n[e];
                            delete i[e.id]
                        }
                    },
                    initAttributes: p,
                    enableAttribute: f,
                    disableUnusedAttributes: g
                }
            }

            function Lr(e, t, i, n) {
                const r = n.isWebGL2;
                let s;
                this.setMode = function(e) {
                    s = e
                }, this.render = function(t, n) {
                    e.drawArrays(s, t, n), i.update(n, s, 1)
                }, this.renderInstances = function(n, a, o) {
                    if (0 === o) return;
                    let l, h;
                    if (r) l = e, h = "drawArraysInstanced";
                    else if (l = t.get("ANGLE_instanced_arrays"), h = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[h](s, n, a, o), i.update(a, s, o)
                }
            }

            function Ir(e, t, i) {
                let n;

                function r(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
                let a = void 0 !== i.precision ? i.precision : "highp";
                const o = r(a);
                o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
                const l = s || t.has("WEBGL_draw_buffers"),
                    h = !0 === i.logarithmicDepthBuffer,
                    c = e.getParameter(34930),
                    u = e.getParameter(35660),
                    d = e.getParameter(3379),
                    p = e.getParameter(34076),
                    f = e.getParameter(34921),
                    m = e.getParameter(36347),
                    g = e.getParameter(36348),
                    y = e.getParameter(36349),
                    _ = u > 0,
                    v = s || t.has("OES_texture_float");
                return {
                    isWebGL2: s,
                    drawBuffers: l,
                    getMaxAnisotropy: function() {
                        if (void 0 !== n) return n;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            const i = t.get("EXT_texture_filter_anisotropic");
                            n = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else n = 0;
                        return n
                    },
                    getMaxPrecision: r,
                    precision: a,
                    logarithmicDepthBuffer: h,
                    maxTextures: c,
                    maxVertexTextures: u,
                    maxTextureSize: d,
                    maxCubemapSize: p,
                    maxAttributes: f,
                    maxVertexUniforms: m,
                    maxVaryings: g,
                    maxFragmentUniforms: y,
                    vertexTextures: _,
                    floatFragmentTextures: v,
                    floatVertexTextures: _ && v,
                    maxSamples: s ? e.getParameter(36183) : 0
                }
            }

            function Pr(e) {
                const t = this;
                let i = null,
                    n = 0,
                    r = !1,
                    s = !1;
                const a = new yr,
                    o = new zt,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function h() {
                    l.value !== i && (l.value = i, l.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
                }

                function c(e, i, n, r) {
                    const s = null !== e ? e.length : 0;
                    let h = null;
                    if (0 !== s) {
                        if (h = l.value, !0 !== r || null === h) {
                            const t = n + 4 * s,
                                r = i.matrixWorldInverse;
                            o.getNormalMatrix(r), (null === h || h.length < t) && (h = new Float32Array(t));
                            for (let t = 0, i = n; t !== s; ++t, i += 4) a.copy(e[t]).applyMatrix4(r, o), a.normal.toArray(h, i), h[i + 3] = a.constant
                        }
                        l.value = h, l.needsUpdate = !0
                    }
                    return t.numPlanes = s, t.numIntersection = 0, h
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, s) {
                    const a = 0 !== e.length || t || 0 !== n || r;
                    return r = t, i = c(e, s, 0), n = e.length, a
                }, this.beginShadows = function() {
                    s = !0, c(null)
                }, this.endShadows = function() {
                    s = !1, h()
                }, this.setState = function(t, a, o) {
                    const u = t.clippingPlanes,
                        d = t.clipIntersection,
                        p = t.clipShadows,
                        f = e.get(t);
                    if (!r || null === u || 0 === u.length || s && !p) s ? c(null) : h();
                    else {
                        const e = s ? 0 : n,
                            t = 4 * e;
                        let r = f.clippingState || null;
                        l.value = r, r = c(u, a, t, o);
                        for (let e = 0; e !== t; ++e) r[e] = i[e];
                        f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
                    }
                }
            }

            function Rr(e) {
                let t = new WeakMap;

                function i(e, t) {
                    return t === ee ? e.mapping = Z : t === te && (e.mapping = Q), e
                }

                function n(e) {
                    const i = e.target;
                    i.removeEventListener("dispose", n);
                    const r = t.get(i);
                    void 0 !== r && (t.delete(i), r.dispose())
                }
                return {
                    get: function(r) {
                        if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                            const s = r.mapping;
                            if (s === ee || s === te) {
                                if (t.has(r)) {
                                    return i(t.get(r).texture, r.mapping)
                                } {
                                    const s = r.image;
                                    if (s && s.height > 0) {
                                        const a = new pr(s.height / 2);
                                        return a.fromEquirectangularTexture(e, r), t.set(r, a), r.addEventListener("dispose", n), i(a.texture, r.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return r
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            Mr.physical = {
                uniforms: sr([Mr.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new Ht(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new Kt(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new Ht
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new Kt(0)
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularColor: {
                        value: new Kt(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    }
                }]),
                vertexShader: Sr.meshphysical_vert,
                fragmentShader: Sr.meshphysical_frag
            };
            class kr extends lr {
                constructor(e = -1, t = 1, i = 1, n = -1, r = .1, s = 2e3) {
                    super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r, this.far = s, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                }
                setViewOffset(e, t, i, n, r, s) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        i = (this.right + this.left) / 2,
                        n = (this.top + this.bottom) / 2;
                    let r = i - e,
                        s = i + e,
                        a = n + t,
                        o = n - t;
                    if (null !== this.view && this.view.enabled) {
                        const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += e * this.view.offsetX, s = r + e * this.view.width, a -= t * this.view.offsetY, o = a - t * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }
            kr.prototype.isOrthographicCamera = !0;
            class Dr extends or {
                constructor(e) {
                    super(e), this.type = "RawShaderMaterial"
                }
            }
            Dr.prototype.isRawShaderMaterial = !0;
            const Or = 4,
                Nr = 8,
                Ur = Math.pow(2, Nr),
                Br = [.125, .215, .35, .446, .526, .582],
                Fr = Nr - Or + 1 + Br.length,
                Hr = 20,
                zr = new kr,
                {
                    _lodPlanes: Vr,
                    _sizeLods: Gr,
                    _sigmas: Wr
                } = Jr(),
                jr = new Kt;
            let qr = null;
            const $r = (1 + Math.sqrt(5)) / 2,
                Xr = 1 / $r,
                Yr = [new ai(1, 1, 1), new ai(-1, 1, 1), new ai(1, 1, -1), new ai(-1, 1, -1), new ai(0, $r, Xr), new ai(0, $r, -Xr), new ai(Xr, 0, $r), new ai(-Xr, 0, $r), new ai($r, Xr, 0), new ai(-$r, Xr, 0)];
            class Kr {
                constructor(e) {
                    this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = function(e) {
                        const t = new Float32Array(e),
                            i = new ai(0, 1, 0);
                        return new Dr({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: e
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: t
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: i
                                }
                            },
                            vertexShader: is(),
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: p,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(Hr), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(e, t = 0, i = .1, n = 100) {
                    qr = this._renderer.getRenderTarget();
                    const r = this._allocateTargets();
                    return this._sceneToCubeUV(e, i, n, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
                }
                fromEquirectangular(e, t = null) {
                    return this._fromTexture(e, t)
                }
                fromCubemap(e, t = null) {
                    return this._fromTexture(e, t)
                }
                compileCubemapShader() {
                    null === this._cubemapShader && (this._cubemapShader = ts(), this._compileMaterial(this._cubemapShader))
                }
                compileEquirectangularShader() {
                    null === this._equirectShader && (this._equirectShader = es(), this._compileMaterial(this._equirectShader))
                }
                dispose() {
                    this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                    for (let e = 0; e < Vr.length; e++) Vr[e].dispose()
                }
                _cleanup(e) {
                    this._renderer.setRenderTarget(qr), e.scissorTest = !1, Qr(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e, t) {
                    qr = this._renderer.getRenderTarget();
                    const i = t || this._allocateTargets(e);
                    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
                }
                _allocateTargets(e) {
                    const t = {
                            magFilter: ce,
                            minFilter: ce,
                            generateMipmaps: !1,
                            type: be,
                            format: Me,
                            encoding: yt,
                            depthBuffer: !1
                        },
                        i = Zr(t);
                    return i.depthBuffer = !e, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = Zr(t)), i
                }
                _compileMaterial(e) {
                    const t = new tr(Vr[0], e);
                    this._renderer.compile(t, zr)
                }
                _sceneToCubeUV(e, t, i, n) {
                    const r = new hr(90, 1, t, i),
                        s = [1, -1, 1, 1, 1, 1],
                        a = [1, 1, 1, -1, -1, -1],
                        o = this._renderer,
                        l = o.autoClear,
                        h = o.toneMapping;
                    o.getClearColor(jr), o.toneMapping = q, o.autoClear = !1;
                    const c = new wn({
                            name: "PMREM.Background",
                            side: u,
                            depthWrite: !1,
                            depthTest: !1
                        }),
                        d = new tr(new nr, c);
                    let p = !1;
                    const f = e.background;
                    f ? f.isColor && (c.color.copy(f), e.background = null, p = !0) : (c.color.copy(jr), p = !0);
                    for (let t = 0; t < 6; t++) {
                        const i = t % 3;
                        0 === i ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0)) : 1 === i ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0)) : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t])), Qr(n, i * Ur, t > 2 ? Ur : 0, Ur, Ur), o.setRenderTarget(n), p && o.render(d, r), o.render(e, r)
                    }
                    d.geometry.dispose(), d.material.dispose(), o.toneMapping = h, o.autoClear = l, e.background = f
                }
                _textureToCubeUV(e, t) {
                    const i = this._renderer,
                        n = e.mapping === Z || e.mapping === Q;
                    n ? (null === this._cubemapShader && (this._cubemapShader = ts()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = es());
                    const r = n ? this._cubemapShader : this._equirectShader,
                        s = new tr(Vr[0], r),
                        a = r.uniforms;
                    a.envMap.value = e, n || a.texelSize.value.set(1 / e.image.width, 1 / e.image.height), Qr(t, 0, 0, 3 * Ur, 2 * Ur), i.setRenderTarget(t), i.render(s, zr)
                }
                _applyPMREM(e) {
                    const t = this._renderer,
                        i = t.autoClear;
                    t.autoClear = !1;
                    for (let t = 1; t < Fr; t++) {
                        const i = Math.sqrt(Wr[t] * Wr[t] - Wr[t - 1] * Wr[t - 1]),
                            n = Yr[(t - 1) % Yr.length];
                        this._blur(e, t - 1, t, i, n)
                    }
                    t.autoClear = i
                }
                _blur(e, t, i, n, r) {
                    const s = this._pingPongRenderTarget;
                    this._halfBlur(e, s, t, i, n, "latitudinal", r), this._halfBlur(s, e, i, i, n, "longitudinal", r)
                }
                _halfBlur(e, t, i, n, r, s, a) {
                    const o = this._renderer,
                        l = this._blurMaterial;
                    "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                    const h = new tr(Vr[n], l),
                        c = l.uniforms,
                        u = Gr[i] - 1,
                        d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                        p = r / d,
                        f = isFinite(r) ? 1 + Math.floor(3 * p) : Hr;
                    f > Hr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                    const m = [];
                    let g = 0;
                    for (let e = 0; e < Hr; ++e) {
                        const t = e / p,
                            i = Math.exp(-t * t / 2);
                        m.push(i), 0 === e ? g += i : e < f && (g += 2 * i)
                    }
                    for (let e = 0; e < m.length; e++) m[e] = m[e] / g;
                    c.envMap.value = e.texture, c.samples.value = f, c.weights.value = m, c.latitudinal.value = "latitudinal" === s, a && (c.poleAxis.value = a), c.dTheta.value = d, c.mipInt.value = Nr - i;
                    const y = Gr[n];
                    Qr(t, 3 * Math.max(0, Ur - 2 * y), (0 === n ? 0 : 2 * Ur) + 2 * y * (n > Nr - Or ? n - Nr + Or : 0), 3 * y, 2 * y), o.setRenderTarget(t), o.render(h, zr)
                }
            }

            function Jr() {
                const e = [],
                    t = [],
                    i = [];
                let n = Nr;
                for (let r = 0; r < Fr; r++) {
                    const s = Math.pow(2, n);
                    t.push(s);
                    let a = 1 / s;
                    r > Nr - Or ? a = Br[r - Nr + Or - 1] : 0 === r && (a = 0), i.push(a);
                    const o = 1 / (s - 1),
                        l = -o / 2,
                        h = 1 + o / 2,
                        c = [l, l, h, l, h, h, l, l, h, h, l, h],
                        u = 6,
                        d = 6,
                        p = 3,
                        f = 2,
                        m = 1,
                        g = new Float32Array(p * d * u),
                        y = new Float32Array(f * d * u),
                        _ = new Float32Array(m * d * u);
                    for (let e = 0; e < u; e++) {
                        const t = e % 3 * 2 / 3 - 1,
                            i = e > 2 ? 0 : -1,
                            n = [t, i, 0, t + 2 / 3, i, 0, t + 2 / 3, i + 1, 0, t, i, 0, t + 2 / 3, i + 1, 0, t, i + 1, 0];
                        g.set(n, p * d * e), y.set(c, f * d * e);
                        const r = [e, e, e, e, e, e];
                        _.set(r, m * d * e)
                    }
                    const v = new Un;
                    v.setAttribute("position", new Mn(g, p)), v.setAttribute("uv", new Mn(y, f)), v.setAttribute("faceIndex", new Mn(_, m)), e.push(v), n > Or && n--
                }
                return {
                    _lodPlanes: e,
                    _sizeLods: t,
                    _sigmas: i
                }
            }

            function Zr(e) {
                const t = new ni(3 * Ur, 3 * Ur, e);
                return t.texture.mapping = ie, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
            }

            function Qr(e, t, i, n, r) {
                e.viewport.set(t, i, n, r), e.scissor.set(t, i, n, r)
            }

            function es() {
                const e = new Ht(1, 1);
                return new Dr({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        texelSize: {
                            value: e
                        }
                    },
                    vertexShader: is(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
                    blending: p,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function ts() {
                return new Dr({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: is(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                    blending: p,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function is() {
                return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
            }

            function ns(e) {
                let t = new WeakMap,
                    i = null;

                function n(e) {
                    const i = e.target;
                    i.removeEventListener("dispose", n);
                    const r = t.get(i);
                    void 0 !== r && (t.delete(i), r.dispose())
                }
                return {
                    get: function(r) {
                        if (r && r.isTexture) {
                            const s = r.mapping,
                                a = s === ee || s === te,
                                o = s === Z || s === Q;
                            if (a || o) {
                                if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                    r.needsPMREMUpdate = !1;
                                    let n = t.get(r);
                                    return null === i && (i = new Kr(e)), n = a ? i.fromEquirectangular(r, n) : i.fromCubemap(r, n), t.set(r, n), n.texture
                                }
                                if (t.has(r)) return t.get(r).texture; {
                                    const s = r.image;
                                    if (a && s && s.height > 0 || o && s && function(e) {
                                            let t = 0;
                                            const i = 6;
                                            for (let n = 0; n < i; n++) void 0 !== e[n] && t++;
                                            return t === i
                                        }(s)) {
                                        null === i && (i = new Kr(e));
                                        const s = a ? i.fromEquirectangular(r) : i.fromCubemap(r);
                                        return t.set(r, s), r.addEventListener("dispose", n), s.texture
                                    }
                                    return null
                                }
                            }
                        }
                        return r
                    },
                    dispose: function() {
                        t = new WeakMap, null !== i && (i.dispose(), i = null)
                    }
                }
            }

            function rs(e) {
                const t = {};

                function i(i) {
                    if (void 0 !== t[i]) return t[i];
                    let n;
                    switch (i) {
                        case "WEBGL_depth_texture":
                            n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            n = e.getExtension(i)
                    }
                    return t[i] = n, n
                }
                return {
                    has: function(e) {
                        return null !== i(e)
                    },
                    init: function(e) {
                        e.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"), i("OES_texture_float"), i("OES_texture_half_float"), i("OES_texture_half_float_linear"), i("OES_standard_derivatives"), i("OES_element_index_uint"), i("OES_vertex_array_object"), i("ANGLE_instanced_arrays")), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture")
                    },
                    get: function(e) {
                        const t = i(e);
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                    }
                }
            }

            function ss(e, t, i, n) {
                const r = {},
                    s = new WeakMap;

                function a(e) {
                    const o = e.target;
                    null !== o.index && t.remove(o.index);
                    for (const e in o.attributes) t.remove(o.attributes[e]);
                    o.removeEventListener("dispose", a), delete r[o.id];
                    const l = s.get(o);
                    l && (t.remove(l), s.delete(o)), n.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, i.memory.geometries--
                }

                function o(e) {
                    const i = [],
                        n = e.index,
                        r = e.attributes.position;
                    let a = 0;
                    if (null !== n) {
                        const e = n.array;
                        a = n.version;
                        for (let t = 0, n = e.length; t < n; t += 3) {
                            const n = e[t + 0],
                                r = e[t + 1],
                                s = e[t + 2];
                            i.push(n, r, r, s, s, n)
                        }
                    } else {
                        const e = r.array;
                        a = r.version;
                        for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) {
                            const e = t + 0,
                                n = t + 1,
                                r = t + 2;
                            i.push(e, n, n, r, r, e)
                        }
                    }
                    const o = new(Vt(i) ? An : Cn)(i, 1);
                    o.version = a;
                    const l = s.get(e);
                    l && t.remove(l), s.set(e, o)
                }
                return {
                    get: function(e, t) {
                        return !0 === r[t.id] || (t.addEventListener("dispose", a), r[t.id] = !0, i.memory.geometries++), t
                    },
                    update: function(e) {
                        const i = e.attributes;
                        for (const e in i) t.update(i[e], 34962);
                        const n = e.morphAttributes;
                        for (const e in n) {
                            const i = n[e];
                            for (let e = 0, n = i.length; e < n; e++) t.update(i[e], 34962)
                        }
                    },
                    getWireframeAttribute: function(e) {
                        const t = s.get(e);
                        if (t) {
                            const i = e.index;
                            null !== i && t.version < i.version && o(e)
                        } else o(e);
                        return s.get(e)
                    }
                }
            }

            function as(e, t, i, n) {
                const r = n.isWebGL2;
                let s, a, o;
                this.setMode = function(e) {
                    s = e
                }, this.setIndex = function(e) {
                    a = e.type, o = e.bytesPerElement
                }, this.render = function(t, n) {
                    e.drawElements(s, n, a, t * o), i.update(n, s, 1)
                }, this.renderInstances = function(n, l, h) {
                    if (0 === h) return;
                    let c, u;
                    if (r) c = e, u = "drawElementsInstanced";
                    else if (c = t.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === c) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    c[u](s, l, a, n * o, h), i.update(l, s, h)
                }
            }

            function os(e) {
                const t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                    },
                    update: function(e, i, n) {
                        switch (t.calls++, i) {
                            case 4:
                                t.triangles += n * (e / 3);
                                break;
                            case 1:
                                t.lines += n * (e / 2);
                                break;
                            case 3:
                                t.lines += n * (e - 1);
                                break;
                            case 2:
                                t.lines += n * e;
                                break;
                            case 0:
                                t.points += n * e;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                        }
                    }
                }
            }
            class ls extends ei {
                constructor(e = null, t = 1, i = 1, n = 1) {
                    super(null), this.image = {
                        data: e,
                        width: t,
                        height: i,
                        depth: n
                    }, this.magFilter = oe, this.minFilter = oe, this.wrapR = se, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }

            function hs(e, t) {
                return e[0] - t[0]
            }

            function cs(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function us(e, t) {
                let i = 1;
                const n = t.isInterleavedBufferAttribute ? t.data.array : t.array;
                n instanceof Int8Array ? i = 127 : n instanceof Int16Array ? i = 32767 : n instanceof Int32Array ? i = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", n), e.divideScalar(i)
            }

            function ds(e, t, i) {
                const n = {},
                    r = new Float32Array(8),
                    s = new WeakMap,
                    a = new ai,
                    o = [];
                for (let e = 0; e < 8; e++) o[e] = [e, 0];
                return {
                    update: function(l, h, c, u) {
                        const d = l.morphTargetInfluences;
                        if (!0 === t.isWebGL2) {
                            const p = h.morphAttributes.position.length;
                            let f = s.get(h);
                            if (void 0 === f || f.count !== p) {
                                void 0 !== f && f.texture.dispose();
                                const y = void 0 !== h.morphAttributes.normal,
                                    _ = h.morphAttributes.position,
                                    v = h.morphAttributes.normal || [],
                                    b = !0 === y ? 2 : 1;
                                let T = h.attributes.position.count * b,
                                    x = 1;
                                T > t.maxTextureSize && (x = Math.ceil(T / t.maxTextureSize), T = t.maxTextureSize);
                                const w = new Float32Array(T * x * 4 * p),
                                    S = new ls(w, T, x, p);
                                S.format = Me, S.type = ve, S.needsUpdate = !0;
                                const E = 4 * b;
                                for (let C = 0; C < p; C++) {
                                    const A = _[C],
                                        L = v[C],
                                        I = T * x * 4 * C;
                                    for (let P = 0; P < A.count; P++) {
                                        a.fromBufferAttribute(A, P), !0 === A.normalized && us(a, A);
                                        const R = P * E;
                                        w[I + R + 0] = a.x, w[I + R + 1] = a.y, w[I + R + 2] = a.z, w[I + R + 3] = 0, !0 === y && (a.fromBufferAttribute(L, P), !0 === L.normalized && us(a, L), w[I + R + 4] = a.x, w[I + R + 5] = a.y, w[I + R + 6] = a.z, w[I + R + 7] = 0)
                                    }
                                }

                                function M() {
                                    S.dispose(), s.delete(h), h.removeEventListener("dispose", M)
                                }
                                f = {
                                    count: p,
                                    texture: S,
                                    size: new Ht(T, x)
                                }, s.set(h, f), h.addEventListener("dispose", M)
                            }
                            let m = 0;
                            for (let k = 0; k < d.length; k++) m += d[k];
                            const g = h.morphTargetsRelative ? 1 : 1 - m;
                            u.getUniforms().setValue(e, "morphTargetBaseInfluence", g), u.getUniforms().setValue(e, "morphTargetInfluences", d), u.getUniforms().setValue(e, "morphTargetsTexture", f.texture, i), u.getUniforms().setValue(e, "morphTargetsTextureSize", f.size)
                        } else {
                            const D = void 0 === d ? 0 : d.length;
                            let O = n[h.id];
                            if (void 0 === O || O.length !== D) {
                                O = [];
                                for (let H = 0; H < D; H++) O[H] = [H, 0];
                                n[h.id] = O
                            }
                            for (let z = 0; z < D; z++) {
                                const V = O[z];
                                V[0] = z, V[1] = d[z]
                            }
                            O.sort(cs);
                            for (let G = 0; G < 8; G++) G < D && O[G][1] ? (o[G][0] = O[G][0], o[G][1] = O[G][1]) : (o[G][0] = Number.MAX_SAFE_INTEGER, o[G][1] = 0);
                            o.sort(hs);
                            const N = h.morphAttributes.position,
                                U = h.morphAttributes.normal;
                            let B = 0;
                            for (let W = 0; W < 8; W++) {
                                const j = o[W],
                                    q = j[0],
                                    $ = j[1];
                                q !== Number.MAX_SAFE_INTEGER && $ ? (N && h.getAttribute("morphTarget" + W) !== N[q] && h.setAttribute("morphTarget" + W, N[q]), U && h.getAttribute("morphNormal" + W) !== U[q] && h.setAttribute("morphNormal" + W, U[q]), r[W] = $, B += $) : (N && !0 === h.hasAttribute("morphTarget" + W) && h.deleteAttribute("morphTarget" + W), U && !0 === h.hasAttribute("morphNormal" + W) && h.deleteAttribute("morphNormal" + W), r[W] = 0)
                            }
                            const F = h.morphTargetsRelative ? 1 : 1 - B;
                            u.getUniforms().setValue(e, "morphTargetBaseInfluence", F), u.getUniforms().setValue(e, "morphTargetInfluences", r)
                        }
                    }
                }
            }

            function ps(e, t, i, n) {
                let r = new WeakMap;

                function s(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", s), i.remove(t.instanceMatrix), null !== t.instanceColor && i.remove(t.instanceColor)
                }
                return {
                    update: function(e) {
                        const a = n.render.frame,
                            o = e.geometry,
                            l = t.get(e, o);
                        return r.get(l) !== a && (t.update(l), r.set(l, a)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), i.update(e.instanceMatrix, 34962), null !== e.instanceColor && i.update(e.instanceColor, 34962)), l
                    },
                    dispose: function() {
                        r = new WeakMap
                    }
                }
            }
            ls.prototype.isDataTexture2DArray = !0;
            class fs extends ei {
                constructor(e = null, t = 1, i = 1, n = 1) {
                    super(null), this.image = {
                        data: e,
                        width: t,
                        height: i,
                        depth: n
                    }, this.magFilter = oe, this.minFilter = oe, this.wrapR = se, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            fs.prototype.isDataTexture3D = !0;
            const ms = new ei,
                gs = new ls,
                ys = new fs,
                _s = new dr,
                vs = [],
                bs = [],
                Ts = new Float32Array(16),
                xs = new Float32Array(9),
                ws = new Float32Array(4);

            function Ss(e, t, i) {
                const n = e[0];
                if (n <= 0 || n > 0) return e;
                const r = t * i;
                let s = vs[r];
                if (void 0 === s && (s = new Float32Array(r), vs[r] = s), 0 !== t) {
                    n.toArray(s, 0);
                    for (let n = 1, r = 0; n !== t; ++n) r += i, e[n].toArray(s, r)
                }
                return s
            }

            function Es(e, t) {
                if (e.length !== t.length) return !1;
                for (let i = 0, n = e.length; i < n; i++)
                    if (e[i] !== t[i]) return !1;
                return !0
            }

            function Ms(e, t) {
                for (let i = 0, n = t.length; i < n; i++) e[i] = t[i]
            }

            function Cs(e, t) {
                let i = bs[t];
                void 0 === i && (i = new Int32Array(t), bs[t] = i);
                for (let n = 0; n !== t; ++n) i[n] = e.allocateTextureUnit();
                return i
            }

            function As(e, t) {
                const i = this.cache;
                i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t)
            }

            function Ls(e, t) {
                const i = this.cache;
                if (void 0 !== t.x) i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y);
                else {
                    if (Es(i, t)) return;
                    e.uniform2fv(this.addr, t), Ms(i, t)
                }
            }

            function Is(e, t) {
                const i = this.cache;
                if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z);
                else if (void 0 !== t.r) i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b);
                else {
                    if (Es(i, t)) return;
                    e.uniform3fv(this.addr, t), Ms(i, t)
                }
            }

            function Ps(e, t) {
                const i = this.cache;
                if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w);
                else {
                    if (Es(i, t)) return;
                    e.uniform4fv(this.addr, t), Ms(i, t)
                }
            }

            function Rs(e, t) {
                const i = this.cache,
                    n = t.elements;
                if (void 0 === n) {
                    if (Es(i, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), Ms(i, t)
                } else {
                    if (Es(i, n)) return;
                    ws.set(n), e.uniformMatrix2fv(this.addr, !1, ws), Ms(i, n)
                }
            }

            function ks(e, t) {
                const i = this.cache,
                    n = t.elements;
                if (void 0 === n) {
                    if (Es(i, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), Ms(i, t)
                } else {
                    if (Es(i, n)) return;
                    xs.set(n), e.uniformMatrix3fv(this.addr, !1, xs), Ms(i, n)
                }
            }

            function Ds(e, t) {
                const i = this.cache,
                    n = t.elements;
                if (void 0 === n) {
                    if (Es(i, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), Ms(i, t)
                } else {
                    if (Es(i, n)) return;
                    Ts.set(n), e.uniformMatrix4fv(this.addr, !1, Ts), Ms(i, n)
                }
            }

            function Os(e, t) {
                const i = this.cache;
                i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t)
            }

            function Ns(e, t) {
                const i = this.cache;
                Es(i, t) || (e.uniform2iv(this.addr, t), Ms(i, t))
            }

            function Us(e, t) {
                const i = this.cache;
                Es(i, t) || (e.uniform3iv(this.addr, t), Ms(i, t))
            }

            function Bs(e, t) {
                const i = this.cache;
                Es(i, t) || (e.uniform4iv(this.addr, t), Ms(i, t))
            }

            function Fs(e, t) {
                const i = this.cache;
                i[0] !== t && (e.uniform1ui(this.addr, t), i[0] = t)
            }

            function Hs(e, t) {
                const i = this.cache;
                Es(i, t) || (e.uniform2uiv(this.addr, t), Ms(i, t))
            }

            function zs(e, t) {
                const i = this.cache;
                Es(i, t) || (e.uniform3uiv(this.addr, t), Ms(i, t))
            }

            function Vs(e, t) {
                const i = this.cache;
                Es(i, t) || (e.uniform4uiv(this.addr, t), Ms(i, t))
            }

            function Gs(e, t, i) {
                const n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(t || ms, r)
            }

            function Ws(e, t, i) {
                const n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || ys, r)
            }

            function js(e, t, i) {
                const n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(t || _s, r)
            }

            function qs(e, t, i) {
                const n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(t || gs, r)
            }

            function $s(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function Xs(e, t) {
                const i = Ss(t, this.size, 2);
                e.uniform2fv(this.addr, i)
            }

            function Ys(e, t) {
                const i = Ss(t, this.size, 3);
                e.uniform3fv(this.addr, i)
            }

            function Ks(e, t) {
                const i = Ss(t, this.size, 4);
                e.uniform4fv(this.addr, i)
            }

            function Js(e, t) {
                const i = Ss(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, i)
            }

            function Zs(e, t) {
                const i = Ss(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, i)
            }

            function Qs(e, t) {
                const i = Ss(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, i)
            }

            function ea(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function ta(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function ia(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function na(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function ra(e, t) {
                e.uniform1uiv(this.addr, t)
            }

            function sa(e, t) {
                e.uniform2uiv(this.addr, t)
            }

            function aa(e, t) {
                e.uniform3uiv(this.addr, t)
            }

            function oa(e, t) {
                e.uniform4uiv(this.addr, t)
            }

            function la(e, t, i) {
                const n = t.length,
                    r = Cs(i, n);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== n; ++e) i.safeSetTexture2D(t[e] || ms, r[e])
            }

            function ha(e, t, i) {
                const n = t.length,
                    r = Cs(i, n);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== n; ++e) i.setTexture3D(t[e] || ys, r[e])
            }

            function ca(e, t, i) {
                const n = t.length,
                    r = Cs(i, n);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== n; ++e) i.safeSetTextureCube(t[e] || _s, r[e])
            }

            function ua(e, t, i) {
                const n = t.length,
                    r = Cs(i, n);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== n; ++e) i.setTexture2DArray(t[e] || gs, r[e])
            }

            function da(e, t, i) {
                this.id = e, this.addr = i, this.cache = [], this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return As;
                        case 35664:
                            return Ls;
                        case 35665:
                            return Is;
                        case 35666:
                            return Ps;
                        case 35674:
                            return Rs;
                        case 35675:
                            return ks;
                        case 35676:
                            return Ds;
                        case 5124:
                        case 35670:
                            return Os;
                        case 35667:
                        case 35671:
                            return Ns;
                        case 35668:
                        case 35672:
                            return Us;
                        case 35669:
                        case 35673:
                            return Bs;
                        case 5125:
                            return Fs;
                        case 36294:
                            return Hs;
                        case 36295:
                            return zs;
                        case 36296:
                            return Vs;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Gs;
                        case 35679:
                        case 36299:
                        case 36307:
                            return Ws;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return js;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return qs
                    }
                }(t.type)
            }

            function pa(e, t, i) {
                this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return $s;
                        case 35664:
                            return Xs;
                        case 35665:
                            return Ys;
                        case 35666:
                            return Ks;
                        case 35674:
                            return Js;
                        case 35675:
                            return Zs;
                        case 35676:
                            return Qs;
                        case 5124:
                        case 35670:
                            return ea;
                        case 35667:
                        case 35671:
                            return ta;
                        case 35668:
                        case 35672:
                            return ia;
                        case 35669:
                        case 35673:
                            return na;
                        case 5125:
                            return ra;
                        case 36294:
                            return sa;
                        case 36295:
                            return aa;
                        case 36296:
                            return oa;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return la;
                        case 35679:
                        case 36299:
                        case 36307:
                            return ha;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return ca;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return ua
                    }
                }(t.type)
            }

            function fa(e) {
                this.id = e, this.seq = [], this.map = {}
            }
            pa.prototype.updateCache = function(e) {
                const t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Ms(t, e)
            }, fa.prototype.setValue = function(e, t, i) {
                const n = this.seq;
                for (let r = 0, s = n.length; r !== s; ++r) {
                    const s = n[r];
                    s.setValue(e, t[s.id], i)
                }
            };
            const ma = /(\w+)(\])?(\[|\.)?/g;

            function ga(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function ya(e, t, i) {
                const n = e.name,
                    r = n.length;
                for (ma.lastIndex = 0;;) {
                    const s = ma.exec(n),
                        a = ma.lastIndex;
                    let o = s[1];
                    const l = "]" === s[2],
                        h = s[3];
                    if (l && (o |= 0), void 0 === h || "[" === h && a + 2 === r) {
                        ga(i, void 0 === h ? new da(o, e, t) : new pa(o, e, t));
                        break
                    } {
                        let e = i.map[o];
                        void 0 === e && (e = new fa(o), ga(i, e)), i = e
                    }
                }
            }

            function _a(e, t) {
                this.seq = [], this.map = {};
                const i = e.getProgramParameter(t, 35718);
                for (let n = 0; n < i; ++n) {
                    const i = e.getActiveUniform(t, n);
                    ya(i, e.getUniformLocation(t, i.name), this)
                }
            }

            function va(e, t, i) {
                const n = e.createShader(t);
                return e.shaderSource(n, i), e.compileShader(n), n
            }
            _a.prototype.setValue = function(e, t, i, n) {
                const r = this.map[t];
                void 0 !== r && r.setValue(e, i, n)
            }, _a.prototype.setOptional = function(e, t, i) {
                const n = t[i];
                void 0 !== n && this.setValue(e, i, n)
            }, _a.upload = function(e, t, i, n) {
                for (let r = 0, s = t.length; r !== s; ++r) {
                    const s = t[r],
                        a = i[s.id];
                    !1 !== a.needsUpdate && s.setValue(e, a.value, n)
                }
            }, _a.seqWithValue = function(e, t) {
                const i = [];
                for (let n = 0, r = e.length; n !== r; ++n) {
                    const r = e[n];
                    r.id in t && i.push(r)
                }
                return i
            };
            let ba = 0;

            function Ta(e, t, i) {
                const n = e.getShaderParameter(t, 35713),
                    r = e.getShaderInfoLog(t).trim();
                return n && "" === r ? "" : i.toUpperCase() + "\n\n" + r + "\n\n" + function(e) {
                    const t = e.split("\n");
                    for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
                    return t.join("\n")
                }(e.getShaderSource(t))
            }

            function xa(e, t) {
                const i = function(e) {
                    switch (e) {
                        case yt:
                            return ["Linear", "( value )"];
                        case _t:
                            return ["sRGB", "( value )"];
                        default:
                            return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
                    }
                }(t);
                return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
            }

            function wa(e, t) {
                let i;
                switch (t) {
                    case $:
                        i = "Linear";
                        break;
                    case X:
                        i = "Reinhard";
                        break;
                    case Y:
                        i = "OptimizedCineon";
                        break;
                    case K:
                        i = "ACESFilmic";
                        break;
                    case J:
                        i = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), i = "Linear"
                }
                return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
            }

            function Sa(e) {
                return "" !== e
            }

            function Ea(e, t) {
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function Ma(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            const Ca = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function Aa(e) {
                return e.replace(Ca, La)
            }

            function La(e, t) {
                const i = Sr[t];
                if (void 0 === i) throw new Error("Can not resolve #include <" + t + ">");
                return Aa(i)
            }
            const Ia = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                Pa = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function Ra(e) {
                return e.replace(Pa, Da).replace(Ia, ka)
            }

            function ka(e, t, i, n) {
                return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Da(e, t, i, n)
            }

            function Da(e, t, i, n) {
                let r = "";
                for (let e = parseInt(t); e < parseInt(i); e++) r += n.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                return r
            }

            function Oa(e) {
                let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function Na(e, t, i, n) {
                const r = e.getContext(),
                    s = i.defines;
                let a = i.vertexShader,
                    c = i.fragmentShader;
                const u = function(e) {
                        let t = "SHADOWMAP_TYPE_BASIC";
                        return e.shadowMapType === o ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === l ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === h && (t = "SHADOWMAP_TYPE_VSM"), t
                    }(i),
                    d = function(e) {
                        let t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case Z:
                            case Q:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case ie:
                            case ne:
                                t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(i),
                    p = function(e) {
                        let t = "ENVMAP_MODE_REFLECTION";
                        if (e.envMap) switch (e.envMapMode) {
                            case Q:
                            case ne:
                                t = "ENVMAP_MODE_REFRACTION"
                        }
                        return t
                    }(i),
                    f = function(e) {
                        let t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case G:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case W:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case j:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(i),
                    m = i.isWebGL2 ? "" : function(e) {
                        return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Sa).join("\n")
                    }(i),
                    g = function(e) {
                        const t = [];
                        for (const i in e) {
                            const n = e[i];
                            !1 !== n && t.push("#define " + i + " " + n)
                        }
                        return t.join("\n")
                    }(s),
                    y = r.createProgram();
                let _, v, b = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
                i.isRawShaderMaterial ? (_ = [g].filter(Sa).join("\n"), _.length > 0 && (_ += "\n"), v = [m, g].filter(Sa).join("\n"), v.length > 0 && (v += "\n")) : (_ = [Oa(i), "#define SHADER_NAME " + i.shaderName, g, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + p : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.morphTargets && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i.morphTargets && i.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + u : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Sa).join("\n"), v = [m, Oa(i), "#define SHADER_NAME " + i.shaderName, g, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + d : "", i.envMap ? "#define " + p : "", i.envMap ? "#define " + f : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + u : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== q ? "#define TONE_MAPPING" : "", i.toneMapping !== q ? Sr.tonemapping_pars_fragment : "", i.toneMapping !== q ? wa("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.transparent ? "" : "#define OPAQUE", Sr.encodings_pars_fragment, xa("linearToOutputTexel", i.outputEncoding), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Sa).join("\n")), a = Aa(a), a = Ea(a, i), a = Ma(a, i), c = Aa(c), c = Ea(c, i), c = Ma(c, i), a = Ra(a), c = Ra(c), i.isWebGL2 && !0 !== i.isRawShaderMaterial && (b = "#version 300 es\n", _ = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + _, v = ["#define varying in", i.glslVersion === Et ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === Et ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
                const T = b + v + c,
                    x = va(r, 35633, b + _ + a),
                    w = va(r, 35632, T);
                if (r.attachShader(y, x), r.attachShader(y, w), void 0 !== i.index0AttributeName ? r.bindAttribLocation(y, 0, i.index0AttributeName) : !0 === i.morphTargets && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), e.debug.checkShaderErrors) {
                    const e = r.getProgramInfoLog(y).trim(),
                        t = r.getShaderInfoLog(x).trim(),
                        i = r.getShaderInfoLog(w).trim();
                    let n = !0,
                        s = !0;
                    if (!1 === r.getProgramParameter(y, 35714)) {
                        n = !1;
                        const t = Ta(r, x, "vertex"),
                            i = Ta(r, w, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(y, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + i)
                    } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== i || (s = !1);
                    s && (this.diagnostics = {
                        runnable: n,
                        programLog: e,
                        vertexShader: {
                            log: t,
                            prefix: _
                        },
                        fragmentShader: {
                            log: i,
                            prefix: v
                        }
                    })
                }
                let S, E;
                return r.deleteShader(x), r.deleteShader(w), this.getUniforms = function() {
                    return void 0 === S && (S = new _a(r, y)), S
                }, this.getAttributes = function() {
                    return void 0 === E && (E = function(e, t) {
                        const i = {},
                            n = e.getProgramParameter(t, 35721);
                        for (let r = 0; r < n; r++) {
                            const n = e.getActiveAttrib(t, r),
                                s = n.name;
                            let a = 1;
                            35674 === n.type && (a = 2), 35675 === n.type && (a = 3), 35676 === n.type && (a = 4), i[s] = {
                                type: n.type,
                                location: e.getAttribLocation(t, s),
                                locationSize: a
                            }
                        }
                        return i
                    }(r, y)), E
                }, this.destroy = function() {
                    n.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0
                }, this.name = i.shaderName, this.id = ba++, this.cacheKey = t, this.usedTimes = 1, this.program = y, this.vertexShader = x, this.fragmentShader = w, this
            }
            let Ua = 0;
            class Ba {
                constructor() {
                    this.shaderCache = new Map, this.materialCache = new Map
                }
                update(e) {
                    const t = e.vertexShader,
                        i = e.fragmentShader,
                        n = this._getShaderStage(t),
                        r = this._getShaderStage(i),
                        s = this._getShaderCacheForMaterial(e);
                    return !1 === s.has(n) && (s.add(n), n.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this
                }
                remove(e) {
                    const t = this.materialCache.get(e);
                    for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e);
                    return this.materialCache.delete(e), this
                }
                getVertexShaderID(e) {
                    return this._getShaderStage(e.vertexShader).id
                }
                getFragmentShaderID(e) {
                    return this._getShaderStage(e.fragmentShader).id
                }
                dispose() {
                    this.shaderCache.clear(), this.materialCache.clear()
                }
                _getShaderCacheForMaterial(e) {
                    const t = this.materialCache;
                    return !1 === t.has(e) && t.set(e, new Set), t.get(e)
                }
                _getShaderStage(e) {
                    const t = this.shaderCache;
                    if (!1 === t.has(e)) {
                        const i = new Fa;
                        t.set(e, i)
                    }
                    return t.get(e)
                }
            }
            class Fa {
                constructor() {
                    this.id = Ua++, this.usedTimes = 0
                }
            }

            function Ha(e, t, i, n, r, s, a) {
                const o = new Xi,
                    l = new Ba,
                    h = [],
                    c = r.isWebGL2,
                    p = r.logarithmicDepthBuffer,
                    f = r.floatVertexTextures,
                    m = r.maxVertexUniforms,
                    g = r.vertexTextures;
                let y = r.precision;
                const _ = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                };
                return {
                    getParameters: function(s, o, h, v, b) {
                        const T = v.fog,
                            x = s.isMeshStandardMaterial ? v.environment : null,
                            w = (s.isMeshStandardMaterial ? i : t).get(s.envMap || x),
                            S = _[s.type],
                            E = b.isSkinnedMesh ? function(e) {
                                const t = e.skeleton.bones;
                                if (f) return 1024; {
                                    const e = m,
                                        i = Math.floor((e - 20) / 4),
                                        n = Math.min(i, t.length);
                                    return n < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + n + "."), 0) : n
                                }
                            }(b) : 0;
                        let M, C, A, L;
                        if (null !== s.precision && (y = r.getMaxPrecision(s.precision), y !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", y, "instead.")), S) {
                            const e = Mr[S];
                            M = e.vertexShader, C = e.fragmentShader
                        } else M = s.vertexShader, C = s.fragmentShader, l.update(s), A = l.getVertexShaderID(s), L = l.getFragmentShaderID(s);
                        const I = e.getRenderTarget(),
                            P = s.alphaTest > 0,
                            R = s.clearcoat > 0;
                        return {
                            isWebGL2: c,
                            shaderID: S,
                            shaderName: s.type,
                            vertexShader: M,
                            fragmentShader: C,
                            defines: s.defines,
                            customVertexShaderID: A,
                            customFragmentShaderID: L,
                            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                            glslVersion: s.glslVersion,
                            precision: y,
                            instancing: !0 === b.isInstancedMesh,
                            instancingColor: !0 === b.isInstancedMesh && null !== b.instanceColor,
                            supportsVertexTextures: g,
                            outputEncoding: null === I ? e.outputEncoding : !0 === I.isXRRenderTarget ? I.texture.encoding : yt,
                            map: !!s.map,
                            matcap: !!s.matcap,
                            envMap: !!w,
                            envMapMode: w && w.mapping,
                            envMapCubeUV: !!w && (w.mapping === ie || w.mapping === ne),
                            lightMap: !!s.lightMap,
                            aoMap: !!s.aoMap,
                            emissiveMap: !!s.emissiveMap,
                            bumpMap: !!s.bumpMap,
                            normalMap: !!s.normalMap,
                            objectSpaceNormalMap: s.normalMapType === Tt,
                            tangentSpaceNormalMap: s.normalMapType === bt,
                            decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === _t,
                            clearcoat: R,
                            clearcoatMap: R && !!s.clearcoatMap,
                            clearcoatRoughnessMap: R && !!s.clearcoatRoughnessMap,
                            clearcoatNormalMap: R && !!s.clearcoatNormalMap,
                            displacementMap: !!s.displacementMap,
                            roughnessMap: !!s.roughnessMap,
                            metalnessMap: !!s.metalnessMap,
                            specularMap: !!s.specularMap,
                            specularIntensityMap: !!s.specularIntensityMap,
                            specularColorMap: !!s.specularColorMap,
                            transparent: s.transparent,
                            alphaMap: !!s.alphaMap,
                            alphaTest: P,
                            gradientMap: !!s.gradientMap,
                            sheen: s.sheen > 0,
                            sheenColorMap: !!s.sheenColorMap,
                            sheenRoughnessMap: !!s.sheenRoughnessMap,
                            transmission: s.transmission > 0,
                            transmissionMap: !!s.transmissionMap,
                            thicknessMap: !!s.thicknessMap,
                            combine: s.combine,
                            vertexTangents: !!s.normalMap && !!b.geometry && !!b.geometry.attributes.tangent,
                            vertexColors: s.vertexColors,
                            vertexAlphas: !0 === s.vertexColors && !!b.geometry && !!b.geometry.attributes.color && 4 === b.geometry.attributes.color.itemSize,
                            vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
                            uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
                            fog: !!T,
                            useFog: s.fog,
                            fogExp2: T && T.isFogExp2,
                            flatShading: !!s.flatShading,
                            sizeAttenuation: s.sizeAttenuation,
                            logarithmicDepthBuffer: p,
                            skinning: !0 === b.isSkinnedMesh && E > 0,
                            maxBones: E,
                            useVertexTexture: f,
                            morphTargets: !!b.geometry && !!b.geometry.morphAttributes.position,
                            morphNormals: !!b.geometry && !!b.geometry.morphAttributes.normal,
                            morphTargetsCount: b.geometry && b.geometry.morphAttributes.position ? b.geometry.morphAttributes.position.length : 0,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numClippingPlanes: a.numPlanes,
                            numClipIntersection: a.numIntersection,
                            dithering: s.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && h.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: s.toneMapped ? e.toneMapping : q,
                            physicallyCorrectLights: e.physicallyCorrectLights,
                            premultipliedAlpha: s.premultipliedAlpha,
                            doubleSided: s.side === d,
                            flipSided: s.side === u,
                            depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                            index0AttributeName: s.index0AttributeName,
                            extensionDerivatives: s.extensions && s.extensions.derivatives,
                            extensionFragDepth: s.extensions && s.extensions.fragDepth,
                            extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                            extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: c || n.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: c || n.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: c || n.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: s.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function(t) {
                        const i = [];
                        if (t.shaderID ? i.push(t.shaderID) : (i.push(t.customVertexShaderID), i.push(t.customFragmentShaderID)), void 0 !== t.defines)
                            for (const e in t.defines) i.push(e), i.push(t.defines[e]);
                        return !1 === t.isRawShaderMaterial && (! function(e, t) {
                            e.push(t.precision), e.push(t.outputEncoding), e.push(t.envMapMode), e.push(t.combine), e.push(t.vertexUvs), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.maxBones), e.push(t.morphTargetsCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection)
                        }(i, t), function(e, t) {
                            o.disableAll(), t.isWebGL2 && o.enable(0);
                            t.supportsVertexTextures && o.enable(1);
                            t.instancing && o.enable(2);
                            t.instancingColor && o.enable(3);
                            t.map && o.enable(4);
                            t.matcap && o.enable(5);
                            t.envMap && o.enable(6);
                            t.envMapCubeUV && o.enable(7);
                            t.lightMap && o.enable(8);
                            t.aoMap && o.enable(9);
                            t.emissiveMap && o.enable(10);
                            t.bumpMap && o.enable(11);
                            t.normalMap && o.enable(12);
                            t.objectSpaceNormalMap && o.enable(13);
                            t.tangentSpaceNormalMap && o.enable(14);
                            t.clearcoat && o.enable(15);
                            t.clearcoatMap && o.enable(16);
                            t.clearcoatRoughnessMap && o.enable(17);
                            t.clearcoatNormalMap && o.enable(18);
                            t.displacementMap && o.enable(19);
                            t.specularMap && o.enable(20);
                            t.roughnessMap && o.enable(21);
                            t.metalnessMap && o.enable(22);
                            t.gradientMap && o.enable(23);
                            t.alphaMap && o.enable(24);
                            t.alphaTest && o.enable(25);
                            t.vertexColors && o.enable(26);
                            t.vertexAlphas && o.enable(27);
                            t.vertexUvs && o.enable(28);
                            t.vertexTangents && o.enable(29);
                            t.uvsVertexOnly && o.enable(30);
                            t.fog && o.enable(31);
                            e.push(o.mask), o.disableAll(), t.useFog && o.enable(0);
                            t.flatShading && o.enable(1);
                            t.logarithmicDepthBuffer && o.enable(2);
                            t.skinning && o.enable(3);
                            t.useVertexTexture && o.enable(4);
                            t.morphTargets && o.enable(5);
                            t.morphNormals && o.enable(6);
                            t.premultipliedAlpha && o.enable(7);
                            t.shadowMapEnabled && o.enable(8);
                            t.physicallyCorrectLights && o.enable(9);
                            t.doubleSided && o.enable(10);
                            t.flipSided && o.enable(11);
                            t.depthPacking && o.enable(12);
                            t.dithering && o.enable(13);
                            t.specularIntensityMap && o.enable(14);
                            t.specularColorMap && o.enable(15);
                            t.transmission && o.enable(16);
                            t.transmissionMap && o.enable(17);
                            t.thicknessMap && o.enable(18);
                            t.sheen && o.enable(19);
                            t.sheenColorMap && o.enable(20);
                            t.sheenRoughnessMap && o.enable(21);
                            t.decodeVideoTexture && o.enable(22);
                            t.transparent && o.enable(23);
                            e.push(o.mask)
                        }(i, t), i.push(e.outputEncoding)), i.push(t.customProgramCacheKey), i.join()
                    },
                    getUniforms: function(e) {
                        const t = _[e.type];
                        let i;
                        if (t) {
                            const e = Mr[t];
                            i = ar.clone(e.uniforms)
                        } else i = e.uniforms;
                        return i
                    },
                    acquireProgram: function(t, i) {
                        let n;
                        for (let e = 0, t = h.length; e < t; e++) {
                            const t = h[e];
                            if (t.cacheKey === i) {
                                n = t, ++n.usedTimes;
                                break
                            }
                        }
                        return void 0 === n && (n = new Na(e, i, t, s), h.push(n)), n
                    },
                    releaseProgram: function(e) {
                        if (0 == --e.usedTimes) {
                            const t = h.indexOf(e);
                            h[t] = h[h.length - 1], h.pop(), e.destroy()
                        }
                    },
                    releaseShaderCache: function(e) {
                        l.remove(e)
                    },
                    programs: h,
                    dispose: function() {
                        l.dispose()
                    }
                }
            }

            function za() {
                let e = new WeakMap;
                return {
                    get: function(t) {
                        let i = e.get(t);
                        return void 0 === i && (i = {}, e.set(t, i)), i
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, i, n) {
                        e.get(t)[i] = n
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function Va(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function Ga(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function Wa() {
                const e = [];
                let t = 0;
                const i = [],
                    n = [],
                    r = [];

                function s(i, n, r, s, a, o) {
                    let l = e[t];
                    return void 0 === l ? (l = {
                        id: i.id,
                        object: i,
                        geometry: n,
                        material: r,
                        groupOrder: s,
                        renderOrder: i.renderOrder,
                        z: a,
                        group: o
                    }, e[t] = l) : (l.id = i.id, l.object = i, l.geometry = n, l.material = r, l.groupOrder = s, l.renderOrder = i.renderOrder, l.z = a, l.group = o), t++, l
                }
                return {
                    opaque: i,
                    transmissive: n,
                    transparent: r,
                    init: function() {
                        t = 0, i.length = 0, n.length = 0, r.length = 0
                    },
                    push: function(e, t, a, o, l, h) {
                        const c = s(e, t, a, o, l, h);
                        a.transmission > 0 ? n.push(c) : !0 === a.transparent ? r.push(c) : i.push(c)
                    },
                    unshift: function(e, t, a, o, l, h) {
                        const c = s(e, t, a, o, l, h);
                        a.transmission > 0 ? n.unshift(c) : !0 === a.transparent ? r.unshift(c) : i.unshift(c)
                    },
                    finish: function() {
                        for (let i = t, n = e.length; i < n; i++) {
                            const t = e[i];
                            if (null === t.id) break;
                            t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
                        }
                    },
                    sort: function(e, t) {
                        i.length > 1 && i.sort(e || Va), n.length > 1 && n.sort(t || Ga), r.length > 1 && r.sort(t || Ga)
                    }
                }
            }

            function ja() {
                let e = new WeakMap;
                return {
                    get: function(t, i) {
                        let n;
                        return !1 === e.has(t) ? (n = new Wa, e.set(t, [n])) : i >= e.get(t).length ? (n = new Wa, e.get(t).push(n)) : n = e.get(t)[i], n
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function qa() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        let i;
                        switch (t.type) {
                            case "DirectionalLight":
                                i = {
                                    direction: new ai,
                                    color: new Kt
                                };
                                break;
                            case "SpotLight":
                                i = {
                                    position: new ai,
                                    direction: new ai,
                                    color: new Kt,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                i = {
                                    position: new ai,
                                    color: new Kt,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                i = {
                                    direction: new ai,
                                    skyColor: new Kt,
                                    groundColor: new Kt
                                };
                                break;
                            case "RectAreaLight":
                                i = {
                                    color: new Kt,
                                    position: new ai,
                                    halfWidth: new ai,
                                    halfHeight: new ai
                                }
                        }
                        return e[t.id] = i, i
                    }
                }
            }
            let $a = 0;

            function Xa(e, t) {
                return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
            }

            function Ya(e, t) {
                const i = new qa,
                    n = function() {
                        const e = {};
                        return {
                            get: function(t) {
                                if (void 0 !== e[t.id]) return e[t.id];
                                let i;
                                switch (t.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        i = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ht
                                        };
                                        break;
                                    case "PointLight":
                                        i = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ht,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return e[t.id] = i, i
                            }
                        }
                    }(),
                    r = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                for (let e = 0; e < 9; e++) r.probe.push(new ai);
                const s = new ai,
                    a = new Ui,
                    o = new Ui;
                return {
                    setup: function(s, a) {
                        let o = 0,
                            l = 0,
                            h = 0;
                        for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
                        let c = 0,
                            u = 0,
                            d = 0,
                            p = 0,
                            f = 0,
                            m = 0,
                            g = 0,
                            y = 0;
                        s.sort(Xa);
                        const _ = !0 !== a ? Math.PI : 1;
                        for (let e = 0, t = s.length; e < t; e++) {
                            const t = s[e],
                                a = t.color,
                                v = t.intensity,
                                b = t.distance,
                                T = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                            if (t.isAmbientLight) o += a.r * v * _, l += a.g * v * _, h += a.b * v * _;
                            else if (t.isLightProbe)
                                for (let e = 0; e < 9; e++) r.probe[e].addScaledVector(t.sh.coefficients[e], v);
                            else if (t.isDirectionalLight) {
                                const e = i.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity * _), t.castShadow) {
                                    const e = t.shadow,
                                        i = n.get(t);
                                    i.shadowBias = e.bias, i.shadowNormalBias = e.normalBias, i.shadowRadius = e.radius, i.shadowMapSize = e.mapSize, r.directionalShadow[c] = i, r.directionalShadowMap[c] = T, r.directionalShadowMatrix[c] = t.shadow.matrix, m++
                                }
                                r.directional[c] = e, c++
                            } else if (t.isSpotLight) {
                                const e = i.get(t);
                                if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(a).multiplyScalar(v * _), e.distance = b, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
                                    const e = t.shadow,
                                        i = n.get(t);
                                    i.shadowBias = e.bias, i.shadowNormalBias = e.normalBias, i.shadowRadius = e.radius, i.shadowMapSize = e.mapSize, r.spotShadow[d] = i, r.spotShadowMap[d] = T, r.spotShadowMatrix[d] = t.shadow.matrix, y++
                                }
                                r.spot[d] = e, d++
                            } else if (t.isRectAreaLight) {
                                const e = i.get(t);
                                e.color.copy(a).multiplyScalar(v), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[p] = e, p++
                            } else if (t.isPointLight) {
                                const e = i.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity * _), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                                    const e = t.shadow,
                                        i = n.get(t);
                                    i.shadowBias = e.bias, i.shadowNormalBias = e.normalBias, i.shadowRadius = e.radius, i.shadowMapSize = e.mapSize, i.shadowCameraNear = e.camera.near, i.shadowCameraFar = e.camera.far, r.pointShadow[u] = i, r.pointShadowMap[u] = T, r.pointShadowMatrix[u] = t.shadow.matrix, g++
                                }
                                r.point[u] = e, u++
                            } else if (t.isHemisphereLight) {
                                const e = i.get(t);
                                e.skyColor.copy(t.color).multiplyScalar(v * _), e.groundColor.copy(t.groundColor).multiplyScalar(v * _), r.hemi[f] = e, f++
                            }
                        }
                        p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Er.LTC_FLOAT_1, r.rectAreaLTC2 = Er.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Er.LTC_HALF_1, r.rectAreaLTC2 = Er.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = h;
                        const v = r.hash;
                        v.directionalLength === c && v.pointLength === u && v.spotLength === d && v.rectAreaLength === p && v.hemiLength === f && v.numDirectionalShadows === m && v.numPointShadows === g && v.numSpotShadows === y || (r.directional.length = c, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = y, r.spotShadowMap.length = y, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = y, v.directionalLength = c, v.pointLength = u, v.spotLength = d, v.rectAreaLength = p, v.hemiLength = f, v.numDirectionalShadows = m, v.numPointShadows = g, v.numSpotShadows = y, r.version = $a++)
                    },
                    setupView: function(e, t) {
                        let i = 0,
                            n = 0,
                            l = 0,
                            h = 0,
                            c = 0;
                        const u = t.matrixWorldInverse;
                        for (let t = 0, d = e.length; t < d; t++) {
                            const d = e[t];
                            if (d.isDirectionalLight) {
                                const e = r.directional[i];
                                e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), i++
                            } else if (d.isSpotLight) {
                                const e = r.spot[l];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(u), l++
                            } else if (d.isRectAreaLight) {
                                const e = r.rectArea[h];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), o.identity(), a.copy(d.matrixWorld), a.premultiply(u), o.extractRotation(a), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), h++
                            } else if (d.isPointLight) {
                                const e = r.point[n];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), n++
                            } else if (d.isHemisphereLight) {
                                const e = r.hemi[c];
                                e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(u), e.direction.normalize(), c++
                            }
                        }
                    },
                    state: r
                }
            }

            function Ka(e, t) {
                const i = new Ya(e, t),
                    n = [],
                    r = [];
                return {
                    init: function() {
                        n.length = 0, r.length = 0
                    },
                    state: {
                        lightsArray: n,
                        shadowsArray: r,
                        lights: i
                    },
                    setupLights: function(e) {
                        i.setup(n, e)
                    },
                    setupLightsView: function(e) {
                        i.setupView(n, e)
                    },
                    pushLight: function(e) {
                        n.push(e)
                    },
                    pushShadow: function(e) {
                        r.push(e)
                    }
                }
            }

            function Ja(e, t) {
                let i = new WeakMap;
                return {
                    get: function(n, r = 0) {
                        let s;
                        return !1 === i.has(n) ? (s = new Ka(e, t), i.set(n, [s])) : r >= i.get(n).length ? (s = new Ka(e, t), i.get(n).push(s)) : s = i.get(n)[r], s
                    },
                    dispose: function() {
                        i = new WeakMap
                    }
                }
            }
            class Za extends xn {
                constructor(e) {
                    super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                }
            }
            Za.prototype.isMeshDepthMaterial = !0;
            class Qa extends xn {
                constructor(e) {
                    super(), this.type = "MeshDistanceMaterial", this.referencePosition = new ai, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                }
            }
            Qa.prototype.isMeshDistanceMaterial = !0;
            const eo = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                to = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

            function io(e, t, i) {
                let n = new br;
                const r = new Ht,
                    s = new Ht,
                    a = new ii,
                    l = new Za({
                        depthPacking: vt
                    }),
                    f = new Qa,
                    m = {},
                    g = i.maxTextureSize,
                    y = {
                        0: u,
                        1: c,
                        2: d
                    },
                    _ = new or({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Ht
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: eo,
                        fragmentShader: to
                    }),
                    v = _.clone();
                v.defines.HORIZONTAL_PASS = 1;
                const b = new Un;
                b.setAttribute("position", new Mn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const T = new tr(b, _),
                    x = this;

                function w(i, n) {
                    const r = t.update(T);
                    _.defines.VSM_SAMPLES !== i.blurSamples && (_.defines.VSM_SAMPLES = i.blurSamples, v.defines.VSM_SAMPLES = i.blurSamples, _.needsUpdate = !0, v.needsUpdate = !0), _.uniforms.shadow_pass.value = i.map.texture, _.uniforms.resolution.value = i.mapSize, _.uniforms.radius.value = i.radius, e.setRenderTarget(i.mapPass), e.clear(), e.renderBufferDirect(n, null, r, _, T, null), v.uniforms.shadow_pass.value = i.mapPass.texture, v.uniforms.resolution.value = i.mapSize, v.uniforms.radius.value = i.radius, e.setRenderTarget(i.map), e.clear(), e.renderBufferDirect(n, null, r, v, T, null)
                }

                function S(t, i, n, r, s, a, o) {
                    let c = null;
                    const u = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (c = void 0 !== u ? u : !0 === r.isPointLight ? f : l, e.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
                        const e = c.uuid,
                            t = n.uuid;
                        let i = m[e];
                        void 0 === i && (i = {}, m[e] = i);
                        let r = i[t];
                        void 0 === r && (r = c.clone(), i[t] = r), c = r
                    }
                    return c.visible = n.visible, c.wireframe = n.wireframe, c.side = o === h ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : y[n.side], c.alphaMap = n.alphaMap, c.alphaTest = n.alphaTest, c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.displacementMap = n.displacementMap, c.displacementScale = n.displacementScale, c.displacementBias = n.displacementBias, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = s, c.farDistance = a), c
                }

                function E(i, r, s, a, o) {
                    if (!1 === i.visible) return;
                    if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && o === h) && (!i.frustumCulled || n.intersectsObject(i))) {
                        i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, i.matrixWorld);
                        const n = t.update(i),
                            r = i.material;
                        if (Array.isArray(r)) {
                            const t = n.groups;
                            for (let l = 0, h = t.length; l < h; l++) {
                                const h = t[l],
                                    c = r[h.materialIndex];
                                if (c && c.visible) {
                                    const t = S(i, 0, c, a, s.near, s.far, o);
                                    e.renderBufferDirect(s, null, n, t, i, h)
                                }
                            }
                        } else if (r.visible) {
                            const t = S(i, 0, r, a, s.near, s.far, o);
                            e.renderBufferDirect(s, null, n, t, i, null)
                        }
                    }
                    const l = i.children;
                    for (let e = 0, t = l.length; e < t; e++) E(l[e], r, s, a, o)
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = o, this.render = function(t, i, o) {
                    if (!1 === x.enabled) return;
                    if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
                    if (0 === t.length) return;
                    const l = e.getRenderTarget(),
                        c = e.getActiveCubeFace(),
                        u = e.getActiveMipmapLevel(),
                        d = e.state;
                    d.setBlending(p), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                    for (let l = 0, c = t.length; l < c; l++) {
                        const c = t[l],
                            u = c.shadow;
                        if (void 0 === u) {
                            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                            continue
                        }
                        if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                        r.copy(u.mapSize);
                        const p = u.getFrameExtents();
                        if (r.multiply(p), s.copy(u.mapSize), (r.x > g || r.y > g) && (r.x > g && (s.x = Math.floor(g / p.x), r.x = s.x * p.x, u.mapSize.x = s.x), r.y > g && (s.y = Math.floor(g / p.y), r.y = s.y * p.y, u.mapSize.y = s.y)), null === u.map && !u.isPointLightShadow && this.type === h) {
                            const e = {
                                minFilter: ce,
                                magFilter: ce,
                                format: Me
                            };
                            u.map = new ni(r.x, r.y, e), u.map.texture.name = c.name + ".shadowMap", u.mapPass = new ni(r.x, r.y, e), u.camera.updateProjectionMatrix()
                        }
                        if (null === u.map) {
                            const e = {
                                minFilter: oe,
                                magFilter: oe,
                                format: Me
                            };
                            u.map = new ni(r.x, r.y, e), u.map.texture.name = c.name + ".shadowMap", u.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(u.map), e.clear();
                        const f = u.getViewportCount();
                        for (let e = 0; e < f; e++) {
                            const t = u.getViewport(e);
                            a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), d.viewport(a), u.updateMatrices(c, e), n = u.getFrustum(), E(i, o, u.camera, c, this.type)
                        }
                        u.isPointLightShadow || this.type !== h || w(u, o), u.needsUpdate = !1
                    }
                    x.needsUpdate = !1, e.setRenderTarget(l, c, u)
                }
            }

            function no(e, t, i) {
                const n = i.isWebGL2;
                const o = new function() {
                        let t = !1;
                        const i = new ii;
                        let n = null;
                        const r = new ii(0, 0, 0, 0);
                        return {
                            setMask: function(i) {
                                n === i || t || (e.colorMask(i, i, i, i), n = i)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t, n, s, a, o) {
                                !0 === o && (t *= a, n *= a, s *= a), i.set(t, n, s, a), !1 === r.equals(i) && (e.clearColor(t, n, s, a), r.copy(i))
                            },
                            reset: function() {
                                t = !1, n = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    l = new function() {
                        let t = !1,
                            i = null,
                            n = null,
                            r = null;
                        return {
                            setTest: function(e) {
                                e ? ve(2929) : be(2929)
                            },
                            setMask: function(n) {
                                i === n || t || (e.depthMask(n), i = n)
                            },
                            setFunc: function(t) {
                                if (n !== t) {
                                    if (t) switch (t) {
                                        case O:
                                            e.depthFunc(512);
                                            break;
                                        case N:
                                            e.depthFunc(519);
                                            break;
                                        case U:
                                            e.depthFunc(513);
                                            break;
                                        case B:
                                            e.depthFunc(515);
                                            break;
                                        case F:
                                            e.depthFunc(514);
                                            break;
                                        case H:
                                            e.depthFunc(518);
                                            break;
                                        case z:
                                            e.depthFunc(516);
                                            break;
                                        case V:
                                            e.depthFunc(517);
                                            break;
                                        default:
                                            e.depthFunc(515)
                                    } else e.depthFunc(515);
                                    n = t
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                r !== t && (e.clearDepth(t), r = t)
                            },
                            reset: function() {
                                t = !1, i = null, n = null, r = null
                            }
                        }
                    },
                    h = new function() {
                        let t = !1,
                            i = null,
                            n = null,
                            r = null,
                            s = null,
                            a = null,
                            o = null,
                            l = null,
                            h = null;
                        return {
                            setTest: function(e) {
                                t || (e ? ve(2960) : be(2960))
                            },
                            setMask: function(n) {
                                i === n || t || (e.stencilMask(n), i = n)
                            },
                            setFunc: function(t, i, a) {
                                n === t && r === i && s === a || (e.stencilFunc(t, i, a), n = t, r = i, s = a)
                            },
                            setOp: function(t, i, n) {
                                a === t && o === i && l === n || (e.stencilOp(t, i, n), a = t, o = i, l = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                h !== t && (e.clearStencil(t), h = t)
                            },
                            reset: function() {
                                t = !1, i = null, n = null, r = null, s = null, a = null, o = null, l = null, h = null
                            }
                        }
                    };
                let c = {},
                    G = {},
                    W = new WeakMap,
                    j = [],
                    q = null,
                    $ = !1,
                    X = null,
                    Y = null,
                    K = null,
                    J = null,
                    Z = null,
                    Q = null,
                    ee = null,
                    te = !1,
                    ie = null,
                    ne = null,
                    re = null,
                    se = null,
                    ae = null;
                const oe = e.getParameter(35661);
                let le = !1,
                    he = 0;
                const ce = e.getParameter(7938); - 1 !== ce.indexOf("WebGL") ? (he = parseFloat(/^WebGL (\d)/.exec(ce)[1]), le = he >= 1) : -1 !== ce.indexOf("OpenGL ES") && (he = parseFloat(/^OpenGL ES (\d)/.exec(ce)[1]), le = he >= 2);
                let ue = null,
                    de = {};
                const pe = e.getParameter(3088),
                    fe = e.getParameter(2978),
                    me = (new ii).fromArray(pe),
                    ge = (new ii).fromArray(fe);

                function ye(t, i, n) {
                    const r = new Uint8Array(4),
                        s = e.createTexture();
                    e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                    for (let t = 0; t < n; t++) e.texImage2D(i + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return s
                }
                const _e = {};

                function ve(t) {
                    !0 !== c[t] && (e.enable(t), c[t] = !0)
                }

                function be(t) {
                    !1 !== c[t] && (e.disable(t), c[t] = !1)
                }
                _e[3553] = ye(3553, 3553, 1), _e[34067] = ye(34067, 34069, 6), o.setClear(0, 0, 0, 1), l.setClear(1), h.setClear(0), ve(2929), l.setFunc(B), Se(!1), Ee(s), ve(2884), we(p);
                const Te = {
                    [v]: 32774,
                    [b]: 32778,
                    [T]: 32779
                };
                if (n) Te[x] = 32775, Te[w] = 32776;
                else {
                    const e = t.get("EXT_blend_minmax");
                    null !== e && (Te[x] = e.MIN_EXT, Te[w] = e.MAX_EXT)
                }
                const xe = {
                    [S]: 0,
                    [E]: 1,
                    [M]: 768,
                    [A]: 770,
                    [D]: 776,
                    [R]: 774,
                    [I]: 772,
                    [C]: 769,
                    [L]: 771,
                    [k]: 775,
                    [P]: 773
                };

                function we(t, i, n, r, s, a, o, l) {
                    if (t !== p) {
                        if (!1 === $ && (ve(3042), $ = !0), t === _) s = s || i, a = a || n, o = o || r, i === Y && s === Z || (e.blendEquationSeparate(Te[i], Te[s]), Y = i, Z = s), n === K && r === J && a === Q && o === ee || (e.blendFuncSeparate(xe[n], xe[r], xe[a], xe[o]), K = n, J = r, Q = a, ee = o), X = t, te = null;
                        else if (t !== X || l !== te) {
                            if (Y === v && Z === v || (e.blendEquation(32774), Y = v, Z = v), l) switch (t) {
                                case f:
                                    e.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case m:
                                    e.blendFunc(1, 1);
                                    break;
                                case g:
                                    e.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case y:
                                    e.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            } else switch (t) {
                                case f:
                                    e.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case m:
                                    e.blendFunc(770, 1);
                                    break;
                                case g:
                                    e.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case y:
                                    e.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                            K = null, J = null, Q = null, ee = null, X = t, te = l
                        }
                    } else !0 === $ && (be(3042), $ = !1)
                }

                function Se(t) {
                    ie !== t && (t ? e.frontFace(2304) : e.frontFace(2305), ie = t)
                }

                function Ee(t) {
                    t !== r ? (ve(2884), t !== ne && (t === s ? e.cullFace(1029) : t === a ? e.cullFace(1028) : e.cullFace(1032))) : be(2884), ne = t
                }

                function Me(t, i, n) {
                    t ? (ve(32823), se === i && ae === n || (e.polygonOffset(i, n), se = i, ae = n)) : be(32823)
                }

                function Ce(t) {
                    void 0 === t && (t = 33984 + oe - 1), ue !== t && (e.activeTexture(t), ue = t)
                }
                return {
                    buffers: {
                        color: o,
                        depth: l,
                        stencil: h
                    },
                    enable: ve,
                    disable: be,
                    bindFramebuffer: function(t, i) {
                        return G[t] !== i && (e.bindFramebuffer(t, i), G[t] = i, n && (36009 === t && (G[36160] = i), 36160 === t && (G[36009] = i)), !0)
                    },
                    drawBuffers: function(n, r) {
                        let s = j,
                            a = !1;
                        if (n)
                            if (s = W.get(r), void 0 === s && (s = [], W.set(r, s)), n.isWebGLMultipleRenderTargets) {
                                const e = n.texture;
                                if (s.length !== e.length || 36064 !== s[0]) {
                                    for (let t = 0, i = e.length; t < i; t++) s[t] = 36064 + t;
                                    s.length = e.length, a = !0
                                }
                            } else 36064 !== s[0] && (s[0] = 36064, a = !0);
                        else 1029 !== s[0] && (s[0] = 1029, a = !0);
                        a && (i.isWebGL2 ? e.drawBuffers(s) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                    },
                    useProgram: function(t) {
                        return q !== t && (e.useProgram(t), q = t, !0)
                    },
                    setBlending: we,
                    setMaterial: function(e, t) {
                        e.side === d ? be(2884) : ve(2884);
                        let i = e.side === u;
                        t && (i = !i), Se(i), e.blending === f && !1 === e.transparent ? we(p) : we(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), l.setFunc(e.depthFunc), l.setTest(e.depthTest), l.setMask(e.depthWrite), o.setMask(e.colorWrite);
                        const n = e.stencilWrite;
                        h.setTest(n), n && (h.setMask(e.stencilWriteMask), h.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), h.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Me(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? ve(32926) : be(32926)
                    },
                    setFlipSided: Se,
                    setCullFace: Ee,
                    setLineWidth: function(t) {
                        t !== re && (le && e.lineWidth(t), re = t)
                    },
                    setPolygonOffset: Me,
                    setScissorTest: function(e) {
                        e ? ve(3089) : be(3089)
                    },
                    activeTexture: Ce,
                    bindTexture: function(t, i) {
                        null === ue && Ce();
                        let n = de[ue];
                        void 0 === n && (n = {
                            type: void 0,
                            texture: void 0
                        }, de[ue] = n), n.type === t && n.texture === i || (e.bindTexture(t, i || _e[t]), n.type = t, n.texture = i)
                    },
                    unbindTexture: function() {
                        const t = de[ue];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage2D: function() {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            e.texStorage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            e.texSubImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            e.compressedTexSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(t) {
                        !1 === me.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), me.copy(t))
                    },
                    viewport: function(t) {
                        !1 === ge.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), ge.copy(t))
                    },
                    reset: function() {
                        e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === n && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), c = {}, ue = null, de = {}, G = {}, W = new WeakMap, j = [], q = null, $ = !1, X = null, Y = null, K = null, J = null, Z = null, Q = null, ee = null, te = !1, ie = null, ne = null, re = null, se = null, ae = null, me.set(0, 0, e.canvas.width, e.canvas.height), ge.set(0, 0, e.canvas.width, e.canvas.height), o.reset(), l.reset(), h.reset()
                    }
                }
            }

            function ro(e, t, i, n, r, s, a) {
                const o = r.isWebGL2,
                    l = r.maxTextures,
                    h = r.maxCubemapSize,
                    c = r.maxTextureSize,
                    u = r.maxSamples,
                    d = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : void 0,
                    p = new WeakMap;
                let f, m = !1;
                try {
                    m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (e) {}

                function g(e, t) {
                    return m ? new OffscreenCanvas(e, t) : Gt("canvas")
                }

                function y(e, t, i, n) {
                    let r = 1;
                    if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)), r < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                            const n = t ? Bt : Math.floor,
                                s = n(r * e.width),
                                a = n(r * e.height);
                            void 0 === f && (f = g(s, a));
                            const o = i ? g(s, a) : f;
                            o.width = s, o.height = a;
                            return o.getContext("2d").drawImage(e, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + a + ")."), o
                        }
                        return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                    }
                    return e
                }

                function _(e) {
                    return Nt(e.width) && Nt(e.height)
                }

                function v(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== oe && e.minFilter !== ce
                }

                function b(t) {
                    e.generateMipmap(t)
                }

                function T(i, n, r, s, a = !1) {
                    if (!1 === o) return n;
                    if (null !== i) {
                        if (void 0 !== e[i]) return e[i];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
                    }
                    let l = n;
                    return 6403 === n && (5126 === r && (l = 33326), 5131 === r && (l = 33325), 5121 === r && (l = 33321)), 33319 === n && (5126 === r && (l = 33328), 5131 === r && (l = 33327), 5121 === r && (l = 33323)), 6408 === n && (5126 === r && (l = 34836), 5131 === r && (l = 34842), 5121 === r && (l = s === _t && !1 === a ? 35907 : 32856), 32819 === r && (l = 32854), 32820 === r && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || t.get("EXT_color_buffer_float"), l
                }

                function x(e, t, i) {
                    return !0 === v(e, i) || e.isFramebufferTexture && e.minFilter !== oe && e.minFilter !== ce ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }

                function w(e) {
                    return e === oe || e === le || e === he ? 9728 : 9729
                }

                function S(t) {
                    const i = t.target;
                    i.removeEventListener("dispose", S),
                        function(t) {
                            const i = n.get(t);
                            if (void 0 === i.__webglInit) return;
                            e.deleteTexture(i.__webglTexture), n.remove(t)
                        }(i), i.isVideoTexture && p.delete(i), a.memory.textures--
                }

                function E(t) {
                    const i = t.target;
                    i.removeEventListener("dispose", E),
                        function(t) {
                            const i = t.texture,
                                r = n.get(t),
                                s = n.get(i);
                            if (!t) return;
                            void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), a.memory.textures--);
                            t.depthTexture && t.depthTexture.dispose();
                            if (t.isWebGLCubeRenderTarget)
                                for (let t = 0; t < 6; t++) e.deleteFramebuffer(r.__webglFramebuffer[t]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]);
                            else e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && e.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                            if (t.isWebGLMultipleRenderTargets)
                                for (let t = 0, r = i.length; t < r; t++) {
                                    const r = n.get(i[t]);
                                    r.__webglTexture && (e.deleteTexture(r.__webglTexture), a.memory.textures--), n.remove(i[t])
                                }
                            n.remove(i), n.remove(t)
                        }(i)
                }
                let M = 0;

                function C(e, t) {
                    const r = n.get(e);
                    if (e.isVideoTexture && function(e) {
                            const t = a.render.frame;
                            p.get(e) !== t && (p.set(e, t), e.update())
                        }(e), e.version > 0 && r.__version !== e.version) {
                        const i = e.image;
                        if (void 0 === i) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== i.complete) return void k(r, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    i.activeTexture(33984 + t), i.bindTexture(3553, r.__webglTexture)
                }

                function A(t, r) {
                    const a = n.get(t);
                    t.version > 0 && a.__version !== t.version ? function(t, n, r) {
                        if (6 !== n.image.length) return;
                        R(t, n), i.activeTexture(33984 + r), i.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, n.flipY), e.pixelStorei(37441, n.premultiplyAlpha), e.pixelStorei(3317, n.unpackAlignment), e.pixelStorei(37443, 0);
                        const a = n && (n.isCompressedTexture || n.image[0].isCompressedTexture),
                            l = n.image[0] && n.image[0].isDataTexture,
                            c = [];
                        for (let e = 0; e < 6; e++) c[e] = a || l ? l ? n.image[e].image : n.image[e] : y(n.image[e], !1, !0, h), c[e] = B(n, c[e]);
                        const u = c[0],
                            d = _(u) || o,
                            p = s.convert(n.format, n.encoding),
                            f = s.convert(n.type),
                            m = T(n.internalFormat, p, f, n.encoding),
                            g = o && !0 !== n.isVideoTexture,
                            w = void 0 === t.__version;
                        let S, E = x(n, u, d);
                        if (P(34067, n, d), a) {
                            g && w && i.texStorage2D(34067, E, m, u.width, u.height);
                            for (let e = 0; e < 6; e++) {
                                S = c[e].mipmaps;
                                for (let t = 0; t < S.length; t++) {
                                    const r = S[t];
                                    n.format !== Me ? null !== p ? g ? i.compressedTexSubImage2D(34069 + e, t, 0, 0, r.width, r.height, p, r.data) : i.compressedTexImage2D(34069 + e, t, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? i.texSubImage2D(34069 + e, t, 0, 0, r.width, r.height, p, f, r.data) : i.texImage2D(34069 + e, t, m, r.width, r.height, 0, p, f, r.data)
                                }
                            }
                        } else {
                            S = n.mipmaps, g && w && (S.length > 0 && E++, i.texStorage2D(34067, E, m, c[0].width, c[0].height));
                            for (let e = 0; e < 6; e++)
                                if (l) {
                                    g ? i.texSubImage2D(34069 + e, 0, 0, 0, c[e].width, c[e].height, p, f, c[e].data) : i.texImage2D(34069 + e, 0, m, c[e].width, c[e].height, 0, p, f, c[e].data);
                                    for (let t = 0; t < S.length; t++) {
                                        const n = S[t].image[e].image;
                                        g ? i.texSubImage2D(34069 + e, t + 1, 0, 0, n.width, n.height, p, f, n.data) : i.texImage2D(34069 + e, t + 1, m, n.width, n.height, 0, p, f, n.data)
                                    }
                                } else {
                                    g ? i.texSubImage2D(34069 + e, 0, 0, 0, p, f, c[e]) : i.texImage2D(34069 + e, 0, m, p, f, c[e]);
                                    for (let t = 0; t < S.length; t++) {
                                        const n = S[t];
                                        g ? i.texSubImage2D(34069 + e, t + 1, 0, 0, p, f, n.image[e]) : i.texImage2D(34069 + e, t + 1, m, p, f, n.image[e])
                                    }
                                }
                        }
                        v(n, d) && b(34067);
                        t.__version = n.version, n.onUpdate && n.onUpdate(n)
                    }(a, t, r) : (i.activeTexture(33984 + r), i.bindTexture(34067, a.__webglTexture))
                }
                const L = {
                        [re]: 10497,
                        [se]: 33071,
                        [ae]: 33648
                    },
                    I = {
                        [oe]: 9728,
                        [le]: 9984,
                        [he]: 9986,
                        [ce]: 9729,
                        [ue]: 9985,
                        [de]: 9987
                    };

                function P(i, s, a) {
                    if (a ? (e.texParameteri(i, 10242, L[s.wrapS]), e.texParameteri(i, 10243, L[s.wrapT]), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, L[s.wrapR]), e.texParameteri(i, 10240, I[s.magFilter]), e.texParameteri(i, 10241, I[s.minFilter])) : (e.texParameteri(i, 10242, 33071), e.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, 33071), s.wrapS === se && s.wrapT === se || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(i, 10240, w(s.magFilter)), e.texParameteri(i, 10241, w(s.minFilter)), s.minFilter !== oe && s.minFilter !== ce && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
                        const a = t.get("EXT_texture_filter_anisotropic");
                        if (s.type === ve && !1 === t.has("OES_texture_float_linear")) return;
                        if (!1 === o && s.type === be && !1 === t.has("OES_texture_half_float_linear")) return;
                        (s.anisotropy > 1 || n.get(s).__currentAnisotropy) && (e.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), n.get(s).__currentAnisotropy = s.anisotropy)
                    }
                }

                function R(t, i) {
                    void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", S), t.__webglTexture = e.createTexture(), a.memory.textures++)
                }

                function k(t, n, r) {
                    let a = 3553;
                    n.isDataTexture2DArray && (a = 35866), n.isDataTexture3D && (a = 32879), R(t, n), i.activeTexture(33984 + r), i.bindTexture(a, t.__webglTexture), e.pixelStorei(37440, n.flipY), e.pixelStorei(37441, n.premultiplyAlpha), e.pixelStorei(3317, n.unpackAlignment), e.pixelStorei(37443, 0);
                    const l = function(e) {
                        return !o && (e.wrapS !== se || e.wrapT !== se || e.minFilter !== oe && e.minFilter !== ce)
                    }(n) && !1 === _(n.image);
                    let h = y(n.image, l, !1, c);
                    h = B(n, h);
                    const u = _(h) || o,
                        d = s.convert(n.format, n.encoding);
                    let p, f = s.convert(n.type),
                        m = T(n.internalFormat, d, f, n.encoding, n.isVideoTexture);
                    P(a, n, u);
                    const g = n.mipmaps,
                        w = o && !0 !== n.isVideoTexture,
                        S = void 0 === t.__version,
                        E = x(n, h, u);
                    if (n.isDepthTexture) m = 6402, o ? m = n.type === ve ? 36012 : n.type === _e ? 33190 : n.type === we ? 35056 : 33189 : n.type === ve && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n.format === Le && 6402 === m && n.type !== ge && n.type !== _e && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = ge, f = s.convert(n.type)), n.format === Ie && 6402 === m && (m = 34041, n.type !== we && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = we, f = s.convert(n.type))), w && S ? i.texStorage2D(3553, 1, m, h.width, h.height) : i.texImage2D(3553, 0, m, h.width, h.height, 0, d, f, null);
                    else if (n.isDataTexture)
                        if (g.length > 0 && u) {
                            w && S && i.texStorage2D(3553, E, m, g[0].width, g[0].height);
                            for (let e = 0, t = g.length; e < t; e++) p = g[e], w ? i.texSubImage2D(3553, 0, 0, 0, p.width, p.height, d, f, p.data) : i.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data);
                            n.generateMipmaps = !1
                        } else w ? (S && i.texStorage2D(3553, E, m, h.width, h.height), i.texSubImage2D(3553, 0, 0, 0, h.width, h.height, d, f, h.data)) : i.texImage2D(3553, 0, m, h.width, h.height, 0, d, f, h.data);
                    else if (n.isCompressedTexture) {
                        w && S && i.texStorage2D(3553, E, m, g[0].width, g[0].height);
                        for (let e = 0, t = g.length; e < t; e++) p = g[e], n.format !== Me ? null !== d ? w ? i.compressedTexSubImage2D(3553, e, 0, 0, p.width, p.height, d, p.data) : i.compressedTexImage2D(3553, e, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : w ? i.texSubImage2D(3553, e, 0, 0, p.width, p.height, d, f, p.data) : i.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data)
                    } else if (n.isDataTexture2DArray) w ? (S && i.texStorage3D(35866, E, m, h.width, h.height, h.depth), i.texSubImage3D(35866, 0, 0, 0, 0, h.width, h.height, h.depth, d, f, h.data)) : i.texImage3D(35866, 0, m, h.width, h.height, h.depth, 0, d, f, h.data);
                    else if (n.isDataTexture3D) w ? (S && i.texStorage3D(32879, E, m, h.width, h.height, h.depth), i.texSubImage3D(32879, 0, 0, 0, 0, h.width, h.height, h.depth, d, f, h.data)) : i.texImage3D(32879, 0, m, h.width, h.height, h.depth, 0, d, f, h.data);
                    else if (n.isFramebufferTexture) w && S ? i.texStorage2D(3553, E, m, h.width, h.height) : i.texImage2D(3553, 0, m, h.width, h.height, 0, d, f, null);
                    else if (g.length > 0 && u) {
                        w && S && i.texStorage2D(3553, E, m, g[0].width, g[0].height);
                        for (let e = 0, t = g.length; e < t; e++) p = g[e], w ? i.texSubImage2D(3553, e, 0, 0, d, f, p) : i.texImage2D(3553, e, m, d, f, p);
                        n.generateMipmaps = !1
                    } else w ? (S && i.texStorage2D(3553, E, m, h.width, h.height), i.texSubImage2D(3553, 0, 0, 0, d, f, h)) : i.texImage2D(3553, 0, m, d, f, h);
                    v(n, u) && b(a), t.__version = n.version, n.onUpdate && n.onUpdate(n)
                }

                function D(t, r, a, o, l) {
                    const h = s.convert(a.format, a.encoding),
                        c = s.convert(a.type),
                        u = T(a.internalFormat, h, c, a.encoding);
                    n.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? i.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, h, c, null) : i.texImage2D(l, 0, u, r.width, r.height, 0, h, c, null)), i.bindFramebuffer(36160, t), r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, o, l, n.get(a).__webglTexture, 0, U(r)) : e.framebufferTexture2D(36160, o, l, n.get(a).__webglTexture, 0), i.bindFramebuffer(36160, null)
                }

                function O(t, i, n) {
                    if (e.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer) {
                        let r = 33189;
                        if (n || i.useRenderToTexture) {
                            const t = i.depthTexture;
                            t && t.isDepthTexture && (t.type === ve ? r = 36012 : t.type === _e && (r = 33190));
                            const n = U(i);
                            i.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, n, r, i.width, i.height) : e.renderbufferStorageMultisample(36161, n, r, i.width, i.height)
                        } else e.renderbufferStorage(36161, r, i.width, i.height);
                        e.framebufferRenderbuffer(36160, 36096, 36161, t)
                    } else if (i.depthBuffer && i.stencilBuffer) {
                        const r = U(i);
                        n && i.useRenderbuffer ? e.renderbufferStorageMultisample(36161, r, 35056, i.width, i.height) : i.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, i.width, i.height) : e.renderbufferStorage(36161, 34041, i.width, i.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)
                    } else {
                        const t = !0 === i.isWebGLMultipleRenderTargets ? i.texture[0] : i.texture,
                            r = s.convert(t.format, t.encoding),
                            a = s.convert(t.type),
                            o = T(t.internalFormat, r, a, t.encoding),
                            l = U(i);
                        n && i.useRenderbuffer ? e.renderbufferStorageMultisample(36161, l, o, i.width, i.height) : i.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, l, o, i.width, i.height) : e.renderbufferStorage(36161, o, i.width, i.height)
                    }
                    e.bindRenderbuffer(36161, null)
                }

                function N(t) {
                    const r = n.get(t),
                        s = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                        if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(t, r) {
                            if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (i.bindFramebuffer(36160, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), C(r.depthTexture, 0);
                            const s = n.get(r.depthTexture).__webglTexture,
                                a = U(r);
                            if (r.depthTexture.format === Le) r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
                            else {
                                if (r.depthTexture.format !== Ie) throw new Error("Unknown depthTexture format");
                                r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : e.framebufferTexture2D(36160, 33306, 3553, s, 0)
                            }
                        }(r.__webglFramebuffer, t)
                    } else if (s) {
                        r.__webglDepthbuffer = [];
                        for (let n = 0; n < 6; n++) i.bindFramebuffer(36160, r.__webglFramebuffer[n]), r.__webglDepthbuffer[n] = e.createRenderbuffer(), O(r.__webglDepthbuffer[n], t, !1)
                    } else i.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), O(r.__webglDepthbuffer, t, !1);
                    i.bindFramebuffer(36160, null)
                }

                function U(e) {
                    return o && (e.useRenderbuffer || e.useRenderToTexture) ? Math.min(u, e.samples) : 0
                }

                function B(e, i) {
                    const n = e.encoding,
                        r = e.format,
                        s = e.type;
                    return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === Mt || n !== yt && (n === _t ? !1 === o ? !0 === t.has("EXT_sRGB") && r === Me ? (e.format = Mt, e.minFilter = ce, e.generateMipmaps = !1) : i = Zt.sRGBToLinear(i) : r === Me && s === pe || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", n)), i
                }
                let F = !1,
                    H = !1;
                this.allocateTextureUnit = function() {
                    const e = M;
                    return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), M += 1, e
                }, this.resetTextureUnits = function() {
                    M = 0
                }, this.setTexture2D = C, this.setTexture2DArray = function(e, t) {
                    const r = n.get(e);
                    e.version > 0 && r.__version !== e.version ? k(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(35866, r.__webglTexture))
                }, this.setTexture3D = function(e, t) {
                    const r = n.get(e);
                    e.version > 0 && r.__version !== e.version ? k(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = A, this.rebindTextures = function(e, t, i) {
                    const r = n.get(e);
                    void 0 !== t && D(r.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== i && N(e)
                }, this.setupRenderTarget = function(t) {
                    const l = t.texture,
                        h = n.get(t),
                        c = n.get(l);
                    t.addEventListener("dispose", E), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === c.__webglTexture && (c.__webglTexture = e.createTexture()), c.__version = l.version, a.memory.textures++);
                    const u = !0 === t.isWebGLCubeRenderTarget,
                        d = !0 === t.isWebGLMultipleRenderTargets,
                        p = l.isDataTexture3D || l.isDataTexture2DArray,
                        f = _(t) || o;
                    if (u) {
                        h.__webglFramebuffer = [];
                        for (let t = 0; t < 6; t++) h.__webglFramebuffer[t] = e.createFramebuffer()
                    } else if (h.__webglFramebuffer = e.createFramebuffer(), d)
                        if (r.drawBuffers) {
                            const i = t.texture;
                            for (let t = 0, r = i.length; t < r; t++) {
                                const r = n.get(i[t]);
                                void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(), a.memory.textures++)
                            }
                        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    else if (t.useRenderbuffer)
                        if (o) {
                            h.__webglMultisampledFramebuffer = e.createFramebuffer(), h.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, h.__webglColorRenderbuffer);
                            const n = s.convert(l.format, l.encoding),
                                r = s.convert(l.type),
                                a = T(l.internalFormat, n, r, l.encoding),
                                o = U(t);
                            e.renderbufferStorageMultisample(36161, o, a, t.width, t.height), i.bindFramebuffer(36160, h.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, h.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (h.__webglDepthRenderbuffer = e.createRenderbuffer(), O(h.__webglDepthRenderbuffer, t, !0)), i.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (u) {
                        i.bindTexture(34067, c.__webglTexture), P(34067, l, f);
                        for (let e = 0; e < 6; e++) D(h.__webglFramebuffer[e], t, l, 36064, 34069 + e);
                        v(l, f) && b(34067), i.unbindTexture()
                    } else if (d) {
                        const e = t.texture;
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r],
                                a = n.get(s);
                            i.bindTexture(3553, a.__webglTexture), P(3553, s, f), D(h.__webglFramebuffer, t, s, 36064 + r, 3553), v(s, f) && b(3553)
                        }
                        i.unbindTexture()
                    } else {
                        let e = 3553;
                        if (p)
                            if (o) {
                                e = l.isDataTexture3D ? 32879 : 35866
                            } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                        i.bindTexture(e, c.__webglTexture), P(e, l, f), D(h.__webglFramebuffer, t, l, 36064, e), v(l, f) && b(e), i.unbindTexture()
                    }
                    t.depthBuffer && N(t)
                }, this.updateRenderTargetMipmap = function(e) {
                    const t = _(e) || o,
                        r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                    for (let s = 0, a = r.length; s < a; s++) {
                        const a = r[s];
                        if (v(a, t)) {
                            const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                                r = n.get(a).__webglTexture;
                            i.bindTexture(t, r), b(t), i.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function(t) {
                    if (t.useRenderbuffer)
                        if (o) {
                            const r = t.width,
                                s = t.height;
                            let a = 16384;
                            const o = [36064],
                                l = t.stencilBuffer ? 33306 : 36096;
                            t.depthBuffer && o.push(l), t.ignoreDepthForMultisampleCopy || (t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024));
                            const h = n.get(t);
                            i.bindFramebuffer(36008, h.__webglMultisampledFramebuffer), i.bindFramebuffer(36009, h.__webglFramebuffer), t.ignoreDepthForMultisampleCopy && (e.invalidateFramebuffer(36008, [l]), e.invalidateFramebuffer(36009, [l])), e.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728), e.invalidateFramebuffer(36008, o), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, h.__webglMultisampledFramebuffer)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }, this.setupDepthRenderbuffer = N, this.setupFrameBufferTexture = D, this.safeSetTexture2D = function(e, t) {
                    e && e.isWebGLRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), F = !0), e = e.texture), C(e, t)
                }, this.safeSetTextureCube = function(e, t) {
                    e && e.isWebGLCubeRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H = !0), e = e.texture), A(e, t)
                }
            }

            function so(e, t, i) {
                const n = i.isWebGL2;
                return {
                    convert: function(e, i = null) {
                        let r;
                        if (e === pe) return 5121;
                        if (e === Te) return 32819;
                        if (e === xe) return 32820;
                        if (e === fe) return 5120;
                        if (e === me) return 5122;
                        if (e === ge) return 5123;
                        if (e === ye) return 5124;
                        if (e === _e) return 5125;
                        if (e === ve) return 5126;
                        if (e === be) return n ? 5131 : (r = t.get("OES_texture_half_float"), null !== r ? r.HALF_FLOAT_OES : null);
                        if (e === Se) return 6406;
                        if (e === Me) return 6408;
                        if (e === Ce) return 6409;
                        if (e === Ae) return 6410;
                        if (e === Le) return 6402;
                        if (e === Ie) return 34041;
                        if (e === Pe) return 6403;
                        if (e === Ee) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
                        if (e === Mt) return r = t.get("EXT_sRGB"), null !== r ? r.SRGB_ALPHA_EXT : null;
                        if (e === Re) return 36244;
                        if (e === ke) return 33319;
                        if (e === De) return 33320;
                        if (e === Oe) return 36249;
                        if (e === Ne || e === Ue || e === Be || e === Fe)
                            if (i === _t) {
                                if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null;
                                if (e === Ne) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (e === Ue) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (e === Be) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (e === Fe) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (r = t.get("WEBGL_compressed_texture_s3tc"), null === r) return null;
                                if (e === Ne) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (e === Ue) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (e === Be) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (e === Fe) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                        if (e === He || e === ze || e === Ve || e === Ge) {
                            if (r = t.get("WEBGL_compressed_texture_pvrtc"), null === r) return null;
                            if (e === He) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (e === ze) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (e === Ve) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (e === Ge) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (e === We) return r = t.get("WEBGL_compressed_texture_etc1"), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if (e === je || e === qe) {
                            if (r = t.get("WEBGL_compressed_texture_etc"), null === r) return null;
                            if (e === je) return i === _t ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                            if (e === qe) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (e === $e || e === Xe || e === Ye || e === Ke || e === Je || e === Ze || e === Qe || e === et || e === tt || e === it || e === nt || e === rt || e === st || e === at) {
                            if (r = t.get("WEBGL_compressed_texture_astc"), null === r) return null;
                            if (e === $e) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (e === Xe) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (e === Ye) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (e === Ke) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (e === Je) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (e === Ze) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (e === Qe) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (e === et) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (e === tt) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (e === it) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (e === nt) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (e === rt) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (e === st) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (e === at) return i === _t ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (e === ot) {
                            if (r = t.get("EXT_texture_compression_bptc"), null === r) return null;
                            if (e === ot) return i === _t ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT
                        }
                        return e === we ? n ? 34042 : (r = t.get("WEBGL_depth_texture"), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                    }
                }
            }
            class ao extends hr {
                constructor(e = []) {
                    super(), this.cameras = e
                }
            }
            ao.prototype.isArrayCamera = !0;
            class oo extends hn {
                constructor() {
                    super(), this.type = "Group"
                }
            }
            oo.prototype.isGroup = !0;
            const lo = {
                type: "move"
            };
            class ho {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new oo, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new oo, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ai, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ai), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new oo, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ai, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ai), this._grip
                }
                dispatchEvent(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                }
                disconnect(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                }
                update(e, t, i) {
                    let n = null,
                        r = null,
                        s = null;
                    const a = this._targetRay,
                        o = this._grip,
                        l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState)
                        if (null !== a && (n = t.getPose(e.targetRaySpace, i), null !== n && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), n.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1, n.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(lo))), l && e.hand) {
                            s = !0;
                            for (const n of e.hand.values()) {
                                const e = t.getJointPose(n, i);
                                if (void 0 === l.joints[n.jointName]) {
                                    const e = new oo;
                                    e.matrixAutoUpdate = !1, e.visible = !1, l.joints[n.jointName] = e, l.add(e)
                                }
                                const r = l.joints[n.jointName];
                                null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = e.radius), r.visible = null !== e
                            }
                            const n = l.joints["index-finger-tip"],
                                r = l.joints["thumb-tip"],
                                a = n.position.distanceTo(r.position),
                                o = .02,
                                h = .005;
                            l.inputState.pinching && a > o + h ? (l.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: e.handedness,
                                target: this
                            })) : !l.inputState.pinching && a <= o - h && (l.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: e.handedness,
                                target: this
                            }))
                        } else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                    return null !== a && (a.visible = null !== n), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
                }
            }
            class co extends ei {
                constructor(e, t, i, n, r, s, a, o, l, h) {
                    if ((h = void 0 !== h ? h : Le) !== Le && h !== Ie) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === i && h === Le && (i = ge), void 0 === i && h === Ie && (i = we), super(null, n, r, s, a, o, h, i, l), this.image = {
                        width: e,
                        height: t
                    }, this.magFilter = void 0 !== a ? a : oe, this.minFilter = void 0 !== o ? o : oe, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            co.prototype.isDepthTexture = !0;
            class uo extends Ct {
                constructor(e, t) {
                    super();
                    const i = this;
                    let n = null,
                        r = 1,
                        s = null,
                        a = "local-floor";
                    const o = e.extensions.has("WEBGL_multisampled_render_to_texture");
                    let l = null,
                        h = null,
                        c = null,
                        u = null,
                        d = !1,
                        p = null;
                    const f = t.getContextAttributes();
                    let m = null,
                        g = null;
                    const y = [],
                        _ = new Map,
                        v = new hr;
                    v.layers.enable(1), v.viewport = new ii;
                    const b = new hr;
                    b.layers.enable(2), b.viewport = new ii;
                    const T = [v, b],
                        x = new ao;
                    x.layers.enable(1), x.layers.enable(2);
                    let w = null,
                        S = null;

                    function E(e) {
                        const t = _.get(e.inputSource);
                        t && t.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        })
                    }

                    function M() {
                        _.forEach((function(e, t) {
                            e.disconnect(t)
                        })), _.clear(), w = null, S = null, e.setRenderTarget(m), u = null, c = null, h = null, n = null, g = null, R.stop(), i.isPresenting = !1, i.dispatchEvent({
                            type: "sessionend"
                        })
                    }

                    function C(e) {
                        const t = n.inputSources;
                        for (let e = 0; e < y.length; e++) _.set(t[e], y[e]);
                        for (let t = 0; t < e.removed.length; t++) {
                            const i = e.removed[t],
                                n = _.get(i);
                            n && (n.dispatchEvent({
                                type: "disconnected",
                                data: i
                            }), _.delete(i))
                        }
                        for (let t = 0; t < e.added.length; t++) {
                            const i = e.added[t],
                                n = _.get(i);
                            n && n.dispatchEvent({
                                type: "connected",
                                data: i
                            })
                        }
                    }
                    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                        let t = y[e];
                        return void 0 === t && (t = new ho, y[e] = t), t.getTargetRaySpace()
                    }, this.getControllerGrip = function(e) {
                        let t = y[e];
                        return void 0 === t && (t = new ho, y[e] = t), t.getGripSpace()
                    }, this.getHand = function(e) {
                        let t = y[e];
                        return void 0 === t && (t = new ho, y[e] = t), t.getHandSpace()
                    }, this.setFramebufferScaleFactor = function(e) {
                        r = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }, this.setReferenceSpaceType = function(e) {
                        a = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }, this.getReferenceSpace = function() {
                        return s
                    }, this.getBaseLayer = function() {
                        return null !== c ? c : u
                    }, this.getBinding = function() {
                        return h
                    }, this.getFrame = function() {
                        return p
                    }, this.getSession = function() {
                        return n
                    }, this.setSession = async function(l) {
                        if (n = l, null !== n) {
                            if (m = e.getRenderTarget(), n.addEventListener("select", E), n.addEventListener("selectstart", E), n.addEventListener("selectend", E), n.addEventListener("squeeze", E), n.addEventListener("squeezestart", E), n.addEventListener("squeezeend", E), n.addEventListener("end", M), n.addEventListener("inputsourceschange", C), !0 !== f.xrCompatible && await t.makeXRCompatible(), void 0 === n.renderState.layers || !1 === e.capabilities.isWebGL2) {
                                const i = {
                                    antialias: void 0 !== n.renderState.layers || f.antialias,
                                    alpha: f.alpha,
                                    depth: f.depth,
                                    stencil: f.stencil,
                                    framebufferScaleFactor: r
                                };
                                u = new XRWebGLLayer(n, t, i), n.updateRenderState({
                                    baseLayer: u
                                }), g = new ni(u.framebufferWidth, u.framebufferHeight, {
                                    format: Me,
                                    type: pe,
                                    encoding: e.outputEncoding
                                })
                            } else {
                                d = f.antialias;
                                let i = null,
                                    s = null,
                                    a = null;
                                f.depth && (a = f.stencil ? 35056 : 33190, i = f.stencil ? Ie : Le, s = f.stencil ? we : ge);
                                const l = {
                                    colorFormat: e.outputEncoding === _t ? 35907 : 32856,
                                    depthFormat: a,
                                    scaleFactor: r
                                };
                                h = new XRWebGLBinding(n, t), c = h.createProjectionLayer(l), n.updateRenderState({
                                    layers: [c]
                                }), g = d ? new ri(c.textureWidth, c.textureHeight, {
                                    format: Me,
                                    type: pe,
                                    depthTexture: new co(c.textureWidth, c.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, i),
                                    stencilBuffer: f.stencil,
                                    ignoreDepth: c.ignoreDepthValues,
                                    useRenderToTexture: o,
                                    encoding: e.outputEncoding
                                }) : new ni(c.textureWidth, c.textureHeight, {
                                    format: Me,
                                    type: pe,
                                    depthTexture: new co(c.textureWidth, c.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, i),
                                    stencilBuffer: f.stencil,
                                    ignoreDepth: c.ignoreDepthValues,
                                    encoding: e.outputEncoding
                                })
                            }
                            g.isXRRenderTarget = !0, this.setFoveation(1), s = await n.requestReferenceSpace(a), R.setContext(n), R.start(), i.isPresenting = !0, i.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    };
                    const A = new ai,
                        L = new ai;

                    function I(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.updateCamera = function(e) {
                        if (null === n) return;
                        x.near = b.near = v.near = e.near, x.far = b.far = v.far = e.far, w === x.near && S === x.far || (n.updateRenderState({
                            depthNear: x.near,
                            depthFar: x.far
                        }), w = x.near, S = x.far);
                        const t = e.parent,
                            i = x.cameras;
                        I(x, t);
                        for (let e = 0; e < i.length; e++) I(i[e], t);
                        x.matrixWorld.decompose(x.position, x.quaternion, x.scale), e.position.copy(x.position), e.quaternion.copy(x.quaternion), e.scale.copy(x.scale), e.matrix.copy(x.matrix), e.matrixWorld.copy(x.matrixWorld);
                        const r = e.children;
                        for (let e = 0, t = r.length; e < t; e++) r[e].updateMatrixWorld(!0);
                        2 === i.length ? function(e, t, i) {
                            A.setFromMatrixPosition(t.matrixWorld), L.setFromMatrixPosition(i.matrixWorld);
                            const n = A.distanceTo(L),
                                r = t.projectionMatrix.elements,
                                s = i.projectionMatrix.elements,
                                a = r[14] / (r[10] - 1),
                                o = r[14] / (r[10] + 1),
                                l = (r[9] + 1) / r[5],
                                h = (r[9] - 1) / r[5],
                                c = (r[8] - 1) / r[0],
                                u = (s[8] + 1) / s[0],
                                d = a * c,
                                p = a * u,
                                f = n / (-c + u),
                                m = f * -c;
                            t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                            const g = a + f,
                                y = o + f,
                                _ = d - m,
                                v = p + (n - m),
                                b = l * o / y * g,
                                T = h * o / y * g;
                            e.projectionMatrix.makePerspective(_, v, b, T, g, y)
                        }(x, v, b) : x.projectionMatrix.copy(v.projectionMatrix)
                    }, this.getCamera = function() {
                        return x
                    }, this.getFoveation = function() {
                        return null !== c ? c.fixedFoveation : null !== u ? u.fixedFoveation : void 0
                    }, this.setFoveation = function(e) {
                        null !== c && (c.fixedFoveation = e), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e)
                    };
                    let P = null;
                    const R = new Tr;
                    R.setAnimationLoop((function(t, i) {
                        if (l = i.getViewerPose(s), p = i, null !== l) {
                            const t = l.views;
                            null !== u && (e.setRenderTargetFramebuffer(g, u.framebuffer), e.setRenderTarget(g));
                            let i = !1;
                            t.length !== x.cameras.length && (x.cameras.length = 0, i = !0);
                            for (let n = 0; n < t.length; n++) {
                                const r = t[n];
                                let s = null;
                                if (null !== u) s = u.getViewport(r);
                                else {
                                    const t = h.getViewSubImage(c, r);
                                    s = t.viewport, 0 === n && (e.setRenderTargetTextures(g, t.colorTexture, c.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(g))
                                }
                                const a = T[n];
                                a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === n && x.matrix.copy(a.matrix), !0 === i && x.cameras.push(a)
                            }
                        }
                        const r = n.inputSources;
                        for (let e = 0; e < y.length; e++) {
                            const t = y[e],
                                n = r[e];
                            t.update(n, i, s)
                        }
                        P && P(t, i), p = null
                    })), this.setAnimationLoop = function(e) {
                        P = e
                    }, this.dispose = function() {}
                }
            }

            function po(e) {
                function t(t, i) {
                    t.opacity.value = i.opacity, i.color && t.diffuse.value.copy(i.color), i.emissive && t.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (t.map.value = i.map), i.alphaMap && (t.alphaMap.value = i.alphaMap), i.specularMap && (t.specularMap.value = i.specularMap), i.alphaTest > 0 && (t.alphaTest.value = i.alphaTest);
                    const n = e.get(i).envMap;
                    let r, s;
                    n && (t.envMap.value = n, t.flipEnvMap.value = n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = i.reflectivity, t.ior.value = i.ior, t.refractionRatio.value = i.refractionRatio), i.lightMap && (t.lightMap.value = i.lightMap, t.lightMapIntensity.value = i.lightMapIntensity), i.aoMap && (t.aoMap.value = i.aoMap, t.aoMapIntensity.value = i.aoMapIntensity), i.map ? r = i.map : i.specularMap ? r = i.specularMap : i.displacementMap ? r = i.displacementMap : i.normalMap ? r = i.normalMap : i.bumpMap ? r = i.bumpMap : i.roughnessMap ? r = i.roughnessMap : i.metalnessMap ? r = i.metalnessMap : i.alphaMap ? r = i.alphaMap : i.emissiveMap ? r = i.emissiveMap : i.clearcoatMap ? r = i.clearcoatMap : i.clearcoatNormalMap ? r = i.clearcoatNormalMap : i.clearcoatRoughnessMap ? r = i.clearcoatRoughnessMap : i.specularIntensityMap ? r = i.specularIntensityMap : i.specularColorMap ? r = i.specularColorMap : i.transmissionMap ? r = i.transmissionMap : i.thicknessMap ? r = i.thicknessMap : i.sheenColorMap ? r = i.sheenColorMap : i.sheenRoughnessMap && (r = i.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), i.aoMap ? s = i.aoMap : i.lightMap && (s = i.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), t.uv2Transform.value.copy(s.matrix))
                }

                function i(t, i) {
                    t.roughness.value = i.roughness, t.metalness.value = i.metalness, i.roughnessMap && (t.roughnessMap.value = i.roughnessMap), i.metalnessMap && (t.metalnessMap.value = i.metalnessMap), i.emissiveMap && (t.emissiveMap.value = i.emissiveMap), i.bumpMap && (t.bumpMap.value = i.bumpMap, t.bumpScale.value = i.bumpScale, i.side === u && (t.bumpScale.value *= -1)), i.normalMap && (t.normalMap.value = i.normalMap, t.normalScale.value.copy(i.normalScale), i.side === u && t.normalScale.value.negate()), i.displacementMap && (t.displacementMap.value = i.displacementMap, t.displacementScale.value = i.displacementScale, t.displacementBias.value = i.displacementBias);
                    e.get(i).envMap && (t.envMapIntensity.value = i.envMapIntensity)
                }
                return {
                    refreshFogUniforms: function(e, t) {
                        e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                    },
                    refreshMaterialUniforms: function(e, n, r, s, a) {
                        n.isMeshBasicMaterial ? t(e, n) : n.isMeshLambertMaterial ? (t(e, n), function(e, t) {
                            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                        }(e, n)) : n.isMeshToonMaterial ? (t(e, n), function(e, t) {
                            t.gradientMap && (e.gradientMap.value = t.gradientMap);
                            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === u && (e.bumpScale.value *= -1));
                            t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === u && e.normalScale.value.negate());
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, n)) : n.isMeshPhongMaterial ? (t(e, n), function(e, t) {
                            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === u && (e.bumpScale.value *= -1));
                            t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === u && e.normalScale.value.negate());
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, n)) : n.isMeshStandardMaterial ? (t(e, n), n.isMeshPhysicalMaterial ? function(e, t, n) {
                            i(e, t), e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap));
                            t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === u && e.clearcoatNormalScale.value.negate()));
                            t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = n.texture, e.transmissionSamplerSize.value.set(n.width, n.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor));
                            e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap);
                            t.specularColorMap && (e.specularColorMap.value = t.specularColorMap)
                        }(e, n, a) : i(e, n)) : n.isMeshMatcapMaterial ? (t(e, n), function(e, t) {
                            t.matcap && (e.matcap.value = t.matcap);
                            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === u && (e.bumpScale.value *= -1));
                            t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === u && e.normalScale.value.negate());
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, n)) : n.isMeshDepthMaterial ? (t(e, n), function(e, t) {
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, n)) : n.isMeshDistanceMaterial ? (t(e, n), function(e, t) {
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                            e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                        }(e, n)) : n.isMeshNormalMaterial ? (t(e, n), function(e, t) {
                            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === u && (e.bumpScale.value *= -1));
                            t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === u && e.normalScale.value.negate());
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, n)) : n.isLineBasicMaterial ? (function(e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
                        }(e, n), n.isLineDashedMaterial && function(e, t) {
                            e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                        }(e, n)) : n.isPointsMaterial ? function(e, t, i, n) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * i, e.scale.value = .5 * n, t.map && (e.map.value = t.map);
                            t.alphaMap && (e.alphaMap.value = t.alphaMap);
                            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                            let r;
                            t.map ? r = t.map : t.alphaMap && (r = t.alphaMap);
                            void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix))
                        }(e, n, r, s) : n.isSpriteMaterial ? function(e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map);
                            t.alphaMap && (e.alphaMap.value = t.alphaMap);
                            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                            let i;
                            t.map ? i = t.map : t.alphaMap && (i = t.alphaMap);
                            void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix))
                        }(e, n) : n.isShadowMaterial ? (e.color.value.copy(n.color), e.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
                    }
                }
            }

            function fo(e = {}) {
                const t = void 0 !== e.canvas ? e.canvas : function() {
                        const e = Gt("canvas");
                        return e.style.display = "block", e
                    }(),
                    i = void 0 !== e.context ? e.context : null,
                    r = void 0 !== e.alpha && e.alpha,
                    s = void 0 === e.depth || e.depth,
                    a = void 0 === e.stencil || e.stencil,
                    o = void 0 !== e.antialias && e.antialias,
                    l = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    h = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    p = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    f = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
                let m = null,
                    g = null;
                const y = [],
                    _ = [];
                this.domElement = t, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = yt, this.physicallyCorrectLights = !1, this.toneMapping = q, this.toneMappingExposure = 1;
                const v = this;
                let b = !1,
                    T = 0,
                    x = 0,
                    w = null,
                    S = -1,
                    E = null;
                const M = new ii,
                    C = new ii;
                let A = null,
                    L = t.width,
                    I = t.height,
                    P = 1,
                    R = null,
                    k = null;
                const D = new ii(0, 0, L, I),
                    O = new ii(0, 0, L, I);
                let N = !1;
                const U = new br;
                let B = !1,
                    F = !1,
                    H = null;
                const z = new Ui,
                    V = new ai,
                    G = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function W() {
                    return null === w ? P : 1
                }
                let j, $, X, Y, K, J, Z, Q, ee, te, ie, ne, re, ae, le, he, ce, ue, fe, me, ge, ye, _e, Te = i;

                function xe(e, i) {
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n],
                            s = t.getContext(r, i);
                        if (null !== s) return s
                    }
                    return null
                }
                try {
                    const e = {
                        alpha: !0,
                        depth: s,
                        stencil: a,
                        antialias: o,
                        premultipliedAlpha: l,
                        preserveDrawingBuffer: h,
                        powerPreference: p,
                        failIfMajorPerformanceCaveat: f
                    };
                    if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${n}`), t.addEventListener("webglcontextlost", Ee, !1), t.addEventListener("webglcontextrestored", Ce, !1), null === Te) {
                        const t = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === v.isWebGL1Renderer && t.shift(), Te = xe(t, e), null === Te) throw xe(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    void 0 === Te.getShaderPrecisionFormat && (Te.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (e) {
                    throw console.error("THREE.WebGLRenderer: " + e.message), e
                }

                function we() {
                    j = new rs(Te), $ = new Ir(Te, j, e), j.init($), ye = new so(Te, j, $), X = new no(Te, j, $), Y = new os(Te), K = new za, J = new ro(Te, j, X, K, $, ye, Y), Z = new Rr(v), Q = new ns(v), ee = new xr(Te, $), _e = new Ar(Te, j, ee, $), te = new ss(Te, ee, Y, _e), ie = new ps(Te, te, ee, Y), fe = new ds(Te, $, J), he = new Pr(K), ne = new Ha(v, Z, Q, j, $, _e, he), re = new po(K), ae = new ja, le = new Ja(j, $), ue = new Cr(v, Z, X, ie, r, l), ce = new io(v, ie, $), me = new Lr(Te, j, Y, $), ge = new as(Te, j, Y, $), Y.programs = ne.programs, v.capabilities = $, v.extensions = j, v.properties = K, v.renderLists = ae, v.shadowMap = ce, v.state = X, v.info = Y
                }
                we();
                const Se = new uo(v, Te);

                function Ee(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = !0
                }

                function Ce() {
                    console.log("THREE.WebGLRenderer: Context Restored."), b = !1;
                    const e = Y.autoReset,
                        t = ce.enabled,
                        i = ce.autoUpdate,
                        n = ce.needsUpdate,
                        r = ce.type;
                    we(), Y.autoReset = e, ce.enabled = t, ce.autoUpdate = i, ce.needsUpdate = n, ce.type = r
                }

                function Ae(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", Ae),
                        function(e) {
                            (function(e) {
                                const t = K.get(e).programs;
                                void 0 !== t && (t.forEach((function(e) {
                                    ne.releaseProgram(e)
                                })), e.isShaderMaterial && ne.releaseShaderCache(e))
                            })(e), K.remove(e)
                        }(t)
                }
                this.xr = Se, this.getContext = function() {
                    return Te
                }, this.getContextAttributes = function() {
                    return Te.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const e = j.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    const e = j.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() {
                    return P
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (P = e, this.setSize(L, I, !1))
                }, this.getSize = function(e) {
                    return e.set(L, I)
                }, this.setSize = function(e, i, n) {
                    Se.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (L = e, I = i, t.width = Math.floor(e * P), t.height = Math.floor(i * P), !1 !== n && (t.style.width = e + "px", t.style.height = i + "px"), this.setViewport(0, 0, e, i))
                }, this.getDrawingBufferSize = function(e) {
                    return e.set(L * P, I * P).floor()
                }, this.setDrawingBufferSize = function(e, i, n) {
                    L = e, I = i, P = n, t.width = Math.floor(e * n), t.height = Math.floor(i * n), this.setViewport(0, 0, e, i)
                }, this.getCurrentViewport = function(e) {
                    return e.copy(M)
                }, this.getViewport = function(e) {
                    return e.copy(D)
                }, this.setViewport = function(e, t, i, n) {
                    e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, i, n), X.viewport(M.copy(D).multiplyScalar(P).floor())
                }, this.getScissor = function(e) {
                    return e.copy(O)
                }, this.setScissor = function(e, t, i, n) {
                    e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, i, n), X.scissor(C.copy(O).multiplyScalar(P).floor())
                }, this.getScissorTest = function() {
                    return N
                }, this.setScissorTest = function(e) {
                    X.setScissorTest(N = e)
                }, this.setOpaqueSort = function(e) {
                    R = e
                }, this.setTransparentSort = function(e) {
                    k = e
                }, this.getClearColor = function(e) {
                    return e.copy(ue.getClearColor())
                }, this.setClearColor = function() {
                    ue.setClearColor.apply(ue, arguments)
                }, this.getClearAlpha = function() {
                    return ue.getClearAlpha()
                }, this.setClearAlpha = function() {
                    ue.setClearAlpha.apply(ue, arguments)
                }, this.clear = function(e, t, i) {
                    let n = 0;
                    (void 0 === e || e) && (n |= 16384), (void 0 === t || t) && (n |= 256), (void 0 === i || i) && (n |= 1024), Te.clear(n)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    t.removeEventListener("webglcontextlost", Ee, !1), t.removeEventListener("webglcontextrestored", Ce, !1), ae.dispose(), le.dispose(), K.dispose(), Z.dispose(), Q.dispose(), ie.dispose(), _e.dispose(), ne.dispose(), Se.dispose(), Se.removeEventListener("sessionstart", Ie), Se.removeEventListener("sessionend", Pe), H && (H.dispose(), H = null), Re.stop()
                }, this.renderBufferDirect = function(e, t, i, n, r, s) {
                    null === t && (t = G);
                    const a = r.isMesh && r.matrixWorld.determinant() < 0,
                        o = function(e, t, i, n, r) {
                            !0 !== t.isScene && (t = G);
                            J.resetTextureUnits();
                            const s = t.fog,
                                a = n.isMeshStandardMaterial ? t.environment : null,
                                o = null === w ? v.outputEncoding : !0 === w.isXRRenderTarget ? w.texture.encoding : yt,
                                l = (n.isMeshStandardMaterial ? Q : Z).get(n.envMap || a),
                                h = !0 === n.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize,
                                c = !!n.normalMap && !!i.attributes.tangent,
                                u = !!i.morphAttributes.position,
                                d = !!i.morphAttributes.normal,
                                p = i.morphAttributes.position ? i.morphAttributes.position.length : 0,
                                f = n.toneMapped ? v.toneMapping : q,
                                m = K.get(n),
                                y = g.state.lights;
                            if (!0 === B && (!0 === F || e !== E)) {
                                const t = e === E && n.id === S;
                                he.setState(n, e, t)
                            }
                            let _ = !1;
                            n.version === m.__version ? m.needsLights && m.lightsStateVersion !== y.state.version || m.outputEncoding !== o || r.isInstancedMesh && !1 === m.instancing ? _ = !0 : r.isInstancedMesh || !0 !== m.instancing ? r.isSkinnedMesh && !1 === m.skinning ? _ = !0 : r.isSkinnedMesh || !0 !== m.skinning ? m.envMap !== l || n.fog && m.fog !== s ? _ = !0 : void 0 === m.numClippingPlanes || m.numClippingPlanes === he.numPlanes && m.numIntersection === he.numIntersection ? (m.vertexAlphas !== h || m.vertexTangents !== c || m.morphTargets !== u || m.morphNormals !== d || m.toneMapping !== f || !0 === $.isWebGL2 && m.morphTargetsCount !== p) && (_ = !0) : _ = !0 : _ = !0 : _ = !0 : (_ = !0, m.__version = n.version);
                            let b = m.currentProgram;
                            !0 === _ && (b = Ue(n, t, r));
                            let T = !1,
                                x = !1,
                                M = !1;
                            const C = b.getUniforms(),
                                A = m.uniforms;
                            X.useProgram(b.program) && (T = !0, x = !0, M = !0);
                            n.id !== S && (S = n.id, x = !0);
                            if (T || E !== e) {
                                if (C.setValue(Te, "projectionMatrix", e.projectionMatrix), $.logarithmicDepthBuffer && C.setValue(Te, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), E !== e && (E = e, x = !0, M = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                                    const t = C.map.cameraPosition;
                                    void 0 !== t && t.setValue(Te, V.setFromMatrixPosition(e.matrixWorld))
                                }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && C.setValue(Te, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || r.isSkinnedMesh) && C.setValue(Te, "viewMatrix", e.matrixWorldInverse)
                            }
                            if (r.isSkinnedMesh) {
                                C.setOptional(Te, r, "bindMatrix"), C.setOptional(Te, r, "bindMatrixInverse");
                                const e = r.skeleton;
                                e && ($.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), C.setValue(Te, "boneTexture", e.boneTexture, J), C.setValue(Te, "boneTextureSize", e.boneTextureSize)) : C.setOptional(Te, e, "boneMatrices"))
                            }!i || void 0 === i.morphAttributes.position && void 0 === i.morphAttributes.normal || fe.update(r, i, n, b);
                            (x || m.receiveShadow !== r.receiveShadow) && (m.receiveShadow = r.receiveShadow, C.setValue(Te, "receiveShadow", r.receiveShadow));
                            x && (C.setValue(Te, "toneMappingExposure", v.toneMappingExposure), m.needsLights && (R = M, (L = A).ambientLightColor.needsUpdate = R, L.lightProbe.needsUpdate = R, L.directionalLights.needsUpdate = R, L.directionalLightShadows.needsUpdate = R, L.pointLights.needsUpdate = R, L.pointLightShadows.needsUpdate = R, L.spotLights.needsUpdate = R, L.spotLightShadows.needsUpdate = R, L.rectAreaLights.needsUpdate = R, L.hemisphereLights.needsUpdate = R), s && n.fog && re.refreshFogUniforms(A, s), re.refreshMaterialUniforms(A, n, P, I, H), _a.upload(Te, m.uniformsList, A, J));
                            var L, R;
                            n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (_a.upload(Te, m.uniformsList, A, J), n.uniformsNeedUpdate = !1);
                            n.isSpriteMaterial && C.setValue(Te, "center", r.center);
                            return C.setValue(Te, "modelViewMatrix", r.modelViewMatrix), C.setValue(Te, "normalMatrix", r.normalMatrix), C.setValue(Te, "modelMatrix", r.matrixWorld), b
                        }(e, t, i, n, r);
                    X.setMaterial(n, a);
                    let l = i.index;
                    const h = i.attributes.position;
                    if (null === l) {
                        if (void 0 === h || 0 === h.count) return
                    } else if (0 === l.count) return;
                    let c, u = 1;
                    !0 === n.wireframe && (l = te.getWireframeAttribute(i), u = 2), _e.setup(r, n, o, i, l);
                    let d = me;
                    null !== l && (c = ee.get(l), d = ge, d.setIndex(c));
                    const p = null !== l ? l.count : h.count,
                        f = i.drawRange.start * u,
                        m = i.drawRange.count * u,
                        y = null !== s ? s.start * u : 0,
                        _ = null !== s ? s.count * u : 1 / 0,
                        b = Math.max(f, y),
                        T = Math.min(p, f + m, y + _) - 1,
                        x = Math.max(0, T - b + 1);
                    if (0 !== x) {
                        if (r.isMesh) !0 === n.wireframe ? (X.setLineWidth(n.wireframeLinewidth * W()), d.setMode(1)) : d.setMode(4);
                        else if (r.isLine) {
                            let e = n.linewidth;
                            void 0 === e && (e = 1), X.setLineWidth(e * W()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                        } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                        if (r.isInstancedMesh) d.renderInstances(b, x, r.count);
                        else if (i.isInstancedBufferGeometry) {
                            const e = Math.min(i.instanceCount, i._maxInstanceCount);
                            d.renderInstances(b, x, e)
                        } else d.render(b, x)
                    }
                }, this.compile = function(e, t) {
                    g = le.get(e), g.init(), _.push(g), e.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (g.pushLight(e), e.castShadow && g.pushShadow(e))
                    })), g.setupLights(v.physicallyCorrectLights), e.traverse((function(t) {
                        const i = t.material;
                        if (i)
                            if (Array.isArray(i))
                                for (let n = 0; n < i.length; n++) {
                                    Ue(i[n], e, t)
                                } else Ue(i, e, t)
                    })), _.pop(), g = null
                };
                let Le = null;

                function Ie() {
                    Re.stop()
                }

                function Pe() {
                    Re.start()
                }
                const Re = new Tr;

                function ke(e, t, i, n) {
                    if (!1 === e.visible) return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup) i = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                    else if (e.isLight) g.pushLight(e), e.castShadow && g.pushShadow(e);
                    else if (e.isSprite) {
                        if (!e.frustumCulled || U.intersectsSprite(e)) {
                            n && V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
                            const t = ie.update(e),
                                r = e.material;
                            r.visible && m.push(e, t, r, i, V.z, null)
                        }
                    } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== Y.render.frame && (e.skeleton.update(), e.skeleton.frame = Y.render.frame), !e.frustumCulled || U.intersectsObject(e))) {
                        n && V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
                        const t = ie.update(e),
                            r = e.material;
                        if (Array.isArray(r)) {
                            const n = t.groups;
                            for (let s = 0, a = n.length; s < a; s++) {
                                const a = n[s],
                                    o = r[a.materialIndex];
                                o && o.visible && m.push(e, t, o, i, V.z, a)
                            }
                        } else r.visible && m.push(e, t, r, i, V.z, null)
                    }
                    const r = e.children;
                    for (let e = 0, s = r.length; e < s; e++) ke(r[e], t, i, n)
                }

                function De(e, t, i, n) {
                    const r = e.opaque,
                        s = e.transmissive,
                        a = e.transparent;
                    g.setupLightsView(i), s.length > 0 && function(e, t, i) {
                        if (null === H) {
                            const e = !0 === o && !0 === $.isWebGL2;
                            H = new(e ? ri : ni)(1024, 1024, {
                                generateMipmaps: !0,
                                type: null !== ye.convert(be) ? be : pe,
                                minFilter: de,
                                magFilter: oe,
                                wrapS: se,
                                wrapT: se,
                                useRenderToTexture: j.has("WEBGL_multisampled_render_to_texture")
                            })
                        }
                        const n = v.getRenderTarget();
                        v.setRenderTarget(H), v.clear();
                        const r = v.toneMapping;
                        v.toneMapping = q, Oe(e, t, i), v.toneMapping = r, J.updateMultisampleRenderTarget(H), J.updateRenderTargetMipmap(H), v.setRenderTarget(n)
                    }(r, t, i), n && X.viewport(M.copy(n)), r.length > 0 && Oe(r, t, i), s.length > 0 && Oe(s, t, i), a.length > 0 && Oe(a, t, i)
                }

                function Oe(e, t, i) {
                    const n = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, s = e.length; r < s; r++) {
                        const s = e[r],
                            a = s.object,
                            o = s.geometry,
                            l = null === n ? s.material : n,
                            h = s.group;
                        a.layers.test(i.layers) && Ne(a, t, i, o, l, h)
                    }
                }

                function Ne(e, t, i, n, r, s) {
                    e.onBeforeRender(v, t, i, n, r, s), e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(v, t, i, n, e, s), !0 === r.transparent && r.side === d ? (r.side = u, r.needsUpdate = !0, v.renderBufferDirect(i, t, n, r, e, s), r.side = c, r.needsUpdate = !0, v.renderBufferDirect(i, t, n, r, e, s), r.side = d) : v.renderBufferDirect(i, t, n, r, e, s), e.onAfterRender(v, t, i, n, r, s)
                }

                function Ue(e, t, i) {
                    !0 !== t.isScene && (t = G);
                    const n = K.get(e),
                        r = g.state.lights,
                        s = g.state.shadowsArray,
                        a = r.state.version,
                        o = ne.getParameters(e, r.state, s, t, i),
                        l = ne.getProgramCacheKey(o);
                    let h = n.programs;
                    n.environment = e.isMeshStandardMaterial ? t.environment : null, n.fog = t.fog, n.envMap = (e.isMeshStandardMaterial ? Q : Z).get(e.envMap || n.environment), void 0 === h && (e.addEventListener("dispose", Ae), h = new Map, n.programs = h);
                    let c = h.get(l);
                    if (void 0 !== c) {
                        if (n.currentProgram === c && n.lightsStateVersion === a) return Be(e, o), c
                    } else o.uniforms = ne.getUniforms(e), e.onBuild(i, o, v), e.onBeforeCompile(o, v), c = ne.acquireProgram(o, l), h.set(l, c), n.uniforms = o.uniforms;
                    const u = n.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = he.uniform), Be(e, o), n.needsLights = function(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e), n.lightsStateVersion = a, n.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    const d = c.getUniforms(),
                        p = _a.seqWithValue(d.seq, u);
                    return n.currentProgram = c, n.uniformsList = p, c
                }

                function Be(e, t) {
                    const i = K.get(e);
                    i.outputEncoding = t.outputEncoding, i.instancing = t.instancing, i.skinning = t.skinning, i.morphTargets = t.morphTargets, i.morphNormals = t.morphNormals, i.morphTargetsCount = t.morphTargetsCount, i.numClippingPlanes = t.numClippingPlanes, i.numIntersection = t.numClipIntersection, i.vertexAlphas = t.vertexAlphas, i.vertexTangents = t.vertexTangents, i.toneMapping = t.toneMapping
                }
                Re.setAnimationLoop((function(e) {
                    Le && Le(e)
                })), "undefined" != typeof window && Re.setContext(window), this.setAnimationLoop = function(e) {
                    Le = e, Se.setAnimationLoop(e), null === e ? Re.stop() : Re.start()
                }, Se.addEventListener("sessionstart", Ie), Se.addEventListener("sessionend", Pe), this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === b) return;
                    !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === Se.enabled && !0 === Se.isPresenting && (!0 === Se.cameraAutoUpdate && Se.updateCamera(t), t = Se.getCamera()), !0 === e.isScene && e.onBeforeRender(v, e, t, w), g = le.get(e, _.length), g.init(), _.push(g), z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), U.setFromProjectionMatrix(z), F = this.localClippingEnabled, B = he.init(this.clippingPlanes, F, t), m = ae.get(e, y.length), m.init(), y.push(m), ke(e, t, 0, v.sortObjects), m.finish(), !0 === v.sortObjects && m.sort(R, k), !0 === B && he.beginShadows();
                    const i = g.state.shadowsArray;
                    if (ce.render(i, e, t), !0 === B && he.endShadows(), !0 === this.info.autoReset && this.info.reset(), ue.render(m, e), g.setupLights(v.physicallyCorrectLights), t.isArrayCamera) {
                        const i = t.cameras;
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            De(m, e, n, n.viewport)
                        }
                    } else De(m, e, t);
                    null !== w && (J.updateMultisampleRenderTarget(w), J.updateRenderTargetMipmap(w)), !0 === e.isScene && e.onAfterRender(v, e, t), X.buffers.depth.setTest(!0), X.buffers.depth.setMask(!0), X.buffers.color.setMask(!0), X.setPolygonOffset(!1), _e.resetDefaultState(), S = -1, E = null, _.pop(), g = _.length > 0 ? _[_.length - 1] : null, y.pop(), m = y.length > 0 ? y[y.length - 1] : null
                }, this.getActiveCubeFace = function() {
                    return T
                }, this.getActiveMipmapLevel = function() {
                    return x
                }, this.getRenderTarget = function() {
                    return w
                }, this.setRenderTargetTextures = function(e, t, i) {
                    K.get(e.texture).__webglTexture = t, K.get(e.depthTexture).__webglTexture = i;
                    const n = K.get(e);
                    n.__hasExternalTextures = !0, n.__hasExternalTextures && (n.__autoAllocateDepthBuffer = void 0 === i, n.__autoAllocateDepthBuffer || e.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), e.useRenderToTexture = !1, e.useRenderbuffer = !0))
                }, this.setRenderTargetFramebuffer = function(e, t) {
                    const i = K.get(e);
                    i.__webglFramebuffer = t, i.__useDefaultFramebuffer = void 0 === t
                }, this.setRenderTarget = function(e, t = 0, i = 0) {
                    w = e, T = t, x = i;
                    let n = !0;
                    if (e) {
                        const t = K.get(e);
                        void 0 !== t.__useDefaultFramebuffer ? (X.bindFramebuffer(36160, null), n = !1) : void 0 === t.__webglFramebuffer ? J.setupRenderTarget(e) : t.__hasExternalTextures && J.rebindTextures(e, K.get(e.texture).__webglTexture, K.get(e.depthTexture).__webglTexture)
                    }
                    let r = null,
                        s = !1,
                        a = !1;
                    if (e) {
                        const i = e.texture;
                        (i.isDataTexture3D || i.isDataTexture2DArray) && (a = !0);
                        const n = K.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (r = n[t], s = !0) : r = e.useRenderbuffer ? K.get(e).__webglMultisampledFramebuffer : n, M.copy(e.viewport), C.copy(e.scissor), A = e.scissorTest
                    } else M.copy(D).multiplyScalar(P).floor(), C.copy(O).multiplyScalar(P).floor(), A = N;
                    if (X.bindFramebuffer(36160, r) && $.drawBuffers && n && X.drawBuffers(e, r), X.viewport(M), X.scissor(C), X.setScissorTest(A), s) {
                        const n = K.get(e.texture);
                        Te.framebufferTexture2D(36160, 36064, 34069 + t, n.__webglTexture, i)
                    } else if (a) {
                        const n = K.get(e.texture),
                            r = t || 0;
                        Te.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, r)
                    }
                    S = -1
                }, this.readRenderTargetPixels = function(e, t, i, n, r, s, a) {
                    if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let o = K.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
                        X.bindFramebuffer(36160, o);
                        try {
                            const a = e.texture,
                                o = a.format,
                                l = a.type;
                            if (o !== Me && ye.convert(o) !== Te.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const h = l === be && (j.has("EXT_color_buffer_half_float") || $.isWebGL2 && j.has("EXT_color_buffer_float"));
                            if (!(l === pe || ye.convert(l) === Te.getParameter(35738) || l === ve && ($.isWebGL2 || j.has("OES_texture_float") || j.has("WEBGL_color_buffer_float")) || h)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === Te.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - r && Te.readPixels(t, i, n, r, ye.convert(o), ye.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            const e = null !== w ? K.get(w).__webglFramebuffer : null;
                            X.bindFramebuffer(36160, e)
                        }
                    }
                }, this.copyFramebufferToTexture = function(e, t, i = 0) {
                    if (!0 !== t.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
                    const n = Math.pow(2, -i),
                        r = Math.floor(t.image.width * n),
                        s = Math.floor(t.image.height * n);
                    J.setTexture2D(t, 0), Te.copyTexSubImage2D(3553, i, 0, 0, e.x, e.y, r, s), X.unbindTexture()
                }, this.copyTextureToTexture = function(e, t, i, n = 0) {
                    const r = t.image.width,
                        s = t.image.height,
                        a = ye.convert(i.format),
                        o = ye.convert(i.type);
                    J.setTexture2D(i, 0), Te.pixelStorei(37440, i.flipY), Te.pixelStorei(37441, i.premultiplyAlpha), Te.pixelStorei(3317, i.unpackAlignment), t.isDataTexture ? Te.texSubImage2D(3553, n, e.x, e.y, r, s, a, o, t.image.data) : t.isCompressedTexture ? Te.compressedTexSubImage2D(3553, n, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : Te.texSubImage2D(3553, n, e.x, e.y, a, o, t.image), 0 === n && i.generateMipmaps && Te.generateMipmap(3553), X.unbindTexture()
                }, this.copyTextureToTexture3D = function(e, t, i, n, r = 0) {
                    if (v.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const s = e.max.x - e.min.x + 1,
                        a = e.max.y - e.min.y + 1,
                        o = e.max.z - e.min.z + 1,
                        l = ye.convert(n.format),
                        h = ye.convert(n.type);
                    let c;
                    if (n.isDataTexture3D) J.setTexture3D(n, 0), c = 32879;
                    else {
                        if (!n.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        J.setTexture2DArray(n, 0), c = 35866
                    }
                    Te.pixelStorei(37440, n.flipY), Te.pixelStorei(37441, n.premultiplyAlpha), Te.pixelStorei(3317, n.unpackAlignment);
                    const u = Te.getParameter(3314),
                        d = Te.getParameter(32878),
                        p = Te.getParameter(3316),
                        f = Te.getParameter(3315),
                        m = Te.getParameter(32877),
                        g = i.isCompressedTexture ? i.mipmaps[0] : i.image;
                    Te.pixelStorei(3314, g.width), Te.pixelStorei(32878, g.height), Te.pixelStorei(3316, e.min.x), Te.pixelStorei(3315, e.min.y), Te.pixelStorei(32877, e.min.z), i.isDataTexture || i.isDataTexture3D ? Te.texSubImage3D(c, r, t.x, t.y, t.z, s, a, o, l, h, g.data) : i.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Te.compressedTexSubImage3D(c, r, t.x, t.y, t.z, s, a, o, l, g.data)) : Te.texSubImage3D(c, r, t.x, t.y, t.z, s, a, o, l, h, g), Te.pixelStorei(3314, u), Te.pixelStorei(32878, d), Te.pixelStorei(3316, p), Te.pixelStorei(3315, f), Te.pixelStorei(32877, m), 0 === r && n.generateMipmaps && Te.generateMipmap(c), X.unbindTexture()
                }, this.initTexture = function(e) {
                    J.setTexture2D(e, 0), X.unbindTexture()
                }, this.resetState = function() {
                    T = 0, x = 0, w = null, X.reset(), _e.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            fo.prototype.isWebGLRenderer = !0;
            (class extends fo {}).prototype.isWebGL1Renderer = !0;
            class mo {
                constructor(e, t = 25e-5) {
                    this.name = "", this.color = new Kt(e), this.density = t
                }
                clone() {
                    return new mo(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            mo.prototype.isFogExp2 = !0;
            class go {
                constructor(e, t = 1, i = 1e3) {
                    this.name = "", this.color = new Kt(e), this.near = t, this.far = i
                }
                clone() {
                    return new go(this.color, this.near, this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            go.prototype.isFog = !0;
            class yo extends hn {
                constructor() {
                    super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(e, t) {
                    return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.fog && (t.object.fog = this.fog.toJSON()), t
                }
            }
            yo.prototype.isScene = !0;
            class _o {
                constructor(e, t) {
                    this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = wt, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0, this.uuid = Rt()
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                }
                copyAt(e, t, i) {
                    e *= this.stride, i *= t.stride;
                    for (let n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                clone(e) {
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Rt()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                        i = new this.constructor(t, this.stride);
                    return i.setUsage(this.usage), i
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                toJSON(e) {
                    return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Rt()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            _o.prototype.isInterleavedBuffer = !0;
            const vo = new ai;
            class bo {
                constructor(e, t, i, n = !1) {
                    this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === n
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(e) {
                    this.data.needsUpdate = e
                }
                applyMatrix4(e) {
                    for (let t = 0, i = this.data.count; t < i; t++) vo.x = this.getX(t), vo.y = this.getY(t), vo.z = this.getZ(t), vo.applyMatrix4(e), this.setXYZ(t, vo.x, vo.y, vo.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, i = this.count; t < i; t++) vo.x = this.getX(t), vo.y = this.getY(t), vo.z = this.getZ(t), vo.applyNormalMatrix(e), this.setXYZ(t, vo.x, vo.y, vo.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, i = this.count; t < i; t++) vo.x = this.getX(t), vo.y = this.getY(t), vo.z = this.getZ(t), vo.transformDirection(e), this.setXYZ(t, vo.x, vo.y, vo.z);
                    return this
                }
                setX(e, t) {
                    return this.data.array[e * this.data.stride + this.offset] = t, this
                }
                setY(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                }
                setZ(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                }
                setW(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                }
                getX(e) {
                    return this.data.array[e * this.data.stride + this.offset]
                }
                getY(e) {
                    return this.data.array[e * this.data.stride + this.offset + 1]
                }
                getZ(e) {
                    return this.data.array[e * this.data.stride + this.offset + 2]
                }
                getW(e) {
                    return this.data.array[e * this.data.stride + this.offset + 3]
                }
                setXY(e, t, i) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
                }
                setXYZ(e, t, i, n) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this
                }
                setXYZW(e, t, i, n, r) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this
                }
                clone(e) {
                    if (void 0 === e) {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const i = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[i + t])
                        }
                        return new Mn(new this.array.constructor(e), this.itemSize, this.normalized)
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new bo(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                }
                toJSON(e) {
                    if (void 0 === e) {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const i = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[i + t])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: e,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }
            bo.prototype.isInterleavedBufferAttribute = !0;
            class To extends xn {
                constructor(e) {
                    super(), this.type = "SpriteMaterial", this.color = new Kt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
                }
            }
            let xo;
            To.prototype.isSpriteMaterial = !0;
            const wo = new ai,
                So = new ai,
                Eo = new ai,
                Mo = new Ht,
                Co = new Ht,
                Ao = new Ui,
                Lo = new ai,
                Io = new ai,
                Po = new ai,
                Ro = new Ht,
                ko = new Ht,
                Do = new Ht;
            class Oo extends hn {
                constructor(e) {
                    if (super(), this.type = "Sprite", void 0 === xo) {
                        xo = new Un;
                        const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                            t = new _o(e, 5);
                        xo.setIndex([0, 1, 2, 0, 2, 3]), xo.setAttribute("position", new bo(t, 3, 0, !1)), xo.setAttribute("uv", new bo(t, 2, 3, !1))
                    }
                    this.geometry = xo, this.material = void 0 !== e ? e : new To, this.center = new Ht(.5, .5)
                }
                raycast(e, t) {
                    null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), So.setFromMatrixScale(this.matrixWorld), Ao.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Eo.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && So.multiplyScalar(-Eo.z);
                    const i = this.material.rotation;
                    let n, r;
                    0 !== i && (r = Math.cos(i), n = Math.sin(i));
                    const s = this.center;
                    No(Lo.set(-.5, -.5, 0), Eo, s, So, n, r), No(Io.set(.5, -.5, 0), Eo, s, So, n, r), No(Po.set(.5, .5, 0), Eo, s, So, n, r), Ro.set(0, 0), ko.set(1, 0), Do.set(1, 1);
                    let a = e.ray.intersectTriangle(Lo, Io, Po, !1, wo);
                    if (null === a && (No(Io.set(-.5, .5, 0), Eo, s, So, n, r), ko.set(0, 1), a = e.ray.intersectTriangle(Lo, Po, Io, !1, wo), null === a)) return;
                    const o = e.ray.origin.distanceTo(wo);
                    o < e.near || o > e.far || t.push({
                        distance: o,
                        point: wo.clone(),
                        uv: bn.getUV(wo, Lo, Io, Po, Ro, ko, Do, new Ht),
                        face: null,
                        object: this
                    })
                }
                copy(e) {
                    return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
                }
            }

            function No(e, t, i, n, r, s) {
                Mo.subVectors(e, i).addScalar(.5).multiply(n), void 0 !== r ? (Co.x = s * Mo.x - r * Mo.y, Co.y = r * Mo.x + s * Mo.y) : Co.copy(Mo), e.copy(t), e.x += Co.x, e.y += Co.y, e.applyMatrix4(Ao)
            }
            Oo.prototype.isSprite = !0;
            const Uo = new ai,
                Bo = new ii,
                Fo = new ii,
                Ho = new ai,
                zo = new Ui;
            class Vo extends tr {
                constructor(e, t) {
                    super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ui, this.bindMatrixInverse = new Ui
                }
                copy(e) {
                    return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
                }
                bind(e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    const e = new ii,
                        t = this.geometry.attributes.skinWeight;
                    for (let i = 0, n = t.count; i < n; i++) {
                        e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.w = t.getW(i);
                        const n = 1 / e.manhattanLength();
                        n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
                    }
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                boneTransform(e, t) {
                    const i = this.skeleton,
                        n = this.geometry;
                    Bo.fromBufferAttribute(n.attributes.skinIndex, e), Fo.fromBufferAttribute(n.attributes.skinWeight, e), Uo.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                    for (let e = 0; e < 4; e++) {
                        const n = Fo.getComponent(e);
                        if (0 !== n) {
                            const r = Bo.getComponent(e);
                            zo.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]), t.addScaledVector(Ho.copy(Uo).applyMatrix4(zo), n)
                        }
                    }
                    return t.applyMatrix4(this.bindMatrixInverse)
                }
            }
            Vo.prototype.isSkinnedMesh = !0;
            class Go extends hn {
                constructor() {
                    super(), this.type = "Bone"
                }
            }
            Go.prototype.isBone = !0;
            class Wo extends ei {
                constructor(e = null, t = 1, i = 1, n, r, s, a, o, l = oe, h = oe, c, u) {
                    super(null, s, a, o, l, h, n, r, c, u), this.image = {
                        data: e,
                        width: t,
                        height: i
                    }, this.magFilter = l, this.minFilter = h, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            Wo.prototype.isDataTexture = !0;
            const jo = new Ui,
                qo = new Ui;
            class $o {
                constructor(e = [], t = []) {
                    this.uuid = Rt(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                }
                init() {
                    const e = this.bones,
                        t = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                    else if (e.length !== t.length) {
                        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                        for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new Ui)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = new Ui;
                        this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
                    }
                }
                pose() {
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                    }
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                    }
                }
                update() {
                    const e = this.bones,
                        t = this.boneInverses,
                        i = this.boneMatrices,
                        n = this.boneTexture;
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = e[n] ? e[n].matrixWorld : qo;
                        jo.multiplyMatrices(r, t[n]), jo.toArray(i, 16 * n)
                    }
                    null !== n && (n.needsUpdate = !0)
                }
                clone() {
                    return new $o(this.bones, this.boneInverses)
                }
                computeBoneTexture() {
                    let e = Math.sqrt(4 * this.bones.length);
                    e = Ut(e), e = Math.max(e, 4);
                    const t = new Float32Array(e * e * 4);
                    t.set(this.boneMatrices);
                    const i = new Wo(t, e, e, Me, ve);
                    return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this
                }
                getBoneByName(e) {
                    for (let t = 0, i = this.bones.length; t < i; t++) {
                        const i = this.bones[t];
                        if (i.name === e) return i
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                }
                fromJSON(e, t) {
                    this.uuid = e.uuid;
                    for (let i = 0, n = e.bones.length; i < n; i++) {
                        const n = e.bones[i];
                        let r = t[n];
                        void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", n), r = new Go), this.bones.push(r), this.boneInverses.push((new Ui).fromArray(e.boneInverses[i]))
                    }
                    return this.init(), this
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    e.uuid = this.uuid;
                    const t = this.bones,
                        i = this.boneInverses;
                    for (let n = 0, r = t.length; n < r; n++) {
                        const r = t[n];
                        e.bones.push(r.uuid);
                        const s = i[n];
                        e.boneInverses.push(s.toArray())
                    }
                    return e
                }
            }
            class Xo extends Mn {
                constructor(e, t, i, n = 1) {
                    "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, i), this.meshPerAttribute = n
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                }
            }
            Xo.prototype.isInstancedBufferAttribute = !0;
            const Yo = new Ui,
                Ko = new Ui,
                Jo = [],
                Zo = new tr;
            class Qo extends tr {
                constructor(e, t, i) {
                    super(e, t), this.instanceMatrix = new Xo(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1
                }
                copy(e) {
                    return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
                }
                getColorAt(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                }
                getMatrixAt(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                }
                raycast(e, t) {
                    const i = this.matrixWorld,
                        n = this.count;
                    if (Zo.geometry = this.geometry, Zo.material = this.material, void 0 !== Zo.material)
                        for (let r = 0; r < n; r++) {
                            this.getMatrixAt(r, Yo), Ko.multiplyMatrices(i, Yo), Zo.matrixWorld = Ko, Zo.raycast(e, Jo);
                            for (let e = 0, i = Jo.length; e < i; e++) {
                                const i = Jo[e];
                                i.instanceId = r, i.object = this, t.push(i)
                            }
                            Jo.length = 0
                        }
                }
                setColorAt(e, t) {
                    null === this.instanceColor && (this.instanceColor = new Xo(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
                }
                setMatrixAt(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            Qo.prototype.isInstancedMesh = !0;
            class el extends xn {
                constructor(e) {
                    super(), this.type = "LineBasicMaterial", this.color = new Kt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
                }
            }
            el.prototype.isLineBasicMaterial = !0;
            const tl = new ai,
                il = new ai,
                nl = new Ui,
                rl = new Ni,
                sl = new Ai;
            class al extends hn {
                constructor(e = new Un, t = new el) {
                    super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e) {
                    return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (e.isBufferGeometry)
                        if (null === e.index) {
                            const t = e.attributes.position,
                                i = [0];
                            for (let e = 1, n = t.count; e < n; e++) tl.fromBufferAttribute(t, e - 1), il.fromBufferAttribute(t, e), i[e] = i[e - 1], i[e] += tl.distanceTo(il);
                            e.setAttribute("lineDistance", new Ln(i, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                }
                raycast(e, t) {
                    const i = this.geometry,
                        n = this.matrixWorld,
                        r = e.params.Line.threshold,
                        s = i.drawRange;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), sl.copy(i.boundingSphere), sl.applyMatrix4(n), sl.radius += r, !1 === e.ray.intersectsSphere(sl)) return;
                    nl.copy(n).invert(), rl.copy(e.ray).applyMatrix4(nl);
                    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        l = new ai,
                        h = new ai,
                        c = new ai,
                        u = new ai,
                        d = this.isLineSegments ? 2 : 1;
                    if (i.isBufferGeometry) {
                        const n = i.index,
                            r = i.attributes.position;
                        if (null !== n) {
                            for (let i = Math.max(0, s.start), a = Math.min(n.count, s.start + s.count) - 1; i < a; i += d) {
                                const s = n.getX(i),
                                    a = n.getX(i + 1);
                                l.fromBufferAttribute(r, s), h.fromBufferAttribute(r, a);
                                if (rl.distanceSqToSegment(l, h, u, c) > o) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const d = e.ray.origin.distanceTo(u);
                                d < e.near || d > e.far || t.push({
                                    distance: d,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else {
                            for (let i = Math.max(0, s.start), n = Math.min(r.count, s.start + s.count) - 1; i < n; i += d) {
                                l.fromBufferAttribute(r, i), h.fromBufferAttribute(r, i + 1);
                                if (rl.distanceSqToSegment(l, h, u, c) > o) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const n = e.ray.origin.distanceTo(u);
                                n < e.near || n > e.far || t.push({
                                    distance: n,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    } else i.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
                updateMorphTargets() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        const t = e.morphAttributes,
                            i = Object.keys(t);
                        if (i.length > 0) {
                            const e = t[i[0]];
                            if (void 0 !== e) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, i = e.length; t < i; t++) {
                                    const i = e[t].name || String(t);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                                }
                            }
                        }
                    } else {
                        const t = e.morphTargets;
                        void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }
            al.prototype.isLine = !0;
            const ol = new ai,
                ll = new ai;
            class hl extends al {
                constructor(e, t) {
                    super(e, t), this.type = "LineSegments"
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (e.isBufferGeometry)
                        if (null === e.index) {
                            const t = e.attributes.position,
                                i = [];
                            for (let e = 0, n = t.count; e < n; e += 2) ol.fromBufferAttribute(t, e), ll.fromBufferAttribute(t, e + 1), i[e] = 0 === e ? 0 : i[e - 1], i[e + 1] = i[e] + ol.distanceTo(ll);
                            e.setAttribute("lineDistance", new Ln(i, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                }
            }
            hl.prototype.isLineSegments = !0;
            class cl extends al {
                constructor(e, t) {
                    super(e, t), this.type = "LineLoop"
                }
            }
            cl.prototype.isLineLoop = !0;
            class ul extends xn {
                constructor(e) {
                    super(), this.type = "PointsMaterial", this.color = new Kt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
                }
            }
            ul.prototype.isPointsMaterial = !0;
            const dl = new Ui,
                pl = new Ni,
                fl = new Ai,
                ml = new ai;
            class gl extends hn {
                constructor(e = new Un, t = new ul) {
                    super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e) {
                    return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
                }
                raycast(e, t) {
                    const i = this.geometry,
                        n = this.matrixWorld,
                        r = e.params.Points.threshold,
                        s = i.drawRange;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), fl.copy(i.boundingSphere), fl.applyMatrix4(n), fl.radius += r, !1 === e.ray.intersectsSphere(fl)) return;
                    dl.copy(n).invert(), pl.copy(e.ray).applyMatrix4(dl);
                    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a;
                    if (i.isBufferGeometry) {
                        const r = i.index,
                            a = i.attributes.position;
                        if (null !== r) {
                            for (let i = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); i < l; i++) {
                                const s = r.getX(i);
                                ml.fromBufferAttribute(a, s), yl(ml, s, o, n, e, t, this)
                            }
                        } else {
                            for (let i = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); i < r; i++) ml.fromBufferAttribute(a, i), yl(ml, i, o, n, e, t, this)
                        }
                    } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
                updateMorphTargets() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        const t = e.morphAttributes,
                            i = Object.keys(t);
                        if (i.length > 0) {
                            const e = t[i[0]];
                            if (void 0 !== e) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, i = e.length; t < i; t++) {
                                    const i = e[t].name || String(t);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                                }
                            }
                        }
                    } else {
                        const t = e.morphTargets;
                        void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }

            function yl(e, t, i, n, r, s, a) {
                const o = pl.distanceSqToPoint(e);
                if (o < i) {
                    const i = new ai;
                    pl.closestPointToPoint(e, i), i.applyMatrix4(n);
                    const l = r.ray.origin.distanceTo(i);
                    if (l < r.near || l > r.far) return;
                    s.push({
                        distance: l,
                        distanceToRay: Math.sqrt(o),
                        point: i,
                        index: t,
                        face: null,
                        object: a
                    })
                }
            }
            gl.prototype.isPoints = !0;
            (class extends ei {
                constructor(e, t, i, n, r, s, a, o, l) {
                    super(e, t, i, n, r, s, a, o, l), this.minFilter = void 0 !== s ? s : ce, this.magFilter = void 0 !== r ? r : ce, this.generateMipmaps = !1;
                    const h = this;
                    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() {
                        h.needsUpdate = !0, e.requestVideoFrameCallback(t)
                    }))
                }
                clone() {
                    return new this.constructor(this.image).copy(this)
                }
                update() {
                    const e = this.image;
                    !1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }).prototype.isVideoTexture = !0;
            (class extends ei {
                constructor(e, t, i) {
                    super({
                        width: e,
                        height: t
                    }), this.format = i, this.magFilter = oe, this.minFilter = oe, this.generateMipmaps = !1, this.needsUpdate = !0
                }
            }).prototype.isFramebufferTexture = !0;
            class _l extends ei {
                constructor(e, t, i, n, r, s, a, o, l, h, c, u) {
                    super(null, s, a, o, l, h, n, r, c, u), this.image = {
                        width: t,
                        height: i
                    }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            _l.prototype.isCompressedTexture = !0;
            (class extends ei {
                constructor(e, t, i, n, r, s, a, o, l) {
                    super(e, t, i, n, r, s, a, o, l), this.needsUpdate = !0
                }
            }).prototype.isCanvasTexture = !0;
            new ai, new ai, new ai, new bn;
            class vl {
                constructor() {
                    this.type = "Curve", this.arcLengthDivisions = 200
                }
                getPoint() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                }
                getPointAt(e, t) {
                    const i = this.getUtoTmapping(e);
                    return this.getPoint(i, t)
                }
                getPoints(e = 5) {
                    const t = [];
                    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
                    return t
                }
                getSpacedPoints(e = 5) {
                    const t = [];
                    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
                    return t
                }
                getLength() {
                    const e = this.getLengths();
                    return e[e.length - 1]
                }
                getLengths(e = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const t = [];
                    let i, n = this.getPoint(0),
                        r = 0;
                    t.push(0);
                    for (let s = 1; s <= e; s++) i = this.getPoint(s / e), r += i.distanceTo(n), t.push(r), n = i;
                    return this.cacheArcLengths = t, t
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.getLengths()
                }
                getUtoTmapping(e, t) {
                    const i = this.getLengths();
                    let n = 0;
                    const r = i.length;
                    let s;
                    s = t || e * i[r - 1];
                    let a, o = 0,
                        l = r - 1;
                    for (; o <= l;)
                        if (n = Math.floor(o + (l - o) / 2), a = i[n] - s, a < 0) o = n + 1;
                        else {
                            if (!(a > 0)) {
                                l = n;
                                break
                            }
                            l = n - 1
                        }
                    if (n = l, i[n] === s) return n / (r - 1);
                    const h = i[n];
                    return (n + (s - h) / (i[n + 1] - h)) / (r - 1)
                }
                getTangent(e, t) {
                    const i = 1e-4;
                    let n = e - i,
                        r = e + i;
                    n < 0 && (n = 0), r > 1 && (r = 1);
                    const s = this.getPoint(n),
                        a = this.getPoint(r),
                        o = t || (s.isVector2 ? new Ht : new ai);
                    return o.copy(a).sub(s).normalize(), o
                }
                getTangentAt(e, t) {
                    const i = this.getUtoTmapping(e);
                    return this.getTangent(i, t)
                }
                computeFrenetFrames(e, t) {
                    const i = new ai,
                        n = [],
                        r = [],
                        s = [],
                        a = new ai,
                        o = new Ui;
                    for (let t = 0; t <= e; t++) {
                        const i = t / e;
                        n[t] = this.getTangentAt(i, new ai)
                    }
                    r[0] = new ai, s[0] = new ai;
                    let l = Number.MAX_VALUE;
                    const h = Math.abs(n[0].x),
                        c = Math.abs(n[0].y),
                        u = Math.abs(n[0].z);
                    h <= l && (l = h, i.set(1, 0, 0)), c <= l && (l = c, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], a), s[0].crossVectors(n[0], r[0]);
                    for (let t = 1; t <= e; t++) {
                        if (r[t] = r[t - 1].clone(), s[t] = s[t - 1].clone(), a.crossVectors(n[t - 1], n[t]), a.length() > Number.EPSILON) {
                            a.normalize();
                            const e = Math.acos(kt(n[t - 1].dot(n[t]), -1, 1));
                            r[t].applyMatrix4(o.makeRotationAxis(a, e))
                        }
                        s[t].crossVectors(n[t], r[t])
                    }
                    if (!0 === t) {
                        let t = Math.acos(kt(r[0].dot(r[e]), -1, 1));
                        t /= e, n[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
                        for (let i = 1; i <= e; i++) r[i].applyMatrix4(o.makeRotationAxis(n[i], t * i)), s[i].crossVectors(n[i], r[i])
                    }
                    return {
                        tangents: n,
                        normals: r,
                        binormals: s
                    }
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                }
                fromJSON(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }
            class bl extends vl {
                constructor(e = 0, t = 0, i = 1, n = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
                    super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
                }
                getPoint(e, t) {
                    const i = t || new Ht,
                        n = 2 * Math.PI;
                    let r = this.aEndAngle - this.aStartAngle;
                    const s = Math.abs(r) < Number.EPSILON;
                    for (; r < 0;) r += n;
                    for (; r > n;) r -= n;
                    r < Number.EPSILON && (r = s ? 0 : n), !0 !== this.aClockwise || s || (r === n ? r = -n : r -= n);
                    const a = this.aStartAngle + e * r;
                    let o = this.aX + this.xRadius * Math.cos(a),
                        l = this.aY + this.yRadius * Math.sin(a);
                    if (0 !== this.aRotation) {
                        const e = Math.cos(this.aRotation),
                            t = Math.sin(this.aRotation),
                            i = o - this.aX,
                            n = l - this.aY;
                        o = i * e - n * t + this.aX, l = i * t + n * e + this.aY
                    }
                    return i.set(o, l)
                }
                copy(e) {
                    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
            }
            bl.prototype.isEllipseCurve = !0;
            class Tl extends bl {
                constructor(e, t, i, n, r, s) {
                    super(e, t, i, i, n, r, s), this.type = "ArcCurve"
                }
            }

            function xl() {
                let e = 0,
                    t = 0,
                    i = 0,
                    n = 0;

                function r(r, s, a, o) {
                    e = r, t = a, i = -3 * r + 3 * s - 2 * a - o, n = 2 * r - 2 * s + a + o
                }
                return {
                    initCatmullRom: function(e, t, i, n, s) {
                        r(t, i, s * (i - e), s * (n - t))
                    },
                    initNonuniformCatmullRom: function(e, t, i, n, s, a, o) {
                        let l = (t - e) / s - (i - e) / (s + a) + (i - t) / a,
                            h = (i - t) / a - (n - t) / (a + o) + (n - i) / o;
                        l *= a, h *= a, r(t, i, l, h)
                    },
                    calc: function(r) {
                        const s = r * r;
                        return e + t * r + i * s + n * (s * r)
                    }
                }
            }
            Tl.prototype.isArcCurve = !0;
            const wl = new ai,
                Sl = new xl,
                El = new xl,
                Ml = new xl;
            class Cl extends vl {
                constructor(e = [], t = !1, i = "centripetal", n = .5) {
                    super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = n
                }
                getPoint(e, t = new ai) {
                    const i = t,
                        n = this.points,
                        r = n.length,
                        s = (r - (this.closed ? 0 : 1)) * e;
                    let a, o, l = Math.floor(s),
                        h = s - l;
                    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === h && l === r - 1 && (l = r - 2, h = 1), this.closed || l > 0 ? a = n[(l - 1) % r] : (wl.subVectors(n[0], n[1]).add(n[0]), a = wl);
                    const c = n[l % r],
                        u = n[(l + 1) % r];
                    if (this.closed || l + 2 < r ? o = n[(l + 2) % r] : (wl.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), o = wl), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        const e = "chordal" === this.curveType ? .5 : .25;
                        let t = Math.pow(a.distanceToSquared(c), e),
                            i = Math.pow(c.distanceToSquared(u), e),
                            n = Math.pow(u.distanceToSquared(o), e);
                        i < 1e-4 && (i = 1), t < 1e-4 && (t = i), n < 1e-4 && (n = i), Sl.initNonuniformCatmullRom(a.x, c.x, u.x, o.x, t, i, n), El.initNonuniformCatmullRom(a.y, c.y, u.y, o.y, t, i, n), Ml.initNonuniformCatmullRom(a.z, c.z, u.z, o.z, t, i, n)
                    } else "catmullrom" === this.curveType && (Sl.initCatmullRom(a.x, c.x, u.x, o.x, this.tension), El.initCatmullRom(a.y, c.y, u.y, o.y, this.tension), Ml.initCatmullRom(a.z, c.z, u.z, o.z, this.tension));
                    return i.set(Sl.calc(h), El.calc(h), Ml.calc(h)), i
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, i = e.points.length; t < i; t++) {
                        const i = e.points[t];
                        this.points.push(i.clone())
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.points = [];
                    for (let t = 0, i = this.points.length; t < i; t++) {
                        const i = this.points[t];
                        e.points.push(i.toArray())
                    }
                    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, i = e.points.length; t < i; t++) {
                        const i = e.points[t];
                        this.points.push((new ai).fromArray(i))
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
            }

            function Al(e, t, i, n, r) {
                const s = .5 * (n - t),
                    a = .5 * (r - i),
                    o = e * e;
                return (2 * i - 2 * n + s + a) * (e * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * e + i
            }

            function Ll(e, t, i, n) {
                return function(e, t) {
                    const i = 1 - e;
                    return i * i * t
                }(e, t) + function(e, t) {
                    return 2 * (1 - e) * e * t
                }(e, i) + function(e, t) {
                    return e * e * t
                }(e, n)
            }

            function Il(e, t, i, n, r) {
                return function(e, t) {
                    const i = 1 - e;
                    return i * i * i * t
                }(e, t) + function(e, t) {
                    const i = 1 - e;
                    return 3 * i * i * e * t
                }(e, i) + function(e, t) {
                    return 3 * (1 - e) * e * e * t
                }(e, n) + function(e, t) {
                    return e * e * e * t
                }(e, r)
            }
            Cl.prototype.isCatmullRomCurve3 = !0;
            class Pl extends vl {
                constructor(e = new Ht, t = new Ht, i = new Ht, n = new Ht) {
                    super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n
                }
                getPoint(e, t = new Ht) {
                    const i = t,
                        n = this.v0,
                        r = this.v1,
                        s = this.v2,
                        a = this.v3;
                    return i.set(Il(e, n.x, r.x, s.x, a.x), Il(e, n.y, r.y, s.y, a.y)), i
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            Pl.prototype.isCubicBezierCurve = !0;
            class Rl extends vl {
                constructor(e = new ai, t = new ai, i = new ai, n = new ai) {
                    super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n
                }
                getPoint(e, t = new ai) {
                    const i = t,
                        n = this.v0,
                        r = this.v1,
                        s = this.v2,
                        a = this.v3;
                    return i.set(Il(e, n.x, r.x, s.x, a.x), Il(e, n.y, r.y, s.y, a.y), Il(e, n.z, r.z, s.z, a.z)), i
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            Rl.prototype.isCubicBezierCurve3 = !0;
            class kl extends vl {
                constructor(e = new Ht, t = new Ht) {
                    super(), this.type = "LineCurve", this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new Ht) {
                    const i = t;
                    return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                getTangent(e, t) {
                    const i = t || new Ht;
                    return i.copy(this.v2).sub(this.v1).normalize(), i
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            kl.prototype.isLineCurve = !0;
            class Dl extends vl {
                constructor(e = new Ht, t = new Ht, i = new Ht) {
                    super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i
                }
                getPoint(e, t = new Ht) {
                    const i = t,
                        n = this.v0,
                        r = this.v1,
                        s = this.v2;
                    return i.set(Ll(e, n.x, r.x, s.x), Ll(e, n.y, r.y, s.y)), i
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            Dl.prototype.isQuadraticBezierCurve = !0;
            class Ol extends vl {
                constructor(e = new ai, t = new ai, i = new ai) {
                    super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i
                }
                getPoint(e, t = new ai) {
                    const i = t,
                        n = this.v0,
                        r = this.v1,
                        s = this.v2;
                    return i.set(Ll(e, n.x, r.x, s.x), Ll(e, n.y, r.y, s.y), Ll(e, n.z, r.z, s.z)), i
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            Ol.prototype.isQuadraticBezierCurve3 = !0;
            class Nl extends vl {
                constructor(e = []) {
                    super(), this.type = "SplineCurve", this.points = e
                }
                getPoint(e, t = new Ht) {
                    const i = t,
                        n = this.points,
                        r = (n.length - 1) * e,
                        s = Math.floor(r),
                        a = r - s,
                        o = n[0 === s ? s : s - 1],
                        l = n[s],
                        h = n[s > n.length - 2 ? n.length - 1 : s + 1],
                        c = n[s > n.length - 3 ? n.length - 1 : s + 2];
                    return i.set(Al(a, o.x, l.x, h.x, c.x), Al(a, o.y, l.y, h.y, c.y)), i
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, i = e.points.length; t < i; t++) {
                        const i = e.points[t];
                        this.points.push(i.clone())
                    }
                    return this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.points = [];
                    for (let t = 0, i = this.points.length; t < i; t++) {
                        const i = this.points[t];
                        e.points.push(i.toArray())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, i = e.points.length; t < i; t++) {
                        const i = e.points[t];
                        this.points.push((new Ht).fromArray(i))
                    }
                    return this
                }
            }
            Nl.prototype.isSplineCurve = !0;
            var Ul = Object.freeze({
                __proto__: null,
                ArcCurve: Tl,
                CatmullRomCurve3: Cl,
                CubicBezierCurve: Pl,
                CubicBezierCurve3: Rl,
                EllipseCurve: bl,
                LineCurve: kl,
                LineCurve3: class extends vl {
                    constructor(e = new ai, t = new ai) {
                        super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t
                    }
                    getPoint(e, t = new ai) {
                        const i = t;
                        return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t)
                    }
                    copy(e) {
                        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                    }
                },
                QuadraticBezierCurve: Dl,
                QuadraticBezierCurve3: Ol,
                SplineCurve: Nl
            });
            class Bl extends vl {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }
                add(e) {
                    this.curves.push(e)
                }
                closePath() {
                    const e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new kl(t, e))
                }
                getPoint(e, t) {
                    const i = e * this.getLength(),
                        n = this.getCurveLengths();
                    let r = 0;
                    for (; r < n.length;) {
                        if (n[r] >= i) {
                            const e = n[r] - i,
                                s = this.curves[r],
                                a = s.getLength(),
                                o = 0 === a ? 0 : 1 - e / a;
                            return s.getPointAt(o, t)
                        }
                        r++
                    }
                    return null
                }
                getLength() {
                    const e = this.getCurveLengths();
                    return e[e.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const e = [];
                    let t = 0;
                    for (let i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t);
                    return this.cacheLengths = e, e
                }
                getSpacedPoints(e = 40) {
                    const t = [];
                    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
                    return this.autoClose && t.push(t[0]), t
                }
                getPoints(e = 12) {
                    const t = [];
                    let i;
                    for (let n = 0, r = this.curves; n < r.length; n++) {
                        const s = r[n],
                            a = s && s.isEllipseCurve ? 2 * e : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e,
                            o = s.getPoints(a);
                        for (let e = 0; e < o.length; e++) {
                            const n = o[e];
                            i && i.equals(n) || (t.push(n), i = n)
                        }
                    }
                    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
                }
                copy(e) {
                    super.copy(e), this.curves = [];
                    for (let t = 0, i = e.curves.length; t < i; t++) {
                        const i = e.curves[t];
                        this.curves.push(i.clone())
                    }
                    return this.autoClose = e.autoClose, this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.autoClose = this.autoClose, e.curves = [];
                    for (let t = 0, i = this.curves.length; t < i; t++) {
                        const i = this.curves[t];
                        e.curves.push(i.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                    for (let t = 0, i = e.curves.length; t < i; t++) {
                        const i = e.curves[t];
                        this.curves.push((new Ul[i.type]).fromJSON(i))
                    }
                    return this
                }
            }
            class Fl extends Bl {
                constructor(e) {
                    super(), this.type = "Path", this.currentPoint = new Ht, e && this.setFromPoints(e)
                }
                setFromPoints(e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
                    return this
                }
                moveTo(e, t) {
                    return this.currentPoint.set(e, t), this
                }
                lineTo(e, t) {
                    const i = new kl(this.currentPoint.clone(), new Ht(e, t));
                    return this.curves.push(i), this.currentPoint.set(e, t), this
                }
                quadraticCurveTo(e, t, i, n) {
                    const r = new Dl(this.currentPoint.clone(), new Ht(e, t), new Ht(i, n));
                    return this.curves.push(r), this.currentPoint.set(i, n), this
                }
                bezierCurveTo(e, t, i, n, r, s) {
                    const a = new Pl(this.currentPoint.clone(), new Ht(e, t), new Ht(i, n), new Ht(r, s));
                    return this.curves.push(a), this.currentPoint.set(r, s), this
                }
                splineThru(e) {
                    const t = [this.currentPoint.clone()].concat(e),
                        i = new Nl(t);
                    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this
                }
                arc(e, t, i, n, r, s) {
                    const a = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(e + a, t + o, i, n, r, s), this
                }
                absarc(e, t, i, n, r, s) {
                    return this.absellipse(e, t, i, i, n, r, s), this
                }
                ellipse(e, t, i, n, r, s, a, o) {
                    const l = this.currentPoint.x,
                        h = this.currentPoint.y;
                    return this.absellipse(e + l, t + h, i, n, r, s, a, o), this
                }
                absellipse(e, t, i, n, r, s, a, o) {
                    const l = new bl(e, t, i, n, r, s, a, o);
                    if (this.curves.length > 0) {
                        const e = l.getPoint(0);
                        e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                    }
                    this.curves.push(l);
                    const h = l.getPoint(1);
                    return this.currentPoint.copy(h), this
                }
                copy(e) {
                    return super.copy(e), this.currentPoint.copy(e.currentPoint), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.currentPoint = this.currentPoint.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }
            class Hl extends Fl {
                constructor(e) {
                    super(e), this.uuid = Rt(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(e) {
                    const t = [];
                    for (let i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
                    return t
                }
                extractPoints(e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                }
                copy(e) {
                    super.copy(e), this.holes = [];
                    for (let t = 0, i = e.holes.length; t < i; t++) {
                        const i = e.holes[t];
                        this.holes.push(i.clone())
                    }
                    return this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.uuid = this.uuid, e.holes = [];
                    for (let t = 0, i = this.holes.length; t < i; t++) {
                        const i = this.holes[t];
                        e.holes.push(i.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                    for (let t = 0, i = e.holes.length; t < i; t++) {
                        const i = e.holes[t];
                        this.holes.push((new Fl).fromJSON(i))
                    }
                    return this
                }
            }
            const zl = function(e, t, i = 2) {
                const n = t && t.length,
                    r = n ? t[0] * i : e.length;
                let s = Vl(e, 0, r, i, !0);
                const a = [];
                if (!s || s.next === s.prev) return a;
                let o, l, h, c, u, d, p;
                if (n && (s = function(e, t, i, n) {
                        const r = [];
                        let s, a, o, l, h;
                        for (s = 0, a = t.length; s < a; s++) o = t[s] * n, l = s < a - 1 ? t[s + 1] * n : e.length, h = Vl(e, o, l, n, !1), h === h.next && (h.steiner = !0), r.push(Ql(h));
                        for (r.sort(Yl), s = 0; s < r.length; s++) Kl(r[s], i), i = Gl(i, i.next);
                        return i
                    }(e, t, s, i)), e.length > 80 * i) {
                    o = h = e[0], l = c = e[1];
                    for (let t = i; t < r; t += i) u = e[t], d = e[t + 1], u < o && (o = u), d < l && (l = d), u > h && (h = u), d > c && (c = d);
                    p = Math.max(h - o, c - l), p = 0 !== p ? 1 / p : 0
                }
                return Wl(s, a, i, o, l, p), a
            };

            function Vl(e, t, i, n, r) {
                let s, a;
                if (r === function(e, t, i, n) {
                        let r = 0;
                        for (let s = t, a = i - n; s < i; s += n) r += (e[a] - e[s]) * (e[s + 1] + e[a + 1]), a = s;
                        return r
                    }(e, t, i, n) > 0)
                    for (s = t; s < i; s += n) a = hh(s, e[s], e[s + 1], a);
                else
                    for (s = i - n; s >= t; s -= n) a = hh(s, e[s], e[s + 1], a);
                return a && nh(a, a.next) && (ch(a), a = a.next), a
            }

            function Gl(e, t) {
                if (!e) return e;
                t || (t = e);
                let i, n = e;
                do {
                    if (i = !1, n.steiner || !nh(n, n.next) && 0 !== ih(n.prev, n, n.next)) n = n.next;
                    else {
                        if (ch(n), n = t = n.prev, n === n.next) break;
                        i = !0
                    }
                } while (i || n !== t);
                return t
            }

            function Wl(e, t, i, n, r, s, a) {
                if (!e) return;
                !a && s && function(e, t, i, n) {
                    let r = e;
                    do {
                        null === r.z && (r.z = Zl(r.x, r.y, t, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== e);
                    r.prevZ.nextZ = null, r.prevZ = null,
                        function(e) {
                            let t, i, n, r, s, a, o, l, h = 1;
                            do {
                                for (i = e, e = null, s = null, a = 0; i;) {
                                    for (a++, n = i, o = 0, t = 0; t < h && (o++, n = n.nextZ, n); t++);
                                    for (l = h; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, o--) : (r = n, n = n.nextZ, l--), s ? s.nextZ = r : e = r, r.prevZ = s, s = r;
                                    i = n
                                }
                                s.nextZ = null, h *= 2
                            } while (a > 1)
                        }(r)
                }(e, n, r, s);
                let o, l, h = e;
                for (; e.prev !== e.next;)
                    if (o = e.prev, l = e.next, s ? ql(e, n, r, s) : jl(e)) t.push(o.i / i), t.push(e.i / i), t.push(l.i / i), ch(e), e = l.next, h = l.next;
                    else if ((e = l) === h) {
                    a ? 1 === a ? Wl(e = $l(Gl(e), t, i), t, i, n, r, s, 2) : 2 === a && Xl(e, t, i, n, r, s) : Wl(Gl(e), t, i, n, r, s, 1);
                    break
                }
            }

            function jl(e) {
                const t = e.prev,
                    i = e,
                    n = e.next;
                if (ih(t, i, n) >= 0) return !1;
                let r = e.next.next;
                for (; r !== e.prev;) {
                    if (eh(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) && ih(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function ql(e, t, i, n) {
                const r = e.prev,
                    s = e,
                    a = e.next;
                if (ih(r, s, a) >= 0) return !1;
                const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x,
                    l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y,
                    h = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x,
                    c = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y,
                    u = Zl(o, l, t, i, n),
                    d = Zl(h, c, t, i, n);
                let p = e.prevZ,
                    f = e.nextZ;
                for (; p && p.z >= u && f && f.z <= d;) {
                    if (p !== e.prev && p !== e.next && eh(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && ih(p.prev, p, p.next) >= 0) return !1;
                    if (p = p.prevZ, f !== e.prev && f !== e.next && eh(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && ih(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                for (; p && p.z >= u;) {
                    if (p !== e.prev && p !== e.next && eh(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && ih(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                for (; f && f.z <= d;) {
                    if (f !== e.prev && f !== e.next && eh(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && ih(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                return !0
            }

            function $l(e, t, i) {
                let n = e;
                do {
                    const r = n.prev,
                        s = n.next.next;
                    !nh(r, s) && rh(r, n, n.next, s) && oh(r, s) && oh(s, r) && (t.push(r.i / i), t.push(n.i / i), t.push(s.i / i), ch(n), ch(n.next), n = e = s), n = n.next
                } while (n !== e);
                return Gl(n)
            }

            function Xl(e, t, i, n, r, s) {
                let a = e;
                do {
                    let e = a.next.next;
                    for (; e !== a.prev;) {
                        if (a.i !== e.i && th(a, e)) {
                            let o = lh(a, e);
                            return a = Gl(a, a.next), o = Gl(o, o.next), Wl(a, t, i, n, r, s), void Wl(o, t, i, n, r, s)
                        }
                        e = e.next
                    }
                    a = a.next
                } while (a !== e)
            }

            function Yl(e, t) {
                return e.x - t.x
            }

            function Kl(e, t) {
                if (t = function(e, t) {
                        let i = t;
                        const n = e.x,
                            r = e.y;
                        let s, a = -1 / 0;
                        do {
                            if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                                const e = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                if (e <= n && e > a) {
                                    if (a = e, e === n) {
                                        if (r === i.y) return i;
                                        if (r === i.next.y) return i.next
                                    }
                                    s = i.x < i.next.x ? i : i.next
                                }
                            }
                            i = i.next
                        } while (i !== t);
                        if (!s) return null;
                        if (n === a) return s;
                        const o = s,
                            l = s.x,
                            h = s.y;
                        let c, u = 1 / 0;
                        i = s;
                        do {
                            n >= i.x && i.x >= l && n !== i.x && eh(r < h ? n : a, r, l, h, r < h ? a : n, r, i.x, i.y) && (c = Math.abs(r - i.y) / (n - i.x), oh(i, e) && (c < u || c === u && (i.x > s.x || i.x === s.x && Jl(s, i))) && (s = i, u = c)), i = i.next
                        } while (i !== o);
                        return s
                    }(e, t), t) {
                    const i = lh(t, e);
                    Gl(t, t.next), Gl(i, i.next)
                }
            }

            function Jl(e, t) {
                return ih(e.prev, e, t.prev) < 0 && ih(t.next, e, e.next) < 0
            }

            function Zl(e, t, i, n, r) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }

            function Ql(e) {
                let t = e,
                    i = e;
                do {
                    (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), t = t.next
                } while (t !== e);
                return i
            }

            function eh(e, t, i, n, r, s, a, o) {
                return (r - a) * (t - o) - (e - a) * (s - o) >= 0 && (e - a) * (n - o) - (i - a) * (t - o) >= 0 && (i - a) * (s - o) - (r - a) * (n - o) >= 0
            }

            function th(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
                    let i = e;
                    do {
                        if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && rh(i, i.next, e, t)) return !0;
                        i = i.next
                    } while (i !== e);
                    return !1
                }(e, t) && (oh(e, t) && oh(t, e) && function(e, t) {
                    let i = e,
                        n = !1;
                    const r = (e.x + t.x) / 2,
                        s = (e.y + t.y) / 2;
                    do {
                        i.y > s != i.next.y > s && i.next.y !== i.y && r < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
                    } while (i !== e);
                    return n
                }(e, t) && (ih(e.prev, e, t.prev) || ih(e, t.prev, t)) || nh(e, t) && ih(e.prev, e, e.next) > 0 && ih(t.prev, t, t.next) > 0)
            }

            function ih(e, t, i) {
                return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
            }

            function nh(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function rh(e, t, i, n) {
                const r = ah(ih(e, t, i)),
                    s = ah(ih(e, t, n)),
                    a = ah(ih(i, n, e)),
                    o = ah(ih(i, n, t));
                return r !== s && a !== o || (!(0 !== r || !sh(e, i, t)) || (!(0 !== s || !sh(e, n, t)) || (!(0 !== a || !sh(i, e, n)) || !(0 !== o || !sh(i, t, n)))))
            }

            function sh(e, t, i) {
                return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y)
            }

            function ah(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }

            function oh(e, t) {
                return ih(e.prev, e, e.next) < 0 ? ih(e, t, e.next) >= 0 && ih(e, e.prev, t) >= 0 : ih(e, t, e.prev) < 0 || ih(e, e.next, t) < 0
            }

            function lh(e, t) {
                const i = new uh(e.i, e.x, e.y),
                    n = new uh(t.i, t.x, t.y),
                    r = e.next,
                    s = t.prev;
                return e.next = t, t.prev = e, i.next = r, r.prev = i, n.next = i, i.prev = n, s.next = n, n.prev = s, n
            }

            function hh(e, t, i, n) {
                const r = new uh(e, t, i);
                return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
            }

            function ch(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function uh(e, t, i) {
                this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            class dh {
                static area(e) {
                    const t = e.length;
                    let i = 0;
                    for (let n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
                    return .5 * i
                }
                static isClockWise(e) {
                    return dh.area(e) < 0
                }
                static triangulateShape(e, t) {
                    const i = [],
                        n = [],
                        r = [];
                    ph(e), fh(i, e);
                    let s = e.length;
                    t.forEach(ph);
                    for (let e = 0; e < t.length; e++) n.push(s), s += t[e].length, fh(i, t[e]);
                    const a = zl(i, n);
                    for (let e = 0; e < a.length; e += 3) r.push(a.slice(e, e + 3));
                    return r
                }
            }

            function ph(e) {
                const t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function fh(e, t) {
                for (let i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y)
            }
            class mh extends Un {
                constructor(e = new Hl([new Ht(.5, .5), new Ht(-.5, .5), new Ht(-.5, -.5), new Ht(.5, -.5)]), t = {}) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: e,
                        options: t
                    }, e = Array.isArray(e) ? e : [e];
                    const i = this,
                        n = [],
                        r = [];
                    for (let t = 0, i = e.length; t < i; t++) {
                        s(e[t])
                    }

                    function s(e) {
                        const s = [],
                            a = void 0 !== t.curveSegments ? t.curveSegments : 12,
                            o = void 0 !== t.steps ? t.steps : 1;
                        let l = void 0 !== t.depth ? t.depth : 1,
                            h = void 0 === t.bevelEnabled || t.bevelEnabled,
                            c = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
                            u = void 0 !== t.bevelSize ? t.bevelSize : c - .1,
                            d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                            p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
                        const f = t.extrudePath,
                            m = void 0 !== t.UVGenerator ? t.UVGenerator : gh;
                        void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = t.amount);
                        let g, y, _, v, b, T = !1;
                        f && (g = f.getSpacedPoints(o), T = !0, h = !1, y = f.computeFrenetFrames(o, !1), _ = new ai, v = new ai, b = new ai), h || (p = 0, c = 0, u = 0, d = 0);
                        const x = e.extractPoints(a);
                        let w = x.shape;
                        const S = x.holes;
                        if (!dh.isClockWise(w)) {
                            w = w.reverse();
                            for (let e = 0, t = S.length; e < t; e++) {
                                const t = S[e];
                                dh.isClockWise(t) && (S[e] = t.reverse())
                            }
                        }
                        const E = dh.triangulateShape(w, S),
                            M = w;
                        for (let e = 0, t = S.length; e < t; e++) {
                            const t = S[e];
                            w = w.concat(t)
                        }

                        function C(e, t, i) {
                            return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
                        }
                        const A = w.length,
                            L = E.length;

                        function I(e, t, i) {
                            let n, r, s;
                            const a = e.x - t.x,
                                o = e.y - t.y,
                                l = i.x - e.x,
                                h = i.y - e.y,
                                c = a * a + o * o,
                                u = a * h - o * l;
                            if (Math.abs(u) > Number.EPSILON) {
                                const u = Math.sqrt(c),
                                    d = Math.sqrt(l * l + h * h),
                                    p = t.x - o / u,
                                    f = t.y + a / u,
                                    m = ((i.x - h / d - p) * h - (i.y + l / d - f) * l) / (a * h - o * l);
                                n = p + a * m - e.x, r = f + o * m - e.y;
                                const g = n * n + r * r;
                                if (g <= 2) return new Ht(n, r);
                                s = Math.sqrt(g / 2)
                            } else {
                                let e = !1;
                                a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(h) && (e = !0), e ? (n = -o, r = a, s = Math.sqrt(c)) : (n = a, r = o, s = Math.sqrt(c / 2))
                            }
                            return new Ht(n / s, r / s)
                        }
                        const P = [];
                        for (let e = 0, t = M.length, i = t - 1, n = e + 1; e < t; e++, i++, n++) i === t && (i = 0), n === t && (n = 0), P[e] = I(M[e], M[i], M[n]);
                        const R = [];
                        let k, D = P.concat();
                        for (let e = 0, t = S.length; e < t; e++) {
                            const t = S[e];
                            k = [];
                            for (let e = 0, i = t.length, n = i - 1, r = e + 1; e < i; e++, n++, r++) n === i && (n = 0), r === i && (r = 0), k[e] = I(t[e], t[n], t[r]);
                            R.push(k), D = D.concat(k)
                        }
                        for (let e = 0; e < p; e++) {
                            const t = e / p,
                                i = c * Math.cos(t * Math.PI / 2),
                                n = u * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, t = M.length; e < t; e++) {
                                const t = C(M[e], P[e], n);
                                U(t.x, t.y, -i)
                            }
                            for (let e = 0, t = S.length; e < t; e++) {
                                const t = S[e];
                                k = R[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = C(t[e], k[e], n);
                                    U(r.x, r.y, -i)
                                }
                            }
                        }
                        const O = u + d;
                        for (let e = 0; e < A; e++) {
                            const t = h ? C(w[e], D[e], O) : w[e];
                            T ? (v.copy(y.normals[0]).multiplyScalar(t.x), _.copy(y.binormals[0]).multiplyScalar(t.y), b.copy(g[0]).add(v).add(_), U(b.x, b.y, b.z)) : U(t.x, t.y, 0)
                        }
                        for (let e = 1; e <= o; e++)
                            for (let t = 0; t < A; t++) {
                                const i = h ? C(w[t], D[t], O) : w[t];
                                T ? (v.copy(y.normals[e]).multiplyScalar(i.x), _.copy(y.binormals[e]).multiplyScalar(i.y), b.copy(g[e]).add(v).add(_), U(b.x, b.y, b.z)) : U(i.x, i.y, l / o * e)
                            }
                        for (let e = p - 1; e >= 0; e--) {
                            const t = e / p,
                                i = c * Math.cos(t * Math.PI / 2),
                                n = u * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, t = M.length; e < t; e++) {
                                const t = C(M[e], P[e], n);
                                U(t.x, t.y, l + i)
                            }
                            for (let e = 0, t = S.length; e < t; e++) {
                                const t = S[e];
                                k = R[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = C(t[e], k[e], n);
                                    T ? U(r.x, r.y + g[o - 1].y, g[o - 1].x + i) : U(r.x, r.y, l + i)
                                }
                            }
                        }

                        function N(e, t) {
                            let i = e.length;
                            for (; --i >= 0;) {
                                const n = i;
                                let r = i - 1;
                                r < 0 && (r = e.length - 1);
                                for (let e = 0, i = o + 2 * p; e < i; e++) {
                                    const i = A * e,
                                        s = A * (e + 1);
                                    F(t + n + i, t + r + i, t + r + s, t + n + s)
                                }
                            }
                        }

                        function U(e, t, i) {
                            s.push(e), s.push(t), s.push(i)
                        }

                        function B(e, t, r) {
                            H(e), H(t), H(r);
                            const s = n.length / 3,
                                a = m.generateTopUV(i, n, s - 3, s - 2, s - 1);
                            z(a[0]), z(a[1]), z(a[2])
                        }

                        function F(e, t, r, s) {
                            H(e), H(t), H(s), H(t), H(r), H(s);
                            const a = n.length / 3,
                                o = m.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                            z(o[0]), z(o[1]), z(o[3]), z(o[1]), z(o[2]), z(o[3])
                        }

                        function H(e) {
                            n.push(s[3 * e + 0]), n.push(s[3 * e + 1]), n.push(s[3 * e + 2])
                        }

                        function z(e) {
                            r.push(e.x), r.push(e.y)
                        }! function() {
                            const e = n.length / 3;
                            if (h) {
                                let e = 0,
                                    t = A * e;
                                for (let e = 0; e < L; e++) {
                                    const i = E[e];
                                    B(i[2] + t, i[1] + t, i[0] + t)
                                }
                                e = o + 2 * p, t = A * e;
                                for (let e = 0; e < L; e++) {
                                    const i = E[e];
                                    B(i[0] + t, i[1] + t, i[2] + t)
                                }
                            } else {
                                for (let e = 0; e < L; e++) {
                                    const t = E[e];
                                    B(t[2], t[1], t[0])
                                }
                                for (let e = 0; e < L; e++) {
                                    const t = E[e];
                                    B(t[0] + A * o, t[1] + A * o, t[2] + A * o)
                                }
                            }
                            i.addGroup(e, n.length / 3 - e, 0)
                        }(),
                        function() {
                            const e = n.length / 3;
                            let t = 0;
                            N(M, t), t += M.length;
                            for (let e = 0, i = S.length; e < i; e++) {
                                const i = S[e];
                                N(i, t), t += i.length
                            }
                            i.addGroup(e, n.length / 3 - e, 1)
                        }()
                    }
                    this.setAttribute("position", new Ln(n, 3)), this.setAttribute("uv", new Ln(r, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    const e = super.toJSON();
                    return function(e, t, i) {
                        if (i.shapes = [], Array.isArray(e))
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                i.shapes.push(n.uuid)
                            } else i.shapes.push(e.uuid);
                        void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON());
                        return i
                    }(this.parameters.shapes, this.parameters.options, e)
                }
                static fromJSON(e, t) {
                    const i = [];
                    for (let n = 0, r = e.shapes.length; n < r; n++) {
                        const r = t[e.shapes[n]];
                        i.push(r)
                    }
                    const n = e.options.extrudePath;
                    return void 0 !== n && (e.options.extrudePath = (new Ul[n.type]).fromJSON(n)), new mh(i, e.options)
                }
            }
            const gh = {
                generateTopUV: function(e, t, i, n, r) {
                    const s = t[3 * i],
                        a = t[3 * i + 1],
                        o = t[3 * n],
                        l = t[3 * n + 1],
                        h = t[3 * r],
                        c = t[3 * r + 1];
                    return [new Ht(s, a), new Ht(o, l), new Ht(h, c)]
                },
                generateSideWallUV: function(e, t, i, n, r, s) {
                    const a = t[3 * i],
                        o = t[3 * i + 1],
                        l = t[3 * i + 2],
                        h = t[3 * n],
                        c = t[3 * n + 1],
                        u = t[3 * n + 2],
                        d = t[3 * r],
                        p = t[3 * r + 1],
                        f = t[3 * r + 2],
                        m = t[3 * s],
                        g = t[3 * s + 1],
                        y = t[3 * s + 2];
                    return Math.abs(o - c) < Math.abs(a - h) ? [new Ht(a, 1 - l), new Ht(h, 1 - u), new Ht(d, 1 - f), new Ht(m, 1 - y)] : [new Ht(o, 1 - l), new Ht(c, 1 - u), new Ht(p, 1 - f), new Ht(g, 1 - y)]
                }
            };
            class yh extends Un {
                constructor(e = new Hl([new Ht(0, .5), new Ht(-.5, -.5), new Ht(.5, -.5)]), t = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: e,
                        curveSegments: t
                    };
                    const i = [],
                        n = [],
                        r = [],
                        s = [];
                    let a = 0,
                        o = 0;
                    if (!1 === Array.isArray(e)) l(e);
                    else
                        for (let t = 0; t < e.length; t++) l(e[t]), this.addGroup(a, o, t), a += o, o = 0;

                    function l(e) {
                        const a = n.length / 3,
                            l = e.extractPoints(t);
                        let h = l.shape;
                        const c = l.holes;
                        !1 === dh.isClockWise(h) && (h = h.reverse());
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            !0 === dh.isClockWise(t) && (c[e] = t.reverse())
                        }
                        const u = dh.triangulateShape(h, c);
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            h = h.concat(t)
                        }
                        for (let e = 0, t = h.length; e < t; e++) {
                            const t = h[e];
                            n.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y)
                        }
                        for (let e = 0, t = u.length; e < t; e++) {
                            const t = u[e],
                                n = t[0] + a,
                                r = t[1] + a,
                                s = t[2] + a;
                            i.push(n, r, s), o += 3
                        }
                    }
                    this.setIndex(i), this.setAttribute("position", new Ln(n, 3)), this.setAttribute("normal", new Ln(r, 3)), this.setAttribute("uv", new Ln(s, 2))
                }
                toJSON() {
                    const e = super.toJSON();
                    return function(e, t) {
                        if (t.shapes = [], Array.isArray(e))
                            for (let i = 0, n = e.length; i < n; i++) {
                                const n = e[i];
                                t.shapes.push(n.uuid)
                            } else t.shapes.push(e.uuid);
                        return t
                    }(this.parameters.shapes, e)
                }
                static fromJSON(e, t) {
                    const i = [];
                    for (let n = 0, r = e.shapes.length; n < r; n++) {
                        const r = t[e.shapes[n]];
                        i.push(r)
                    }
                    return new yh(i, e.curveSegments)
                }
            }
            class _h extends xn {
                constructor(e) {
                    super(), this.type = "ShadowMaterial", this.color = new Kt(0), this.transparent = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this
                }
            }
            _h.prototype.isShadowMaterial = !0;
            class vh extends xn {
                constructor(e) {
                    super(), this.defines = {
                        STANDARD: ""
                    }, this.type = "MeshStandardMaterial", this.color = new Kt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = bt, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
                }
            }
            vh.prototype.isMeshStandardMaterial = !0;
            class bh extends vh {
                constructor(e) {
                    super(), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ht(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                        get: function() {
                            return kt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(e) {
                            this.ior = (1 + .4 * e) / (1 - .4 * e)
                        }
                    }), this.sheenColor = new Kt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Kt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Kt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e)
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(e) {
                    this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(e) {
                    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(e) {
                    this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                }
            }
            bh.prototype.isMeshPhysicalMaterial = !0;
            class Th extends xn {
                constructor(e) {
                    super(), this.type = "MeshPhongMaterial", this.color = new Kt(16777215), this.specular = new Kt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = bt, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = G, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
                }
            }
            Th.prototype.isMeshPhongMaterial = !0;
            class xh extends xn {
                constructor(e) {
                    super(), this.defines = {
                        TOON: ""
                    }, this.type = "MeshToonMaterial", this.color = new Kt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = bt, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
                }
            }
            xh.prototype.isMeshToonMaterial = !0;
            class wh extends xn {
                constructor(e) {
                    super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = bt, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
                }
            }
            wh.prototype.isMeshNormalMaterial = !0;
            class Sh extends xn {
                constructor(e) {
                    super(), this.type = "MeshLambertMaterial", this.color = new Kt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = G, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
                }
            }
            Sh.prototype.isMeshLambertMaterial = !0;
            class Eh extends xn {
                constructor(e) {
                    super(), this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new Kt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = bt, this.normalScale = new Ht(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        MATCAP: ""
                    }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this
                }
            }
            Eh.prototype.isMeshMatcapMaterial = !0;
            class Mh extends el {
                constructor(e) {
                    super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
                }
            }
            Mh.prototype.isLineDashedMaterial = !0;
            const Ch = {
                arraySlice: function(e, t, i) {
                    return Ch.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
                },
                convertArray: function(e, t, i) {
                    return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                },
                isTypedArray: function(e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                },
                getKeyframeOrder: function(e) {
                    const t = e.length,
                        i = new Array(t);
                    for (let e = 0; e !== t; ++e) i[e] = e;
                    return i.sort((function(t, i) {
                        return e[t] - e[i]
                    })), i
                },
                sortedArray: function(e, t, i) {
                    const n = e.length,
                        r = new e.constructor(n);
                    for (let s = 0, a = 0; a !== n; ++s) {
                        const n = i[s] * t;
                        for (let i = 0; i !== t; ++i) r[a++] = e[n + i]
                    }
                    return r
                },
                flattenJSON: function(e, t, i, n) {
                    let r = 1,
                        s = e[0];
                    for (; void 0 !== s && void 0 === s[n];) s = e[r++];
                    if (void 0 === s) return;
                    let a = s[n];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                a = s[n], void 0 !== a && (t.push(s.time), i.push.apply(i, a)), s = e[r++]
                            } while (void 0 !== s);
                        else if (void 0 !== a.toArray)
                        do {
                            a = s[n], void 0 !== a && (t.push(s.time), a.toArray(i, i.length)), s = e[r++]
                        } while (void 0 !== s);
                    else
                        do {
                            a = s[n], void 0 !== a && (t.push(s.time), i.push(a)), s = e[r++]
                        } while (void 0 !== s)
                },
                subclip: function(e, t, i, n, r = 30) {
                    const s = e.clone();
                    s.name = t;
                    const a = [];
                    for (let e = 0; e < s.tracks.length; ++e) {
                        const t = s.tracks[e],
                            o = t.getValueSize(),
                            l = [],
                            h = [];
                        for (let e = 0; e < t.times.length; ++e) {
                            const s = t.times[e] * r;
                            if (!(s < i || s >= n)) {
                                l.push(t.times[e]);
                                for (let i = 0; i < o; ++i) h.push(t.values[e * o + i])
                            }
                        }
                        0 !== l.length && (t.times = Ch.convertArray(l, t.times.constructor), t.values = Ch.convertArray(h, t.values.constructor), a.push(t))
                    }
                    s.tracks = a;
                    let o = 1 / 0;
                    for (let e = 0; e < s.tracks.length; ++e) o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]);
                    for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * o);
                    return s.resetDuration(), s
                },
                makeClipAdditive: function(e, t = 0, i = e, n = 30) {
                    n <= 0 && (n = 30);
                    const r = i.tracks.length,
                        s = t / n;
                    for (let t = 0; t < r; ++t) {
                        const n = i.tracks[t],
                            r = n.ValueTypeName;
                        if ("bool" === r || "string" === r) continue;
                        const a = e.tracks.find((function(e) {
                            return e.name === n.name && e.ValueTypeName === r
                        }));
                        if (void 0 === a) continue;
                        let o = 0;
                        const l = n.getValueSize();
                        n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                        let h = 0;
                        const c = a.getValueSize();
                        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = c / 3);
                        const u = n.times.length - 1;
                        let d;
                        if (s <= n.times[0]) {
                            const e = o,
                                t = l - o;
                            d = Ch.arraySlice(n.values, e, t)
                        } else if (s >= n.times[u]) {
                            const e = u * l + o,
                                t = e + l - o;
                            d = Ch.arraySlice(n.values, e, t)
                        } else {
                            const e = n.createInterpolant(),
                                t = o,
                                i = l - o;
                            e.evaluate(s), d = Ch.arraySlice(e.resultBuffer, t, i)
                        }
                        if ("quaternion" === r) {
                            (new si).fromArray(d).normalize().conjugate().toArray(d)
                        }
                        const p = a.times.length;
                        for (let e = 0; e < p; ++e) {
                            const t = e * c + h;
                            if ("quaternion" === r) si.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t);
                            else {
                                const e = c - 2 * h;
                                for (let i = 0; i < e; ++i) a.values[t + i] -= d[i]
                            }
                        }
                    }
                    return e.blendMode = 2501, e
                }
            };
            class Ah {
                constructor(e, t, i, n) {
                    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(e) {
                    const t = this.parameterPositions;
                    let i = this._cachedIndex,
                        n = t[i],
                        r = t[i - 1];
                    e: {
                        t: {
                            let s;i: {
                                n: if (!(e < n)) {
                                    for (let s = i + 2;;) {
                                        if (void 0 === n) {
                                            if (e < r) break n;
                                            return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, e, r)
                                        }
                                        if (i === s) break;
                                        if (r = n, n = t[++i], e < n) break t
                                    }
                                    s = t.length;
                                    break i
                                }if (e >= r) break e; {
                                    const a = t[1];
                                    e < a && (i = 2, r = a);
                                    for (let s = i - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                                        if (i === s) break;
                                        if (n = r, r = t[--i - 1], e >= r) break t
                                    }
                                    s = i, i = 0
                                }
                            }
                            for (; i < s;) {
                                const n = i + s >>> 1;
                                e < t[n] ? s = n : i = n + 1
                            }
                            if (n = t[i], r = t[i - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                            if (void 0 === n) return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, e)
                        }
                        this._cachedIndex = i,
                        this.intervalChanged_(i, r, n)
                    }
                    return this.interpolate_(i, r, e, n)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer,
                        i = this.sampleValues,
                        n = this.valueSize,
                        r = e * n;
                    for (let e = 0; e !== n; ++e) t[e] = i[r + e];
                    return t
                }
                interpolate_() {
                    throw new Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            Ah.prototype.beforeStart_ = Ah.prototype.copySampleValue_, Ah.prototype.afterEnd_ = Ah.prototype.copySampleValue_;
            class Lh extends Ah {
                constructor(e, t, i, n) {
                    super(e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: ut,
                        endingEnd: ut
                    }
                }
                intervalChanged_(e, t, i) {
                    const n = this.parameterPositions;
                    let r = e - 2,
                        s = e + 1,
                        a = n[r],
                        o = n[s];
                    if (void 0 === a) switch (this.getSettings_().endingStart) {
                        case dt:
                            r = e, a = 2 * t - i;
                            break;
                        case pt:
                            r = n.length - 2, a = t + n[r] - n[r + 1];
                            break;
                        default:
                            r = e, a = i
                    }
                    if (void 0 === o) switch (this.getSettings_().endingEnd) {
                        case dt:
                            s = e, o = 2 * i - t;
                            break;
                        case pt:
                            s = 1, o = i + n[1] - n[0];
                            break;
                        default:
                            s = e - 1, o = t
                    }
                    const l = .5 * (i - t),
                        h = this.valueSize;
                    this._weightPrev = l / (t - a), this._weightNext = l / (o - i), this._offsetPrev = r * h, this._offsetNext = s * h
                }
                interpolate_(e, t, i, n) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = e * a,
                        l = o - a,
                        h = this._offsetPrev,
                        c = this._offsetNext,
                        u = this._weightPrev,
                        d = this._weightNext,
                        p = (i - t) / (n - t),
                        f = p * p,
                        m = f * p,
                        g = -u * m + 2 * u * f - u * p,
                        y = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1,
                        _ = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                        v = d * m - d * f;
                    for (let e = 0; e !== a; ++e) r[e] = g * s[h + e] + y * s[l + e] + _ * s[o + e] + v * s[c + e];
                    return r
                }
            }
            class Ih extends Ah {
                constructor(e, t, i, n) {
                    super(e, t, i, n)
                }
                interpolate_(e, t, i, n) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = e * a,
                        l = o - a,
                        h = (i - t) / (n - t),
                        c = 1 - h;
                    for (let e = 0; e !== a; ++e) r[e] = s[l + e] * c + s[o + e] * h;
                    return r
                }
            }
            class Ph extends Ah {
                constructor(e, t, i, n) {
                    super(e, t, i, n)
                }
                interpolate_(e) {
                    return this.copySampleValue_(e - 1)
                }
            }
            class Rh {
                constructor(e, t, i, n) {
                    if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e, this.times = Ch.convertArray(t, this.TimeBufferType), this.values = Ch.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
                }
                static toJSON(e) {
                    const t = e.constructor;
                    let i;
                    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
                    else {
                        i = {
                            name: e.name,
                            times: Ch.convertArray(e.times, Array),
                            values: Ch.convertArray(e.values, Array)
                        };
                        const t = e.getInterpolation();
                        t !== e.DefaultInterpolation && (i.interpolation = t)
                    }
                    return i.type = e.ValueTypeName, i
                }
                InterpolantFactoryMethodDiscrete(e) {
                    return new Ph(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new Ih(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodSmooth(e) {
                    return new Lh(this.times, this.values, this.getValueSize(), e)
                }
                setInterpolation(e) {
                    let t;
                    switch (e) {
                        case lt:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case ht:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case ct:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(t);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", t), this
                    }
                    return this.createInterpolant = t, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return lt;
                        case this.InterpolantFactoryMethodLinear:
                            return ht;
                        case this.InterpolantFactoryMethodSmooth:
                            return ct
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(e) {
                    if (0 !== e) {
                        const t = this.times;
                        for (let i = 0, n = t.length; i !== n; ++i) t[i] += e
                    }
                    return this
                }
                scale(e) {
                    if (1 !== e) {
                        const t = this.times;
                        for (let i = 0, n = t.length; i !== n; ++i) t[i] *= e
                    }
                    return this
                }
                trim(e, t) {
                    const i = this.times,
                        n = i.length;
                    let r = 0,
                        s = n - 1;
                    for (; r !== n && i[r] < e;) ++r;
                    for (; - 1 !== s && i[s] > t;) --s;
                    if (++s, 0 !== r || s !== n) {
                        r >= s && (s = Math.max(s, 1), r = s - 1);
                        const e = this.getValueSize();
                        this.times = Ch.arraySlice(i, r, s), this.values = Ch.arraySlice(this.values, r * e, s * e)
                    }
                    return this
                }
                validate() {
                    let e = !0;
                    const t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    const i = this.times,
                        n = this.values,
                        r = i.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    let s = null;
                    for (let t = 0; t !== r; t++) {
                        const n = i[t];
                        if ("number" == typeof n && isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, n), e = !1;
                            break
                        }
                        if (null !== s && s > n) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, t, n, s), e = !1;
                            break
                        }
                        s = n
                    }
                    if (void 0 !== n && Ch.isTypedArray(n))
                        for (let t = 0, i = n.length; t !== i; ++t) {
                            const i = n[t];
                            if (isNaN(i)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, i), e = !1;
                                break
                            }
                        }
                    return e
                }
                optimize() {
                    const e = Ch.arraySlice(this.times),
                        t = Ch.arraySlice(this.values),
                        i = this.getValueSize(),
                        n = this.getInterpolation() === ct,
                        r = e.length - 1;
                    let s = 1;
                    for (let a = 1; a < r; ++a) {
                        let r = !1;
                        const o = e[a];
                        if (o !== e[a + 1] && (1 !== a || o !== e[0]))
                            if (n) r = !0;
                            else {
                                const e = a * i,
                                    n = e - i,
                                    s = e + i;
                                for (let a = 0; a !== i; ++a) {
                                    const i = t[e + a];
                                    if (i !== t[n + a] || i !== t[s + a]) {
                                        r = !0;
                                        break
                                    }
                                }
                            }
                        if (r) {
                            if (a !== s) {
                                e[s] = e[a];
                                const n = a * i,
                                    r = s * i;
                                for (let e = 0; e !== i; ++e) t[r + e] = t[n + e]
                            }++s
                        }
                    }
                    if (r > 0) {
                        e[s] = e[r];
                        for (let e = r * i, n = s * i, a = 0; a !== i; ++a) t[n + a] = t[e + a];
                        ++s
                    }
                    return s !== e.length ? (this.times = Ch.arraySlice(e, 0, s), this.values = Ch.arraySlice(t, 0, s * i)) : (this.times = e, this.values = t), this
                }
                clone() {
                    const e = Ch.arraySlice(this.times, 0),
                        t = Ch.arraySlice(this.values, 0),
                        i = new(0, this.constructor)(this.name, e, t);
                    return i.createInterpolant = this.createInterpolant, i
                }
            }
            Rh.prototype.TimeBufferType = Float32Array, Rh.prototype.ValueBufferType = Float32Array, Rh.prototype.DefaultInterpolation = ht;
            class kh extends Rh {}
            kh.prototype.ValueTypeName = "bool", kh.prototype.ValueBufferType = Array, kh.prototype.DefaultInterpolation = lt, kh.prototype.InterpolantFactoryMethodLinear = void 0, kh.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Dh extends Rh {}
            Dh.prototype.ValueTypeName = "color";
            class Oh extends Rh {}
            Oh.prototype.ValueTypeName = "number";
            class Nh extends Ah {
                constructor(e, t, i, n) {
                    super(e, t, i, n)
                }
                interpolate_(e, t, i, n) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        a = this.valueSize,
                        o = (i - t) / (n - t);
                    let l = e * a;
                    for (let e = l + a; l !== e; l += 4) si.slerpFlat(r, 0, s, l - a, s, l, o);
                    return r
                }
            }
            class Uh extends Rh {
                InterpolantFactoryMethodLinear(e) {
                    return new Nh(this.times, this.values, this.getValueSize(), e)
                }
            }
            Uh.prototype.ValueTypeName = "quaternion", Uh.prototype.DefaultInterpolation = ht, Uh.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Bh extends Rh {}
            Bh.prototype.ValueTypeName = "string", Bh.prototype.ValueBufferType = Array, Bh.prototype.DefaultInterpolation = lt, Bh.prototype.InterpolantFactoryMethodLinear = void 0, Bh.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Fh extends Rh {}
            Fh.prototype.ValueTypeName = "vector";
            class Hh {
                constructor(e, t = -1, i, n = 2500) {
                    this.name = e, this.tracks = i, this.duration = t, this.blendMode = n, this.uuid = Rt(), this.duration < 0 && this.resetDuration()
                }
                static parse(e) {
                    const t = [],
                        i = e.tracks,
                        n = 1 / (e.fps || 1);
                    for (let e = 0, r = i.length; e !== r; ++e) t.push(zh(i[e]).scale(n));
                    const r = new this(e.name, e.duration, t, e.blendMode);
                    return r.uuid = e.uuid, r
                }
                static toJSON(e) {
                    const t = [],
                        i = e.tracks,
                        n = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode
                        };
                    for (let e = 0, n = i.length; e !== n; ++e) t.push(Rh.toJSON(i[e]));
                    return n
                }
                static CreateFromMorphTargetSequence(e, t, i, n) {
                    const r = t.length,
                        s = [];
                    for (let e = 0; e < r; e++) {
                        let a = [],
                            o = [];
                        a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
                        const l = Ch.getKeyframeOrder(a);
                        a = Ch.sortedArray(a, 1, l), o = Ch.sortedArray(o, 1, l), n || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new Oh(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(1 / i))
                    }
                    return new this(e, -1, s)
                }
                static findByName(e, t) {
                    let i = e;
                    if (!Array.isArray(e)) {
                        const t = e;
                        i = t.geometry && t.geometry.animations || t.animations
                    }
                    for (let e = 0; e < i.length; e++)
                        if (i[e].name === t) return i[e];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(e, t, i) {
                    const n = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let t = 0, i = e.length; t < i; t++) {
                        const i = e[t],
                            s = i.name.match(r);
                        if (s && s.length > 1) {
                            const e = s[1];
                            let t = n[e];
                            t || (n[e] = t = []), t.push(i)
                        }
                    }
                    const s = [];
                    for (const e in n) s.push(this.CreateFromMorphTargetSequence(e, n[e], t, i));
                    return s
                }
                static parseAnimation(e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    const i = function(e, t, i, n, r) {
                            if (0 !== i.length) {
                                const s = [],
                                    a = [];
                                Ch.flattenJSON(i, s, a, n), 0 !== s.length && r.push(new e(t, s, a))
                            }
                        },
                        n = [],
                        r = e.name || "default",
                        s = e.fps || 30,
                        a = e.blendMode;
                    let o = e.length || -1;
                    const l = e.hierarchy || [];
                    for (let e = 0; e < l.length; e++) {
                        const r = l[e].keys;
                        if (r && 0 !== r.length)
                            if (r[0].morphTargets) {
                                const e = {};
                                let t;
                                for (t = 0; t < r.length; t++)
                                    if (r[t].morphTargets)
                                        for (let i = 0; i < r[t].morphTargets.length; i++) e[r[t].morphTargets[i]] = -1;
                                for (const i in e) {
                                    const e = [],
                                        s = [];
                                    for (let n = 0; n !== r[t].morphTargets.length; ++n) {
                                        const n = r[t];
                                        e.push(n.time), s.push(n.morphTarget === i ? 1 : 0)
                                    }
                                    n.push(new Oh(".morphTargetInfluence[" + i + "]", e, s))
                                }
                                o = e.length * (s || 1)
                            } else {
                                const s = ".bones[" + t[e].name + "]";
                                i(Fh, s + ".position", r, "pos", n), i(Uh, s + ".quaternion", r, "rot", n), i(Fh, s + ".scale", r, "scl", n)
                            }
                    }
                    if (0 === n.length) return null;
                    return new this(r, o, n, a)
                }
                resetDuration() {
                    let e = 0;
                    for (let t = 0, i = this.tracks.length; t !== i; ++t) {
                        const i = this.tracks[t];
                        e = Math.max(e, i.times[i.times.length - 1])
                    }
                    return this.duration = e, this
                }
                trim() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                }
                validate() {
                    let e = !0;
                    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                }
                optimize() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
                clone() {
                    const e = [];
                    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new this.constructor(this.name, this.duration, e, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }

            function zh(e) {
                if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const t = function(e) {
                    switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Oh;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Fh;
                        case "color":
                            return Dh;
                        case "quaternion":
                            return Uh;
                        case "bool":
                        case "boolean":
                            return kh;
                        case "string":
                            return Bh
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }(e.type);
                if (void 0 === e.times) {
                    const t = [],
                        i = [];
                    Ch.flattenJSON(e.keys, t, i, "value"), e.times = t, e.values = i
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }
            const Vh = {
                enabled: !1,
                files: {},
                add: function(e, t) {
                    !1 !== this.enabled && (this.files[e] = t)
                },
                get: function(e) {
                    if (!1 !== this.enabled) return this.files[e]
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            };
            class Gh {
                constructor(e, t, i) {
                    const n = this;
                    let r, s = !1,
                        a = 0,
                        o = 0;
                    const l = [];
                    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(e) {
                        o++, !1 === s && void 0 !== n.onStart && n.onStart(e, a, o), s = !0
                    }, this.itemEnd = function(e) {
                        a++, void 0 !== n.onProgress && n.onProgress(e, a, o), a === o && (s = !1, void 0 !== n.onLoad && n.onLoad())
                    }, this.itemError = function(e) {
                        void 0 !== n.onError && n.onError(e)
                    }, this.resolveURL = function(e) {
                        return r ? r(e) : e
                    }, this.setURLModifier = function(e) {
                        return r = e, this
                    }, this.addHandler = function(e, t) {
                        return l.push(e, t), this
                    }, this.removeHandler = function(e) {
                        const t = l.indexOf(e);
                        return -1 !== t && l.splice(t, 2), this
                    }, this.getHandler = function(e) {
                        for (let t = 0, i = l.length; t < i; t += 2) {
                            const i = l[t],
                                n = l[t + 1];
                            if (i.global && (i.lastIndex = 0), i.test(e)) return n
                        }
                        return null
                    }
                }
            }
            const Wh = new Gh;
            class jh {
                constructor(e) {
                    this.manager = void 0 !== e ? e : Wh, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(e, t) {
                    const i = this;
                    return new Promise((function(n, r) {
                        i.load(e, n, t, r)
                    }))
                }
                parse() {}
                setCrossOrigin(e) {
                    return this.crossOrigin = e, this
                }
                setWithCredentials(e) {
                    return this.withCredentials = e, this
                }
                setPath(e) {
                    return this.path = e, this
                }
                setResourcePath(e) {
                    return this.resourcePath = e, this
                }
                setRequestHeader(e) {
                    return this.requestHeader = e, this
                }
            }
            const qh = {};
            class $h extends jh {
                constructor(e) {
                    super(e)
                }
                load(e, t, i, n) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = Vh.get(e);
                    if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => {
                        t && t(r), this.manager.itemEnd(e)
                    }), 0), r;
                    if (void 0 !== qh[e]) return void qh[e].push({
                        onLoad: t,
                        onProgress: i,
                        onError: n
                    });
                    qh[e] = [], qh[e].push({
                        onLoad: t,
                        onProgress: i,
                        onError: n
                    });
                    const s = new Request(e, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin"
                        }),
                        a = this.mimeType,
                        o = this.responseType;
                    fetch(s).then((t => {
                        if (200 === t.status || 0 === t.status) {
                            if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body.getReader) return t;
                            const i = qh[e],
                                n = t.body.getReader(),
                                r = t.headers.get("Content-Length"),
                                s = r ? parseInt(r) : 0,
                                a = 0 !== s;
                            let o = 0;
                            const l = new ReadableStream({
                                start(e) {
                                    ! function t() {
                                        n.read().then((({
                                            done: n,
                                            value: r
                                        }) => {
                                            if (n) e.close();
                                            else {
                                                o += r.byteLength;
                                                const n = new ProgressEvent("progress", {
                                                    lengthComputable: a,
                                                    loaded: o,
                                                    total: s
                                                });
                                                for (let e = 0, t = i.length; e < t; e++) {
                                                    const t = i[e];
                                                    t.onProgress && t.onProgress(n)
                                                }
                                                e.enqueue(r), t()
                                            }
                                        }))
                                    }()
                                }
                            });
                            return new Response(l)
                        }
                        throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)
                    })).then((e => {
                        switch (o) {
                            case "arraybuffer":
                                return e.arrayBuffer();
                            case "blob":
                                return e.blob();
                            case "document":
                                return e.text().then((e => (new DOMParser).parseFromString(e, a)));
                            case "json":
                                return e.json();
                            default:
                                if (void 0 === a) return e.text(); {
                                    const t = /charset="?([^;"\s]*)"?/i.exec(a),
                                        i = t && t[1] ? t[1].toLowerCase() : void 0,
                                        n = new TextDecoder(i);
                                    return e.arrayBuffer().then((e => n.decode(e)))
                                }
                        }
                    })).then((t => {
                        Vh.add(e, t);
                        const i = qh[e];
                        delete qh[e];
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            n.onLoad && n.onLoad(t)
                        }
                    })).catch((t => {
                        const i = qh[e];
                        if (void 0 === i) throw this.manager.itemError(e), t;
                        delete qh[e];
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            n.onError && n.onError(t)
                        }
                        this.manager.itemError(e)
                    })).finally((() => {
                        this.manager.itemEnd(e)
                    })), this.manager.itemStart(e)
                }
                setResponseType(e) {
                    return this.responseType = e, this
                }
                setMimeType(e) {
                    return this.mimeType = e, this
                }
            }
            class Xh extends jh {
                constructor(e) {
                    super(e)
                }
                load(e, t, i, n) {
                    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = this,
                        s = Vh.get(e);
                    if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function() {
                        t && t(s), r.manager.itemEnd(e)
                    }), 0), s;
                    const a = Gt("img");

                    function o() {
                        h(), Vh.add(e, this), t && t(this), r.manager.itemEnd(e)
                    }

                    function l(t) {
                        h(), n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }

                    function h() {
                        a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
                    }
                    return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a
                }
            }
            class Yh extends jh {
                constructor(e) {
                    super(e)
                }
                load(e, t, i, n) {
                    const r = new dr,
                        s = new Xh(this.manager);
                    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                    let a = 0;

                    function o(i) {
                        s.load(e[i], (function(e) {
                            r.images[i] = e, a++, 6 === a && (r.needsUpdate = !0, t && t(r))
                        }), void 0, n)
                    }
                    for (let t = 0; t < e.length; ++t) o(t);
                    return r
                }
            }
            class Kh extends jh {
                constructor(e) {
                    super(e)
                }
                load(e, t, i, n) {
                    const r = new ei,
                        s = new Xh(this.manager);
                    return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function(e) {
                        r.image = e, r.needsUpdate = !0, void 0 !== t && t(r)
                    }), i, n), r
                }
            }
            class Jh extends hn {
                constructor(e, t = 1) {
                    super(), this.type = "Light", this.color = new Kt(e), this.intensity = t
                }
                dispose() {}
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }
            Jh.prototype.isLight = !0;
            class Zh extends Jh {
                constructor(e, t, i) {
                    super(e, i), this.type = "HemisphereLight", this.position.copy(hn.DefaultUp), this.updateMatrix(), this.groundColor = new Kt(t)
                }
                copy(e) {
                    return Jh.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
                }
            }
            Zh.prototype.isHemisphereLight = !0;
            const Qh = new Ui,
                ec = new ai,
                tc = new ai;
            class ic {
                constructor(e) {
                    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ht(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ui, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new br, this._frameExtents = new Ht(1, 1), this._viewportCount = 1, this._viewports = [new ii(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(e) {
                    const t = this.camera,
                        i = this.matrix;
                    ec.setFromMatrixPosition(e.matrixWorld), t.position.copy(ec), tc.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(tc), t.updateMatrixWorld(), Qh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Qh), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(t.projectionMatrix), i.multiply(t.matrixWorldInverse)
                }
                getViewport(e) {
                    return this._viewports[e]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }
            class nc extends ic {
                constructor() {
                    super(new hr(50, 1, .5, 500)), this.focus = 1
                }
                updateMatrices(e) {
                    const t = this.camera,
                        i = 2 * Pt * e.angle * this.focus,
                        n = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    i === t.fov && n === t.aspect && r === t.far || (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
                }
                copy(e) {
                    return super.copy(e), this.focus = e.focus, this
                }
            }
            nc.prototype.isSpotLightShadow = !0;
            class rc extends Jh {
                constructor(e, t, i = 0, n = Math.PI / 3, r = 0, s = 1) {
                    super(e, t), this.type = "SpotLight", this.position.copy(hn.DefaultUp), this.updateMatrix(), this.target = new hn, this.distance = i, this.angle = n, this.penumbra = r, this.decay = s, this.shadow = new nc
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / Math.PI
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            rc.prototype.isSpotLight = !0;
            const sc = new Ui,
                ac = new ai,
                oc = new ai;
            class lc extends ic {
                constructor() {
                    super(new hr(90, 1, .5, 500)), this._frameExtents = new Ht(4, 2), this._viewportCount = 6, this._viewports = [new ii(2, 1, 1, 1), new ii(0, 1, 1, 1), new ii(3, 1, 1, 1), new ii(1, 1, 1, 1), new ii(3, 0, 1, 1), new ii(1, 0, 1, 1)], this._cubeDirections = [new ai(1, 0, 0), new ai(-1, 0, 0), new ai(0, 0, 1), new ai(0, 0, -1), new ai(0, 1, 0), new ai(0, -1, 0)], this._cubeUps = [new ai(0, 1, 0), new ai(0, 1, 0), new ai(0, 1, 0), new ai(0, 1, 0), new ai(0, 0, 1), new ai(0, 0, -1)]
                }
                updateMatrices(e, t = 0) {
                    const i = this.camera,
                        n = this.matrix,
                        r = e.distance || i.far;
                    r !== i.far && (i.far = r, i.updateProjectionMatrix()), ac.setFromMatrixPosition(e.matrixWorld), i.position.copy(ac), oc.copy(i.position), oc.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(oc), i.updateMatrixWorld(), n.makeTranslation(-ac.x, -ac.y, -ac.z), sc.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sc)
                }
            }
            lc.prototype.isPointLightShadow = !0;
            class hc extends Jh {
                constructor(e, t, i = 0, n = 1) {
                    super(e, t), this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new lc
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / (4 * Math.PI)
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }
            hc.prototype.isPointLight = !0;
            class cc extends ic {
                constructor() {
                    super(new kr(-5, 5, 5, -5, .5, 500))
                }
            }
            cc.prototype.isDirectionalLightShadow = !0;
            class uc extends Jh {
                constructor(e, t) {
                    super(e, t), this.type = "DirectionalLight", this.position.copy(hn.DefaultUp), this.updateMatrix(), this.target = new hn, this.shadow = new cc
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            uc.prototype.isDirectionalLight = !0;
            class dc extends Jh {
                constructor(e, t) {
                    super(e, t), this.type = "AmbientLight"
                }
            }
            dc.prototype.isAmbientLight = !0;
            class pc extends Jh {
                constructor(e, t, i = 10, n = 10) {
                    super(e, t), this.type = "RectAreaLight", this.width = i, this.height = n
                }
                get power() {
                    return this.intensity * this.width * this.height * Math.PI
                }
                set power(e) {
                    this.intensity = e / (this.width * this.height * Math.PI)
                }
                copy(e) {
                    return super.copy(e), this.width = e.width, this.height = e.height, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            }
            pc.prototype.isRectAreaLight = !0;
            class fc {
                constructor() {
                    this.coefficients = [];
                    for (let e = 0; e < 9; e++) this.coefficients.push(new ai)
                }
                set(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                    return this
                }
                zero() {
                    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                    return this
                }
                getAt(e, t) {
                    const i = e.x,
                        n = e.y,
                        r = e.z,
                        s = this.coefficients;
                    return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * n), t.addScaledVector(s[2], .488603 * r), t.addScaledVector(s[3], .488603 * i), t.addScaledVector(s[4], i * n * 1.092548), t.addScaledVector(s[5], n * r * 1.092548), t.addScaledVector(s[6], .315392 * (3 * r * r - 1)), t.addScaledVector(s[7], i * r * 1.092548), t.addScaledVector(s[8], .546274 * (i * i - n * n)), t
                }
                getIrradianceAt(e, t) {
                    const i = e.x,
                        n = e.y,
                        r = e.z,
                        s = this.coefficients;
                    return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * n), t.addScaledVector(s[2], 1.023328 * r), t.addScaledVector(s[3], 1.023328 * i), t.addScaledVector(s[4], .858086 * i * n), t.addScaledVector(s[5], .858086 * n * r), t.addScaledVector(s[6], .743125 * r * r - .247708), t.addScaledVector(s[7], .858086 * i * r), t.addScaledVector(s[8], .429043 * (i * i - n * n)), t
                }
                add(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                    return this
                }
                addScaledSH(e, t) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(e.coefficients[i], t);
                    return this
                }
                scale(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                    return this
                }
                lerp(e, t) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
                    return this
                }
                equals(e) {
                    for (let t = 0; t < 9; t++)
                        if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                    return !0
                }
                copy(e) {
                    return this.set(e.coefficients)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                fromArray(e, t = 0) {
                    const i = this.coefficients;
                    for (let n = 0; n < 9; n++) i[n].fromArray(e, t + 3 * n);
                    return this
                }
                toArray(e = [], t = 0) {
                    const i = this.coefficients;
                    for (let n = 0; n < 9; n++) i[n].toArray(e, t + 3 * n);
                    return e
                }
                static getBasisAt(e, t) {
                    const i = e.x,
                        n = e.y,
                        r = e.z;
                    t[0] = .282095, t[1] = .488603 * n, t[2] = .488603 * r, t[3] = .488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * i * r, t[8] = .546274 * (i * i - n * n)
                }
            }
            fc.prototype.isSphericalHarmonics3 = !0;
            class mc extends Jh {
                constructor(e = new fc, t = 1) {
                    super(void 0, t), this.sh = e
                }
                copy(e) {
                    return super.copy(e), this.sh.copy(e.sh), this
                }
                fromJSON(e) {
                    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.sh = this.sh.toArray(), t
                }
            }
            mc.prototype.isLightProbe = !0;
            class gc {
                static decodeText(e) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                    let t = "";
                    for (let i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
                    try {
                        return decodeURIComponent(escape(t))
                    } catch (e) {
                        return t
                    }
                }
                static extractUrlBase(e) {
                    const t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.substr(0, t + 1)
                }
                static resolveURL(e, t) {
                    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                }
            }
            class yc extends Un {
                constructor() {
                    super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                }
                copy(e) {
                    return super.copy(e), this.instanceCount = e.instanceCount, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const e = super.toJSON(this);
                    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
                }
            }
            yc.prototype.isInstancedBufferGeometry = !0;
            class _c extends jh {
                constructor(e) {
                    super(e), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                setOptions(e) {
                    return this.options = e, this
                }
                load(e, t, i, n) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = this,
                        s = Vh.get(e);
                    if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function() {
                        t && t(s), r.manager.itemEnd(e)
                    }), 0), s;
                    const a = {};
                    a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then((function(e) {
                        return e.blob()
                    })).then((function(e) {
                        return createImageBitmap(e, Object.assign(r.options, {
                            colorSpaceConversion: "none"
                        }))
                    })).then((function(i) {
                        Vh.add(e, i), t && t(i), r.manager.itemEnd(e)
                    })).catch((function(t) {
                        n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    })), r.manager.itemStart(e)
                }
            }
            let vc;
            _c.prototype.isImageBitmapLoader = !0;
            const bc = function() {
                return void 0 === vc && (vc = new(window.AudioContext || window.webkitAudioContext)), vc
            };
            class Tc extends jh {
                constructor(e) {
                    super(e)
                }
                load(e, t, i, n) {
                    const r = this,
                        s = new $h(this.manager);
                    s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function(i) {
                        try {
                            const e = i.slice(0);
                            bc().decodeAudioData(e, (function(e) {
                                t(e)
                            }))
                        } catch (t) {
                            n ? n(t) : console.error(t), r.manager.itemError(e)
                        }
                    }), i, n)
                }
            }(class extends mc {
                constructor(e, t, i = 1) {
                    super(void 0, i);
                    const n = (new Kt).set(e),
                        r = (new Kt).set(t),
                        s = new ai(n.r, n.g, n.b),
                        a = new ai(r.r, r.g, r.b),
                        o = Math.sqrt(Math.PI),
                        l = o * Math.sqrt(.75);
                    this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
                }
            }).prototype.isHemisphereLightProbe = !0;
            (class extends mc {
                constructor(e, t = 1) {
                    super(void 0, t);
                    const i = (new Kt).set(e);
                    this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                }
            }).prototype.isAmbientLightProbe = !0;
            class xc {
                constructor(e = !0) {
                    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = wc(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        const t = wc();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }

            function wc() {
                return ("undefined" == typeof performance ? Date : performance).now()
            }
            class Sc extends hn {
                constructor(e) {
                    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                }
                setMediaElementSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                }
                setMediaStreamSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                }
                setBuffer(e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(e = 0) {
                    if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    this._startedAt = this.context.currentTime + e;
                    const t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                stop() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(e) {
                    return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
                }
                setDetune(e) {
                    if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(e) {
                    return this.setFilters(e ? [e] : [])
                }
                setPlaybackRate(e) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                }
                setLoop(e) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                setLoopStart(e) {
                    return this.loopStart = e, this
                }
                setLoopEnd(e) {
                    return this.loopEnd = e, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }
            class Ec {
                constructor(e, t, i) {
                    let n, r, s;
                    switch (this.binding = e, this.valueSize = i, t) {
                        case "quaternion":
                            n = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            n = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i);
                            break;
                        default:
                            n = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i)
                    }
                    this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                }
                accumulate(e, t) {
                    const i = this.buffer,
                        n = this.valueSize,
                        r = e * n + n;
                    let s = this.cumulativeWeight;
                    if (0 === s) {
                        for (let e = 0; e !== n; ++e) i[r + e] = i[e];
                        s = t
                    } else {
                        s += t;
                        const e = t / s;
                        this._mixBufferRegion(i, r, 0, e, n)
                    }
                    this.cumulativeWeight = s
                }
                accumulateAdditive(e) {
                    const t = this.buffer,
                        i = this.valueSize,
                        n = i * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, i), this.cumulativeWeightAdditive += e
                }
                apply(e) {
                    const t = this.valueSize,
                        i = this.buffer,
                        n = e * t + t,
                        r = this.cumulativeWeight,
                        s = this.cumulativeWeightAdditive,
                        a = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                        const e = t * this._origIndex;
                        this._mixBufferRegion(i, n, e, 1 - r, t)
                    }
                    s > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
                    for (let e = t, r = t + t; e !== r; ++e)
                        if (i[e] !== i[e + t]) {
                            a.setValue(i, n);
                            break
                        }
                }
                saveOriginalState() {
                    const e = this.binding,
                        t = this.buffer,
                        i = this.valueSize,
                        n = i * this._origIndex;
                    e.getValue(t, n);
                    for (let e = i, r = n; e !== r; ++e) t[e] = t[n + e % i];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                }
                restoreOriginalState() {
                    const e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                }
                _setAdditiveIdentityNumeric() {
                    const e = this._addIndex * this.valueSize,
                        t = e + this.valueSize;
                    for (let i = e; i < t; i++) this.buffer[i] = 0
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                }
                _setAdditiveIdentityOther() {
                    const e = this._origIndex * this.valueSize,
                        t = this._addIndex * this.valueSize;
                    for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i]
                }
                _select(e, t, i, n, r) {
                    if (n >= .5)
                        for (let n = 0; n !== r; ++n) e[t + n] = e[i + n]
                }
                _slerp(e, t, i, n) {
                    si.slerpFlat(e, t, e, t, e, i, n)
                }
                _slerpAdditive(e, t, i, n, r) {
                    const s = this._workIndex * r;
                    si.multiplyQuaternionsFlat(e, s, e, t, e, i), si.slerpFlat(e, t, e, t, e, s, n)
                }
                _lerp(e, t, i, n, r) {
                    const s = 1 - n;
                    for (let a = 0; a !== r; ++a) {
                        const r = t + a;
                        e[r] = e[r] * s + e[i + a] * n
                    }
                }
                _lerpAdditive(e, t, i, n, r) {
                    for (let s = 0; s !== r; ++s) {
                        const r = t + s;
                        e[r] = e[r] + e[i + s] * n
                    }
                }
            }
            const Mc = "\\[\\]\\.:\\/",
                Cc = new RegExp("[" + Mc + "]", "g"),
                Ac = "[^" + Mc + "]",
                Lc = "[^" + Mc.replace("\\.", "") + "]",
                Ic = /((?:WC+[\/:])*)/.source.replace("WC", Ac),
                Pc = /(WCOD+)?/.source.replace("WCOD", Lc),
                Rc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ac),
                kc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ac),
                Dc = new RegExp("^" + Ic + Pc + Rc + kc + "$"),
                Oc = ["material", "materials", "bones"];
            class Nc {
                constructor(e, t, i) {
                    this.path = t, this.parsedPath = i || Nc.parseTrackName(t), this.node = Nc.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(e, t, i) {
                    return e && e.isAnimationObjectGroup ? new Nc.Composite(e, t, i) : new Nc(e, t, i)
                }
                static sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace(Cc, "")
                }
                static parseTrackName(e) {
                    const t = Dc.exec(e);
                    if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    const i = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        n = i.nodeName && i.nodeName.lastIndexOf(".");
                    if (void 0 !== n && -1 !== n) {
                        const e = i.nodeName.substring(n + 1); - 1 !== Oc.indexOf(e) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = e)
                    }
                    if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return i
                }
                static findNode(e, t) {
                    if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        const i = e.skeleton.getBoneByName(t);
                        if (void 0 !== i) return i
                    }
                    if (e.children) {
                        const i = function(e) {
                                for (let n = 0; n < e.length; n++) {
                                    const r = e[n];
                                    if (r.name === t || r.uuid === t) return r;
                                    const s = i(r.children);
                                    if (s) return s
                                }
                                return null
                            },
                            n = i(e.children);
                        if (n) return n
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName]
                }
                _getValue_array(e, t) {
                    const i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) e[t++] = i[n]
                }
                _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }
                _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(e, t) {
                    const i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++]
                }
                _setValue_array_setNeedsUpdate(e, t) {
                    const i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                    const i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(e, t) {
                    this.bind(), this.getValue(e, t)
                }
                _setValue_unbound(e, t) {
                    this.bind(), this.setValue(e, t)
                }
                bind() {
                    let e = this.node;
                    const t = this.parsedPath,
                        i = t.objectName,
                        n = t.propertyName;
                    let r = t.propertyIndex;
                    if (e || (e = Nc.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (i) {
                        let n = t.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                e = e.skeleton.bones;
                                for (let t = 0; t < e.length; t++)
                                    if (e[t].name === n) {
                                        n = t;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                e = e[i]
                        }
                        if (void 0 !== n) {
                            if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[n]
                        }
                    }
                    const s = e[n];
                    if (void 0 === s) {
                        const i = t.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", e)
                    }
                    let a = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                    let o = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                        }
                        o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            Nc.Composite = class {
                constructor(e, t, i) {
                    const n = i || Nc.parseTrackName(t);
                    this._targetGroup = e, this._bindings = e.subscribe_(t, n)
                }
                getValue(e, t) {
                    this.bind();
                    const i = this._targetGroup.nCachedObjects_,
                        n = this._bindings[i];
                    void 0 !== n && n.getValue(e, t)
                }
                setValue(e, t) {
                    const i = this._bindings;
                    for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t)
                }
                bind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
                }
                unbind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
                }
            }, Nc.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, Nc.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, Nc.prototype.GetterByBindingType = [Nc.prototype._getValue_direct, Nc.prototype._getValue_array, Nc.prototype._getValue_arrayElement, Nc.prototype._getValue_toArray], Nc.prototype.SetterByBindingTypeAndVersioning = [
                [Nc.prototype._setValue_direct, Nc.prototype._setValue_direct_setNeedsUpdate, Nc.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [Nc.prototype._setValue_array, Nc.prototype._setValue_array_setNeedsUpdate, Nc.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [Nc.prototype._setValue_arrayElement, Nc.prototype._setValue_arrayElement_setNeedsUpdate, Nc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [Nc.prototype._setValue_fromArray, Nc.prototype._setValue_fromArray_setNeedsUpdate, Nc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            class Uc {
                constructor(e, t, i = null, n = t.blendMode) {
                    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = n;
                    const r = t.tracks,
                        s = r.length,
                        a = new Array(s),
                        o = {
                            endingStart: ut,
                            endingEnd: ut
                        };
                    for (let e = 0; e !== s; ++e) {
                        const t = r[e].createInterpolant(null);
                        a[e] = t, t.settings = o
                    }
                    this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(e) {
                    return this._startTime = e, this
                }
                setLoop(e, t) {
                    return this.loop = e, this.repetitions = t, this
                }
                setEffectiveWeight(e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(e) {
                    return this._scheduleFading(e, 0, 1)
                }
                fadeOut(e) {
                    return this._scheduleFading(e, 1, 0)
                }
                crossFadeFrom(e, t, i) {
                    if (e.fadeOut(t), this.fadeIn(t), i) {
                        const i = this._clip.duration,
                            n = e._clip.duration,
                            r = n / i,
                            s = i / n;
                        e.warp(1, r, t), this.warp(s, 1, t)
                    }
                    return this
                }
                crossFadeTo(e, t, i) {
                    return e.crossFadeFrom(this, t, i)
                }
                stopFading() {
                    const e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                setEffectiveTimeScale(e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                }
                syncWith(e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                }
                halt(e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                }
                warp(e, t, i) {
                    const n = this._mixer,
                        r = n.time,
                        s = this.timeScale;
                    let a = this._timeScaleInterpolant;
                    null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
                    const o = a.parameterPositions,
                        l = a.sampleValues;
                    return o[0] = r, o[1] = r + i, l[0] = e / s, l[1] = t / s, this
                }
                stopWarping() {
                    const e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(e, t, i, n) {
                    if (!this.enabled) return void this._updateWeight(e);
                    const r = this._startTime;
                    if (null !== r) {
                        const n = (e - r) * i;
                        if (n < 0 || 0 === i) return;
                        this._startTime = null, t = i * n
                    }
                    t *= this._updateTimeScale(e);
                    const s = this._updateTime(t),
                        a = this._updateWeight(e);
                    if (a > 0) {
                        const e = this._interpolants,
                            t = this._propertyBindings;
                        if (2501 === this.blendMode)
                            for (let i = 0, n = e.length; i !== n; ++i) e[i].evaluate(s), t[i].accumulateAdditive(a);
                        else
                            for (let i = 0, r = e.length; i !== r; ++i) e[i].evaluate(s), t[i].accumulate(n, a)
                    }
                }
                _updateWeight(e) {
                    let t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        const i = this._weightInterpolant;
                        if (null !== i) {
                            const n = i.evaluate(e)[0];
                            t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                }
                _updateTimeScale(e) {
                    let t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        const i = this._timeScaleInterpolant;
                        if (null !== i) {
                            t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                        }
                    }
                    return this._effectiveTimeScale = t, t
                }
                _updateTime(e) {
                    const t = this._clip.duration,
                        i = this.loop;
                    let n = this.time + e,
                        r = this._loopCount;
                    const s = 2202 === i;
                    if (0 === e) return -1 === r ? n : s && 1 == (1 & r) ? t - n : n;
                    if (2200 === i) {
                        -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        e: {
                            if (n >= t) n = t;
                            else {
                                if (!(n < 0)) {
                                    this.time = n;
                                    break e
                                }
                                n = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = n,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), n >= t || n < 0) {
                            const i = Math.floor(n / t);
                            n -= t * i, r += Math.abs(i);
                            const a = this.repetitions - r;
                            if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                            else {
                                if (1 === a) {
                                    const t = e < 0;
                                    this._setEndings(t, !t, s)
                                } else this._setEndings(!1, !1, s);
                                this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: i
                                })
                            }
                        } else this.time = n;
                        if (s && 1 == (1 & r)) return t - n
                    }
                    return n
                }
                _setEndings(e, t, i) {
                    const n = this._interpolantSettings;
                    i ? (n.endingStart = dt, n.endingEnd = dt) : (n.endingStart = e ? this.zeroSlopeAtStart ? dt : ut : pt, n.endingEnd = t ? this.zeroSlopeAtEnd ? dt : ut : pt)
                }
                _scheduleFading(e, t, i) {
                    const n = this._mixer,
                        r = n.time;
                    let s = this._weightInterpolant;
                    null === s && (s = n._lendControlInterpolant(), this._weightInterpolant = s);
                    const a = s.parameterPositions,
                        o = s.sampleValues;
                    return a[0] = r, o[0] = t, a[1] = r + e, o[1] = i, this
                }
            }(class extends Ct {
                constructor(e) {
                    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                }
                _bindAction(e, t) {
                    const i = e._localRoot || this._root,
                        n = e._clip.tracks,
                        r = n.length,
                        s = e._propertyBindings,
                        a = e._interpolants,
                        o = i.uuid,
                        l = this._bindingsByRootAndName;
                    let h = l[o];
                    void 0 === h && (h = {}, l[o] = h);
                    for (let e = 0; e !== r; ++e) {
                        const r = n[e],
                            l = r.name;
                        let c = h[l];
                        if (void 0 !== c) ++c.referenceCount, s[e] = c;
                        else {
                            if (c = s[e], void 0 !== c) {
                                null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, o, l));
                                continue
                            }
                            const n = t && t._propertyBindings[e].binding.parsedPath;
                            c = new Ec(Nc.create(i, l, n), r.ValueTypeName, r.getValueSize()), ++c.referenceCount, this._addInactiveBinding(c, o, l), s[e] = c
                        }
                        a[e].resultBuffer = c.buffer
                    }
                }
                _activateAction(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            const t = (e._localRoot || this._root).uuid,
                                i = e._clip.uuid,
                                n = this._actionsByClip[i];
                            this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t)
                        }
                        const t = e._propertyBindings;
                        for (let e = 0, i = t.length; e !== i; ++e) {
                            const i = t[e];
                            0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                }
                _deactivateAction(e) {
                    if (this._isActiveAction(e)) {
                        const t = e._propertyBindings;
                        for (let e = 0, i = t.length; e !== i; ++e) {
                            const i = t[e];
                            0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                        }
                        this._takeBackAction(e)
                    }
                }
                _initMemoryManager() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    const e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                }
                _isActiveAction(e) {
                    const t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                }
                _addInactiveAction(e, t, i) {
                    const n = this._actions,
                        r = this._actionsByClip;
                    let s = r[t];
                    if (void 0 === s) s = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, r[t] = s;
                    else {
                        const t = s.knownActions;
                        e._byClipCacheIndex = t.length, t.push(e)
                    }
                    e._cacheIndex = n.length, n.push(e), s.actionByRoot[i] = e
                }
                _removeInactiveAction(e) {
                    const t = this._actions,
                        i = t[t.length - 1],
                        n = e._cacheIndex;
                    i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null;
                    const r = e._clip.uuid,
                        s = this._actionsByClip,
                        a = s[r],
                        o = a.knownActions,
                        l = o[o.length - 1],
                        h = e._byClipCacheIndex;
                    l._byClipCacheIndex = h, o[h] = l, o.pop(), e._byClipCacheIndex = null;
                    delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(e)
                }
                _removeInactiveBindingsForAction(e) {
                    const t = e._propertyBindings;
                    for (let e = 0, i = t.length; e !== i; ++e) {
                        const i = t[e];
                        0 == --i.referenceCount && this._removeInactiveBinding(i)
                    }
                }
                _lendAction(e) {
                    const t = this._actions,
                        i = e._cacheIndex,
                        n = this._nActiveActions++,
                        r = t[n];
                    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
                }
                _takeBackAction(e) {
                    const t = this._actions,
                        i = e._cacheIndex,
                        n = --this._nActiveActions,
                        r = t[n];
                    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
                }
                _addInactiveBinding(e, t, i) {
                    const n = this._bindingsByRootAndName,
                        r = this._bindings;
                    let s = n[t];
                    void 0 === s && (s = {}, n[t] = s), s[i] = e, e._cacheIndex = r.length, r.push(e)
                }
                _removeInactiveBinding(e) {
                    const t = this._bindings,
                        i = e.binding,
                        n = i.rootNode.uuid,
                        r = i.path,
                        s = this._bindingsByRootAndName,
                        a = s[n],
                        o = t[t.length - 1],
                        l = e._cacheIndex;
                    o._cacheIndex = l, t[l] = o, t.pop(), delete a[r], 0 === Object.keys(a).length && delete s[n]
                }
                _lendBinding(e) {
                    const t = this._bindings,
                        i = e._cacheIndex,
                        n = this._nActiveBindings++,
                        r = t[n];
                    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
                }
                _takeBackBinding(e) {
                    const t = this._bindings,
                        i = e._cacheIndex,
                        n = --this._nActiveBindings,
                        r = t[n];
                    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
                }
                _lendControlInterpolant() {
                    const e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++;
                    let i = e[t];
                    return void 0 === i && (i = new Ih(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = t, e[t] = i), i
                }
                _takeBackControlInterpolant(e) {
                    const t = this._controlInterpolants,
                        i = e.__cacheIndex,
                        n = --this._nActiveControlInterpolants,
                        r = t[n];
                    e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r
                }
                clipAction(e, t, i) {
                    const n = t || this._root,
                        r = n.uuid;
                    let s = "string" == typeof e ? Hh.findByName(n, e) : e;
                    const a = null !== s ? s.uuid : e,
                        o = this._actionsByClip[a];
                    let l = null;
                    if (void 0 === i && (i = null !== s ? s.blendMode : ft), void 0 !== o) {
                        const e = o.actionByRoot[r];
                        if (void 0 !== e && e.blendMode === i) return e;
                        l = o.knownActions[0], null === s && (s = l._clip)
                    }
                    if (null === s) return null;
                    const h = new Uc(this, s, t, i);
                    return this._bindAction(h, l), this._addInactiveAction(h, a, r), h
                }
                existingAction(e, t) {
                    const i = t || this._root,
                        n = i.uuid,
                        r = "string" == typeof e ? Hh.findByName(i, e) : e,
                        s = r ? r.uuid : e,
                        a = this._actionsByClip[s];
                    return void 0 !== a && a.actionByRoot[n] || null
                }
                stopAllAction() {
                    const e = this._actions;
                    for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
                    return this
                }
                update(e) {
                    e *= this.timeScale;
                    const t = this._actions,
                        i = this._nActiveActions,
                        n = this.time += e,
                        r = Math.sign(e),
                        s = this._accuIndex ^= 1;
                    for (let a = 0; a !== i; ++a) {
                        t[a]._update(n, e, r, s)
                    }
                    const a = this._bindings,
                        o = this._nActiveBindings;
                    for (let e = 0; e !== o; ++e) a[e].apply(s);
                    return this
                }
                setTime(e) {
                    this.time = 0;
                    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                    return this.update(e)
                }
                getRoot() {
                    return this._root
                }
                uncacheClip(e) {
                    const t = this._actions,
                        i = e.uuid,
                        n = this._actionsByClip,
                        r = n[i];
                    if (void 0 !== r) {
                        const e = r.knownActions;
                        for (let i = 0, n = e.length; i !== n; ++i) {
                            const n = e[i];
                            this._deactivateAction(n);
                            const r = n._cacheIndex,
                                s = t[t.length - 1];
                            n._cacheIndex = null, n._byClipCacheIndex = null, s._cacheIndex = r, t[r] = s, t.pop(), this._removeInactiveBindingsForAction(n)
                        }
                        delete n[i]
                    }
                }
                uncacheRoot(e) {
                    const t = e.uuid,
                        i = this._actionsByClip;
                    for (const e in i) {
                        const n = i[e].actionByRoot[t];
                        void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                    const n = this._bindingsByRootAndName[t];
                    if (void 0 !== n)
                        for (const e in n) {
                            const t = n[e];
                            t.restoreOriginalState(), this._removeInactiveBinding(t)
                        }
                }
                uncacheAction(e, t) {
                    const i = this.existingAction(e, t);
                    null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
            }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
            class Bc {
                constructor(e) {
                    "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
                }
                clone() {
                    return new Bc(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }(class extends _o {
                constructor(e, t, i = 1) {
                    super(e, t), this.meshPerAttribute = i
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                clone(e) {
                    const t = super.clone(e);
                    return t.meshPerAttribute = this.meshPerAttribute, t
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
                }
            }).prototype.isInstancedInterleavedBuffer = !0;
            const Fc = new Ht;
            class Hc {
                constructor(e = new Ht(1 / 0, 1 / 0), t = new Ht(-1 / 0, -1 / 0)) {
                    this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const i = Fc.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return Fc.copy(e).clamp(this.min, this.max).sub(e).length()
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            Hc.prototype.isBox2 = !0;
            const zc = new ai,
                Vc = new Ui,
                Gc = new Ui;

            function Wc(e) {
                const t = [];
                e && e.isBone && t.push(e);
                for (let i = 0; i < e.children.length; i++) t.push.apply(t, Wc(e.children[i]));
                return t
            }
            const jc = new Float32Array(1);
            new Int32Array(jc.buffer);
            vl.create = function(e, t) {
                return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(vl.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
            }, Fl.prototype.fromPoints = function(e) {
                return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
            }, class extends hl {
                constructor(e = 10, t = 10, i = 4473924, n = 8947848) {
                    i = new Kt(i), n = new Kt(n);
                    const r = t / 2,
                        s = e / t,
                        a = e / 2,
                        o = [],
                        l = [];
                    for (let e = 0, h = 0, c = -a; e <= t; e++, c += s) {
                        o.push(-a, 0, c, a, 0, c), o.push(c, 0, -a, c, 0, a);
                        const t = e === r ? i : n;
                        t.toArray(l, h), h += 3, t.toArray(l, h), h += 3, t.toArray(l, h), h += 3, t.toArray(l, h), h += 3
                    }
                    const h = new Un;
                    h.setAttribute("position", new Ln(o, 3)), h.setAttribute("color", new Ln(l, 3));
                    super(h, new el({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "GridHelper"
                }
            }.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, class extends hl {
                constructor(e) {
                    const t = Wc(e),
                        i = new Un,
                        n = [],
                        r = [],
                        s = new Kt(0, 0, 1),
                        a = new Kt(0, 1, 0);
                    for (let e = 0; e < t.length; e++) {
                        const i = t[e];
                        i.parent && i.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b))
                    }
                    i.setAttribute("position", new Ln(n, 3)), i.setAttribute("color", new Ln(r, 3));
                    super(i, new el({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(e) {
                    const t = this.bones,
                        i = this.geometry,
                        n = i.getAttribute("position");
                    Gc.copy(this.root.matrixWorld).invert();
                    for (let e = 0, i = 0; e < t.length; e++) {
                        const r = t[e];
                        r.parent && r.parent.isBone && (Vc.multiplyMatrices(Gc, r.matrixWorld), zc.setFromMatrixPosition(Vc), n.setXYZ(i, zc.x, zc.y, zc.z), Vc.multiplyMatrices(Gc, r.parent.matrixWorld), zc.setFromMatrixPosition(Vc), n.setXYZ(i + 1, zc.x, zc.y, zc.z), i += 2)
                    }
                    i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
                }
            }.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, jh.prototype.extractUrlBase = function(e) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), gc.extractUrlBase(e)
            }, jh.Handlers = {
                add: function() {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function() {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            }, Hc.prototype.center = function(e) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
            }, Hc.prototype.empty = function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, Hc.prototype.isIntersectionBox = function(e) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            }, Hc.prototype.size = function(e) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
            }, hi.prototype.center = function(e) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
            }, hi.prototype.empty = function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, hi.prototype.isIntersectionBox = function(e) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            }, hi.prototype.isIntersectionSphere = function(e) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
            }, hi.prototype.size = function(e) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
            }, Ai.prototype.empty = function() {
                return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, br.prototype.setFromMatrix = function(e) {
                return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e)
            }, zt.prototype.flattenToArrayOffset = function(e, t) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
            }, zt.prototype.multiplyVector3 = function(e) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
            }, zt.prototype.multiplyVector3Array = function() {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            }, zt.prototype.applyToBufferAttribute = function(e) {
                return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
            }, zt.prototype.applyToVector3Array = function() {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }, zt.prototype.getInverse = function(e) {
                return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
            }, Ui.prototype.extractPosition = function(e) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
            }, Ui.prototype.flattenToArrayOffset = function(e, t) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
            }, Ui.prototype.getPosition = function() {
                return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new ai).setFromMatrixColumn(this, 3)
            }, Ui.prototype.setRotationFromQuaternion = function(e) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
            }, Ui.prototype.multiplyToArray = function() {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            }, Ui.prototype.multiplyVector3 = function(e) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            }, Ui.prototype.multiplyVector4 = function(e) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            }, Ui.prototype.multiplyVector3Array = function() {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            }, Ui.prototype.rotateAxis = function(e) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
            }, Ui.prototype.crossVector = function(e) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            }, Ui.prototype.translate = function() {
                console.error("THREE.Matrix4: .translate() has been removed.")
            }, Ui.prototype.rotateX = function() {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            }, Ui.prototype.rotateY = function() {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            }, Ui.prototype.rotateZ = function() {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            }, Ui.prototype.rotateByAxis = function() {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }, Ui.prototype.applyToBufferAttribute = function(e) {
                return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            }, Ui.prototype.applyToVector3Array = function() {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            }, Ui.prototype.makeFrustum = function(e, t, i, n, r, s) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, s)
            }, Ui.prototype.getInverse = function(e) {
                return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
            }, yr.prototype.isIntersectionLine = function(e) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
            }, si.prototype.multiplyVector3 = function(e) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
            }, si.prototype.inverse = function() {
                return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
            }, Ni.prototype.isIntersectionBox = function(e) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            }, Ni.prototype.isIntersectionPlane = function(e) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
            }, Ni.prototype.isIntersectionSphere = function(e) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
            }, bn.prototype.area = function() {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
            }, bn.prototype.barycoordFromPoint = function(e, t) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
            }, bn.prototype.midpoint = function(e) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
            }, bn.prototypenormal = function(e) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
            }, bn.prototype.plane = function(e) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
            }, bn.barycoordFromPoint = function(e, t, i, n, r) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), bn.getBarycoord(e, t, i, n, r)
            }, bn.normal = function(e, t, i, n) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), bn.getNormal(e, t, i, n)
            }, Hl.prototype.extractAllPoints = function(e) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
            }, Hl.prototype.extrude = function(e) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new mh(this, e)
            }, Hl.prototype.makeGeometry = function(e) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new yh(this, e)
            }, Ht.prototype.fromAttribute = function(e, t, i) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
            }, Ht.prototype.distanceToManhattan = function(e) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
            }, Ht.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, ai.prototype.setEulerFromRotationMatrix = function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }, ai.prototype.setEulerFromQuaternion = function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }, ai.prototype.getPositionFromMatrix = function(e) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
            }, ai.prototype.getScaleFromMatrix = function(e) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
            }, ai.prototype.getColumnFromMatrix = function(e, t) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
            }, ai.prototype.applyProjection = function(e) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
            }, ai.prototype.fromAttribute = function(e, t, i) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
            }, ai.prototype.distanceToManhattan = function(e) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
            }, ai.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, ii.prototype.fromAttribute = function(e, t, i) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
            }, ii.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, hn.prototype.getChildByName = function(e) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
            }, hn.prototype.renderDepth = function() {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            }, hn.prototype.translate = function(e, t) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
            }, hn.prototype.getWorldRotation = function() {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            }, hn.prototype.applyMatrix = function(e) {
                return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }, Object.defineProperties(hn.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(e) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), tr.prototype.setDrawMode = function() {
                console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }, Object.defineProperties(tr.prototype, {
                drawMode: {
                    get: function() {
                        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                    },
                    set: function() {
                        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }
            }), Vo.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, hr.prototype.setLens = function(e, t) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
            }, Object.defineProperties(Jh.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                    }
                },
                shadowCameraLeft: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                    }
                },
                shadowCameraRight: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                    }
                },
                shadowCameraTop: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                    }
                },
                shadowCameraBottom: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                    }
                },
                shadowCameraNear: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                    }
                },
                shadowCameraFar: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                    }
                },
                shadowMapHeight: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                    }
                }
            }), Object.defineProperties(Mn.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                dynamic: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === St
                    },
                    set: function() {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(St)
                    }
                }
            }), Mn.prototype.setDynamic = function(e) {
                return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? St : wt), this
            }, Mn.prototype.copyIndicesArray = function() {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            }, Mn.prototype.setArray = function() {
                console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, Un.prototype.addIndex = function(e) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
            }, Un.prototype.addAttribute = function(e, t) {
                return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new Mn(arguments[1], arguments[2])))
            }, Un.prototype.addDrawCall = function(e, t, i) {
                void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
            }, Un.prototype.clearDrawCalls = function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            }, Un.prototype.computeOffsets = function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }, Un.prototype.removeAttribute = function(e) {
                return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
            }, Un.prototype.applyMatrix = function(e) {
                return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }, Object.defineProperties(Un.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), _o.prototype.setDynamic = function(e) {
                return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? St : wt), this
            }, _o.prototype.setArray = function() {
                console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, mh.prototype.getArrays = function() {
                console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
            }, mh.prototype.addShapeList = function() {
                console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
            }, mh.prototype.addShape = function() {
                console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
            }, yo.prototype.dispose = function() {
                console.error("THREE.Scene: .dispose() has been removed.")
            }, Bc.prototype.onUpdate = function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }, Object.defineProperties(xn.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new Kt
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
                    }
                },
                stencilMask: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                    },
                    set: function(e) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
                    }
                },
                vertexTangents: {
                    get: function() {
                        console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                    },
                    set: function() {
                        console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                    }
                }
            }), Object.defineProperties(or.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(e) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                    }
                }
            }), fo.prototype.clearTarget = function(e, t, i, n) {
                console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, n)
            }, fo.prototype.animate = function(e) {
                console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
            }, fo.prototype.getCurrentRenderTarget = function() {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            }, fo.prototype.getMaxAnisotropy = function() {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            }, fo.prototype.getPrecision = function() {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            }, fo.prototype.resetGLState = function() {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            }, fo.prototype.supportsFloatTextures = function() {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            }, fo.prototype.supportsHalfFloatTextures = function() {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            }, fo.prototype.supportsStandardDerivatives = function() {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            }, fo.prototype.supportsCompressedTextureS3TC = function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            }, fo.prototype.supportsCompressedTexturePVRTC = function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            }, fo.prototype.supportsBlendMinMax = function() {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            }, fo.prototype.supportsVertexTextures = function() {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            }, fo.prototype.supportsInstancedArrays = function() {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            }, fo.prototype.enableScissorTest = function(e) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
            }, fo.prototype.initMaterial = function() {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            }, fo.prototype.addPrePlugin = function() {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            }, fo.prototype.addPostPlugin = function() {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            }, fo.prototype.updateShadowMap = function() {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }, fo.prototype.setFaceCulling = function() {
                console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
            }, fo.prototype.allocTextureUnit = function() {
                console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
            }, fo.prototype.setTexture = function() {
                console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
            }, fo.prototype.setTexture2D = function() {
                console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
            }, fo.prototype.setTextureCube = function() {
                console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
            }, fo.prototype.getActiveMipMapLevel = function() {
                return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
            }, Object.defineProperties(fo.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                context: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                    }
                },
                vr: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                    }
                },
                gammaInput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                    }
                },
                gammaOutput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? _t : yt
                    }
                },
                toneMappingWhitePoint: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                    }
                },
                gammaFactor: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                    }
                }
            }), Object.defineProperties(io.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(ni.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                    }
                }
            }), Sc.prototype.load = function(e) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                const t = this;
                return (new Tc).load(e, (function(e) {
                    t.setBuffer(e)
                })), this
            }, ur.prototype.updateCubeMap = function(e, t) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
            }, ur.prototype.clear = function(e, t, i, n) {
                return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, i, n)
            }, Zt.crossOrigin = void 0, Zt.loadTexture = function(e, t, i, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                const r = new Kh;
                r.setCrossOrigin(this.crossOrigin);
                const s = r.load(e, i, void 0, n);
                return t && (s.mapping = t), s
            }, Zt.loadTextureCube = function(e, t, i, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                const r = new Yh;
                r.setCrossOrigin(this.crossOrigin);
                const s = r.load(e, i, void 0, n);
                return t && (s.mapping = t), s
            }, Zt.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, Zt.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: n
                }
            })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = n)
        },
        5682: (e, t, i) => {
            "use strict";
            i.d(t, {
                C: () => r
            });
            var n = i(4599);
            class r extends n.xsS {
                constructor() {
                    super();
                    const e = new n.DvJ;
                    e.deleteAttribute("uv");
                    const t = new n.Wid({
                            side: n._Li
                        }),
                        i = new n.Wid,
                        r = new n.cek(16777215, 5, 28, 2);
                    r.position.set(.418, 16.199, .3), this.add(r);
                    const a = new n.Kj0(e, t);
                    a.position.set(-.757, 13.219, .717), a.scale.set(31.713, 28.305, 28.591), this.add(a);
                    const o = new n.Kj0(e, i);
                    o.position.set(-10.906, 2.009, 1.846), o.rotation.set(0, -.195, 0), o.scale.set(2.328, 7.905, 4.651), this.add(o);
                    const l = new n.Kj0(e, i);
                    l.position.set(-5.607, -.754, -.758), l.rotation.set(0, .994, 0), l.scale.set(1.97, 1.534, 3.955), this.add(l);
                    const h = new n.Kj0(e, i);
                    h.position.set(6.167, .857, 7.803), h.rotation.set(0, .561, 0), h.scale.set(3.927, 6.285, 3.687), this.add(h);
                    const c = new n.Kj0(e, i);
                    c.position.set(-2.017, .018, 6.124), c.rotation.set(0, .333, 0), c.scale.set(2.002, 4.566, 2.064), this.add(c);
                    const u = new n.Kj0(e, i);
                    u.position.set(2.291, -.756, -2.621), u.rotation.set(0, -.286, 0), u.scale.set(1.546, 1.552, 1.496), this.add(u);
                    const d = new n.Kj0(e, i);
                    d.position.set(-2.193, -.369, -5.547), d.rotation.set(0, .516, 0), d.scale.set(3.875, 3.487, 2.986), this.add(d);
                    const p = new n.Kj0(e, s(50));
                    p.position.set(-16.116, 14.37, 8.208), p.scale.set(.1, 2.428, 2.739), this.add(p);
                    const f = new n.Kj0(e, s(50));
                    f.position.set(-16.109, 18.021, -8.207), f.scale.set(.1, 2.425, 2.751), this.add(f);
                    const m = new n.Kj0(e, s(17));
                    m.position.set(14.904, 12.198, -1.832), m.scale.set(.15, 4.265, 6.331), this.add(m);
                    const g = new n.Kj0(e, s(43));
                    g.position.set(-.462, 8.89, 14.52), g.scale.set(4.38, 5.441, .088), this.add(g);
                    const y = new n.Kj0(e, s(20));
                    y.position.set(3.235, 11.486, -12.541), y.scale.set(2.5, 2, .1), this.add(y);
                    const _ = new n.Kj0(e, s(100));
                    _.position.set(0, 20, 0), _.scale.set(1, .1, 1), this.add(_)
                }
            }

            function s(e) {
                const t = new n.vBJ;
                return t.color.setScalar(e), t
            }
        },
        7428: (e, t, i) => {
            "use strict";
            i.d(t, {
                _: () => s
            });
            var n = i(4599);
            const r = new WeakMap;
            class s extends n.aNw {
                constructor(e) {
                    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                        position: "POSITION",
                        normal: "NORMAL",
                        color: "COLOR",
                        uv: "TEX_COORD"
                    }, this.defaultAttributeTypes = {
                        position: "Float32Array",
                        normal: "Float32Array",
                        color: "Float32Array",
                        uv: "Float32Array"
                    }
                }
                setDecoderPath(e) {
                    return this.decoderPath = e, this
                }
                setDecoderConfig(e) {
                    return this.decoderConfig = e, this
                }
                setWorkerLimit(e) {
                    return this.workerLimit = e, this
                }
                load(e, t, i, r) {
                    const s = new n.hH6(this.manager);
                    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (e => {
                        const i = {
                            attributeIDs: this.defaultAttributeIDs,
                            attributeTypes: this.defaultAttributeTypes,
                            useUniqueIDs: !1
                        };
                        this.decodeGeometry(e, i).then(t).catch(r)
                    }), i, r)
                }
                decodeDracoFile(e, t, i, n) {
                    const r = {
                        attributeIDs: i || this.defaultAttributeIDs,
                        attributeTypes: n || this.defaultAttributeTypes,
                        useUniqueIDs: !!i
                    };
                    this.decodeGeometry(e, r).then(t)
                }
                decodeGeometry(e, t) {
                    for (const e in t.attributeTypes) {
                        const i = t.attributeTypes[e];
                        void 0 !== i.BYTES_PER_ELEMENT && (t.attributeTypes[e] = i.name)
                    }
                    const i = JSON.stringify(t);
                    if (r.has(e)) {
                        const t = r.get(e);
                        if (t.key === i) return t.promise;
                        if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                    }
                    let n;
                    const s = this.workerNextTaskID++,
                        a = e.byteLength,
                        o = this._getWorker(s, a).then((i => (n = i, new Promise(((i, r) => {
                            n._callbacks[s] = {
                                resolve: i,
                                reject: r
                            }, n.postMessage({
                                type: "decode",
                                id: s,
                                taskConfig: t,
                                buffer: e
                            }, [e])
                        }))))).then((e => this._createGeometry(e.geometry)));
                    return o.catch((() => !0)).then((() => {
                        n && s && this._releaseTask(n, s)
                    })), r.set(e, {
                        key: i,
                        promise: o
                    }), o
                }
                _createGeometry(e) {
                    const t = new n.u9r;
                    e.index && t.setIndex(new n.TlE(e.index.array, 1));
                    for (let i = 0; i < e.attributes.length; i++) {
                        const r = e.attributes[i],
                            s = r.name,
                            a = r.array,
                            o = r.itemSize;
                        t.setAttribute(s, new n.TlE(a, o))
                    }
                    return t
                }
                _loadLibrary(e, t) {
                    const i = new n.hH6(this.manager);
                    return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise(((t, n) => {
                        i.load(e, t, void 0, n)
                    }))
                }
                preload() {
                    return this._initDecoder(), this
                }
                _initDecoder() {
                    if (this.decoderPending) return this.decoderPending;
                    const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                        t = [];
                    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                        const i = t[0];
                        e || (this.decoderConfig.wasmBinary = t[1]);
                        const n = a.toString(),
                            r = ["/* draco decoder */", i, "", "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                    })), this.decoderPending
                }
                _getWorker(e, t) {
                    return this._initDecoder().then((() => {
                        if (this.workerPool.length < this.workerLimit) {
                            const e = new Worker(this.workerSourceURL);
                            e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                                type: "init",
                                decoderConfig: this.decoderConfig
                            }), e.onmessage = function(t) {
                                const i = t.data;
                                switch (i.type) {
                                    case "decode":
                                        e._callbacks[i.id].resolve(i);
                                        break;
                                    case "error":
                                        e._callbacks[i.id].reject(i);
                                        break;
                                    default:
                                        console.error('THREE.DRACOLoader: Unexpected message, "' + i.type + '"')
                                }
                            }, this.workerPool.push(e)
                        } else this.workerPool.sort((function(e, t) {
                            return e._taskLoad > t._taskLoad ? -1 : 1
                        }));
                        const i = this.workerPool[this.workerPool.length - 1];
                        return i._taskCosts[e] = t, i._taskLoad += t, i
                    }))
                }
                _releaseTask(e, t) {
                    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
                }
                debug() {
                    console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
                }
                dispose() {
                    for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                    return this.workerPool.length = 0, this
                }
            }

            function a() {
                let e, t;

                function i(e, t, i, n, r, s) {
                    const a = s.num_components(),
                        o = i.num_points() * a,
                        l = o * r.BYTES_PER_ELEMENT,
                        h = function(e, t) {
                            switch (t) {
                                case Float32Array:
                                    return e.DT_FLOAT32;
                                case Int8Array:
                                    return e.DT_INT8;
                                case Int16Array:
                                    return e.DT_INT16;
                                case Int32Array:
                                    return e.DT_INT32;
                                case Uint8Array:
                                    return e.DT_UINT8;
                                case Uint16Array:
                                    return e.DT_UINT16;
                                case Uint32Array:
                                    return e.DT_UINT32
                            }
                        }(e, r),
                        c = e._malloc(l);
                    t.GetAttributeDataArrayForAllPoints(i, s, h, l, c);
                    const u = new r(e.HEAPF32.buffer, c, o).slice();
                    return e._free(c), {
                        name: n,
                        array: u,
                        itemSize: a
                    }
                }
                onmessage = function(n) {
                    const r = n.data;
                    switch (r.type) {
                        case "init":
                            e = r.decoderConfig, t = new Promise((function(t) {
                                e.onModuleLoaded = function(e) {
                                    t({
                                        draco: e
                                    })
                                }, DracoDecoderModule(e)
                            }));
                            break;
                        case "decode":
                            const n = r.buffer,
                                s = r.taskConfig;
                            t.then((e => {
                                const t = e.draco,
                                    a = new t.Decoder,
                                    o = new t.DecoderBuffer;
                                o.Init(new Int8Array(n), n.byteLength);
                                try {
                                    const e = function(e, t, n, r) {
                                            const s = r.attributeIDs,
                                                a = r.attributeTypes;
                                            let o, l;
                                            const h = t.GetEncodedGeometryType(n);
                                            if (h === e.TRIANGULAR_MESH) o = new e.Mesh, l = t.DecodeBufferToMesh(n, o);
                                            else {
                                                if (h !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                                o = new e.PointCloud, l = t.DecodeBufferToPointCloud(n, o)
                                            }
                                            if (!l.ok() || 0 === o.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                            const c = {
                                                index: null,
                                                attributes: []
                                            };
                                            for (const n in s) {
                                                const l = self[a[n]];
                                                let h, u;
                                                if (r.useUniqueIDs) u = s[n], h = t.GetAttributeByUniqueId(o, u);
                                                else {
                                                    if (u = t.GetAttributeId(o, e[s[n]]), -1 === u) continue;
                                                    h = t.GetAttribute(o, u)
                                                }
                                                c.attributes.push(i(e, t, o, n, l, h))
                                            }
                                            h === e.TRIANGULAR_MESH && (c.index = function(e, t, i) {
                                                const n = i.num_faces(),
                                                    r = 3 * n,
                                                    s = 4 * r,
                                                    a = e._malloc(s);
                                                t.GetTrianglesUInt32Array(i, s, a);
                                                const o = new Uint32Array(e.HEAPF32.buffer, a, r).slice();
                                                return e._free(a), {
                                                    array: o,
                                                    itemSize: 1
                                                }
                                            }(e, t, o));
                                            return e.destroy(o), c
                                        }(t, a, o, s),
                                        n = e.attributes.map((e => e.array.buffer));
                                    e.index && n.push(e.index.array.buffer), self.postMessage({
                                        type: "decode",
                                        id: r.id,
                                        geometry: e
                                    }, n)
                                } catch (e) {
                                    console.error(e), self.postMessage({
                                        type: "error",
                                        id: r.id,
                                        error: e.message
                                    })
                                } finally {
                                    t.destroy(o), t.destroy(a)
                                }
                            }))
                    }
                }
            }
        },
        3306: (e, t, i) => {
            "use strict";
            i.d(t, {
                E: () => r
            });
            var n = i(4599);
            class r extends n.aNw {
                constructor(e) {
                    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
                        return new h(e)
                    })), this.register((function(e) {
                        return new m(e)
                    })), this.register((function(e) {
                        return new g(e)
                    })), this.register((function(e) {
                        return new c(e)
                    })), this.register((function(e) {
                        return new u(e)
                    })), this.register((function(e) {
                        return new d(e)
                    })), this.register((function(e) {
                        return new p(e)
                    })), this.register((function(e) {
                        return new f(e)
                    })), this.register((function(e) {
                        return new o(e)
                    })), this.register((function(e) {
                        return new y(e)
                    }))
                }
                load(e, t, i, r) {
                    const s = this;
                    let a;
                    a = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : n.Zp0.extractUrlBase(e), this.manager.itemStart(e);
                    const o = function(t) {
                            r ? r(t) : console.error(t), s.manager.itemError(e), s.manager.itemEnd(e)
                        },
                        l = new n.hH6(this.manager);
                    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, (function(i) {
                        try {
                            s.parse(i, a, (function(i) {
                                t(i), s.manager.itemEnd(e)
                            }), o)
                        } catch (e) {
                            o(e)
                        }
                    }), i, o)
                }
                setDRACOLoader(e) {
                    return this.dracoLoader = e, this
                }
                setDDSLoader() {
                    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                }
                setKTX2Loader(e) {
                    return this.ktx2Loader = e, this
                }
                setMeshoptDecoder(e) {
                    return this.meshoptDecoder = e, this
                }
                register(e) {
                    return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
                }
                unregister(e) {
                    return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
                }
                parse(e, t, i, r) {
                    let s;
                    const o = {},
                        h = {};
                    if ("string" == typeof e) s = e;
                    else {
                        if (n.Zp0.decodeText(new Uint8Array(e, 0, 4)) === _) {
                            try {
                                o[a.KHR_BINARY_GLTF] = new T(e)
                            } catch (e) {
                                return void(r && r(e))
                            }
                            s = o[a.KHR_BINARY_GLTF].content
                        } else s = n.Zp0.decodeText(new Uint8Array(e))
                    }
                    const c = JSON.parse(s);
                    if (void 0 === c.asset || c.asset.version[0] < 2) return void(r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                    const u = new Q(c, {
                        path: t || this.resourcePath || "",
                        crossOrigin: this.crossOrigin,
                        requestHeader: this.requestHeader,
                        manager: this.manager,
                        ktx2Loader: this.ktx2Loader,
                        meshoptDecoder: this.meshoptDecoder
                    });
                    u.fileLoader.setRequestHeader(this.requestHeader);
                    for (let e = 0; e < this.pluginCallbacks.length; e++) {
                        const t = this.pluginCallbacks[e](u);
                        h[t.name] = t, o[t.name] = !0
                    }
                    if (c.extensionsUsed)
                        for (let e = 0; e < c.extensionsUsed.length; ++e) {
                            const t = c.extensionsUsed[e],
                                i = c.extensionsRequired || [];
                            switch (t) {
                                case a.KHR_MATERIALS_UNLIT:
                                    o[t] = new l;
                                    break;
                                case a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                    o[t] = new E;
                                    break;
                                case a.KHR_DRACO_MESH_COMPRESSION:
                                    o[t] = new x(c, this.dracoLoader);
                                    break;
                                case a.KHR_TEXTURE_TRANSFORM:
                                    o[t] = new w;
                                    break;
                                case a.KHR_MESH_QUANTIZATION:
                                    o[t] = new M;
                                    break;
                                default:
                                    i.indexOf(t) >= 0 && void 0 === h[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                            }
                        }
                    u.setExtensions(o), u.setPlugins(h), u.parse(i, r)
                }
                parseAsync(e, t) {
                    const i = this;
                    return new Promise((function(n, r) {
                        i.parse(e, t, n, r)
                    }))
                }
            }

            function s() {
                let e = {};
                return {
                    get: function(t) {
                        return e[t]
                    },
                    add: function(t, i) {
                        e[t] = i
                    },
                    remove: function(t) {
                        delete e[t]
                    },
                    removeAll: function() {
                        e = {}
                    }
                }
            }
            const a = {
                KHR_BINARY_GLTF: "KHR_binary_glTF",
                KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                KHR_MATERIALS_IOR: "KHR_materials_ior",
                KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                EXT_TEXTURE_WEBP: "EXT_texture_webp",
                EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
            };
            class o {
                constructor(e) {
                    this.parser = e, this.name = a.KHR_LIGHTS_PUNCTUAL, this.cache = {
                        refs: {},
                        uses: {}
                    }
                }
                _markDefs() {
                    const e = this.parser,
                        t = this.parser.json.nodes || [];
                    for (let i = 0, n = t.length; i < n; i++) {
                        const n = t[i];
                        n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light)
                    }
                }
                _loadLight(e) {
                    const t = this.parser,
                        i = "light:" + e;
                    let r = t.cache.get(i);
                    if (r) return r;
                    const s = t.json,
                        a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
                    let o;
                    const l = new n.Ilk(16777215);
                    void 0 !== a.color && l.fromArray(a.color);
                    const h = void 0 !== a.range ? a.range : 0;
                    switch (a.type) {
                        case "directional":
                            o = new n.Ox3(l), o.target.position.set(0, 0, -1), o.add(o.target);
                            break;
                        case "point":
                            o = new n.cek(l), o.distance = h;
                            break;
                        case "spot":
                            o = new n.PMe(l), o.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4, o.angle = a.spot.outerConeAngle, o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
                            break;
                        default:
                            throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
                    }
                    return o.position.set(0, 0, 0), o.decay = 2, void 0 !== a.intensity && (o.intensity = a.intensity), o.name = t.createUniqueName(a.name || "light_" + e), r = Promise.resolve(o), t.cache.add(i, r), r
                }
                createNodeAttachment(e) {
                    const t = this,
                        i = this.parser,
                        n = i.json.nodes[e],
                        r = (n.extensions && n.extensions[this.name] || {}).light;
                    return void 0 === r ? null : this._loadLight(r).then((function(e) {
                        return i._getNodeRef(t.cache, r, e)
                    }))
                }
            }
            class l {
                constructor() {
                    this.name = a.KHR_MATERIALS_UNLIT
                }
                getMaterialType() {
                    return n.vBJ
                }
                extendParams(e, t, i) {
                    const r = [];
                    e.color = new n.Ilk(1, 1, 1), e.opacity = 1;
                    const s = t.pbrMetallicRoughness;
                    if (s) {
                        if (Array.isArray(s.baseColorFactor)) {
                            const t = s.baseColorFactor;
                            e.color.fromArray(t), e.opacity = t[3]
                        }
                        void 0 !== s.baseColorTexture && r.push(i.assignTexture(e, "map", s.baseColorTexture))
                    }
                    return Promise.all(r)
                }
            }
            class h {
                constructor(e) {
                    this.parser = e, this.name = a.KHR_MATERIALS_CLEARCOAT
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? n.EJi : null
                }
                extendMaterialParams(e, t) {
                    const i = this.parser,
                        r = i.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    const s = [],
                        a = r.extensions[this.name];
                    if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && s.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && s.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (s.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) {
                        const e = a.clearcoatNormalTexture.scale;
                        t.clearcoatNormalScale = new n.FM8(e, e)
                    }
                    return Promise.all(s)
                }
            }
            class c {
                constructor(e) {
                    this.parser = e, this.name = a.KHR_MATERIALS_SHEEN
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? n.EJi : null
                }
                extendMaterialParams(e, t) {
                    const i = this.parser,
                        r = i.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    const s = [];
                    t.sheenColor = new n.Ilk(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                    const a = r.extensions[this.name];
                    return void 0 !== a.sheenColorFactor && t.sheenColor.fromArray(a.sheenColorFactor), void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor), void 0 !== a.sheenColorTexture && s.push(i.assignTexture(t, "sheenColorMap", a.sheenColorTexture)), void 0 !== a.sheenRoughnessTexture && s.push(i.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s)
                }
            }
            class u {
                constructor(e) {
                    this.parser = e, this.name = a.KHR_MATERIALS_TRANSMISSION
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? n.EJi : null
                }
                extendMaterialParams(e, t) {
                    const i = this.parser,
                        n = i.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        s = n.extensions[this.name];
                    return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(i.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r)
                }
            }
            class d {
                constructor(e) {
                    this.parser = e, this.name = a.KHR_MATERIALS_VOLUME
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? n.EJi : null
                }
                extendMaterialParams(e, t) {
                    const i = this.parser,
                        r = i.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    const s = [],
                        a = r.extensions[this.name];
                    t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && s.push(i.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 0;
                    const o = a.attenuationColor || [1, 1, 1];
                    return t.attenuationColor = new n.Ilk(o[0], o[1], o[2]), Promise.all(s)
                }
            }
            class p {
                constructor(e) {
                    this.parser = e, this.name = a.KHR_MATERIALS_IOR
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? n.EJi : null
                }
                extendMaterialParams(e, t) {
                    const i = this.parser.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const n = i.extensions[this.name];
                    return t.ior = void 0 !== n.ior ? n.ior : 1.5, Promise.resolve()
                }
            }
            class f {
                constructor(e) {
                    this.parser = e, this.name = a.KHR_MATERIALS_SPECULAR
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? n.EJi : null
                }
                extendMaterialParams(e, t) {
                    const i = this.parser,
                        r = i.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                    const s = [],
                        a = r.extensions[this.name];
                    t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && s.push(i.assignTexture(t, "specularIntensityMap", a.specularTexture));
                    const o = a.specularColorFactor || [1, 1, 1];
                    return t.specularColor = new n.Ilk(o[0], o[1], o[2]), void 0 !== a.specularColorTexture && s.push(i.assignTexture(t, "specularColorMap", a.specularColorTexture).then((function(e) {
                        e.encoding = n.knz
                    }))), Promise.all(s)
                }
            }
            class m {
                constructor(e) {
                    this.parser = e, this.name = a.KHR_TEXTURE_BASISU
                }
                loadTexture(e) {
                    const t = this.parser,
                        i = t.json,
                        n = i.textures[e];
                    if (!n.extensions || !n.extensions[this.name]) return null;
                    const r = n.extensions[this.name],
                        s = i.images[r.source],
                        a = t.options.ktx2Loader;
                    if (!a) {
                        if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                        return null
                    }
                    return t.loadTextureImage(e, s, a)
                }
            }
            class g {
                constructor(e) {
                    this.parser = e, this.name = a.EXT_TEXTURE_WEBP, this.isSupported = null
                }
                loadTexture(e) {
                    const t = this.name,
                        i = this.parser,
                        n = i.json,
                        r = n.textures[e];
                    if (!r.extensions || !r.extensions[t]) return null;
                    const s = r.extensions[t],
                        a = n.images[s.source];
                    let o = i.textureLoader;
                    if (a.uri) {
                        const e = i.options.manager.getHandler(a.uri);
                        null !== e && (o = e)
                    }
                    return this.detectSupport().then((function(r) {
                        if (r) return i.loadTextureImage(e, a, o);
                        if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                        return i.loadTexture(e)
                    }))
                }
                detectSupport() {
                    return this.isSupported || (this.isSupported = new Promise((function(e) {
                        const t = new Image;
                        t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                            e(1 === t.height)
                        }
                    }))), this.isSupported
                }
            }
            class y {
                constructor(e) {
                    this.name = a.EXT_MESHOPT_COMPRESSION, this.parser = e
                }
                loadBufferView(e) {
                    const t = this.parser.json,
                        i = t.bufferViews[e];
                    if (i.extensions && i.extensions[this.name]) {
                        const e = i.extensions[this.name],
                            n = this.parser.getDependency("buffer", e.buffer),
                            r = this.parser.options.meshoptDecoder;
                        if (!r || !r.supported) {
                            if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                            return null
                        }
                        return Promise.all([n, r.ready]).then((function(t) {
                            const i = e.byteOffset || 0,
                                n = e.byteLength || 0,
                                s = e.count,
                                a = e.byteStride,
                                o = new ArrayBuffer(s * a),
                                l = new Uint8Array(t[0], i, n);
                            return r.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter), o
                        }))
                    }
                    return null
                }
            }
            const _ = "glTF",
                v = 1313821514,
                b = 5130562;
            class T {
                constructor(e) {
                    this.name = a.KHR_BINARY_GLTF, this.content = null, this.body = null;
                    const t = new DataView(e, 0, 12);
                    if (this.header = {
                            magic: n.Zp0.decodeText(new Uint8Array(e.slice(0, 4))),
                            version: t.getUint32(4, !0),
                            length: t.getUint32(8, !0)
                        }, this.header.magic !== _) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                    const i = this.header.length - 12,
                        r = new DataView(e, 12);
                    let s = 0;
                    for (; s < i;) {
                        const t = r.getUint32(s, !0);
                        s += 4;
                        const i = r.getUint32(s, !0);
                        if (s += 4, i === v) {
                            const i = new Uint8Array(e, 12 + s, t);
                            this.content = n.Zp0.decodeText(i)
                        } else if (i === b) {
                            const i = 12 + s;
                            this.body = e.slice(i, i + t)
                        }
                        s += t
                    }
                    if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                }
            }
            class x {
                constructor(e, t) {
                    if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                    this.name = a.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
                }
                decodePrimitive(e, t) {
                    const i = this.json,
                        n = this.dracoLoader,
                        r = e.extensions[this.name].bufferView,
                        s = e.extensions[this.name].attributes,
                        a = {},
                        o = {},
                        l = {};
                    for (const e in s) {
                        const t = z[e] || e.toLowerCase();
                        a[t] = s[e]
                    }
                    for (const t in e.attributes) {
                        const n = z[t] || t.toLowerCase();
                        if (void 0 !== s[t]) {
                            const r = i.accessors[e.attributes[t]],
                                s = U[r.componentType];
                            l[n] = s, o[n] = !0 === r.normalized
                        }
                    }
                    return t.getDependency("bufferView", r).then((function(e) {
                        return new Promise((function(t) {
                            n.decodeDracoFile(e, (function(e) {
                                for (const t in e.attributes) {
                                    const i = e.attributes[t],
                                        n = o[t];
                                    void 0 !== n && (i.normalized = n)
                                }
                                t(e)
                            }), a, l)
                        }))
                    }))
                }
            }
            class w {
                constructor() {
                    this.name = a.KHR_TEXTURE_TRANSFORM
                }
                extendTexture(e, t) {
                    return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
                }
            }
            class S extends n.Wid {
                constructor(e) {
                    super(), this.isGLTFSpecularGlossinessMaterial = !0;
                    const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                        i = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                        r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                        s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                        a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                        o = {
                            specular: {
                                value: (new n.Ilk).setHex(16777215)
                            },
                            glossiness: {
                                value: 1
                            },
                            specularMap: {
                                value: null
                            },
                            glossinessMap: {
                                value: null
                            }
                        };
                    this._extraUniforms = o, this.onBeforeCompile = function(e) {
                        for (const t in o) e.uniforms[t] = o[t];
                        e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", a)
                    }, Object.defineProperties(this, {
                        specular: {
                            get: function() {
                                return o.specular.value
                            },
                            set: function(e) {
                                o.specular.value = e
                            }
                        },
                        specularMap: {
                            get: function() {
                                return o.specularMap.value
                            },
                            set: function(e) {
                                o.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                            }
                        },
                        glossiness: {
                            get: function() {
                                return o.glossiness.value
                            },
                            set: function(e) {
                                o.glossiness.value = e
                            }
                        },
                        glossinessMap: {
                            get: function() {
                                return o.glossinessMap.value
                            },
                            set: function(e) {
                                o.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                            }
                        }
                    }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
                }
            }
            class E {
                constructor() {
                    this.name = a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
                }
                getMaterialType() {
                    return S
                }
                extendParams(e, t, i) {
                    const r = t.extensions[this.name];
                    e.color = new n.Ilk(1, 1, 1), e.opacity = 1;
                    const s = [];
                    if (Array.isArray(r.diffuseFactor)) {
                        const t = r.diffuseFactor;
                        e.color.fromArray(t), e.opacity = t[3]
                    }
                    if (void 0 !== r.diffuseTexture && s.push(i.assignTexture(e, "map", r.diffuseTexture)), e.emissive = new n.Ilk(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new n.Ilk(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) {
                        const t = r.specularGlossinessTexture;
                        s.push(i.assignTexture(e, "glossinessMap", t)), s.push(i.assignTexture(e, "specularMap", t))
                    }
                    return Promise.all(s)
                }
                createMaterial(e) {
                    const t = new S(e);
                    return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = n.IOt, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
                }
            }
            class M {
                constructor() {
                    this.name = a.KHR_MESH_QUANTIZATION
                }
            }
            class C extends n._C8 {
                constructor(e, t, i, n) {
                    super(e, t, i, n)
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer,
                        i = this.sampleValues,
                        n = this.valueSize,
                        r = e * n * 3 + n;
                    for (let e = 0; e !== n; e++) t[e] = i[r + e];
                    return t
                }
            }
            C.prototype.beforeStart_ = C.prototype.copySampleValue_, C.prototype.afterEnd_ = C.prototype.copySampleValue_, C.prototype.interpolate_ = function(e, t, i, n) {
                const r = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize,
                    o = 2 * a,
                    l = 3 * a,
                    h = n - t,
                    c = (i - t) / h,
                    u = c * c,
                    d = u * c,
                    p = e * l,
                    f = p - l,
                    m = -2 * d + 3 * u,
                    g = d - u,
                    y = 1 - m,
                    _ = g - u + c;
                for (let e = 0; e !== a; e++) {
                    const t = s[f + e + a],
                        i = s[f + e + o] * h,
                        n = s[p + e + a],
                        l = s[p + e] * h;
                    r[e] = y * t + _ * i + m * n + g * l
                }
                return r
            };
            const A = new n._fP;
            class L extends C {
                interpolate_(e, t, i, n) {
                    const r = super.interpolate_(e, t, i, n);
                    return A.fromArray(r).normalize().toArray(r), r
                }
            }
            const I = 0,
                P = 1,
                R = 2,
                k = 3,
                D = 4,
                O = 5,
                N = 6,
                U = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                },
                B = {
                    9728: n.TyD,
                    9729: n.wem,
                    9984: n.YLQ,
                    9985: n.qyh,
                    9986: n.aH4,
                    9987: n.D1R
                },
                F = {
                    33071: n.uWy,
                    33648: n.OoA,
                    10497: n.rpg
                },
                H = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16
                },
                z = {
                    POSITION: "position",
                    NORMAL: "normal",
                    TANGENT: "tangent",
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv2",
                    COLOR_0: "color",
                    WEIGHTS_0: "skinWeight",
                    JOINTS_0: "skinIndex"
                },
                V = {
                    scale: "scale",
                    translation: "position",
                    rotation: "quaternion",
                    weights: "morphTargetInfluences"
                },
                G = {
                    CUBICSPLINE: void 0,
                    LINEAR: n.NMF,
                    STEP: n.Syv
                },
                W = "OPAQUE",
                j = "MASK",
                q = "BLEND";

            function $(e, t, i) {
                for (const n in i.extensions) void 0 === e[n] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = i.extensions[n])
            }

            function X(e, t) {
                void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
            }

            function Y(e, t) {
                if (e.updateMorphTargets(), void 0 !== t.weights)
                    for (let i = 0, n = t.weights.length; i < n; i++) e.morphTargetInfluences[i] = t.weights[i];
                if (t.extras && Array.isArray(t.extras.targetNames)) {
                    const i = t.extras.targetNames;
                    if (e.morphTargetInfluences.length === i.length) {
                        e.morphTargetDictionary = {};
                        for (let t = 0, n = i.length; t < n; t++) e.morphTargetDictionary[i[t]] = t
                    } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                }
            }

            function K(e) {
                const t = e.extensions && e.extensions[a.KHR_DRACO_MESH_COMPRESSION];
                let i;
                return i = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + J(t.attributes) : e.indices + ":" + J(e.attributes) + ":" + e.mode, i
            }

            function J(e) {
                let t = "";
                const i = Object.keys(e).sort();
                for (let n = 0, r = i.length; n < r; n++) t += i[n] + ":" + e[i[n]] + ";";
                return t
            }

            function Z(e) {
                switch (e) {
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                }
            }
            class Q {
                constructor(e = {}, t = {}) {
                    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new s, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                        refs: {},
                        uses: {}
                    }, this.cameraCache = {
                        refs: {},
                        uses: {}
                    }, this.lightCache = {
                        refs: {},
                        uses: {}
                    }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? this.textureLoader = new n.QRU(this.options.manager) : this.textureLoader = new n.dpR(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new n.hH6(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                }
                setExtensions(e) {
                    this.extensions = e
                }
                setPlugins(e) {
                    this.plugins = e
                }
                parse(e, t) {
                    const i = this,
                        n = this.json,
                        r = this.extensions;
                    this.cache.removeAll(), this._invokeAll((function(e) {
                        return e._markDefs && e._markDefs()
                    })), Promise.all(this._invokeAll((function(e) {
                        return e.beforeRoot && e.beforeRoot()
                    }))).then((function() {
                        return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
                    })).then((function(t) {
                        const s = {
                            scene: t[0][n.scene || 0],
                            scenes: t[0],
                            animations: t[1],
                            cameras: t[2],
                            asset: n.asset,
                            parser: i,
                            userData: {}
                        };
                        $(r, s, n), X(s, n), Promise.all(i._invokeAll((function(e) {
                            return e.afterRoot && e.afterRoot(s)
                        }))).then((function() {
                            e(s)
                        }))
                    })).catch(t)
                }
                _markDefs() {
                    const e = this.json.nodes || [],
                        t = this.json.skins || [],
                        i = this.json.meshes || [];
                    for (let i = 0, n = t.length; i < n; i++) {
                        const n = t[i].joints;
                        for (let t = 0, i = n.length; t < i; t++) e[n[t]].isBone = !0
                    }
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        void 0 !== n.mesh && (this._addNodeRef(this.meshCache, n.mesh), void 0 !== n.skin && (i[n.mesh].isSkinnedMesh = !0)), void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera)
                    }
                }
                _addNodeRef(e, t) {
                    void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
                }
                _getNodeRef(e, t, i) {
                    if (e.refs[t] <= 1) return i;
                    const n = i.clone(),
                        r = (e, t) => {
                            const i = this.associations.get(e);
                            null != i && this.associations.set(t, i);
                            for (const [i, n] of e.children.entries()) r(n, t.children[i])
                        };
                    return r(i, n), n.name += "_instance_" + e.uses[t]++, n
                }
                _invokeOne(e) {
                    const t = Object.values(this.plugins);
                    t.push(this);
                    for (let i = 0; i < t.length; i++) {
                        const n = e(t[i]);
                        if (n) return n
                    }
                    return null
                }
                _invokeAll(e) {
                    const t = Object.values(this.plugins);
                    t.unshift(this);
                    const i = [];
                    for (let n = 0; n < t.length; n++) {
                        const r = e(t[n]);
                        r && i.push(r)
                    }
                    return i
                }
                getDependency(e, t) {
                    const i = e + ":" + t;
                    let n = this.cache.get(i);
                    if (!n) {
                        switch (e) {
                            case "scene":
                                n = this.loadScene(t);
                                break;
                            case "node":
                                n = this.loadNode(t);
                                break;
                            case "mesh":
                                n = this._invokeOne((function(e) {
                                    return e.loadMesh && e.loadMesh(t)
                                }));
                                break;
                            case "accessor":
                                n = this.loadAccessor(t);
                                break;
                            case "bufferView":
                                n = this._invokeOne((function(e) {
                                    return e.loadBufferView && e.loadBufferView(t)
                                }));
                                break;
                            case "buffer":
                                n = this.loadBuffer(t);
                                break;
                            case "material":
                                n = this._invokeOne((function(e) {
                                    return e.loadMaterial && e.loadMaterial(t)
                                }));
                                break;
                            case "texture":
                                n = this._invokeOne((function(e) {
                                    return e.loadTexture && e.loadTexture(t)
                                }));
                                break;
                            case "skin":
                                n = this.loadSkin(t);
                                break;
                            case "animation":
                                n = this.loadAnimation(t);
                                break;
                            case "camera":
                                n = this.loadCamera(t);
                                break;
                            default:
                                throw new Error("Unknown type: " + e)
                        }
                        this.cache.add(i, n)
                    }
                    return n
                }
                getDependencies(e) {
                    let t = this.cache.get(e);
                    if (!t) {
                        const i = this,
                            n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                        t = Promise.all(n.map((function(t, n) {
                            return i.getDependency(e, n)
                        }))), this.cache.add(e, t)
                    }
                    return t
                }
                loadBuffer(e) {
                    const t = this.json.buffers[e],
                        i = this.fileLoader;
                    if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                    if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[a.KHR_BINARY_GLTF].body);
                    const r = this.options;
                    return new Promise((function(e, s) {
                        i.load(n.Zp0.resolveURL(t.uri, r.path), e, void 0, (function() {
                            s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                        }))
                    }))
                }
                loadBufferView(e) {
                    const t = this.json.bufferViews[e];
                    return this.getDependency("buffer", t.buffer).then((function(e) {
                        const i = t.byteLength || 0,
                            n = t.byteOffset || 0;
                        return e.slice(n, n + i)
                    }))
                }
                loadAccessor(e) {
                    const t = this,
                        i = this.json,
                        r = this.json.accessors[e];
                    if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null);
                    const s = [];
                    return void 0 !== r.bufferView ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), void 0 !== r.sparse && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then((function(e) {
                        const s = e[0],
                            a = H[r.type],
                            o = U[r.componentType],
                            l = o.BYTES_PER_ELEMENT,
                            h = l * a,
                            c = r.byteOffset || 0,
                            u = void 0 !== r.bufferView ? i.bufferViews[r.bufferView].byteStride : void 0,
                            d = !0 === r.normalized;
                        let p, f;
                        if (u && u !== h) {
                            const e = Math.floor(c / u),
                                i = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
                            let h = t.cache.get(i);
                            h || (p = new o(s, e * u, r.count * u / l), h = new n.vpT(p, u / l), t.cache.add(i, h)), f = new n.kB5(h, a, c % u / l, d)
                        } else p = null === s ? new o(r.count * a) : new o(s, c, r.count * a), f = new n.TlE(p, a, d);
                        if (void 0 !== r.sparse) {
                            const t = H.SCALAR,
                                i = U[r.sparse.indices.componentType],
                                l = r.sparse.indices.byteOffset || 0,
                                h = r.sparse.values.byteOffset || 0,
                                c = new i(e[1], l, r.sparse.count * t),
                                u = new o(e[2], h, r.sparse.count * a);
                            null !== s && (f = new n.TlE(f.array.slice(), f.itemSize, f.normalized));
                            for (let e = 0, t = c.length; e < t; e++) {
                                const t = c[e];
                                if (f.setX(t, u[e * a]), a >= 2 && f.setY(t, u[e * a + 1]), a >= 3 && f.setZ(t, u[e * a + 2]), a >= 4 && f.setW(t, u[e * a + 3]), a >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                            }
                        }
                        return f
                    }))
                }
                loadTexture(e) {
                    const t = this.json,
                        i = this.options,
                        n = t.textures[e],
                        r = t.images[n.source];
                    let s = this.textureLoader;
                    if (r.uri) {
                        const e = i.manager.getHandler(r.uri);
                        null !== e && (s = e)
                    }
                    return this.loadTextureImage(e, r, s)
                }
                loadTextureImage(e, t, i) {
                    const r = this,
                        s = this.json,
                        a = this.options,
                        o = s.textures[e],
                        l = (t.uri || t.bufferView) + ":" + o.sampler;
                    if (this.textureCache[l]) return this.textureCache[l];
                    const h = self.URL || self.webkitURL;
                    let c = t.uri || "",
                        u = !1;
                    if (void 0 !== t.bufferView) c = r.getDependency("bufferView", t.bufferView).then((function(e) {
                        u = !0;
                        const i = new Blob([e], {
                            type: t.mimeType
                        });
                        return c = h.createObjectURL(i), c
                    }));
                    else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                    const d = Promise.resolve(c).then((function(e) {
                        return new Promise((function(t, r) {
                            let s = t;
                            !0 === i.isImageBitmapLoader && (s = function(e) {
                                const i = new n.xEZ(e);
                                i.needsUpdate = !0, t(i)
                            }), i.load(n.Zp0.resolveURL(e, a.path), s, void 0, r)
                        }))
                    })).then((function(t) {
                        !0 === u && h.revokeObjectURL(c), t.flipY = !1, o.name && (t.name = o.name);
                        const i = (s.samplers || {})[o.sampler] || {};
                        return t.magFilter = B[i.magFilter] || n.wem, t.minFilter = B[i.minFilter] || n.D1R, t.wrapS = F[i.wrapS] || n.rpg, t.wrapT = F[i.wrapT] || n.rpg, r.associations.set(t, {
                            textures: e
                        }), t
                    })).catch((function() {
                        return console.error("THREE.GLTFLoader: Couldn't load texture", c), null
                    }));
                    return this.textureCache[l] = d, d
                }
                assignTexture(e, t, i) {
                    const n = this;
                    return this.getDependency("texture", i.index).then((function(r) {
                        if (void 0 === i.texCoord || 0 == i.texCoord || "aoMap" === t && 1 == i.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."), n.extensions[a.KHR_TEXTURE_TRANSFORM]) {
                            const e = void 0 !== i.extensions ? i.extensions[a.KHR_TEXTURE_TRANSFORM] : void 0;
                            if (e) {
                                const t = n.associations.get(r);
                                r = n.extensions[a.KHR_TEXTURE_TRANSFORM].extendTexture(r, e), n.associations.set(r, t)
                            }
                        }
                        return e[t] = r, r
                    }))
                }
                assignFinalMaterial(e) {
                    const t = e.geometry;
                    let i = e.material;
                    const r = void 0 === t.attributes.tangent,
                        s = void 0 !== t.attributes.color,
                        a = void 0 === t.attributes.normal;
                    if (e.isPoints) {
                        const e = "PointsMaterial:" + i.uuid;
                        let t = this.cache.get(e);
                        t || (t = new n.UY4, n.F5T.prototype.copy.call(t, i), t.color.copy(i.color), t.map = i.map, t.sizeAttenuation = !1, this.cache.add(e, t)), i = t
                    } else if (e.isLine) {
                        const e = "LineBasicMaterial:" + i.uuid;
                        let t = this.cache.get(e);
                        t || (t = new n.nls, n.F5T.prototype.copy.call(t, i), t.color.copy(i.color), this.cache.add(e, t)), i = t
                    }
                    if (r || s || a) {
                        let e = "ClonedMaterial:" + i.uuid + ":";
                        i.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), r && (e += "derivative-tangents:"), s && (e += "vertex-colors:"), a && (e += "flat-shading:");
                        let t = this.cache.get(e);
                        t || (t = i.clone(), s && (t.vertexColors = !0), a && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(i))), i = t
                    }
                    i.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = i
                }
                getMaterialType() {
                    return n.Wid
                }
                loadMaterial(e) {
                    const t = this,
                        i = this.json,
                        r = this.extensions,
                        s = i.materials[e];
                    let o;
                    const l = {},
                        h = s.extensions || {},
                        c = [];
                    if (h[a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                        const e = r[a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                        o = e.getMaterialType(), c.push(e.extendParams(l, s, t))
                    } else if (h[a.KHR_MATERIALS_UNLIT]) {
                        const e = r[a.KHR_MATERIALS_UNLIT];
                        o = e.getMaterialType(), c.push(e.extendParams(l, s, t))
                    } else {
                        const i = s.pbrMetallicRoughness || {};
                        if (l.color = new n.Ilk(1, 1, 1), l.opacity = 1, Array.isArray(i.baseColorFactor)) {
                            const e = i.baseColorFactor;
                            l.color.fromArray(e), l.opacity = e[3]
                        }
                        void 0 !== i.baseColorTexture && c.push(t.assignTexture(l, "map", i.baseColorTexture)), l.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1, l.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1, void 0 !== i.metallicRoughnessTexture && (c.push(t.assignTexture(l, "metalnessMap", i.metallicRoughnessTexture)), c.push(t.assignTexture(l, "roughnessMap", i.metallicRoughnessTexture))), o = this._invokeOne((function(t) {
                            return t.getMaterialType && t.getMaterialType(e)
                        })), c.push(Promise.all(this._invokeAll((function(t) {
                            return t.extendMaterialParams && t.extendMaterialParams(e, l)
                        }))))
                    }!0 === s.doubleSided && (l.side = n.ehD);
                    const u = s.alphaMode || W;
                    if (u === q ? (l.transparent = !0, l.depthWrite = !1) : (l.transparent = !1, u === j && (l.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && o !== n.vBJ && (c.push(t.assignTexture(l, "normalMap", s.normalTexture)), l.normalScale = new n.FM8(1, 1), void 0 !== s.normalTexture.scale)) {
                        const e = s.normalTexture.scale;
                        l.normalScale.set(e, e)
                    }
                    return void 0 !== s.occlusionTexture && o !== n.vBJ && (c.push(t.assignTexture(l, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (l.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && o !== n.vBJ && (l.emissive = (new n.Ilk).fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && o !== n.vBJ && c.push(t.assignTexture(l, "emissiveMap", s.emissiveTexture)), Promise.all(c).then((function() {
                        let i;
                        return i = o === S ? r[a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(l) : new o(l), s.name && (i.name = s.name), i.map && (i.map.encoding = n.knz), i.emissiveMap && (i.emissiveMap.encoding = n.knz), X(i, s), t.associations.set(i, {
                            materials: e
                        }), s.extensions && $(r, i, s), i
                    }))
                }
                createUniqueName(e) {
                    const t = n.iUV.sanitizeNodeName(e || "");
                    let i = t;
                    for (let e = 1; this.nodeNamesUsed[i]; ++e) i = t + "_" + e;
                    return this.nodeNamesUsed[i] = !0, i
                }
                loadGeometries(e) {
                    const t = this,
                        i = this.extensions,
                        r = this.primitiveCache;

                    function s(e) {
                        return i[a.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(i) {
                            return te(i, e, t)
                        }))
                    }
                    const o = [];
                    for (let i = 0, l = e.length; i < l; i++) {
                        const l = e[i],
                            h = K(l),
                            c = r[h];
                        if (c) o.push(c.promise);
                        else {
                            let e;
                            e = l.extensions && l.extensions[a.KHR_DRACO_MESH_COMPRESSION] ? s(l) : te(new n.u9r, l, t), r[h] = {
                                primitive: l,
                                promise: e
                            }, o.push(e)
                        }
                    }
                    return Promise.all(o)
                }
                loadMesh(e) {
                    const t = this,
                        i = this.json,
                        r = this.extensions,
                        s = i.meshes[e],
                        a = s.primitives,
                        o = [];
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = void 0 === a[e].material ? (void 0 === (l = this.cache).DefaultMaterial && (l.DefaultMaterial = new n.Wid({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: n.Wl3
                        })), l.DefaultMaterial) : this.getDependency("material", a[e].material);
                        o.push(t)
                    }
                    var l;
                    return o.push(t.loadGeometries(a)), Promise.all(o).then((function(i) {
                        const o = i.slice(0, i.length - 1),
                            l = i[i.length - 1],
                            h = [];
                        for (let i = 0, c = l.length; i < c; i++) {
                            const c = l[i],
                                u = a[i];
                            let d;
                            const p = o[i];
                            if (u.mode === D || u.mode === O || u.mode === N || void 0 === u.mode) d = !0 === s.isSkinnedMesh ? new n.TUv(c, p) : new n.Kj0(c, p), !0 !== d.isSkinnedMesh || d.geometry.attributes.skinWeight.normalized || d.normalizeSkinWeights(), u.mode === O ? d.geometry = ie(d.geometry, n.UlW) : u.mode === N && (d.geometry = ie(d.geometry, n.z$h));
                            else if (u.mode === P) d = new n.ejS(c, p);
                            else if (u.mode === k) d = new n.x12(c, p);
                            else if (u.mode === R) d = new n.blk(c, p);
                            else {
                                if (u.mode !== I) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                                d = new n.woe(c, p)
                            }
                            Object.keys(d.geometry.morphAttributes).length > 0 && Y(d, s), d.name = t.createUniqueName(s.name || "mesh_" + e), X(d, s), u.extensions && $(r, d, u), t.assignFinalMaterial(d), h.push(d)
                        }
                        for (let i = 0, n = h.length; i < n; i++) t.associations.set(h[i], {
                            meshes: e,
                            primitives: i
                        });
                        if (1 === h.length) return h[0];
                        const c = new n.ZAu;
                        t.associations.set(c, {
                            meshes: e
                        });
                        for (let e = 0, t = h.length; e < t; e++) c.add(h[e]);
                        return c
                    }))
                }
                loadCamera(e) {
                    let t;
                    const i = this.json.cameras[e],
                        r = i[i.type];
                    if (r) return "perspective" === i.type ? t = new n.cPb(n.M8C.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === i.type && (t = new n.iKG(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), X(t, i), Promise.resolve(t);
                    console.warn("THREE.GLTFLoader: Missing camera parameters.")
                }
                loadSkin(e) {
                    const t = this.json.skins[e],
                        i = {
                            joints: t.joints
                        };
                    return void 0 === t.inverseBindMatrices ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
                        return i.inverseBindMatrices = e, i
                    }))
                }
                loadAnimation(e) {
                    const t = this.json.animations[e],
                        i = [],
                        r = [],
                        s = [],
                        a = [],
                        o = [];
                    for (let e = 0, n = t.channels.length; e < n; e++) {
                        const n = t.channels[e],
                            l = t.samplers[n.sampler],
                            h = n.target,
                            c = void 0 !== h.node ? h.node : h.id,
                            u = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
                            d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
                        i.push(this.getDependency("node", c)), r.push(this.getDependency("accessor", u)), s.push(this.getDependency("accessor", d)), a.push(l), o.push(h)
                    }
                    return Promise.all([Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(a), Promise.all(o)]).then((function(i) {
                        const r = i[0],
                            s = i[1],
                            a = i[2],
                            o = i[3],
                            l = i[4],
                            h = [];
                        for (let e = 0, t = r.length; e < t; e++) {
                            const t = r[e],
                                i = s[e],
                                c = a[e],
                                u = o[e],
                                d = l[e];
                            if (void 0 === t) continue;
                            let p;
                            switch (t.updateMatrix(), t.matrixAutoUpdate = !0, V[d.path]) {
                                case V.weights:
                                    p = n.dUE;
                                    break;
                                case V.rotation:
                                    p = n.iLg;
                                    break;
                                default:
                                    p = n.yC1
                            }
                            const f = t.name ? t.name : t.uuid,
                                m = void 0 !== u.interpolation ? G[u.interpolation] : n.NMF,
                                g = [];
                            V[d.path] === V.weights ? t.traverse((function(e) {
                                e.morphTargetInfluences && g.push(e.name ? e.name : e.uuid)
                            })) : g.push(f);
                            let y = c.array;
                            if (c.normalized) {
                                const e = Z(y.constructor),
                                    t = new Float32Array(y.length);
                                for (let i = 0, n = y.length; i < n; i++) t[i] = y[i] * e;
                                y = t
                            }
                            for (let e = 0, t = g.length; e < t; e++) {
                                const t = new p(g[e] + "." + V[d.path], i.array, y, m);
                                "CUBICSPLINE" === u.interpolation && (t.createInterpolant = function(e) {
                                    return new(this instanceof n.iLg ? L : C)(this.times, this.values, this.getValueSize() / 3, e)
                                }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), h.push(t)
                            }
                        }
                        const c = t.name ? t.name : "animation_" + e;
                        return new n.m7l(c, void 0, h)
                    }))
                }
                createNodeMesh(e) {
                    const t = this.json,
                        i = this,
                        n = t.nodes[e];
                    return void 0 === n.mesh ? null : i.getDependency("mesh", n.mesh).then((function(e) {
                        const t = i._getNodeRef(i.meshCache, n.mesh, e);
                        return void 0 !== n.weights && t.traverse((function(e) {
                            if (e.isMesh)
                                for (let t = 0, i = n.weights.length; t < i; t++) e.morphTargetInfluences[t] = n.weights[t]
                        })), t
                    }))
                }
                loadNode(e) {
                    const t = this.json,
                        i = this.extensions,
                        r = this,
                        s = t.nodes[e],
                        a = s.name ? r.createUniqueName(s.name) : "";
                    return function() {
                        const t = [],
                            i = r._invokeOne((function(t) {
                                return t.createNodeMesh && t.createNodeMesh(e)
                            }));
                        return i && t.push(i), void 0 !== s.camera && t.push(r.getDependency("camera", s.camera).then((function(e) {
                            return r._getNodeRef(r.cameraCache, s.camera, e)
                        }))), r._invokeAll((function(t) {
                            return t.createNodeAttachment && t.createNodeAttachment(e)
                        })).forEach((function(e) {
                            t.push(e)
                        })), Promise.all(t)
                    }().then((function(t) {
                        let o;
                        if (o = !0 === s.isBone ? new n.N$j : t.length > 1 ? new n.ZAu : 1 === t.length ? t[0] : new n.Tme, o !== t[0])
                            for (let e = 0, i = t.length; e < i; e++) o.add(t[e]);
                        if (s.name && (o.userData.name = s.name, o.name = a), X(o, s), s.extensions && $(i, o, s), void 0 !== s.matrix) {
                            const e = new n.yGw;
                            e.fromArray(s.matrix), o.applyMatrix4(e)
                        } else void 0 !== s.translation && o.position.fromArray(s.translation), void 0 !== s.rotation && o.quaternion.fromArray(s.rotation), void 0 !== s.scale && o.scale.fromArray(s.scale);
                        return r.associations.has(o) || r.associations.set(o, {}), r.associations.get(o).nodes = e, o
                    }))
                }
                loadScene(e) {
                    const t = this.json,
                        i = this.extensions,
                        r = this.json.scenes[e],
                        s = this,
                        a = new n.ZAu;
                    r.name && (a.name = s.createUniqueName(r.name)), X(a, r), r.extensions && $(i, a, r);
                    const o = r.nodes || [],
                        l = [];
                    for (let e = 0, i = o.length; e < i; e++) l.push(ee(o[e], a, t, s));
                    return Promise.all(l).then((function() {
                        return s.associations = (e => {
                            const t = new Map;
                            for (const [e, i] of s.associations)(e instanceof n.F5T || e instanceof n.xEZ) && t.set(e, i);
                            return e.traverse((e => {
                                const i = s.associations.get(e);
                                null != i && t.set(e, i)
                            })), t
                        })(a), a
                    }))
                }
            }

            function ee(e, t, i, r) {
                const s = i.nodes[e];
                return r.getDependency("node", e).then((function(e) {
                    if (void 0 === s.skin) return e;
                    let t;
                    return r.getDependency("skin", s.skin).then((function(e) {
                        t = e;
                        const i = [];
                        for (let e = 0, n = t.joints.length; e < n; e++) i.push(r.getDependency("node", t.joints[e]));
                        return Promise.all(i)
                    })).then((function(i) {
                        return e.traverse((function(e) {
                            if (!e.isMesh) return;
                            const r = [],
                                s = [];
                            for (let e = 0, a = i.length; e < a; e++) {
                                const a = i[e];
                                if (a) {
                                    r.push(a);
                                    const i = new n.yGw;
                                    void 0 !== t.inverseBindMatrices && i.fromArray(t.inverseBindMatrices.array, 16 * e), s.push(i)
                                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                            }
                            e.bind(new n.OdW(r, s), e.matrixWorld)
                        })), e
                    }))
                })).then((function(e) {
                    t.add(e);
                    const n = [];
                    if (s.children) {
                        const t = s.children;
                        for (let s = 0, a = t.length; s < a; s++) {
                            const a = t[s];
                            n.push(ee(a, e, i, r))
                        }
                    }
                    return Promise.all(n)
                }))
            }

            function te(e, t, i) {
                const r = t.attributes,
                    s = [];

                function a(t, n) {
                    return i.getDependency("accessor", t).then((function(t) {
                        e.setAttribute(n, t)
                    }))
                }
                for (const t in r) {
                    const i = z[t] || t.toLowerCase();
                    i in e.attributes || s.push(a(r[t], i))
                }
                if (void 0 !== t.indices && !e.index) {
                    const n = i.getDependency("accessor", t.indices).then((function(t) {
                        e.setIndex(t)
                    }));
                    s.push(n)
                }
                return X(e, t),
                    function(e, t, i) {
                        const r = t.attributes,
                            s = new n.ZzF;
                        if (void 0 === r.POSITION) return; {
                            const e = i.json.accessors[r.POSITION],
                                t = e.min,
                                a = e.max;
                            if (void 0 === t || void 0 === a) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                            if (s.set(new n.Pa4(t[0], t[1], t[2]), new n.Pa4(a[0], a[1], a[2])), e.normalized) {
                                const t = Z(U[e.componentType]);
                                s.min.multiplyScalar(t), s.max.multiplyScalar(t)
                            }
                        }
                        const a = t.targets;
                        if (void 0 !== a) {
                            const e = new n.Pa4,
                                t = new n.Pa4;
                            for (let n = 0, r = a.length; n < r; n++) {
                                const r = a[n];
                                if (void 0 !== r.POSITION) {
                                    const n = i.json.accessors[r.POSITION],
                                        s = n.min,
                                        a = n.max;
                                    if (void 0 !== s && void 0 !== a) {
                                        if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))), n.normalized) {
                                            const e = Z(U[n.componentType]);
                                            t.multiplyScalar(e)
                                        }
                                        e.max(t)
                                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                }
                            }
                            s.expandByVector(e)
                        }
                        e.boundingBox = s;
                        const o = new n.aLr;
                        s.getCenter(o.center), o.radius = s.min.distanceTo(s.max) / 2, e.boundingSphere = o
                    }(e, t, i), Promise.all(s).then((function() {
                        return void 0 !== t.targets ? function(e, t, i) {
                            let n = !1,
                                r = !1;
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e];
                                if (void 0 !== i.POSITION && (n = !0), void 0 !== i.NORMAL && (r = !0), n && r) break
                            }
                            if (!n && !r) return Promise.resolve(e);
                            const s = [],
                                a = [];
                            for (let o = 0, l = t.length; o < l; o++) {
                                const l = t[o];
                                if (n) {
                                    const t = void 0 !== l.POSITION ? i.getDependency("accessor", l.POSITION) : e.attributes.position;
                                    s.push(t)
                                }
                                if (r) {
                                    const t = void 0 !== l.NORMAL ? i.getDependency("accessor", l.NORMAL) : e.attributes.normal;
                                    a.push(t)
                                }
                            }
                            return Promise.all([Promise.all(s), Promise.all(a)]).then((function(t) {
                                const i = t[0],
                                    s = t[1];
                                return n && (e.morphAttributes.position = i), r && (e.morphAttributes.normal = s), e.morphTargetsRelative = !0, e
                            }))
                        }(e, t.targets, i) : e
                    }))
            }

            function ie(e, t) {
                let i = e.getIndex();
                if (null === i) {
                    const t = [],
                        n = e.getAttribute("position");
                    if (void 0 === n) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                    for (let e = 0; e < n.count; e++) t.push(e);
                    e.setIndex(t), i = e.getIndex()
                }
                const r = i.count - 2,
                    s = [];
                if (t === n.z$h)
                    for (let e = 1; e <= r; e++) s.push(i.getX(0)), s.push(i.getX(e)), s.push(i.getX(e + 1));
                else
                    for (let e = 0; e < r; e++) e % 2 == 0 ? (s.push(i.getX(e)), s.push(i.getX(e + 1)), s.push(i.getX(e + 2))) : (s.push(i.getX(e + 2)), s.push(i.getX(e + 1)), s.push(i.getX(e)));
                s.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const a = e.clone();
                return a.setIndex(s), a
            }
        }
    }
]);